{"version":3,"file":"index.umd.js","sources":["../src/utils/validation.ts","../src/action.ts","../src/create-custom-action.ts","../src/create-standard-action.ts","../src/get-type.ts","../src/create-action.ts","../src/create-async-action.ts","../src/create-reducer.ts","../src/is-of-type.ts","../src/is-action-of.ts","../src/create-action-deprecated.ts"],"sourcesContent":["import { ActionCreator, TypeMeta, TypeConstant } from '../type-helpers';\n\nexport function checkIsEmpty(arg: unknown, argPosition: number = 1) {\n  return arg == null;\n}\n\nexport function throwIsEmpty(argPosition: number = 1): never {\n  throw new Error(`Argument ${argPosition} is empty.`);\n}\n\nexport function checkValidActionCreator(\n  arg: unknown\n): arg is ActionCreator<TypeConstant> {\n  return typeof arg === 'function' && 'getType' in arg;\n}\n\nexport function checkInvalidActionCreator(arg: unknown) {\n  return !checkValidActionCreator(arg);\n}\n\nexport function throwInvalidActionCreator(argPosition: number = 1): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action-creator instance from \"typesafe-actions\"`\n  );\n}\n\nexport function checkInvalidActionCreatorInArray(\n  arg: ActionCreator<TypeConstant> & TypeMeta<TypeConstant>,\n  idx: number\n): void | never {\n  if (arg == null) {\n    throw new Error(\n      `Argument contains array with empty element at index ${idx}`\n    );\n  } else if (arg.getType == null) {\n    throw new Error(\n      // tslint:disable-next-line:max-line-length\n      `Argument contains array with invalid element at index ${idx}, it should be an action-creator instance from \"typesafe-actions\"`\n    );\n  }\n}\n\nexport function checkValidActionType(arg: unknown): arg is string | symbol {\n  return typeof arg === 'string' || typeof arg === 'symbol';\n}\n\nexport function checkInvalidActionType(arg: unknown): arg is string | symbol {\n  return !checkValidActionType(arg);\n}\n\nexport function throwInvalidActionType(argPosition: number = 1): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action type of type: string | symbol`\n  );\n}\n\nexport function checkInvalidActionTypeInArray(\n  arg: TypeConstant,\n  idx: number\n): void | never {\n  if (arg == null) {\n    throw new Error(\n      `Argument contains array with empty element at index ${idx}`\n    );\n  } else if (typeof arg !== 'string' && typeof arg !== 'symbol') {\n    throw new Error(\n      `Argument contains array with invalid element at index ${idx}, it should be of type: string | symbol`\n    );\n  }\n}\n\nexport function throwInvalidActionTypeOrActionCreator(\n  argPosition: number = 1\n): never {\n  throw new Error(\n    `Argument ${argPosition} is invalid, it should be an action-creator instance from \"typesafe-actions\" or action type of type: string | symbol`\n  );\n}\n","import { TypeConstant } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionCreator,\n} from './utils/validation';\n\nexport function action<T extends TypeConstant, E>(\n  type: T,\n  payload: undefined,\n  meta: undefined,\n  error: E\n): { type: T; error: E };\n\nexport function action<T extends TypeConstant, M, E>(\n  type: T,\n  payload: undefined,\n  meta: M,\n  error: E\n): { type: T; meta: M; error: E };\n\nexport function action<T extends TypeConstant, P, E>(\n  type: T,\n  payload: P,\n  meta: undefined,\n  error: E\n): { type: T; payload: P; error: E };\n\nexport function action<T extends TypeConstant, P, M, E>(\n  type: T,\n  payload: P,\n  meta: M,\n  error: E\n): { type: T; payload: P; meta: M; error: E };\n\nexport function action<T extends TypeConstant, M>(\n  type: T,\n  payload: undefined,\n  meta: M\n): { type: T; meta: M };\n\nexport function action<T extends TypeConstant, P, M>(\n  type: T,\n  payload: P,\n  meta: M\n): { type: T; payload: P; meta: M };\n\nexport function action<T extends TypeConstant, P>(\n  type: T,\n  payload: P\n): { type: T; payload: P };\n\nexport function action<T extends TypeConstant>(type: T): { type: T };\n\n/**\n * @description flux standard action factory\n * @example\n * ```\n * const add = (amount: number, meta?: Meta, error?: boolean) => action('INCREMENT', amount, meta, error);\n * ```\n */\nexport function action<\n  T extends TypeConstant,\n  P = undefined,\n  M = undefined,\n  E = undefined\n>(type: T, payload?: P, meta?: M, error?: E) {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionCreator(1);\n  }\n\n  return { type, payload, meta, error } as any;\n}\n","import { ActionCreator, TypeConstant } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from './utils/validation';\n\n/**\n * @description create custom action-creator using constructor function with injected type argument\n */\nexport function createCustomAction<\n  T extends TypeConstant,\n  AC extends ActionCreator<T> = () => { type: T }\n>(type: T, createHandler?: (type: T) => AC): AC {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  const actionCreator: AC =\n    createHandler != null ? createHandler(type) : ((() => ({ type })) as AC);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import {\n  TypeConstant,\n  ActionBuilderConstructor,\n  ActionBuilderMap,\n} from './type-helpers';\nimport { createCustomAction } from './create-custom-action';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionType,\n  throwInvalidActionType,\n} from './utils/validation';\n\nexport interface ActionBuilder<T extends TypeConstant> {\n  <P = undefined, M = undefined>(): ActionBuilderConstructor<T, P, M>;\n  map<R, P = undefined, M = undefined>(\n    fn: (payload: P, meta: M) => R\n  ): ActionBuilderMap<T, R, P, M>;\n}\n\n/**\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createStandardAction<T extends TypeConstant>(\n  type: T\n): ActionBuilder<T> {\n  if (checkIsEmpty(type)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionType(type)) {\n    throwInvalidActionType(1);\n  }\n\n  function constructor<P, M = undefined>(): ActionBuilderConstructor<T, P, M> {\n    return createCustomAction(type, _type => (payload: P, meta: M) => ({\n      type: _type,\n      payload,\n      meta,\n    })) as ActionBuilderConstructor<T, P, M>;\n  }\n\n  function map<R, P, M>(\n    fn: (payload: P, meta: M) => R\n  ): ActionBuilderMap<T, R, P, M> {\n    return createCustomAction(type, _type => (payload: P, meta: M) =>\n      Object.assign(fn(payload, meta), { type: _type })\n    ) as ActionBuilderMap<T, R, P, M>;\n  }\n\n  return Object.assign(constructor, { map });\n}\n","import { TypeConstant, ActionCreator, TypeMeta } from './type-helpers';\nimport {\n  checkIsEmpty,\n  throwIsEmpty,\n  checkInvalidActionCreator,\n  throwInvalidActionCreator,\n} from './utils/validation';\n\n/**\n * @description get the \"type literal\" of a given action-creator\n */\nexport function getType<T extends TypeConstant>(\n  actionCreator: ActionCreator<T> & TypeMeta<T>\n): T {\n  if (checkIsEmpty(actionCreator)) {\n    throwIsEmpty(1);\n  }\n\n  if (checkInvalidActionCreator(actionCreator)) {\n    throwInvalidActionCreator(1);\n  }\n\n  return actionCreator.getType!();\n}\n","import { TypeConstant, ActionCreator } from './type-helpers';\nimport { action } from './action';\n\nexport type PayloadMetaAction<\n  T extends TypeConstant,\n  P,\n  M\n> = P extends undefined\n  ? M extends undefined\n    ? { type: T }\n    : { type: T; meta: M }\n  : M extends undefined\n  ? { type: T; payload: P }\n  : { type: T; payload: P; meta: M };\n\n/**\n * @description typesafe action-creator factory\n */\nexport function createAction<\n  T extends TypeConstant,\n  AC extends ActionCreator<T> = () => { type: T }\n>(\n  type: T,\n  createHandler?: (\n    actionCallback: <P = undefined, M = undefined>(\n      payload?: P,\n      meta?: M\n    ) => PayloadMetaAction<T, P, M>\n  ) => AC\n): AC {\n  // validation is already done in action function\n\n  const actionCreator: AC =\n    createHandler == null\n      ? ((() => action(type)) as AC)\n      : createHandler(action.bind(null, type) as Parameters<\n          typeof createHandler\n        >[0]);\n\n  return Object.assign(actionCreator, {\n    getType: () => type,\n    // redux-actions compatibility\n    toString: () => type,\n  });\n}\n","import {\n  TypeConstant,\n  ActionBuilderConstructor,\n  // ActionBuilderMap,\n} from './type-helpers';\nimport { createCustomAction } from './create-custom-action';\nimport { checkInvalidActionTypeInArray } from './utils/validation';\nimport { createStandardAction } from './create-standard-action';\n\nexport interface AsyncActionBuilder<\n  TType1 extends TypeConstant,\n  TType2 extends TypeConstant,\n  TType3 extends TypeConstant,\n  TType4 extends TypeConstant\n> {\n  // tslint:disable-next-line:callable-types\n  <TPayload1, TPayload2, TPayload3, TPayload4>(): {\n    request: ActionBuilderConstructor<TType1, TPayload1>;\n    success: ActionBuilderConstructor<TType2, TPayload2>;\n    failure: ActionBuilderConstructor<TType3, TPayload3>;\n    cancel: ActionBuilderConstructor<TType4, TPayload4>;\n  };\n  <TPayload1, TPayload2, TPayload3>(): {\n    request: ActionBuilderConstructor<TType1, TPayload1>;\n    success: ActionBuilderConstructor<TType2, TPayload2>;\n    failure: ActionBuilderConstructor<TType3, TPayload3>;\n  };\n}\n\n/**\n * implementation\n */\nexport function createAsyncAction<\n  TType1 extends TypeConstant,\n  TType2 extends TypeConstant,\n  TType3 extends TypeConstant,\n  TType4 extends TypeConstant\n>(\n  requestType: TType1,\n  successType: TType2,\n  failureType: TType3,\n  cancelType?: TType4\n): AsyncActionBuilder<TType1, TType2, TType3, TType4> {\n  [requestType, successType, failureType].forEach(\n    checkInvalidActionTypeInArray\n  );\n\n  const constructor = (<TPayload1, TPayload2, TPayload3, TPayload4>() => {\n    return {\n      request: createStandardAction(requestType)<TPayload1>(),\n      success: createStandardAction(successType)<TPayload2>(),\n      failure: createStandardAction(failureType)<TPayload3>(),\n      cancel: cancelType && createStandardAction(cancelType)<TPayload4>(),\n    };\n  }) as AsyncActionBuilder<TType1, TType2, TType3, TType4>;\n\n  const api = Object.assign<\n    AsyncActionBuilder<TType1, TType2, TType3, TType4>,\n    {}\n  >(constructor, {\n    // extension point for chain api\n  });\n\n  return api;\n}\n\n// export interface AsyncActionBuilder<\n// {\n// withMappers<A1 = undefined, P1 = undefined, A2 = undefined, P2 = undefined, A3 = undefined, P3 = undefined>(\n//   requestMapper: (a?: A1) => P1,\n//   successMapper: (a?: A2) => P2,\n//   failureMapper: (a?: A3) => P3\n// ): AsyncActionBuilderWithMappers<T1, T2, T3, A1, P1, A2, P2, A3, P3>;\n// }\n\n// export type AsyncActionBuilderWithMappers<\n//   T1 extends StringType,\n//   T2 extends StringType,\n//   T3 extends StringType,\n//   A1 = undefined,\n//   P1 = undefined,\n//   A2 = undefined,\n//   P2 = undefined,\n//   A3 = undefined,\n//   P3 = undefined\n//   > = {\n//     request: ActionBuilderMap<T1, A1, P1>;\n//     success: ActionBuilderMap<T2, A2, P2>;\n//     failure: ActionBuilderMap<T3, A3, P3>;\n//   };\n\n// function withMappers<A1, P1, A2, P2, A3, P3>(\n//   requestMapper: (a?: A1) => P1,\n//   successMapper: (a?: A2) => P2,\n//   failureMapper: (a?: A3) => P3\n// ): AsyncActionBuilderWithMappers<T1, T2, T3, A1, P1, A2, P2, A3, P3> {\n//   return {\n//     request: createCustomAction(requestType, type => (payload?: A1) => ({\n//       type,\n//       payload: requestMapper != null ? requestMapper(payload) : undefined,\n//     })) as MapBuilder<T1, A1, P1>,\n//     success: createCustomAction(successType, type => (payload?: A2) => ({\n//       type,\n//       payload: successMapper != null ? successMapper(payload) : undefined,\n//     })) as MapBuilder<T2, A2, P2>,\n//     failure: createCustomAction(failureType, type => (payload?: A3) => ({\n//       type,\n//       payload: failureMapper != null ? failureMapper(payload) : undefined,\n//     })) as MapBuilder<T3, A3, P3>,\n//   };\n// }\n","import { getType } from './get-type';\nimport {\n  checkValidActionCreator,\n  checkValidActionType,\n  throwInvalidActionTypeOrActionCreator,\n} from './utils/validation';\nimport { Reducer, Action, Types } from './type-helpers';\n\n// RootAction is injected from consumer or any\nexport type RootAction = Types extends { RootAction: infer T } ? T : any;\n\ntype CreateReducerChainApi<\n  TState,\n  TPrevNotHandledAction extends Action,\n  TRootAction extends Action\n> = <\n  TType extends TPrevNotHandledAction['type'],\n  THandledTypeAction extends TPrevNotHandledAction extends Action<TType>\n    ? TPrevNotHandledAction\n    : never,\n  TCreator extends (...args: any[]) => TPrevNotHandledAction,\n  THandledCreatorAction extends TPrevNotHandledAction extends ReturnType<\n    TCreator\n  >\n    ? TPrevNotHandledAction\n    : never,\n  THandledAction extends THandledTypeAction extends THandledCreatorAction\n    ? THandledTypeAction\n    : never\n>(\n  singleOrMultipleCreatorsAndTypes: TType | TType[] | TCreator | TCreator[],\n  reducer: (state: TState, action: THandledAction) => TState\n) => [\n  Exclude<TPrevNotHandledAction, THandledTypeAction & THandledCreatorAction>\n] extends [never]\n  ? Reducer<TState, TRootAction> & {\n      handlers: Record<\n        TRootAction['type'],\n        (state: TState, action: TRootAction) => TState\n      >;\n    }\n  : Reducer<TState, TRootAction> & {\n      handlers: Record<\n        Exclude<\n          TRootAction,\n          Exclude<\n            TPrevNotHandledAction,\n            THandledTypeAction & THandledCreatorAction\n          >\n        >['type'],\n        (state: TState, action: TRootAction) => TState\n      >;\n      handleAction: CreateReducerChainApi<\n        TState,\n        Exclude<\n          TPrevNotHandledAction,\n          THandledTypeAction & THandledCreatorAction\n        >,\n        TRootAction\n      >;\n    };\n\ntype GetAction<\n  TAction extends Action,\n  TType extends TAction['type']\n> = TAction extends Action<TType> ? TAction : never;\n\ntype InitialHandler<TState, TRootAction extends Action> = {\n  [P in TRootAction['type']]?: (\n    state: TState,\n    action: GetAction<TRootAction, P>\n  ) => TState\n};\n\nexport function createReducer<TState, TRootAction extends Action = RootAction>(\n  initialState: TState,\n  initialHandlers: InitialHandler<TState, TRootAction> = {}\n) {\n  const handlers: Partial<\n    Record<any, (state: TState, action: any) => TState>\n  > = {\n    ...initialHandlers,\n  };\n\n  const rootReducer: Reducer<TState, TRootAction> = (\n    state = initialState,\n    action\n  ) => {\n    if (handlers.hasOwnProperty(action.type)) {\n      const reducer = handlers[action.type];\n      if (typeof reducer !== 'function') {\n        throw Error(\n          `Reducer under \"${action.type}\" key is not a valid reducer`\n        );\n      }\n      return reducer(state, action);\n    } else {\n      return state;\n    }\n  };\n\n  const handleAction = ((singleOrMultipleCreatorsAndTypes, reducer) => {\n    const creatorsAndTypes = Array.isArray(singleOrMultipleCreatorsAndTypes)\n      ? singleOrMultipleCreatorsAndTypes\n      : [singleOrMultipleCreatorsAndTypes];\n\n    const newHandlers: typeof handlers = {};\n    creatorsAndTypes\n      .map(acOrType =>\n        checkValidActionCreator(acOrType)\n          ? getType(acOrType)\n          : checkValidActionType(acOrType)\n          ? acOrType\n          : throwInvalidActionTypeOrActionCreator()\n      )\n      .forEach(type => (newHandlers[type] = reducer));\n\n    return createReducer<TState, TRootAction>(initialState, {\n      ...handlers,\n      ...newHandlers,\n    });\n  }) as CreateReducerChainApi<TState, TRootAction, TRootAction>;\n\n  const chainApi = Object.assign(rootReducer, {\n    handlers: { ...handlers },\n    handleAction,\n  } as const);\n\n  return chainApi;\n}\n","import {\n  checkInvalidActionTypeInArray,\n  checkIsEmpty,\n  throwIsEmpty,\n} from './utils/validation';\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends string, A extends { type: string }>(\n  type: T | T[],\n  action: A\n): action is A extends { type: T } ? A : never;\n\n/**\n * @description (curried assert function) check if action type is equal given type-constant\n * @description it works with discriminated union types\n */\nexport function isOfType<T extends string>(\n  type: T | T[]\n): <A extends { type: string }>(\n  action: A\n) => action is A extends { type: T } ? A : never;\n\n/**\n * implementation\n */\nexport function isOfType<T extends string, A extends { type: T }>(\n  actionTypeOrTypes: T | T[],\n  action?: A\n) {\n  if (checkIsEmpty(actionTypeOrTypes)) {\n    throwIsEmpty(1);\n  }\n\n  const actionTypes = Array.isArray(actionTypeOrTypes)\n    ? actionTypeOrTypes\n    : [actionTypeOrTypes];\n\n  actionTypes.forEach(checkInvalidActionTypeInArray);\n\n  const assertFn = (_action: A) => actionTypes.includes(_action.type);\n\n  // 1 arg case => return curried version\n  if (action === undefined) {\n    return assertFn;\n  }\n  // 2 args case => invoke assertFn and return the result\n  return assertFn(action);\n}\n","import { TypeMeta } from './type-helpers';\nimport {\n  checkInvalidActionCreatorInArray,\n  checkIsEmpty,\n  throwIsEmpty,\n} from './utils/validation';\n\nexport type ActionCreator<T extends { type: string }> = ((\n  ...args: any[]\n) => T) &\n  TypeMeta<T['type']>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreator: AC | AC[],\n  action: { type: string }\n): action is ReturnType<AC>;\n\n/**\n * @description (curried assert function) check if an action is the instance of given action-creator(s)\n * @description it works with discriminated union types\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreator: AC | AC[]\n): (action: { type: string }) => action is ReturnType<AC>;\n\n/**\n * implementation\n */\nexport function isActionOf<AC extends ActionCreator<{ type: string }>>(\n  actionCreatorOrCreators: AC | AC[],\n  action?: { type: string }\n) {\n  if (checkIsEmpty(actionCreatorOrCreators)) {\n    throwIsEmpty(1);\n  }\n\n  const actionCreators = Array.isArray(actionCreatorOrCreators)\n    ? actionCreatorOrCreators\n    : [actionCreatorOrCreators];\n\n  actionCreators.forEach(checkInvalidActionCreatorInArray);\n\n  const assertFn = (_action: { type: string }) =>\n    actionCreators.some(\n      actionCreator => _action.type === actionCreator.getType!()\n    );\n\n  // 1 arg case => return curried version\n  if (action === undefined) {\n    return assertFn;\n  }\n  // 2 args case => invoke assertFn and return the result\n  return assertFn(action);\n}\n","/**\n * DEPRECATED\n */\n\nimport { TypeConstant } from './type-helpers';\n\ninterface FSA<T extends TypeConstant, P = {}, M = {}, E = boolean> {\n  type: T;\n  payload?: P;\n  meta?: M;\n  error?: E;\n}\n\n/**\n * @deprecated\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createActionDeprecated<\n  T extends TypeConstant,\n  AC extends (...args: any[]) => FSA<T>\n>(actionType: T, creatorFunction: AC): AC;\n\n/**\n * @deprecated\n * @description create an action-creator of a given function that contains hidden \"type\" metadata\n */\nexport function createActionDeprecated<\n  T extends TypeConstant,\n  AC extends () => { type: T }\n>(actionType: T): AC;\n\n/**\n *  implementation\n */\nexport function createActionDeprecated<\n  T extends TypeConstant,\n  AC extends (...args: any[]) => FSA<T>\n>(actionType: T, creatorFunction?: AC): AC {\n  let actionCreator: AC;\n\n  if (creatorFunction != null) {\n    if (typeof creatorFunction !== 'function') {\n      throw new Error('second argument is not a function');\n    }\n\n    actionCreator = creatorFunction as AC;\n  } else {\n    actionCreator = (() => ({ type: actionType })) as AC;\n  }\n\n  if (actionType != null) {\n    if (typeof actionType !== 'string' && typeof actionType !== 'symbol') {\n      throw new Error('first argument should be type of: string | symbol');\n    }\n  } else {\n    throw new Error('first argument is missing');\n  }\n\n  return actionCreator;\n}\n"],"names":["checkIsEmpty","arg","argPosition","throwIsEmpty","Error","checkValidActionCreator","throwInvalidActionCreator","checkInvalidActionCreatorInArray","idx","getType","checkValidActionType","checkInvalidActionType","throwInvalidActionType","checkInvalidActionTypeInArray","action","type","payload","meta","error","createCustomAction","createHandler","actionCreator","Object","assign","toString","createStandardAction","_type","map","fn","bind","requestType","successType","failureType","cancelType","forEach","request","success","failure","cancel","createReducer","initialState","initialHandlers","handlers","state","hasOwnProperty","reducer","handleAction","singleOrMultipleCreatorsAndTypes","newHandlers","Array","isArray","acOrType","throwInvalidActionTypeOrActionCreator","actionTypeOrTypes","actionTypes","assertFn","_action","includes","undefined","actionCreatorOrCreators","actionCreators","some","actionType","creatorFunction"],"mappings":"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"}