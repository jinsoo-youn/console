function checkIsEmpty(arg, argPosition = 1) {
    return arg == null;
}
function throwIsEmpty(argPosition = 1) {
    throw new Error(`Argument ${argPosition} is empty.`);
}
function checkValidActionCreator(arg) {
    return typeof arg === 'function' && 'getType' in arg;
}
function checkInvalidActionCreator(arg) {
    return !checkValidActionCreator(arg);
}
function throwInvalidActionCreator(argPosition = 1) {
    throw new Error(`Argument ${argPosition} is invalid, it should be an action-creator instance from "typesafe-actions"`);
}
function checkInvalidActionCreatorInArray(arg, idx) {
    if (arg == null) {
        throw new Error(`Argument contains array with empty element at index ${idx}`);
    }
    else if (arg.getType == null) {
        throw new Error(`Argument contains array with invalid element at index ${idx}, it should be an action-creator instance from "typesafe-actions"`);
    }
}
function checkValidActionType(arg) {
    return typeof arg === 'string' || typeof arg === 'symbol';
}
function checkInvalidActionType(arg) {
    return !checkValidActionType(arg);
}
function throwInvalidActionType(argPosition = 1) {
    throw new Error(`Argument ${argPosition} is invalid, it should be an action type of type: string | symbol`);
}
function checkInvalidActionTypeInArray(arg, idx) {
    if (arg == null) {
        throw new Error(`Argument contains array with empty element at index ${idx}`);
    }
    else if (typeof arg !== 'string' && typeof arg !== 'symbol') {
        throw new Error(`Argument contains array with invalid element at index ${idx}, it should be of type: string | symbol`);
    }
}
function throwInvalidActionTypeOrActionCreator(argPosition = 1) {
    throw new Error(`Argument ${argPosition} is invalid, it should be an action-creator instance from "typesafe-actions" or action type of type: string | symbol`);
}

function action(type, payload, meta, error) {
    if (checkIsEmpty(type)) {
        throwIsEmpty(1);
    }
    if (checkInvalidActionType(type)) {
        throwInvalidActionCreator(1);
    }
    return { type, payload, meta, error };
}

function createAction(type, createHandler) {
    const actionCreator = createHandler == null
        ? (() => action(type))
        : createHandler(action.bind(null, type));
    return Object.assign(actionCreator, {
        getType: () => type,
        toString: () => type,
    });
}

function createCustomAction(type, createHandler) {
    if (checkIsEmpty(type)) {
        throwIsEmpty(1);
    }
    if (checkInvalidActionType(type)) {
        throwInvalidActionType(1);
    }
    const actionCreator = createHandler != null ? createHandler(type) : (() => ({ type }));
    return Object.assign(actionCreator, {
        getType: () => type,
        toString: () => type,
    });
}

function createStandardAction(type) {
    if (checkIsEmpty(type)) {
        throwIsEmpty(1);
    }
    if (checkInvalidActionType(type)) {
        throwInvalidActionType(1);
    }
    function constructor() {
        return createCustomAction(type, _type => (payload, meta) => ({
            type: _type,
            payload,
            meta,
        }));
    }
    function map(fn) {
        return createCustomAction(type, _type => (payload, meta) => Object.assign(fn(payload, meta), { type: _type }));
    }
    return Object.assign(constructor, { map });
}

function createAsyncAction(requestType, successType, failureType, cancelType) {
    [requestType, successType, failureType].forEach(checkInvalidActionTypeInArray);
    const constructor = (() => {
        return {
            request: createStandardAction(requestType)(),
            success: createStandardAction(successType)(),
            failure: createStandardAction(failureType)(),
            cancel: cancelType && createStandardAction(cancelType)(),
        };
    });
    const api = Object.assign(constructor, {});
    return api;
}

function getType(actionCreator) {
    if (checkIsEmpty(actionCreator)) {
        throwIsEmpty(1);
    }
    if (checkInvalidActionCreator(actionCreator)) {
        throwInvalidActionCreator(1);
    }
    return actionCreator.getType();
}

function createReducer(initialState, initialHandlers = {}) {
    const handlers = Object.assign({}, initialHandlers);
    const rootReducer = (state = initialState, action) => {
        if (handlers.hasOwnProperty(action.type)) {
            const reducer = handlers[action.type];
            if (typeof reducer !== 'function') {
                throw Error(`Reducer under "${action.type}" key is not a valid reducer`);
            }
            return reducer(state, action);
        }
        else {
            return state;
        }
    };
    const handleAction = ((singleOrMultipleCreatorsAndTypes, reducer) => {
        const creatorsAndTypes = Array.isArray(singleOrMultipleCreatorsAndTypes)
            ? singleOrMultipleCreatorsAndTypes
            : [singleOrMultipleCreatorsAndTypes];
        const newHandlers = {};
        creatorsAndTypes
            .map(acOrType => checkValidActionCreator(acOrType)
            ? getType(acOrType)
            : checkValidActionType(acOrType)
                ? acOrType
                : throwInvalidActionTypeOrActionCreator())
            .forEach(type => (newHandlers[type] = reducer));
        return createReducer(initialState, Object.assign({}, handlers, newHandlers));
    });
    const chainApi = Object.assign(rootReducer, {
        handlers: Object.assign({}, handlers),
        handleAction,
    });
    return chainApi;
}

function isOfType(actionTypeOrTypes, action) {
    if (checkIsEmpty(actionTypeOrTypes)) {
        throwIsEmpty(1);
    }
    const actionTypes = Array.isArray(actionTypeOrTypes)
        ? actionTypeOrTypes
        : [actionTypeOrTypes];
    actionTypes.forEach(checkInvalidActionTypeInArray);
    const assertFn = (_action) => actionTypes.includes(_action.type);
    if (action === undefined) {
        return assertFn;
    }
    return assertFn(action);
}

function isActionOf(actionCreatorOrCreators, action) {
    if (checkIsEmpty(actionCreatorOrCreators)) {
        throwIsEmpty(1);
    }
    const actionCreators = Array.isArray(actionCreatorOrCreators)
        ? actionCreatorOrCreators
        : [actionCreatorOrCreators];
    actionCreators.forEach(checkInvalidActionCreatorInArray);
    const assertFn = (_action) => actionCreators.some(actionCreator => _action.type === actionCreator.getType());
    if (action === undefined) {
        return assertFn;
    }
    return assertFn(action);
}

function createActionDeprecated(actionType, creatorFunction) {
    let actionCreator;
    if (creatorFunction != null) {
        if (typeof creatorFunction !== 'function') {
            throw new Error('second argument is not a function');
        }
        actionCreator = creatorFunction;
    }
    else {
        actionCreator = (() => ({ type: actionType }));
    }
    if (actionType != null) {
        if (typeof actionType !== 'string' && typeof actionType !== 'symbol') {
            throw new Error('first argument should be type of: string | symbol');
        }
    }
    else {
        throw new Error('first argument is missing');
    }
    return actionCreator;
}

export { action, createAction, createStandardAction, createCustomAction, createAsyncAction, createReducer, getType, isOfType, isActionOf, createActionDeprecated };
