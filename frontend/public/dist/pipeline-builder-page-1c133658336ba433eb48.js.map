{"version":3,"file":"pipeline-builder-page-1c133658336ba433eb48.js","sources":["webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderForm.scss?7c9b","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderForm.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderHeader.scss?692e","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderHeader.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderPage.scss?f1cd","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderPage.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/PipelineBuilderVisualization.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/const.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/hooks.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/modals/ModalContent.scss?ca1a","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/modals/ModalContent.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/modals/index.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/Sidebar.scss?3217","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/Sidebar.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/TaskSidebar.scss?3eda","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/TaskSidebar.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/TaskSidebarName.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/TaskSidebarParam.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/TaskSidebarResource.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/task-sidebar/temp-utils.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/update-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/utils.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-builder/validation-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/resource-utils.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { FormikProps, FormikValues } from 'formik';\nimport { Form, Stack, StackItem, TextInputTypes } from '@patternfly/react-core';\nimport { InputField, FormFooter } from '@console/shared';\nimport { Pipeline } from '../../../utils/pipeline-augment';\nimport { PipelineParameters, PipelineResources } from '../detail-page-tabs';\nimport { UpdateOperationType } from './const';\nimport { useResourceValidation } from './hooks';\nimport { removeTaskModal } from './modals';\nimport PipelineBuilderHeader from './PipelineBuilderHeader';\nimport PipelineBuilderVisualization from './PipelineBuilderVisualization';\nimport Sidebar from './task-sidebar/Sidebar';\nimport TaskSidebar from './task-sidebar/TaskSidebar';\nimport {\n  CleanupResults,\n  PipelineBuilderTaskGroup,\n  SelectedBuilderTask,\n  UpdateErrors,\n  UpdateOperationUpdateTaskData,\n} from './types';\nimport { applyChange } from './update-utils';\n\nimport './PipelineBuilderForm.scss';\n\ntype PipelineBuilderFormProps = FormikProps<FormikValues> & {\n  existingPipeline: Pipeline;\n  namespace: string;\n};\n\nconst PipelineBuilderForm: React.FC<PipelineBuilderFormProps> = (props) => {\n  const [selectedTask, setSelectedTask] = React.useState<SelectedBuilderTask>(null);\n  const selectedTaskRef = React.useRef<SelectedBuilderTask>(null);\n  selectedTaskRef.current = selectedTask;\n\n  const {\n    existingPipeline,\n    status,\n    isSubmitting,\n    dirty,\n    handleReset,\n    handleSubmit,\n    errors,\n    namespace,\n    setFieldValue,\n    setStatus,\n    values,\n  } = props;\n  const statusRef = React.useRef(status);\n  statusRef.current = status;\n\n  const updateErrors: UpdateErrors = React.useCallback(\n    (taskErrors) => {\n      if (taskErrors) {\n        setStatus({\n          ...statusRef.current,\n          tasks: _.omitBy(_.merge({}, statusRef.current?.tasks, taskErrors), (v) => !v),\n        });\n      }\n    },\n    [setStatus],\n  );\n\n  useResourceValidation(values.tasks, values.resources, updateErrors);\n\n  const updateTasks = (changes: CleanupResults): void => {\n    const { tasks, listTasks, errors: taskErrors } = changes;\n\n    setFieldValue('tasks', tasks);\n    setFieldValue('listTasks', listTasks);\n    updateErrors(taskErrors);\n  };\n\n  const selectedId = values.tasks[selectedTask?.taskIndex]?.name;\n  const selectedIds = selectedId ? [selectedId] : [];\n\n  const taskGroup: PipelineBuilderTaskGroup = {\n    tasks: values.tasks,\n    listTasks: values.listTasks,\n    highlightedIds: selectedIds,\n  };\n\n  const closeSidebarAndHandleReset = React.useCallback(() => {\n    setSelectedTask(null);\n    selectedTaskRef.current = null;\n    handleReset();\n  }, [handleReset]);\n\n  return (\n    <>\n      <Stack className=\"odc-pipeline-builder-form\">\n        <StackItem>\n          <PipelineBuilderHeader existingPipeline={existingPipeline} namespace={namespace} />\n        </StackItem>\n        <StackItem isFilled className=\"odc-pipeline-builder-form__content\">\n          <Form className=\"odc-pipeline-builder-form__grid\" onSubmit={handleSubmit}>\n            <div className=\"odc-pipeline-builder-form__short-section\">\n              <InputField\n                label=\"Name\"\n                name=\"name\"\n                type={TextInputTypes.text}\n                isDisabled={!!existingPipeline}\n                required\n              />\n            </div>\n\n            <div>\n              <h2>Tasks</h2>\n              <PipelineBuilderVisualization\n                namespace={namespace}\n                tasksInError={status?.tasks || {}}\n                onTaskSelection={(task, resource) => {\n                  setSelectedTask({\n                    taskIndex: values.tasks.findIndex(({ name }) => name === task.name),\n                    resource,\n                  });\n                }}\n                onUpdateTasks={(updatedTaskGroup, op) =>\n                  updateTasks(applyChange(updatedTaskGroup, op))\n                }\n                taskGroup={taskGroup}\n              />\n            </div>\n\n            <div>\n              <h2>Parameters</h2>\n              <PipelineParameters addLabel=\"Add Parameters\" fieldName=\"params\" />\n            </div>\n\n            <div>\n              <h2>Resources</h2>\n              <PipelineResources addLabel=\"Add Resources\" fieldName=\"resources\" />\n            </div>\n            <FormFooter\n              handleReset={closeSidebarAndHandleReset}\n              errorMessage={status?.submitError}\n              isSubmitting={isSubmitting}\n              submitLabel={existingPipeline ? 'Save' : 'Create'}\n              disableSubmit={\n                !dirty ||\n                !_.isEmpty(errors) ||\n                !_.isEmpty(status?.tasks) ||\n                values.tasks.length === 0\n              }\n              resetLabel=\"Cancel\"\n              sticky\n            />\n          </Form>\n        </StackItem>\n      </Stack>\n      <Sidebar\n        open={!!selectedTask}\n        onRequestClose={() => {\n          if (selectedTask?.taskIndex === selectedTaskRef.current?.taskIndex) {\n            setSelectedTask(null);\n          }\n        }}\n      >\n        {() => (\n          <div className=\"pf-c-form\">\n            <TaskSidebar\n              // Intentional remount when selection changes\n              key={selectedTask.taskIndex}\n              resourceList={values.resources || []}\n              errorMap={status?.tasks || {}}\n              onUpdateTask={(data: UpdateOperationUpdateTaskData) => {\n                updateTasks(\n                  applyChange(taskGroup, { type: UpdateOperationType.UPDATE_TASK, data }),\n                );\n              }}\n              onRemoveTask={(taskName) => {\n                removeTaskModal(taskName, () => {\n                  setSelectedTask(null);\n                  updateTasks(\n                    applyChange(taskGroup, {\n                      type: UpdateOperationType.REMOVE_TASK,\n                      data: { taskName },\n                    }),\n                  );\n                });\n              }}\n              selectedPipelineTaskIndex={selectedTask.taskIndex}\n              taskResource={selectedTask.resource}\n            />\n          </div>\n        )}\n      </Sidebar>\n    </>\n  );\n};\n\nexport default PipelineBuilderForm;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Button, Flex, FlexItem, FlexItemModifiers } from '@patternfly/react-core';\nimport { warnYAML } from './modals';\nimport { TechPreviewBadge } from '@console/shared';\nimport { Pipeline } from '../../../utils/pipeline-augment';\nimport { goToYAML } from './utils';\n\nimport './PipelineBuilderHeader.scss';\n\ntype PipelineBuilderHeaderProps = {\n  existingPipeline: Pipeline;\n  namespace: string;\n};\n\nconst PipelineBuilderHeader: React.FC<PipelineBuilderHeaderProps> = (props) => {\n  const { existingPipeline, namespace } = props;\n\n  return (\n    <div className=\"odc-pipeline-builder-header\">\n      <Flex className=\"odc-pipeline-builder-header__content\">\n        <FlexItem breakpointMods={[{ modifier: FlexItemModifiers.grow }]}>\n          <h1 className=\"odc-pipeline-builder-header__title\">Pipeline Builder</h1>\n        </FlexItem>\n        <FlexItem>\n          <Button\n            variant=\"link\"\n            onClick={() => {\n              warnYAML(() => goToYAML(existingPipeline, namespace));\n            }}\n          >\n            Edit YAML\n          </Button>\n        </FlexItem>\n        <FlexItem>\n          <TechPreviewBadge />\n        </FlexItem>\n      </Flex>\n      <hr />\n    </div>\n  );\n};\n\nexport default PipelineBuilderHeader;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { RouteComponentProps } from 'react-router-dom';\nimport { Helmet } from 'react-helmet';\nimport { Formik, FormikBag } from 'formik';\nimport { history } from '@console/internal/components/utils';\nimport { k8sCreate, k8sUpdate } from '@console/internal/module/k8s';\nimport { PipelineModel } from '../../../models';\nimport { Pipeline } from '../../../utils/pipeline-augment';\nimport PipelineBuilderForm from './PipelineBuilderForm';\nimport { PipelineBuilderFormValues, PipelineBuilderFormikValues } from './types';\nimport {\n  convertBuilderFormToPipeline,\n  convertPipelineToBuilderForm,\n  getPipelineURL,\n} from './utils';\nimport { validationSchema } from './validation-utils';\n\nimport './PipelineBuilderPage.scss';\n\ntype PipelineBuilderPageProps = RouteComponentProps<{ ns?: string }> & {\n  existingPipeline?: Pipeline;\n};\n\nconst PipelineBuilderPage: React.FC<PipelineBuilderPageProps> = (props) => {\n  const {\n    existingPipeline,\n    match: {\n      params: { ns },\n    },\n  } = props;\n\n  const initialValues: PipelineBuilderFormValues = {\n    name: 'new-pipeline',\n    params: [],\n    resources: [],\n    tasks: [],\n    listTasks: [],\n    ...(convertPipelineToBuilderForm(existingPipeline) || {}),\n  };\n\n  const handleSubmit = (\n    values: PipelineBuilderFormikValues,\n    actions: FormikBag<any, PipelineBuilderFormValues>,\n  ) => {\n    let resourceCall;\n    if (existingPipeline) {\n      resourceCall = k8sUpdate(\n        PipelineModel,\n        convertBuilderFormToPipeline(values, ns, existingPipeline),\n        ns,\n        existingPipeline.metadata.name,\n      );\n    } else {\n      resourceCall = k8sCreate(PipelineModel, convertBuilderFormToPipeline(values, ns));\n    }\n\n    return resourceCall\n      .then(() => {\n        actions.setSubmitting(false);\n        history.push(`${getPipelineURL(ns)}/${values.name}`);\n      })\n      .catch((e) => {\n        actions.setStatus({ submitError: e.message });\n      });\n  };\n\n  return (\n    <div className=\"odc-pipeline-builder-page\">\n      <Helmet>\n        <title>Pipeline Builder</title>\n      </Helmet>\n      <Formik\n        initialValues={initialValues}\n        onSubmit={handleSubmit}\n        onReset={history.goBack}\n        validationSchema={validationSchema}\n        render={(formikProps) => (\n          <PipelineBuilderForm\n            {...formikProps}\n            namespace={ns}\n            existingPipeline={existingPipeline}\n          />\n        )}\n      />\n    </div>\n  );\n};\n\nexport default PipelineBuilderPage;\n","import * as React from 'react';\nimport { Alert } from '@patternfly/react-core';\nimport { LoadingBox } from '@console/internal/components/utils';\nimport { PipelineLayout } from '../pipeline-topology/const';\nimport PipelineTopologyGraph from '../pipeline-topology/PipelineTopologyGraph';\nimport { getEdgesFromNodes } from '../pipeline-topology/utils';\nimport { useNodes } from './hooks';\nimport {\n  PipelineBuilderTaskGroup,\n  SelectTaskCallback,\n  TaskErrorMap,\n  UpdateTasksCallback,\n} from './types';\n\ntype PipelineBuilderVisualizationProps = {\n  namespace: string;\n  onTaskSelection: SelectTaskCallback;\n  onUpdateTasks: UpdateTasksCallback;\n  taskGroup: PipelineBuilderTaskGroup;\n  tasksInError: TaskErrorMap;\n};\n\nconst PipelineBuilderVisualization: React.FC<PipelineBuilderVisualizationProps> = ({\n  namespace,\n  onTaskSelection,\n  onUpdateTasks,\n  taskGroup,\n  tasksInError,\n}) => {\n  const { tasksLoaded, tasksCount, nodes, loadingTasksError } = useNodes(\n    namespace,\n    onTaskSelection,\n    onUpdateTasks,\n    taskGroup,\n    tasksInError,\n  );\n\n  if (loadingTasksError) {\n    return (\n      <Alert variant=\"danger\" isInline title=\"Error loading the tasks.\">\n        {loadingTasksError}\n      </Alert>\n    );\n  }\n  if (!tasksLoaded) {\n    return <LoadingBox />;\n  }\n  if (tasksCount === 0 && taskGroup.tasks.length === 0) {\n    // No tasks, nothing we can do here...\n    return <Alert variant=\"danger\" isInline title=\"Unable to locate any tasks.\" />;\n  }\n\n  return (\n    <PipelineTopologyGraph\n      // TODO: fix this; the graph layout isn't properly laying out nodes\n      key={nodes.map((n) => n.id).join('-')}\n      id=\"pipeline-builder\"\n      fluid\n      nodes={nodes}\n      edges={getEdgesFromNodes(nodes)}\n      layout={PipelineLayout.DAGRE_BUILDER}\n    />\n  );\n};\n\nexport default PipelineBuilderVisualization;\n","export const TASK_INCOMPLETE_ERROR_MESSAGE = 'Incomplete Task';\n\nexport enum UpdateOperationType {\n  ADD_LIST_TASK,\n  CONVERT_LIST_TO_TASK,\n  UPDATE_TASK,\n  REMOVE_TASK,\n  DELETE_LIST_TASK,\n  FIX_INVALID_LIST_TASK,\n}\n\nexport enum TaskErrorType {\n  MISSING_REQUIRED_PARAMS = 'missingParams',\n  MISSING_NAME = 'nameMissing',\n  MISSING_RESOURCES = 'missingResources',\n}\n\nexport const TASK_ERROR_STRINGS = {\n  [TaskErrorType.MISSING_RESOURCES]: 'Missing Resources',\n  [TaskErrorType.MISSING_REQUIRED_PARAMS]: 'Missing Parameters',\n  [TaskErrorType.MISSING_NAME]: 'Task Name is Required',\n};\n\nexport const nodeTaskErrors = [\n  TaskErrorType.MISSING_REQUIRED_PARAMS,\n  TaskErrorType.MISSING_RESOURCES,\n];\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { k8sList } from '@console/internal/module/k8s';\nimport { ClusterTaskModel, TaskModel } from '../../../models';\nimport {\n  PipelineResource,\n  PipelineResourceTask,\n  PipelineTask,\n  PipelineTaskRef,\n} from '../../../utils/pipeline-augment';\nimport { PipelineVisualizationTaskItem } from '../../../utils/pipeline-utils';\nimport { AddNodeDirection } from '../pipeline-topology/const';\nimport {\n  PipelineBuilderTaskNodeModel,\n  PipelineMixedNodeModel,\n  PipelineTaskListNodeModel,\n} from '../pipeline-topology/types';\nimport {\n  createInvalidTaskListNode,\n  createTaskListNode,\n  handleParallelToParallelNodes,\n  tasksToBuilderNodes,\n} from '../pipeline-topology/utils';\nimport {\n  PipelineBuilderTaskGroup,\n  SelectTaskCallback,\n  TaskErrorMap,\n  UpdateErrors,\n  UpdateOperationAddData,\n  UpdateOperationConvertToTaskData,\n  UpdateOperationFixInvalidTaskListData,\n  UpdateTasksCallback,\n} from './types';\nimport { nodeTaskErrors, TaskErrorType, UpdateOperationType } from './const';\nimport { getErrorMessage } from './utils';\n\ntype UseTasks = {\n  namespacedTasks: PipelineResourceTask[] | null;\n  clusterTasks: PipelineResourceTask[] | null;\n  errorMsg?: string;\n};\nexport const useTasks = (namespace?: string): UseTasks => {\n  const [namespacedTasks, setNamespacedTasks] = React.useState<PipelineResourceTask[]>(null);\n  const [clusterTasks, setClusterTasks] = React.useState<PipelineResourceTask[]>(null);\n  const [loadErrorMsg, setLoadErrorMsg] = React.useState<string>(undefined);\n\n  React.useEffect(() => {\n    let ignore = false;\n    if (loadErrorMsg) {\n      return null;\n    }\n\n    if (!namespacedTasks) {\n      if (!namespace) {\n        setNamespacedTasks([]);\n      } else {\n        k8sList(TaskModel, { ns: namespace })\n          .then((res: PipelineResourceTask[]) => {\n            if (ignore) {\n              return;\n            }\n            setNamespacedTasks(res);\n          })\n          .catch(() => {\n            setLoadErrorMsg(`Failed to load namespace Tasks. ${loadErrorMsg || ''}`);\n          });\n      }\n    }\n\n    if (!clusterTasks) {\n      k8sList(ClusterTaskModel)\n        .then((res: PipelineResourceTask[]) => {\n          if (ignore) {\n            return;\n          }\n          setClusterTasks(res);\n        })\n        .catch(() => {\n          setLoadErrorMsg(`Failed to load ClusterTasks. ${loadErrorMsg || ''}`);\n        });\n    }\n    return () => {\n      ignore = true;\n    };\n  }, [\n    namespace,\n    namespacedTasks,\n    setNamespacedTasks,\n    clusterTasks,\n    setClusterTasks,\n    setLoadErrorMsg,\n    loadErrorMsg,\n  ]);\n\n  return {\n    namespacedTasks,\n    clusterTasks,\n    errorMsg: loadErrorMsg,\n  };\n};\n\ntype UseNodes = {\n  nodes: PipelineMixedNodeModel[];\n  tasksCount: number;\n  tasksLoaded: boolean;\n  loadingTasksError?: string;\n};\nexport const useNodes = (\n  namespace: string,\n  onTaskSelection: SelectTaskCallback,\n  onUpdateTasks: UpdateTasksCallback,\n  taskGroup: PipelineBuilderTaskGroup,\n  tasksInError: TaskErrorMap,\n): UseNodes => {\n  const { clusterTasks, namespacedTasks, errorMsg } = useTasks(namespace);\n\n  const getTask = (taskRef: PipelineTaskRef) => {\n    if (taskRef.kind === ClusterTaskModel.kind) {\n      return clusterTasks?.find((task) => task.metadata.name === taskRef.name);\n    }\n    return namespacedTasks?.find((task) => task.metadata.name === taskRef.name);\n  };\n\n  const taskGroupRef = React.useRef(taskGroup);\n  taskGroupRef.current = taskGroup;\n\n  const onNewListNode = (task: PipelineVisualizationTaskItem, direction: AddNodeDirection) => {\n    const data: UpdateOperationAddData = { direction, relatedTask: task };\n    onUpdateTasks(taskGroupRef.current, { type: UpdateOperationType.ADD_LIST_TASK, data });\n  };\n  const onNewTask = (resource: PipelineResourceTask, name: string, runAfter?: string[]) => {\n    const data: UpdateOperationConvertToTaskData = { resource, name, runAfter };\n    onUpdateTasks(taskGroupRef.current, { type: UpdateOperationType.CONVERT_LIST_TO_TASK, data });\n  };\n\n  // TODO: Fix id collisions then remove this utility; we shouldn't need to trim the tasks\n  const noDuplicates = (resource: PipelineResourceTask) =>\n    !taskGroupRef.current.tasks.find((pt) => pt.name === resource.metadata.name);\n  const newListNode = (\n    name: string,\n    runAfter?: string[],\n    firstTask?: boolean,\n  ): PipelineTaskListNodeModel =>\n    createTaskListNode(name, {\n      namespaceTaskList: namespacedTasks?.filter(noDuplicates),\n      clusterTaskList: clusterTasks?.filter(noDuplicates),\n      onNewTask: (resource: PipelineResourceTask) => {\n        onNewTask(resource, name, runAfter);\n      },\n      onRemoveTask: firstTask\n        ? null\n        : () => {\n            onUpdateTasks(taskGroupRef.current, {\n              type: UpdateOperationType.DELETE_LIST_TASK,\n              data: { listTaskName: name },\n            });\n          },\n      task: {\n        name,\n        runAfter: runAfter || [],\n      },\n    });\n  const soloTask = (name = 'initial-node') => newListNode(name, undefined, true);\n  const newInvalidListNode = (name: string, runAfter?: string[]): PipelineTaskListNodeModel =>\n    createInvalidTaskListNode(name, {\n      namespaceTaskList: namespacedTasks?.filter(noDuplicates),\n      clusterTaskList: clusterTasks?.filter(noDuplicates),\n      onNewTask: (resource: PipelineResourceTask) => {\n        const data: UpdateOperationFixInvalidTaskListData = {\n          existingName: name,\n          resource,\n          runAfter,\n        };\n\n        onUpdateTasks(taskGroupRef.current, {\n          type: UpdateOperationType.FIX_INVALID_LIST_TASK,\n          data,\n        });\n      },\n      onRemoveTask: () => {\n        onUpdateTasks(taskGroupRef.current, {\n          type: UpdateOperationType.REMOVE_TASK,\n          data: { taskName: name },\n        });\n      },\n      task: {\n        name,\n        runAfter: runAfter || [],\n      },\n    });\n\n  const invalidTaskList = taskGroup.tasks.filter((task) => !getTask(task.taskRef));\n  const validTaskList = taskGroup.tasks.filter((task) => !!getTask(task.taskRef));\n\n  const invalidTaskListNodes: PipelineTaskListNodeModel[] = invalidTaskList.map((task) =>\n    newInvalidListNode(task.name, task.runAfter),\n  );\n  const taskNodes: PipelineBuilderTaskNodeModel[] =\n    validTaskList.length > 0\n      ? tasksToBuilderNodes(\n          validTaskList,\n          onNewListNode,\n          (task) => onTaskSelection(task, getTask(task.taskRef)),\n          getErrorMessage(nodeTaskErrors, tasksInError),\n          taskGroup.highlightedIds,\n        )\n      : [];\n  const taskListNodes: PipelineTaskListNodeModel[] =\n    taskGroup.tasks.length === 0 && taskGroup.listTasks.length <= 1\n      ? [soloTask(taskGroup.listTasks[0]?.name)]\n      : taskGroup.listTasks.map((listTask) => newListNode(listTask.name, listTask.runAfter));\n\n  const nodes: PipelineMixedNodeModel[] = handleParallelToParallelNodes([\n    ...taskNodes,\n    ...taskListNodes,\n    ...invalidTaskListNodes,\n  ]);\n\n  const localTaskCount = namespacedTasks?.length || 0;\n  const clusterTaskCount = clusterTasks?.length || 0;\n\n  return {\n    tasksCount: localTaskCount + clusterTaskCount,\n    tasksLoaded: !!namespacedTasks && !!clusterTasks,\n    loadingTasksError: errorMsg,\n    nodes,\n  };\n};\n\nexport const useResourceValidation = (\n  tasks: PipelineTask[],\n  resourceValues: PipelineResource[],\n  onError: UpdateErrors,\n) => {\n  const [previousErrorIds, setPreviousErrorIds] = React.useState([]);\n\n  React.useEffect(() => {\n    const resourceNames = resourceValues.map((r) => r.name);\n\n    const errors = tasks.reduce((acc, task) => {\n      const output = task.resources?.outputs || [];\n      const input = task.resources?.inputs || [];\n      const missingResources = [...output, ...input].filter(\n        (r) => !resourceNames.includes(r.resource),\n      );\n\n      if (missingResources.length === 0) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [task.name]: [TaskErrorType.MISSING_RESOURCES],\n      };\n    }, {});\n\n    if (!_.isEmpty(errors) || previousErrorIds.length > 0) {\n      const outputErrors = previousErrorIds.reduce((acc, id) => {\n        if (acc[id]) {\n          // Error exists, leave it alone\n          return acc;\n        }\n\n        // Error doesn't exist but we had it once, make sure it is cleared\n        return {\n          ...acc,\n          [id]: null,\n        };\n      }, errors);\n\n      const currentErrorIds = Object.keys(outputErrors).filter((id) => !!outputErrors[id]);\n      if (!_.isEqual(currentErrorIds, previousErrorIds)) {\n        setPreviousErrorIds(currentErrorIds);\n      }\n      onError(outputErrors);\n    }\n  }, [tasks, resourceValues, onError, previousErrorIds, setPreviousErrorIds]);\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Split, SplitItem } from '@patternfly/react-core';\n\nimport './ModalContent.scss';\n\ntype ModalContentProps = {\n  icon?: React.ReactNode;\n  title: string;\n  message: string;\n};\n\nconst ModalContent: React.FC<ModalContentProps> = ({ icon, message, title }) => {\n  return (\n    <Split className=\"odc-modal-content\" gutter=\"md\">\n      {icon && <SplitItem>{icon}</SplitItem>}\n      <SplitItem isFilled>\n        <h2 className=\"co-break-word odc-modal-content__confirm-title\">{title}</h2>\n        <p className=\"co-break-word\">{message}</p>\n      </SplitItem>\n    </Split>\n  );\n};\n\nexport default ModalContent;\n","import * as React from 'react';\nimport { confirmModal } from '@console/internal/components/modals/confirm-modal';\nimport ModalContent from './ModalContent';\nimport { ExclamationTriangleIcon } from '@patternfly/react-icons';\nimport { global_warning_color_100 as warningColor } from '@patternfly/react-tokens';\n\ntype ModalCallback = () => void;\n\nexport const removeTaskModal = (taskName: string, onRemove: ModalCallback) => {\n  confirmModal({\n    title: 'Remove Task',\n    message: (\n      <ModalContent\n        icon={<ExclamationTriangleIcon size=\"lg\" color={warningColor.value} />}\n        title={`Remove ${taskName}?`}\n        message={`Are you sure you want to remove ${taskName}?`}\n      />\n    ),\n    buttonText: 'Remove',\n    executeFn: () => {\n      onRemove();\n      return Promise.resolve();\n    },\n    submitDanger: true,\n  });\n};\n\nexport const warnYAML = (onAccept: ModalCallback) => {\n  confirmModal({\n    message: (\n      <ModalContent\n        icon={<ExclamationTriangleIcon size=\"lg\" color={warningColor.value} />}\n        title=\"Switch to YAML Editor?\"\n        message=\"Switching to YAML will lose any unsaved changes in this pipeline builder and allow you to build your pipeline in YAML.\n        Are you sure you want to switch?\"\n      />\n    ),\n    submitDanger: true,\n    btnText: 'Continue',\n    executeFn: () => {\n      onAccept();\n      return Promise.resolve();\n    },\n  });\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { CSSTransition } from 'react-transition-group';\n\nimport './Sidebar.scss';\n\ntype LazyRender = () => React.ReactNode;\ntype SidebarProps = {\n  children: React.ReactNode | LazyRender;\n  onRequestClose: () => void;\n  open: boolean;\n};\n\nconst DURATION = 225;\n\nconst Sidebar: React.FC<SidebarProps> = (props) => {\n  const { children, onRequestClose, open } = props;\n\n  const [canClose, setCanClose] = React.useState(false);\n  const contentRef = React.useRef(null);\n  const closeRef = React.useCallback(\n    (e) => {\n      if (canClose && !contentRef?.current?.contains(e?.target)) {\n        onRequestClose();\n      }\n    },\n    [canClose, onRequestClose],\n  );\n\n  React.useEffect(() => {\n    let timeout = null;\n    if (open) {\n      timeout = setTimeout(() => setCanClose(true), DURATION);\n    } else {\n      setCanClose(false);\n    }\n\n    return () => {\n      clearTimeout(timeout);\n    };\n  }, [open, setCanClose]);\n  React.useEffect(() => {\n    window.addEventListener('click', closeRef);\n\n    return () => {\n      window.removeEventListener('click', closeRef);\n    };\n  }, [closeRef]);\n\n  const render = () => {\n    if (typeof children === 'function') {\n      if (open) {\n        return (children as LazyRender)();\n      }\n    } else {\n      return children;\n    }\n    return null;\n  };\n\n  return (\n    <CSSTransition in={open} timeout={DURATION} classNames=\"odc-sidebar\">\n      <div ref={contentRef} className=\"odc-sidebar odc-sidebar__content\">\n        {render()}\n      </div>\n    </CSSTransition>\n  );\n};\n\nexport default Sidebar;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { useField } from 'formik';\nimport { ActionsMenu, ResourceIcon } from '@console/internal/components/utils';\nimport { referenceFor } from '@console/internal/module/k8s';\nimport {\n  getResourceModelFromTaskKind,\n  PipelineResource,\n  PipelineResourceTask,\n  PipelineResourceTaskResource,\n  PipelineTask,\n  PipelineTaskParam,\n  PipelineTaskResource,\n} from '../../../../utils/pipeline-augment';\nimport { getTaskParameters, getTaskResources } from '../../resource-utils';\nimport { ResourceTarget, TaskErrorMap, UpdateOperationUpdateTaskData } from '../types';\nimport { TaskErrorType } from '../const';\nimport TaskSidebarParam from './TaskSidebarParam';\nimport TaskSidebarResource from './TaskSidebarResource';\nimport TaskSidebarName from './TaskSidebarName';\n\nimport './TaskSidebar.scss';\n\ntype TaskSidebarProps = {\n  errorMap: TaskErrorMap;\n  onRemoveTask: (taskName: string) => void;\n  onUpdateTask: (data: UpdateOperationUpdateTaskData) => void;\n  resourceList: PipelineResource[];\n  selectedPipelineTaskIndex: number;\n  taskResource: PipelineResourceTask;\n};\n\nconst TaskSidebar: React.FC<TaskSidebarProps> = (props) => {\n  const {\n    errorMap,\n    onRemoveTask,\n    onUpdateTask,\n    resourceList,\n    selectedPipelineTaskIndex,\n    taskResource,\n  } = props;\n  const formikTaskReference = `tasks.${selectedPipelineTaskIndex}`;\n  const [taskField] = useField<PipelineTask>(formikTaskReference);\n\n  const updateTask = (newData: Partial<UpdateOperationUpdateTaskData>) => {\n    onUpdateTask({ thisPipelineTask: taskField.value, taskResource, ...newData });\n  };\n\n  const thisTaskError = errorMap[taskField.value.name];\n\n  const params = getTaskParameters(taskResource);\n  const resources = getTaskResources(taskResource);\n  const inputResources = resources.inputs;\n  const outputResources = resources.outputs;\n\n  const renderResource = (type: ResourceTarget) => (resource: PipelineResourceTaskResource) => {\n    const taskResources: PipelineTaskResource[] = taskField.value?.resources?.[type] || [];\n    const thisResource = taskResources.find(\n      (taskFieldResource) => taskFieldResource.name === resource.name,\n    );\n\n    return (\n      <div key={resource.name} className=\"odc-task-sidebar__resource\">\n        <TaskSidebarResource\n          availableResources={resourceList}\n          onChange={(resourceName, selectedResource) => {\n            updateTask({\n              resources: {\n                resourceTarget: type,\n                selectedPipelineResource: selectedResource,\n                taskResourceName: resourceName,\n              },\n            });\n          }}\n          taskResource={thisResource}\n          resource={resource}\n        />\n      </div>\n    );\n  };\n\n  return (\n    <div className=\"odc-task-sidebar\">\n      <div className=\"odc-task-sidebar__header\">\n        <h1 className=\"co-m-pane__heading\">\n          <div className=\"co-m-pane__name co-resource-item\">\n            <ResourceIcon\n              className=\"co-m-resource-icon--lg\"\n              kind={referenceFor(getResourceModelFromTaskKind(taskResource.kind))}\n            />\n            {taskResource.metadata.name}\n          </div>\n          <div className=\"co-actions\">\n            <ActionsMenu\n              actions={[\n                {\n                  label: 'Remove Task',\n                  callback: () => onRemoveTask(taskField.value.name),\n                },\n              ]}\n            />\n          </div>\n        </h1>\n      </div>\n      <hr />\n\n      <div className=\"odc-task-sidebar__content\">\n        <TaskSidebarName\n          initialName={taskField.value.name}\n          taskName={taskResource.metadata.name}\n          onChange={(newName) => updateTask({ newName })}\n        />\n\n        {params && (\n          <>\n            <h2>Parameters</h2>\n            {params.map((param) => {\n              const taskParams: PipelineTaskParam[] = taskField.value?.params || [];\n              const thisParam = taskParams.find(\n                (taskFieldParam) => taskFieldParam.name === param.name,\n              );\n              return (\n                <div key={param.name} className=\"odc-task-sidebar__param\">\n                  <TaskSidebarParam\n                    hasParamError={!!thisTaskError?.includes(TaskErrorType.MISSING_REQUIRED_PARAMS)}\n                    resourceParam={param}\n                    taskParam={thisParam}\n                    onChange={(value) => {\n                      updateTask({\n                        params: {\n                          newValue: value,\n                          taskParamName: param.name,\n                        },\n                      });\n                    }}\n                  />\n                </div>\n              );\n            })}\n          </>\n        )}\n\n        {inputResources && (\n          <>\n            <h2>Input Resources</h2>\n            {inputResources.map(renderResource('inputs'))}\n          </>\n        )}\n        {outputResources && (\n          <>\n            <h2>Output Resources</h2>\n            {outputResources.map(renderResource('outputs'))}\n          </>\n        )}\n      </div>\n    </div>\n  );\n};\n\nexport default TaskSidebar;\n","import * as React from 'react';\nimport { FormGroup, TextInput, TextInputTypes } from '@patternfly/react-core';\nimport { SidebarInputWrapper } from './temp-utils';\n\ntype TaskSidebarNameProps = {\n  initialName: string;\n  onChange: (newName: string) => void;\n  taskName: string;\n};\n\nconst VALID_NAME = /^([a-z]([-a-z0-9]*[a-z0-9])?)*$/;\nconst INVALID_ERROR_MESSAGE =\n  'Name must consist of lower-case letters, numbers and hyphens. It must start with a letter and end with a letter or number.';\n\nconst getError = (value: string): string | null => {\n  let error = null;\n  if (value === '') {\n    error = 'Required';\n  } else if (!VALID_NAME.test(value)) {\n    error = INVALID_ERROR_MESSAGE;\n  }\n  return error;\n};\n\nconst TaskSidebarName: React.FC<TaskSidebarNameProps> = (props) => {\n  const { initialName, onChange, taskName } = props;\n  const [interimName, setInterimName] = React.useState(initialName);\n  const [error, setError] = React.useState(null);\n  const isValid = !error;\n\n  return (\n    <FormGroup\n      fieldId=\"task-name\"\n      label=\"Display Name\"\n      helperTextInvalid={error}\n      isValid={isValid}\n      isRequired\n    >\n      <SidebarInputWrapper>\n        <TextInput\n          id=\"task-name\"\n          isValid={isValid}\n          isRequired\n          onChange={(value) => {\n            setInterimName(value);\n            setError(getError(value));\n          }}\n          onBlur={() => {\n            if (isValid) {\n              onChange(interimName);\n            }\n          }}\n          placeholder={taskName}\n          type={TextInputTypes.text}\n          value={interimName}\n        />\n      </SidebarInputWrapper>\n    </FormGroup>\n  );\n};\n\nexport default TaskSidebarName;\n","import * as React from 'react';\nimport { FormGroup } from '@patternfly/react-core';\nimport { PipelineResourceTaskParam, PipelineTaskParam } from '../../../../utils/pipeline-augment';\nimport { taskParamIsRequired } from '../utils';\nimport { ArrayParam, ParameterProps, SidebarInputWrapper, StringParam } from './temp-utils';\n\ntype TaskSidebarParamProps = {\n  hasParamError?: boolean;\n  resourceParam: PipelineResourceTaskParam;\n  taskParam?: PipelineTaskParam;\n  onChange: (newValue: string) => void;\n};\n\nconst TaskSidebarParam: React.FC<TaskSidebarParamProps> = (props) => {\n  const { hasParamError, onChange, resourceParam, taskParam } = props;\n  const [dirty, setDirty] = React.useState(false);\n\n  const currentValue = taskParam?.value;\n  const emptyIsInvalid = taskParamIsRequired(resourceParam);\n\n  const isValid = !(dirty && hasParamError && emptyIsInvalid && currentValue != null);\n\n  const paramRenderProps: ParameterProps = {\n    currentValue,\n    defaultValue: resourceParam.default,\n    isValid,\n    name: resourceParam.name,\n    onChange,\n    setDirty,\n  };\n\n  return (\n    <FormGroup\n      fieldId={resourceParam.name}\n      label={resourceParam.name}\n      helperText={resourceParam.type === 'string' ? resourceParam.description : null}\n      helperTextInvalid=\"Required\"\n      isValid={isValid}\n      isRequired={emptyIsInvalid}\n    >\n      {resourceParam.type === 'array' ? (\n        <ArrayParam {...paramRenderProps} description={resourceParam.description} />\n      ) : (\n        <SidebarInputWrapper>\n          <StringParam {...paramRenderProps} />\n        </SidebarInputWrapper>\n      )}\n    </FormGroup>\n  );\n};\n\nexport default TaskSidebarParam;\n","import * as React from 'react';\nimport { FormGroup } from '@patternfly/react-core';\nimport { Dropdown } from '@console/internal/components/utils';\nimport {\n  PipelineResource,\n  PipelineResourceTaskResource,\n  PipelineTaskResource,\n} from '../../../../utils/pipeline-augment';\nimport { SidebarInputWrapper } from './temp-utils';\n\ntype TaskSidebarResourceProps = {\n  availableResources: PipelineResource[];\n  onChange: (resourceName: string, resource: PipelineResource) => void;\n  resource: PipelineResourceTaskResource;\n  taskResource?: PipelineTaskResource;\n};\n\nconst TaskSidebarResource: React.FC<TaskSidebarResourceProps> = (props) => {\n  const { availableResources, onChange, resource, taskResource } = props;\n\n  const dropdownResources = availableResources.filter(\n    ({ name, type }) => resource.type === type && !!name,\n  );\n\n  return (\n    <FormGroup\n      fieldId={resource.name}\n      label={resource.name}\n      helperText={`Only showing resources for this type (${resource.type}).`}\n      helperTextInvalid={\n        dropdownResources.length === 0 ? `No resources available. Add pipeline resources.` : ''\n      }\n      validated={dropdownResources.length > 0 ? 'default' : 'error'}\n      isRequired={!resource?.optional}\n    >\n      <SidebarInputWrapper>\n        <Dropdown\n          title={`Select ${resource.type} resource...`}\n          items={dropdownResources.reduce((acc, { name }) => ({ ...acc, [name]: name }), {})}\n          disabled={dropdownResources.length === 0}\n          selectedKey={taskResource?.resource || ''}\n          dropDownClassName=\"dropdown--full-width\"\n          onChange={(value: string) => {\n            onChange(\n              resource.name,\n              dropdownResources.find(({ name }) => name === value),\n            );\n          }}\n        />\n      </SidebarInputWrapper>\n    </FormGroup>\n  );\n};\n\nexport default TaskSidebarResource;\n","import * as React from 'react';\nimport { MinusCircleIcon } from '@patternfly/react-icons';\nimport { global_disabled_color_200 as disabledColor } from '@patternfly/react-tokens';\nimport { Flex, FlexItem, FlexModifiers, TextInput } from '@patternfly/react-core';\nimport MultiColumnFieldFooter from '@console/shared/src/components/formik-fields/multi-column-field/MultiColumnFieldFooter';\n\nexport type ParamValueType = string | string[];\nexport type ParameterProps = {\n  currentValue: ParamValueType;\n  defaultValue: ParamValueType;\n  description?: string;\n  isValid: boolean;\n  name: string;\n  onChange: (value: ParamValueType) => void;\n  setDirty: (dirty: boolean) => void;\n};\n\nexport const StringParam: React.FC<ParameterProps> = (props) => {\n  const { currentValue, defaultValue, isValid, name, onChange, setDirty } = props;\n\n  return (\n    <TextInput\n      id={name}\n      isValid={isValid}\n      isRequired={!defaultValue}\n      onBlur={() => setDirty(true)}\n      onChange={(value) => {\n        onChange(value);\n      }}\n      placeholder={defaultValue as string}\n      value={(currentValue || '') as string}\n    />\n  );\n};\n\nexport const ArrayParam: React.FC<ParameterProps> = (props) => {\n  const { currentValue, defaultValue, description, name, onChange, setDirty } = props;\n\n  const values = (currentValue || defaultValue || ['']) as string[];\n\n  return (\n    <>\n      {values.map((value, index) => {\n        return (\n          <Flex\n            key={`${index.toString()}`}\n            style={{ marginBottom: 'var(--pf-global--spacer--xs)' }}\n          >\n            <FlexItem breakpointMods={[{ modifier: FlexModifiers.grow }]}>\n              <StringParam\n                {...props}\n                name={`${name}-${index}`}\n                currentValue={value}\n                onChange={(changedValue: string) => {\n                  const newValues: string[] = [...values];\n                  newValues[index] = changedValue;\n                  onChange(newValues);\n                }}\n              />\n            </FlexItem>\n            <FlexItem>\n              <MinusCircleIcon\n                aria-hidden=\"true\"\n                style={{ color: values.length === 1 ? disabledColor.value : null }}\n                onClick={() => {\n                  if (values.length === 1) {\n                    return;\n                  }\n\n                  setDirty(true);\n                  setTimeout(\n                    () => onChange([...values.slice(0, index), ...values.slice(index + 1)]),\n                    0,\n                  );\n                }}\n              />\n            </FlexItem>\n          </Flex>\n        );\n      })}\n      <p\n        className=\"pf-c-form__helper-text\"\n        style={{ marginBottom: 'var(--pf-global--spacer--sm)' }}\n      >\n        {description}\n      </p>\n      <MultiColumnFieldFooter\n        addLabel=\"Add another value\"\n        onAdd={() => {\n          setDirty(true);\n          onChange([...values, '']);\n        }}\n      />\n    </>\n  );\n};\n\nexport const SidebarInputWrapper: React.FC = ({ children }) => {\n  return <div style={{ width: 'calc(100% - 28px)' }}>{children}</div>;\n};\n","import { getRandomChars } from '@console/shared/src/utils';\nimport {\n  PipelineResourceTask,\n  PipelineTask,\n  PipelineTaskParam,\n  PipelineTaskResource,\n} from '../../../utils/pipeline-augment';\nimport { AddNodeDirection } from '../pipeline-topology/const';\nimport { getTaskParameters, getTaskResources } from '../resource-utils';\nimport { TaskErrorType, UpdateOperationType } from './const';\nimport {\n  CleanupResults,\n  PipelineBuilderListTask,\n  PipelineBuilderTaskBase,\n  PipelineBuilderTaskGroup,\n  TaskErrorMap,\n  UpdateOperation,\n  UpdateOperationAction,\n  UpdateOperationAddData,\n  UpdateOperationConvertToTaskData,\n  UpdateOperationDeleteListTaskData,\n  UpdateOperationFixInvalidTaskListData,\n  UpdateOperationRemoveTaskData,\n  UpdateOperationUpdateTaskData,\n  UpdateTaskParamData,\n  UpdateTaskResourceData,\n} from './types';\nimport { convertResourceToTask, taskParamIsRequired } from './utils';\n\nconst mapReplaceRelatedInOthers = <TaskType extends PipelineBuilderTaskBase>(\n  taskName: string,\n  relatedTaskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!iterationTask?.runAfter?.includes(relatedTaskName)) {\n    return iterationTask;\n  }\n\n  const remainingRunAfters = iterationTask.runAfter.filter(\n    (runAfterName) => runAfterName !== relatedTaskName,\n  );\n\n  return {\n    ...iterationTask,\n    runAfter: [...remainingRunAfters, taskName],\n  };\n};\n\nconst mapRemoveRelatedInOthers = <TaskType extends PipelineBuilderTaskBase>(\n  taskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!iterationTask?.runAfter?.includes(taskName)) {\n    return iterationTask;\n  }\n\n  return {\n    ...iterationTask,\n    runAfter: iterationTask.runAfter.filter((runAfterName) => runAfterName !== taskName),\n  };\n};\n\nconst mapStitchReplaceInOthers = <TaskType extends PipelineBuilderTaskBase>(\n  removalTask: PipelineBuilderTaskBase,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!removalTask?.runAfter) {\n    return mapRemoveRelatedInOthers<TaskType>(removalTask.name, iterationTask);\n  }\n  if (!iterationTask?.runAfter?.includes(removalTask.name)) {\n    return iterationTask;\n  }\n\n  const updatedIterationTask = mapRemoveRelatedInOthers(removalTask.name, iterationTask);\n  if (updatedIterationTask.runAfter.length > 0) {\n    return updatedIterationTask;\n  }\n\n  return {\n    ...updatedIterationTask,\n    runAfter: removalTask.runAfter,\n  };\n};\n\nconst mapBeRelated = <TaskType extends PipelineBuilderTaskBase>(\n  newTaskName: string,\n  relatedTaskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (iterationTask.name !== relatedTaskName) {\n    return iterationTask;\n  }\n\n  return {\n    ...iterationTask,\n    runAfter: [newTaskName],\n  };\n};\n\nconst mapAddRelatedToOthers = <TaskType extends PipelineBuilderTaskBase>(\n  taskName: string,\n  relatedTaskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!iterationTask?.runAfter?.includes(relatedTaskName)) {\n    return iterationTask;\n  }\n\n  return {\n    ...iterationTask,\n    runAfter: [...iterationTask.runAfter, taskName],\n  };\n};\n\n// TODO: Can we use yup? Do we need this level of checking for errors?\nconst getErrors = (task: PipelineTask, resource: PipelineResourceTask): TaskErrorMap => {\n  const params = getTaskParameters(resource);\n  const resourceParams = params || [];\n  const requiredParamNames = resourceParams.filter(taskParamIsRequired).map((param) => param.name);\n  const hasNonDefaultParams = task.params\n    ?.filter(({ name }) => requiredParamNames.includes(name))\n    ?.map(({ value }) => !value)\n    .reduce((acc, missingDefault) => missingDefault || acc, false);\n\n  const needsName = !task.name;\n\n  const resources = getTaskResources(resource);\n\n  const taskInputResources = task.resources?.inputs?.length || 0;\n  const requiredInputResources = (resources.inputs || []).filter((r) => !r?.optional).length;\n  const missingInputResources = requiredInputResources - taskInputResources > 0;\n\n  const taskOutputResources = task.resources?.outputs?.length || 0;\n  const requiredOutputResources = (resources.outputs || []).filter((r) => !r?.optional).length;\n  const missingOutputResources = requiredOutputResources - taskOutputResources > 0;\n\n  const errorListing: TaskErrorType[] = [];\n  if (hasNonDefaultParams) {\n    errorListing.push(TaskErrorType.MISSING_REQUIRED_PARAMS);\n  }\n  if (missingInputResources || missingOutputResources) {\n    errorListing.push(TaskErrorType.MISSING_RESOURCES);\n  }\n  if (needsName) {\n    errorListing.push(TaskErrorType.MISSING_NAME);\n  }\n\n  return { [task.name]: errorListing.length > 0 ? errorListing : null };\n};\n\nconst addListNode: UpdateOperationAction<UpdateOperationAddData> = (tasks, listTasks, data) => {\n  const { direction, relatedTask } = data;\n\n  const newTaskName = `${direction}-${getRandomChars(6)}`;\n  const relatedTaskName = relatedTask.name;\n\n  switch (direction) {\n    case AddNodeDirection.BEFORE:\n      return {\n        tasks: tasks.map((pipelineTask) =>\n          mapBeRelated<PipelineTask>(newTaskName, relatedTaskName, pipelineTask),\n        ),\n        listTasks: [\n          ...listTasks.map((listTask) =>\n            mapBeRelated<PipelineBuilderListTask>(newTaskName, relatedTaskName, listTask),\n          ),\n          { name: newTaskName, runAfter: relatedTask.runAfter },\n        ],\n      };\n    case AddNodeDirection.AFTER:\n      return {\n        tasks: tasks.map((pipelineTask) =>\n          mapReplaceRelatedInOthers<PipelineTask>(newTaskName, relatedTaskName, pipelineTask),\n        ),\n        listTasks: [\n          ...listTasks.map((listTask) =>\n            mapReplaceRelatedInOthers<PipelineBuilderListTask>(\n              newTaskName,\n              relatedTaskName,\n              listTask,\n            ),\n          ),\n          { name: newTaskName, runAfter: [relatedTaskName] },\n        ],\n      };\n    case AddNodeDirection.PARALLEL:\n      return {\n        tasks: tasks.map((pipelineTask) =>\n          mapAddRelatedToOthers<PipelineTask>(newTaskName, relatedTaskName, pipelineTask),\n        ),\n        listTasks: [\n          ...listTasks.map((listTask) =>\n            mapAddRelatedToOthers<PipelineBuilderListTask>(newTaskName, relatedTaskName, listTask),\n          ),\n          { name: newTaskName, runAfter: relatedTask.runAfter },\n        ],\n      };\n    default:\n      throw new Error(`Invalid direction ${direction}`);\n  }\n};\n\nconst convertListToTask: UpdateOperationAction<UpdateOperationConvertToTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { name, resource, runAfter } = data;\n\n  const newPipelineTask: PipelineTask = convertResourceToTask(resource, runAfter);\n\n  return {\n    tasks: [\n      ...tasks.map((pipelineTask) =>\n        mapReplaceRelatedInOthers(newPipelineTask.name, name, pipelineTask),\n      ),\n      newPipelineTask,\n    ],\n    listTasks: listTasks\n      .filter((n) => n.name !== name)\n      .map((listTask) => mapReplaceRelatedInOthers(newPipelineTask.name, name, listTask)),\n    errors: getErrors(newPipelineTask, resource),\n  };\n};\n\nconst removeAndUpdateTasks = <\n  URT extends PipelineBuilderTaskBase,\n  UT extends PipelineBuilderTaskBase\n>(\n  removalTaskName: string,\n  updateAndRemoveTasks: URT[],\n  updateOnlyTasks: UT[],\n): { updateOnlyTasks: UT[]; updateAndRemoveTasks: URT[] } => {\n  const removalTask = updateAndRemoveTasks.find((task) => task.name === removalTaskName);\n  return {\n    updateOnlyTasks: updateOnlyTasks.map((task) => mapStitchReplaceInOthers<UT>(removalTask, task)),\n    updateAndRemoveTasks: updateAndRemoveTasks\n      .filter((task) => task.name !== removalTaskName)\n      .map((task) => mapStitchReplaceInOthers<URT>(removalTask, task)),\n  };\n};\n\nconst deleteListTask: UpdateOperationAction<UpdateOperationDeleteListTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { listTaskName } = data;\n\n  const { updateOnlyTasks, updateAndRemoveTasks } = removeAndUpdateTasks<\n    PipelineBuilderListTask,\n    PipelineTask\n  >(listTaskName, listTasks, tasks);\n  return {\n    tasks: updateOnlyTasks,\n    listTasks: updateAndRemoveTasks,\n    errors: null,\n  };\n};\n\nexport const removeTask: UpdateOperationAction<UpdateOperationRemoveTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { taskName } = data;\n\n  const { updateOnlyTasks, updateAndRemoveTasks } = removeAndUpdateTasks<\n    PipelineTask,\n    PipelineBuilderListTask\n  >(taskName, tasks, listTasks);\n  return {\n    tasks: updateAndRemoveTasks,\n    listTasks: updateOnlyTasks,\n    errors: { [taskName]: null },\n  };\n};\n\nconst applyResourceUpdate = (\n  pipelineTask: PipelineTask,\n  resources: UpdateTaskResourceData,\n): PipelineTask => {\n  const { resourceTarget, selectedPipelineResource, taskResourceName } = resources;\n\n  const existingResources: PipelineTaskResource[] = pipelineTask.resources?.[resourceTarget] || [];\n  const filteredResources = existingResources.filter((resource: PipelineTaskResource) => {\n    return resource.name !== taskResourceName;\n  });\n\n  return {\n    ...pipelineTask,\n    resources: {\n      ...pipelineTask.resources,\n      [resourceTarget]: [\n        ...filteredResources,\n        {\n          name: taskResourceName,\n          resource: selectedPipelineResource.name,\n        },\n      ],\n    },\n  };\n};\n\nconst applyParamsUpdate = (\n  pipelineTask: PipelineTask,\n  params: UpdateTaskParamData,\n): PipelineTask => {\n  const { newValue, taskParamName } = params;\n\n  return {\n    ...pipelineTask,\n    params: pipelineTask.params.map(\n      (param): PipelineTaskParam => {\n        if (param.name !== taskParamName) {\n          return param;\n        }\n\n        return {\n          ...param,\n          value: newValue,\n        };\n      },\n    ),\n  };\n};\n\nconst updateTask: UpdateOperationAction<UpdateOperationUpdateTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { thisPipelineTask, taskResource, newName, params, resources } = data;\n\n  const canRename = !!newName;\n\n  const updatedResourceIndex = tasks.findIndex(\n    (pipelineTask) => pipelineTask.name === thisPipelineTask.name,\n  );\n  const updatedTasks = tasks.map((pipelineTask) => {\n    if (pipelineTask.name !== thisPipelineTask.name) {\n      if (canRename) {\n        return mapReplaceRelatedInOthers(newName, thisPipelineTask.name, pipelineTask);\n      }\n      return pipelineTask;\n    }\n\n    let updatedResource = pipelineTask;\n    if (resources) {\n      updatedResource = applyResourceUpdate(updatedResource, resources);\n    }\n    if (params) {\n      updatedResource = applyParamsUpdate(updatedResource, params);\n    }\n    if (canRename) {\n      updatedResource = {\n        ...updatedResource,\n        name: newName,\n      };\n    }\n\n    return updatedResource;\n  });\n  const updatedResource = updatedTasks[updatedResourceIndex];\n\n  return {\n    tasks: updatedTasks,\n    listTasks: canRename\n      ? listTasks.map((listTask) =>\n          mapReplaceRelatedInOthers(newName, thisPipelineTask.name, listTask),\n        )\n      : listTasks,\n    errors: {\n      [thisPipelineTask.name]: null,\n      ...getErrors(updatedResource, taskResource),\n    },\n  };\n};\n\nconst fixInvalidListTask: UpdateOperationAction<UpdateOperationFixInvalidTaskListData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { existingName, resource, runAfter } = data;\n\n  const newPipelineTask: PipelineTask = convertResourceToTask(resource, runAfter);\n\n  return {\n    tasks: [\n      ...tasks\n        .filter((pipelineTask) => pipelineTask.name !== existingName)\n        .map((pipelineTask) =>\n          mapReplaceRelatedInOthers(newPipelineTask.name, existingName, pipelineTask),\n        ),\n      newPipelineTask,\n    ],\n    listTasks,\n    errors: getErrors(newPipelineTask, resource),\n  };\n};\n\nexport const applyChange = (\n  taskGroup: PipelineBuilderTaskGroup,\n  op: UpdateOperation,\n): CleanupResults => {\n  const { type, data } = op;\n  const { tasks, listTasks } = taskGroup;\n\n  switch (type) {\n    case UpdateOperationType.ADD_LIST_TASK:\n      return addListNode(tasks, listTasks, data as UpdateOperationAddData);\n    case UpdateOperationType.CONVERT_LIST_TO_TASK:\n      return convertListToTask(tasks, listTasks, data as UpdateOperationConvertToTaskData);\n    case UpdateOperationType.DELETE_LIST_TASK:\n      return deleteListTask(tasks, listTasks, data as UpdateOperationDeleteListTaskData);\n    case UpdateOperationType.REMOVE_TASK:\n      return removeTask(tasks, listTasks, data as UpdateOperationRemoveTaskData);\n    case UpdateOperationType.UPDATE_TASK:\n      return updateTask(tasks, listTasks, data as UpdateOperationUpdateTaskData);\n    case UpdateOperationType.FIX_INVALID_LIST_TASK:\n      return fixInvalidListTask(tasks, listTasks, data as UpdateOperationFixInvalidTaskListData);\n    default:\n      throw new Error(`Invalid update operation ${type}`);\n  }\n};\n","import { history, resourcePathFromModel } from '@console/internal/components/utils';\nimport { apiVersionForModel, referenceForModel } from '@console/internal/module/k8s';\nimport { ClusterTaskModel, PipelineModel } from '../../../models';\nimport {\n  Pipeline,\n  PipelineResourceTask,\n  PipelineResourceTaskParam,\n  PipelineTask,\n} from '../../../utils/pipeline-augment';\nimport { getTaskParameters } from '../resource-utils';\nimport { TASK_ERROR_STRINGS, TaskErrorType } from './const';\nimport { PipelineBuilderFormikValues, PipelineBuilderFormValues, TaskErrorMap } from './types';\n\nexport const getErrorMessage = (errorTypes: TaskErrorType[], errorMap: TaskErrorMap) => (\n  taskName: string,\n): string => {\n  if (!taskName) {\n    return TASK_ERROR_STRINGS[TaskErrorType.MISSING_NAME];\n  }\n\n  const errorList: TaskErrorType[] | undefined = errorMap?.[taskName];\n  if (!errorList) return null;\n\n  const hasRequestedError = errorList.filter((error) => errorTypes.includes(error));\n  return hasRequestedError.length > 0 ? TASK_ERROR_STRINGS[hasRequestedError[0]] : null;\n};\n\nexport const taskParamIsRequired = (param: PipelineResourceTaskParam): boolean => {\n  return !('default' in param);\n};\n\nexport const convertResourceToTask = (\n  resource: PipelineResourceTask,\n  runAfter?: string[],\n): PipelineTask => {\n  return {\n    name: resource.metadata.name,\n    runAfter,\n    taskRef: {\n      kind: resource.kind === ClusterTaskModel.kind ? ClusterTaskModel.kind : undefined,\n      name: resource.metadata.name,\n    },\n    params: getTaskParameters(resource).map((param) => ({\n      name: param.name,\n      value: param.default,\n    })),\n  };\n};\n\nexport const getPipelineURL = (namespace: string) => {\n  return `/k8s/ns/${namespace}/${referenceForModel(PipelineModel)}`;\n};\n\nconst removeListRunAfters = (task: PipelineTask, listIds: string[]): PipelineTask => {\n  if (task?.runAfter && listIds.length > 0) {\n    // Trim out any runAfters pointing at list nodes\n    const runAfter = (task.runAfter || []).filter(\n      (runAfterName) => !listIds.includes(runAfterName),\n    );\n\n    return {\n      ...task,\n      runAfter,\n    };\n  }\n\n  return task;\n};\n\nconst removeEmptyDefaultParams = (task: PipelineTask): PipelineTask => {\n  if (task.params?.length > 0) {\n    // Since we can submit, this param has a default; check for empty values and remove\n    return {\n      ...task,\n      params: task.params.filter((param) => !!param.value),\n    };\n  }\n\n  return task;\n};\n\nexport const convertBuilderFormToPipeline = (\n  formValues: PipelineBuilderFormikValues,\n  namespace: string,\n  existingPipeline?: Pipeline,\n): Pipeline => {\n  const { name, resources, params, tasks, listTasks } = formValues;\n  const listIds = listTasks.map((listTask) => listTask.name);\n\n  return {\n    ...existingPipeline,\n    apiVersion: apiVersionForModel(PipelineModel),\n    kind: PipelineModel.kind,\n    metadata: {\n      ...existingPipeline?.metadata,\n      name,\n      namespace,\n    },\n    spec: {\n      ...existingPipeline?.spec,\n      params,\n      resources,\n      tasks: tasks.map((task) => removeEmptyDefaultParams(removeListRunAfters(task, listIds))),\n    },\n  };\n};\n\nexport const convertPipelineToBuilderForm = (pipeline: Pipeline): PipelineBuilderFormValues => {\n  if (!pipeline) return null;\n\n  const {\n    metadata: { name },\n    spec: { params = [], resources = [], tasks = [] },\n  } = pipeline;\n\n  return {\n    name,\n    params,\n    resources,\n    tasks,\n    listTasks: [],\n  };\n};\n\nexport const goToYAML = (existingPipeline?: Pipeline, namespace?: string) => {\n  history.push(\n    existingPipeline\n      ? `${resourcePathFromModel(\n          PipelineModel,\n          existingPipeline?.metadata?.name,\n          existingPipeline?.metadata?.namespace,\n        )}/yaml`\n      : `${getPipelineURL(namespace)}/~new`,\n  );\n};\n","import * as yup from 'yup';\n\nexport const validationSchema = yup.object({\n  name: yup.string().required('Required'),\n  params: yup.array().of(\n    yup.object({\n      name: yup.string().required('Required'),\n      description: yup.string(),\n      default: yup.string(),\n    }),\n  ),\n  resources: yup.array().of(\n    yup.object({\n      name: yup.string().required('Required'),\n      type: yup.string().required('Required'),\n    }),\n  ),\n  tasks: yup\n    .array()\n    .of(\n      yup.object({\n        name: yup.string().required('Required'),\n        runAfter: yup.array().of(yup.string()),\n        taskRef: yup\n          .object({\n            name: yup.string().required('Required'),\n            kind: yup.string(),\n          })\n          .required('Required'),\n      }),\n    )\n    .min(1, 'Must define at least one task')\n    .required('Required'),\n  taskList: yup.array().of(\n    yup.object({\n      name: yup.string().required('Required'),\n      runAfter: yup.string(),\n    }),\n  ),\n});\n","import { get } from 'lodash';\nimport {\n  PipelineResourceTask,\n  PipelineResourceTaskParam,\n  PipelineResourceTaskResource,\n} from '../../utils/pipeline-augment';\n\ntype PipelineResourceTaskAlpha = PipelineResourceTask & {\n  spec: {\n    inputs?: {\n      params?: PipelineResourceTaskParam[];\n      resources?: PipelineResourceTaskResource[];\n    };\n    outputs?: {\n      resources?: PipelineResourceTaskResource[];\n    };\n  };\n};\n\nexport type InputOutputResources = {\n  inputs?: PipelineResourceTaskResource[];\n  outputs?: PipelineResourceTaskResource[];\n};\n\nenum PATHS {\n  alphaInputResources = 'spec.inputs.resources',\n  alphaOutputResources = 'spec.outputs.resources',\n  alphaParameters = 'spec.inputs.params',\n\n  betaInputResources = 'spec.resources.inputs',\n  betaOutputResources = 'spec.resources.outputs',\n  betaParameters = 'spec.params',\n}\n\nexport const getTaskResources = (\n  taskResource: PipelineResourceTask | PipelineResourceTaskAlpha,\n): InputOutputResources => {\n  const inputs =\n    get(taskResource, PATHS.alphaInputResources) || get(taskResource, PATHS.betaInputResources);\n  const outputs =\n    get(taskResource, PATHS.alphaOutputResources) || get(taskResource, PATHS.betaOutputResources);\n\n  if (inputs || outputs) {\n    return {\n      inputs,\n      outputs,\n    };\n  }\n\n  return {};\n};\n\nexport const getTaskParameters = (\n  taskResource: PipelineResourceTask | PipelineResourceTaskAlpha,\n): PipelineResourceTaskParam[] => {\n  return get(taskResource, PATHS.alphaParameters) || get(taskResource, PATHS.betaParameters) || [];\n};\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAEA;AAOA;;AACA;AACA;AACA;AAEA;AAaA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAOA;AACA;AACA;AAQA;;AAGA;AACA;AACA;AACA;AAIA;AACA;;AAAA;AACA;AAIA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AASA;AAEA;;;;;;;;;;;;AC/LA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAKA;AACA;AAGA;AAGA;AAEA;;;;;;;;;;;;AC1CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AAEA;AAMA;AACA;AAOA;AASA;AAIA;AACA;AACA;AAMA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAeA;AAEA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAgBA;AAOA;AAQA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AAAA;AACA;AAQA;AAEA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC1BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAcA;AAgBA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAQA;;AAOA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AAOA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACrRA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AASA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AAEA;;;;;;;;;;;;ACpEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AASA;AAEA;AACA;AACA;AACA;AAEA;AAWA;AACA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AACA;AAIA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AAMA;AAEA;AACA;;AACA;AACA;AAGA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AAEA;AACA;AAGA;AAEA;AACA;AAMA;AAEA;;;;;;;;;;;;;AC9JA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AAEA;;;;;;;;;;;;;AC7DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AASA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAaA;AAKA;AAEA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AASA;AACA;AAEA;AAIA;AAWA;AACA;AAOA;AAIA;AAKA;AAEA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAaA;AACA;AAEA;AAOA;AACA;AAKA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AAKA;AACA;AAKA;AACA;AACA;AACA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAIA;AAKA;AACA;AAMA;AAGA;AACA;AACA;AAIA;AAEA;AACA;AACA;;;;;;;;;;;;;ACnGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAOA;AACA;AACA;AAkBA;AAEA;;AAKA;AACA;AACA;AAEA;AAIA;AAIA;AAEA;;AAIA;AACA;AACA;AAEA;AAIA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AAKA;AACA;AACA;AAEA;AAIA;AAEA;;AAKA;AACA;AACA;AAEA;AAIA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAIA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAIA;AAEA;AAIA;AACA;AACA;AAEA;AAIA;AAGA;AAEA;AAKA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAIA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzaA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAOA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAIA;AAEA;AACA;AAEA;;AACA;AACA;AACA;AAIA;AAEA;AACA;AAEA;AAKA;AACA;AAEA;AAOA;AAKA;AAIA;AAEA;AACA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AAKA;AAEA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA,oDACA;AACA;AAEA;AACA;AACA,2DACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAwBA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AACA;;;;;A","sourceRoot":""}