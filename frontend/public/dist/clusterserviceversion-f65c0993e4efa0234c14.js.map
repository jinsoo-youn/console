{"version":3,"file":"clusterserviceversion-f65c0993e4efa0234c14.js","sources":["webpack:///./packages/operator-lifecycle-manager/src/components/clusterserviceversion.tsx"],"sourcesContent":["import * as React from 'react';\nimport { Link, match as RouterMatch } from 'react-router-dom';\nimport * as _ from 'lodash';\nimport { connect } from 'react-redux';\nimport * as classNames from 'classnames';\nimport { sortable, wrappable } from '@patternfly/react-table';\nimport { Helmet } from 'react-helmet';\nimport { AddCircleOIcon } from '@patternfly/react-icons';\nimport {\n  Alert,\n  Button,\n  Card,\n  CardBody,\n  CardFooter,\n  CardHeader,\n  Popover,\n} from '@patternfly/react-core';\nimport { ALL_NAMESPACES_KEY, Status, WarningStatus, getNamespace, getUID } from '@console/shared';\nimport {\n  DetailsPage,\n  Table,\n  TableRow,\n  TableData,\n  MultiListPage,\n  RowFunctionArgs,\n} from '@console/internal/components/factory';\nimport { withFallback } from '@console/shared/src/components/error/error-boundary';\nimport {\n  modelFor,\n  referenceForModel,\n  referenceFor,\n  GroupVersionKind,\n  K8sKind,\n  k8sKill,\n  k8sPatch,\n  k8sGet,\n} from '@console/internal/module/k8s';\nimport { ResourceEventStream } from '@console/internal/components/events';\nimport { Conditions } from '@console/internal/components/conditions';\nimport {\n  Kebab,\n  MsgBox,\n  navFactory,\n  ResourceKebab,\n  ResourceLink,\n  Timestamp,\n  SectionHeading,\n  ResourceSummary,\n  ScrollToTopOnMount,\n  AsyncComponent,\n  ExternalLink,\n  FirehoseResult,\n  StatusBox,\n  Page,\n  RequireCreatePermission,\n  resourcePathFromModel,\n  KebabOption,\n  resourceObjPath,\n  KebabAction,\n} from '@console/internal/components/utils';\nimport { useAccessReview } from '@console/internal/components/utils/rbac';\nimport { RootState } from '@console/internal/redux';\nimport {\n  ClusterServiceVersionModel,\n  SubscriptionModel,\n  PackageManifestModel,\n  CatalogSourceModel,\n  InstallPlanModel,\n  OperatorGroupModel,\n} from '../models';\nimport {\n  APIServiceDefinition,\n  CatalogSourceKind,\n  ClusterServiceVersionKind,\n  ClusterServiceVersionPhase,\n  CRDDescription,\n  InstallPlanKind,\n  PackageManifestKind,\n  SubscriptionKind,\n} from '../types';\nimport { subscriptionForCSV, getSubscriptionStatus } from '../status/csv-status';\nimport { getInternalObjects, isInternalObject } from '../utils';\nimport { ProvidedAPIsPage, ProvidedAPIPage } from './operand';\nimport { createUninstallOperatorModal } from './modals/uninstall-operator-modal';\nimport { operatorGroupFor, operatorNamespaceFor } from './operator-group';\nimport { SubscriptionDetails, catalogSourceForSubscription } from './subscription';\nimport { ClusterServiceVersionLogo, referenceForProvidedAPI, providedAPIsFor } from './index';\n\nconst clusterServiceVersionStateToProps = (state: RootState): ClusterServiceVersionStateProps => {\n  return {\n    activeNamespace: state.UI.get('activeNamespace'),\n  };\n};\n\nconst isSubscription = (obj) => referenceFor(obj) === referenceForModel(SubscriptionModel);\nconst isCSV = (obj) => referenceFor(obj) === referenceForModel(ClusterServiceVersionModel);\nconst isPackageServer = (obj) =>\n  obj.metadata.name === 'packageserver' &&\n  obj.metadata.namespace === 'openshift-operator-lifecycle-manager';\n\nconst nameColumnClass = '';\nconst namespaceColumnClass = '';\nconst managedNamespacesColumnClass = classNames('pf-m-hidden', 'pf-m-visible-on-sm');\nconst statusColumnClass = classNames('pf-m-hidden', 'pf-m-visible-on-lg');\nconst lastUpdatedColumnClass = classNames('pf-m-hidden', 'pf-m-visible-on-2xl');\nconst providedAPIsColumnClass = classNames('pf-m-hidden', 'pf-m-visible-on-xl');\n\nconst nameHeader: Header = {\n  title: 'Name',\n  sortField: 'metadata.name',\n  transforms: [sortable],\n  props: { className: nameColumnClass },\n};\n\nconst namespaceHeader: Header = {\n  title: 'Namespace',\n  sortFunc: 'getOperatorNamespace',\n  transforms: [sortable],\n  props: { className: namespaceColumnClass },\n};\n\nconst managedNamespacesHeader: Header = {\n  title: 'Managed Namespaces',\n  sortFunc: 'formatTargetNamespaces',\n  transforms: [sortable, wrappable],\n  props: { className: managedNamespacesColumnClass },\n};\n\nconst statusHeader: Header = {\n  title: 'Status',\n  props: { className: statusColumnClass },\n};\n\nconst lastUpdatedHeader: Header = {\n  title: 'Last Updated',\n  props: { className: lastUpdatedColumnClass },\n};\n\nconst providedAPIsHeader: Header = {\n  title: 'Provided APIs',\n  props: { className: providedAPIsColumnClass },\n};\n\nconst kebabHeader: Header = {\n  title: '',\n  props: { className: Kebab.columnClass },\n};\n\nexport const AllProjectsTableHeader = (): Header[] => [\n  nameHeader,\n  namespaceHeader,\n  managedNamespacesHeader,\n  statusHeader,\n  lastUpdatedHeader,\n  providedAPIsHeader,\n  kebabHeader,\n];\nexport const SingleProjectTableHeader = (): Header[] => [\n  nameHeader,\n  managedNamespacesHeader,\n  statusHeader,\n  lastUpdatedHeader,\n  providedAPIsHeader,\n  kebabHeader,\n];\n\nconst editSubscription = (sub: SubscriptionKind): KebabOption =>\n  !_.isNil(sub)\n    ? {\n        label: 'Edit Subscription',\n        href: `${resourcePathFromModel(\n          SubscriptionModel,\n          sub.metadata.name,\n          sub.metadata.namespace,\n        )}/yaml`,\n      }\n    : null;\n\nconst uninstall = (sub: SubscriptionKind, csv?: ClusterServiceVersionKind): KebabOption =>\n  !_.isNil(sub)\n    ? {\n        label: 'Uninstall Operator',\n        callback: () =>\n          createUninstallOperatorModal({\n            k8sKill,\n            k8sGet,\n            k8sPatch,\n            subscription: sub,\n            csv,\n          }),\n        accessReview: {\n          group: SubscriptionModel.apiGroup,\n          resource: SubscriptionModel.plural,\n          name: sub.metadata.name,\n          namespace: sub.metadata.namespace,\n          verb: 'delete',\n        },\n      }\n    : null;\n\nconst menuActionsForCSV = (\n  csv: ClusterServiceVersionKind,\n  subscription: SubscriptionKind,\n): KebabAction[] => {\n  return _.isEmpty(subscription)\n    ? [Kebab.factory.Delete]\n    : [() => editSubscription(subscription), () => uninstall(subscription, csv)];\n};\n\nconst ClusterServiceVersionStatus: React.FC<ClusterServiceVersionStatusProps> = ({\n  catalogSourceMissing,\n  obj,\n  subscription,\n}) => {\n  const status = _.get(obj, 'status.phase');\n  const subscriptionStatus = getSubscriptionStatus(subscription);\n\n  if (obj.metadata.deletionTimestamp) {\n    return (\n      <span className=\"co-icon-and-text\">\n        <Status status={ClusterServiceVersionPhase.CSVPhaseDeleting} />\n      </span>\n    );\n  }\n\n  if (catalogSourceMissing) {\n    return (\n      <>\n        <WarningStatus title=\"Cannot update\" />\n        <span className=\"text-muted\">Catalog source was removed</span>\n      </>\n    );\n  }\n\n  return status ? (\n    <>\n      <span className=\"co-icon-and-text\">\n        <Status status={status} />\n      </span>\n      {subscription && <span className=\"text-muted\">{subscriptionStatus.title}</span>}\n    </>\n  ) : null;\n};\n\nconst ManagedNamespaces: React.FC<ManagedNamespacesProps> = ({ obj }) => {\n  const { 'olm.targetNamespaces': olmTargetNamespaces = '' } = obj.metadata?.annotations || {};\n  const managedNamespaces = olmTargetNamespaces?.split(',') || [];\n\n  if (managedNamespaces.length === 1 && managedNamespaces[0] === '') {\n    return <>All Namespaces</>;\n  }\n\n  switch (managedNamespaces.length) {\n    case 0:\n      return <span className=\"text-muted\">All Namespaces</span>;\n    case 1:\n      return (\n        <ResourceLink kind=\"Namespace\" title={managedNamespaces[0]} name={managedNamespaces[0]} />\n      );\n    default:\n      return (\n        <Popover\n          headerContent=\"Managed Namespaces\"\n          bodyContent={managedNamespaces.map((namespace) => (\n            <ResourceLink kind=\"Namespace\" title={namespace} name={namespace} />\n          ))}\n        >\n          <Button variant=\"link\" isInline>\n            {managedNamespaces.length} Namespaces\n          </Button>\n        </Popover>\n      );\n  }\n};\n\nexport const NamespacedClusterServiceVersionTableRow = withFallback<\n  ClusterServiceVersionTableRowProps\n>(({ activeNamespace, obj, rowKey, subscription, catalogSourceMissing, index, style }) => {\n  const { displayName, provider, version } = _.get(obj, 'spec');\n  const { 'olm.operatorNamespace': olmOperatorNamespace = '' } = obj.metadata?.annotations || {};\n  const [icon] = _.get(obj, 'spec.icon', []);\n  const route = resourceObjPath(obj, referenceFor(obj));\n  const uid = getUID(obj);\n  const internalObjects = getInternalObjects(obj);\n  const providedAPIs = providedAPIsFor(obj).filter(\n    (desc) => !isInternalObject(internalObjects, desc.name),\n  );\n\n  return (\n    <TableRow id={uid} trKey={rowKey} index={index} style={style}>\n      {/* Name */}\n      <TableData className={nameColumnClass}>\n        <Link\n          to={route}\n          className=\"co-clusterserviceversion-link\"\n          data-test-operator-row={displayName}\n        >\n          <ClusterServiceVersionLogo\n            icon={icon}\n            displayName={displayName}\n            version={version}\n            provider={provider}\n          />\n        </Link>\n      </TableData>\n\n      {/* Operator Namespace */}\n      {activeNamespace === ALL_NAMESPACES_KEY ? (\n        <TableData className={namespaceColumnClass}>\n          <ResourceLink kind=\"Namespace\" title={olmOperatorNamespace} name={olmOperatorNamespace} />\n        </TableData>\n      ) : null}\n\n      {/* Managed Namespaces */}\n      <TableData className={managedNamespacesColumnClass}>\n        <ManagedNamespaces obj={obj} />\n      </TableData>\n\n      {/* Status */}\n      <TableData className={statusColumnClass}>\n        <div className=\"co-clusterserviceversion-row__status\">\n          <ClusterServiceVersionStatus\n            catalogSourceMissing={catalogSourceMissing}\n            obj={obj}\n            subscription={subscription}\n          />\n        </div>\n      </TableData>\n\n      {/* Last Updated */}\n      <TableData className={lastUpdatedColumnClass}>\n        {obj.status == null ? '-' : <Timestamp timestamp={obj.status.lastUpdateTime} />}\n      </TableData>\n\n      {/* Provided APIs */}\n      <TableData className={providedAPIsColumnClass}>\n        {!_.isEmpty(providedAPIs)\n          ? _.take(providedAPIs, 4).map((desc) => (\n              <div key={referenceForProvidedAPI(desc)}>\n                <Link to={`${route}/${referenceForProvidedAPI(desc)}`} title={desc.name}>\n                  {desc.displayName || desc.kind}\n                </Link>\n              </div>\n            ))\n          : '-'}\n        {providedAPIs.length > 4 && (\n          <Link to={route} title={`View ${providedAPIsFor(obj).length - 4} more...`}>\n            {`View ${providedAPIsFor(obj).length - 4} more...`}\n          </Link>\n        )}\n      </TableData>\n\n      {/* Kebab */}\n      <TableData className={Kebab.columnClass}>\n        <ResourceKebab\n          resource={obj}\n          kind={referenceFor(obj)}\n          actions={menuActionsForCSV(obj, subscription)}\n        />\n      </TableData>\n    </TableRow>\n  );\n});\n\nexport const ClusterServiceVersionTableRow = connect(clusterServiceVersionStateToProps)(\n  NamespacedClusterServiceVersionTableRow,\n);\n\nconst NamespacedSubscriptionTableRow: React.FC<SubscriptionTableRowProps> = ({\n  activeNamespace,\n  catalogSourceMissing,\n  rowKey,\n  obj,\n  index,\n  style,\n}) => {\n  const csvName = _.get(obj, 'spec.name');\n  const menuActions = [Kebab.factory.Edit, () => uninstall(obj)];\n  const namespace = getNamespace(obj);\n  const route = resourceObjPath(obj, referenceForModel(SubscriptionModel));\n  const subscriptionState = _.get(obj, 'status.state', 'Unknown');\n  const uid = getUID(obj);\n  const getStatus = () => {\n    if (catalogSourceMissing) {\n      return (\n        <>\n          <WarningStatus title=\"Cannot update\" />\n          <span className=\"text-muted\">Catalog source was removed</span>\n        </>\n      );\n    }\n    return (\n      <span className=\"co-icon-and-text\">\n        <Status status={subscriptionState} />\n      </span>\n    );\n  };\n\n  return (\n    <TableRow id={uid} trKey={rowKey} index={index} style={style}>\n      {/* Name */}\n      <TableData className={nameColumnClass}>\n        <Link to={route}>\n          <ClusterServiceVersionLogo\n            icon={null}\n            displayName={csvName}\n            version={null}\n            provider={null}\n          />\n        </Link>\n      </TableData>\n\n      {/* Operator Namespace */}\n      {activeNamespace === ALL_NAMESPACES_KEY ? (\n        <TableData className={namespaceColumnClass}>\n          <ResourceLink kind=\"Namespace\" title={namespace} name={namespace} />\n        </TableData>\n      ) : null}\n\n      {/* Managed Namespaces */}\n      <TableData className={managedNamespacesColumnClass}>\n        <span className=\"text-muted\">None</span>\n      </TableData>\n\n      {/* Status */}\n      <TableData className={statusColumnClass}>{getStatus()}</TableData>\n\n      {/* Last Updated */}\n      <TableData className={lastUpdatedColumnClass}>\n        {obj.status == null ? '-' : <Timestamp timestamp={obj.status.lastUpdated} />}\n      </TableData>\n\n      {/* Provided APIs */}\n      <TableData className={providedAPIsColumnClass}>\n        <span className=\"text-muted\">None</span>\n      </TableData>\n\n      {/* Kebab */}\n      <TableData className={Kebab.columnClass}>\n        <ResourceKebab resource={obj} kind={referenceFor(obj)} actions={menuActions} />\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const SubscriptionTableRow = connect(clusterServiceVersionStateToProps)(\n  NamespacedSubscriptionTableRow,\n);\n\nconst InstalledOperatorTableRow: React.FC<InstalledOperatorTableRowProps> = ({\n  obj,\n  catalogSources = [],\n  subscriptions = [],\n  ...rest\n}) => {\n  const subscription = isCSV(obj)\n    ? subscriptionForCSV(subscriptions, obj as ClusterServiceVersionKind)\n    : (obj as SubscriptionKind);\n  // Only warn about missing catalog sources if the user was able to list them\n  // but exclude PackageServer as it does not have a subscription.\n  const catalogSourceMissing =\n    !_.isEmpty(catalogSources) &&\n    !catalogSourceForSubscription(catalogSources, subscription) &&\n    !isPackageServer(obj);\n\n  return isCSV(obj) ? (\n    <ClusterServiceVersionTableRow\n      {...rest}\n      catalogSourceMissing={catalogSourceMissing}\n      obj={obj as ClusterServiceVersionKind}\n      subscription={subscription}\n    />\n  ) : (\n    <SubscriptionTableRow\n      {...rest}\n      catalogSourceMissing={catalogSourceMissing}\n      obj={subscription as SubscriptionKind}\n    />\n  );\n};\n\nconst NoOperatorsMatchFilterMsg = () => <MsgBox title=\"No Operators Found\" />;\n\nexport const NamespacedClusterServiceVersionList: React.SFC<ClusterServiceVersionListProps> = ({\n  activeNamespace,\n  subscriptions,\n  catalogSources,\n  data,\n  ...rest\n}) => {\n  const noDataDetail = (\n    <>\n      <div>\n        No Operators are available\n        {activeNamespace !== ALL_NAMESPACES_KEY && (\n          <>\n            {' '}\n            for project{' '}\n            <span className=\"co-clusterserviceversion-empty__state__namespace\">\n              {activeNamespace}\n            </span>\n          </>\n        )}\n        .\n      </div>\n      <div>\n        Discover and install Operators from the <a href=\"/operatorhub\">OperatorHub</a>.\n      </div>\n    </>\n  );\n  const NoDataEmptyMsg = () => <MsgBox title=\"No Operators Found\" detail={noDataDetail} />;\n\n  const isCopiedCSV = (source, kind) => {\n    return (\n      referenceForModel(ClusterServiceVersionModel) === kind && source.status?.reason === 'Copied'\n    );\n  };\n\n  const removeCopiedCSVs = (operators: (ClusterServiceVersionKind | SubscriptionKind)[]) => {\n    return operators.filter((source) => {\n      const kind = referenceFor(source);\n      if (isSubscription(kind)) {\n        return true;\n      }\n      return !isCopiedCSV(source, kind);\n    });\n  };\n\n  const formatTargetNamespaces = (obj: ClusterServiceVersionKind | SubscriptionKind): string => {\n    if (obj.kind === 'Subscription') {\n      return 'None';\n    }\n\n    const namespaces = obj.metadata.annotations?.['olm.targetNamespaces']?.split(',') || [];\n\n    if (namespaces.length === 1 && namespaces[0] === '') {\n      return 'All Namespaces';\n    }\n\n    switch (namespaces.length) {\n      case 0:\n        return 'All Namespaces';\n      case 1:\n        return namespaces[0];\n      default:\n        return `${namespaces.length} Namespaces`;\n    }\n  };\n  const getOperatorNamespace = (\n    obj: ClusterServiceVersionKind | SubscriptionKind,\n  ): string | null => {\n    const olmOperatorNamespace = obj.metadata?.annotations?.['olm.operatorNamespace'];\n    return olmOperatorNamespace ?? getNamespace(obj);\n  };\n\n  return activeNamespace === ALL_NAMESPACES_KEY ? (\n    <Table\n      data={removeCopiedCSVs(data) as any[]}\n      {...rest}\n      aria-label=\"Installed Operators\"\n      Header={AllProjectsTableHeader}\n      Row={(rowArgs: RowFunctionArgs<ClusterServiceVersionKind | SubscriptionKind>) => (\n        <InstalledOperatorTableRow\n          obj={rowArgs.obj}\n          index={rowArgs.index}\n          rowKey={rowArgs.key}\n          style={rowArgs.style}\n          catalogSources={catalogSources.data}\n          subscriptions={subscriptions.data}\n        />\n      )}\n      EmptyMsg={NoOperatorsMatchFilterMsg}\n      NoDataEmptyMsg={NoDataEmptyMsg}\n      virtualize\n      customSorts={{\n        formatTargetNamespaces,\n        getOperatorNamespace,\n      }}\n    />\n  ) : (\n    <Table\n      data={data}\n      {...rest}\n      aria-label=\"Installed Operators\"\n      Header={SingleProjectTableHeader}\n      Row={(rowArgs: RowFunctionArgs<ClusterServiceVersionKind | SubscriptionKind>) => (\n        <InstalledOperatorTableRow\n          obj={rowArgs.obj}\n          index={rowArgs.index}\n          rowKey={rowArgs.key}\n          style={rowArgs.style}\n          catalogSources={catalogSources.data}\n          subscriptions={subscriptions.data}\n        />\n      )}\n      EmptyMsg={NoOperatorsMatchFilterMsg}\n      NoDataEmptyMsg={NoDataEmptyMsg}\n      virtualize\n      customSorts={{\n        formatTargetNamespaces,\n        getOperatorNamespace,\n      }}\n    />\n  );\n};\n\nexport const ClusterServiceVersionList = connect(clusterServiceVersionStateToProps)(\n  NamespacedClusterServiceVersionList,\n);\n\nexport const ClusterServiceVersionsPage: React.FC<ClusterServiceVersionsPageProps> = (props) => {\n  const title = 'Installed Operators';\n  const helpText = (\n    <p className=\"co-help-text\">\n      Installed Operators are represented by Cluster Service Versions within this namespace. For\n      more information, see the{' '}\n      <ExternalLink\n        href=\"https://github.com/operator-framework/operator-lifecycle-manager/blob/master/doc/design/architecture.md\"\n        text=\"Operator Lifecycle Manager documentation\"\n      />\n      . Or create an Operator and Cluster Service Version using the{' '}\n      <ExternalLink href=\"https://github.com/operator-framework/operator-sdk\" text=\"Operator SDK\" />\n      .\n    </p>\n  );\n\n  const flatten = ({ clusterServiceVersions, subscriptions }) =>\n    [\n      ..._.get(clusterServiceVersions, 'data', []),\n      ..._.get(subscriptions, 'data', []).filter(\n        (sub) =>\n          ['', sub.metadata.namespace].includes(props.namespace) &&\n          _.isNil(_.get(sub, 'status.installedCSV')),\n      ),\n    ].filter(\n      (obj, i, all) =>\n        isSubscription(obj) ||\n        _.isUndefined(\n          all.find(({ metadata }) =>\n            [_.get(obj, 'status.currentCSV'), _.get(obj, 'spec.startingCSV')].includes(\n              metadata.name,\n            ),\n          ),\n        ),\n    );\n\n  return (\n    <>\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n      <MultiListPage\n        {...props}\n        resources={[\n          {\n            kind: referenceForModel(ClusterServiceVersionModel),\n            namespace: props.namespace,\n            prop: 'clusterServiceVersions',\n          },\n          {\n            kind: referenceForModel(SubscriptionModel),\n            prop: 'subscriptions',\n            optional: true,\n          },\n          {\n            kind: referenceForModel(CatalogSourceModel),\n            prop: 'catalogSources',\n            optional: true,\n          },\n        ]}\n        title={title}\n        flatten={flatten}\n        namespace={props.namespace}\n        ListComponent={ClusterServiceVersionList}\n        helpText={helpText}\n      />\n    </>\n  );\n};\n\nexport const MarkdownView = (props: {\n  content: string;\n  styles?: string;\n  exactHeight?: boolean;\n}) => {\n  return (\n    <AsyncComponent\n      loader={() =>\n        import('@console/internal/components/markdown-view').then((c) => c.SyncMarkdownView)\n      }\n      {...props}\n    />\n  );\n};\n\nexport const CRDCard: React.SFC<CRDCardProps> = (props) => {\n  const { csv, crd, canCreate } = props;\n  const reference = referenceForProvidedAPI(crd);\n  const model = modelFor(reference);\n  const createRoute = () =>\n    `/k8s/ns/${csv.metadata.namespace}/${ClusterServiceVersionModel.plural}/${csv.metadata.name}/${reference}/~new`;\n  return (\n    <Card>\n      <CardHeader>\n        <ResourceLink\n          kind={referenceForProvidedAPI(crd)}\n          title={crd.name}\n          linkTo={false}\n          displayName={crd.displayName || crd.kind}\n        />\n      </CardHeader>\n      <CardBody>\n        <p>{crd.description}</p>\n      </CardBody>\n      {canCreate && (\n        <RequireCreatePermission model={model} namespace={csv.metadata.namespace}>\n          <CardFooter>\n            <Link to={createRoute()}>\n              <AddCircleOIcon className=\"co-icon-space-r\" />\n              Create Instance\n            </Link>\n          </CardFooter>\n        </RequireCreatePermission>\n      )}\n    </Card>\n  );\n};\n\nconst crdCardRowStateToProps = ({ k8s }, { crdDescs }) => {\n  const models: K8sKind[] = _.compact(\n    crdDescs.map((desc) => k8s.getIn(['RESOURCES', 'models', referenceForProvidedAPI(desc)])),\n  );\n  return {\n    crdDescs: crdDescs.filter((desc) =>\n      models.find((m) => referenceForModel(m) === referenceForProvidedAPI(desc)),\n    ),\n    createable: models\n      .filter((m) => (m.verbs || []).includes('create'))\n      .map((m) => referenceForModel(m)),\n  };\n};\n\nexport const CRDCardRow = connect(crdCardRowStateToProps)((props: CRDCardRowProps) => {\n  const internalObjects = getInternalObjects(props.csv);\n  const crds = props.crdDescs?.filter(({ name }) => !isInternalObject(internalObjects, name));\n  return (\n    <div className=\"co-crd-card-row\">\n      {_.isEmpty(crds) ? (\n        <span className=\"text-muted\">No Kubernetes APIs are being provided by this Operator.</span>\n      ) : (\n        crds.map((crd) => (\n          <CRDCard\n            key={referenceForProvidedAPI(crd)}\n            crd={crd}\n            csv={props.csv}\n            canCreate={props.createable.includes(referenceForProvidedAPI(crd))}\n          />\n        ))\n      )}\n    </div>\n  );\n});\n\nexport const ClusterServiceVersionDetails: React.SFC<ClusterServiceVersionDetailsProps> = (\n  props,\n) => {\n  const { spec, metadata, status } = props.obj;\n  const {\n    'marketplace.openshift.io/support-workflow': marketplaceSupportWorkflow,\n    'olm.targetNamespaces': olmTargetNamespaces = '',\n  } = metadata.annotations || {};\n\n  return (\n    <>\n      <ScrollToTopOnMount />\n\n      <div className=\"co-m-pane__body\">\n        <div className=\"co-m-pane__body-group\">\n          <div className=\"row\">\n            <div className=\"col-sm-9\">\n              {status && status.phase === ClusterServiceVersionPhase.CSVPhaseFailed && (\n                <Alert\n                  isInline\n                  className=\"co-alert\"\n                  variant=\"danger\"\n                  title={`${status.phase}: ${status.message}`}\n                />\n              )}\n              <SectionHeading text=\"Provided APIs\" />\n              <CRDCardRow csv={props.obj} crdDescs={providedAPIsFor(props.obj)} />\n              <SectionHeading text=\"Description\" />\n              <MarkdownView content={spec.description || 'Not available'} />\n            </div>\n            <div className=\"col-sm-3\">\n              <dl className=\"co-clusterserviceversion-details__field\">\n                <dt>Provider</dt>\n                <dd>\n                  {spec.provider && spec.provider.name ? spec.provider.name : 'Not available'}\n                </dd>\n                {marketplaceSupportWorkflow && (\n                  <>\n                    <dt>Support</dt>\n                    <dd>\n                      <ExternalLink href={marketplaceSupportWorkflow} text=\"Get support\" />\n                    </dd>\n                  </>\n                )}\n                <dt>Created At</dt>\n                <dd>\n                  <Timestamp timestamp={metadata.creationTimestamp} />\n                </dd>\n              </dl>\n              <dl className=\"co-clusterserviceversion-details__field\">\n                <dt>Links</dt>\n                {spec.links && spec.links.length > 0 ? (\n                  spec.links.map((link) => (\n                    <dd key={link.url} style={{ display: 'flex', flexDirection: 'column' }}>\n                      {link.name}{' '}\n                      <ExternalLink\n                        href={link.url}\n                        text={link.url || '-'}\n                        additionalClassName=\"co-break-all\"\n                      />\n                    </dd>\n                  ))\n                ) : (\n                  <dd>Not available</dd>\n                )}\n              </dl>\n              <dl className=\"co-clusterserviceversion-details__field\">\n                <dt>Maintainers</dt>\n                {spec.maintainers && spec.maintainers.length > 0 ? (\n                  spec.maintainers.map((maintainer) => (\n                    <dd key={maintainer.email} style={{ display: 'flex', flexDirection: 'column' }}>\n                      {maintainer.name}{' '}\n                      <a href={`mailto:${maintainer.email}`} className=\"co-break-all\">\n                        {maintainer.email || '-'}\n                      </a>\n                    </dd>\n                  ))\n                ) : (\n                  <dd>Not available</dd>\n                )}\n              </dl>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text=\"ClusterServiceVersion Details\" />\n        <div className=\"co-m-pane__body-group\">\n          <div className=\"row\">\n            <div className=\"col-sm-6\">\n              <ResourceSummary resource={props.obj}>\n                <dt>\n                  <Popover\n                    headerContent={<div>Managed Namespaces</div>}\n                    bodyContent={<div>Operands in this Namespace are managed by the Operator.</div>}\n                    maxWidth=\"30rem\"\n                  >\n                    <Button variant=\"plain\" className=\"co-m-pane__details-popover-button\">\n                      Managed Namespaces\n                    </Button>\n                  </Popover>\n                </dt>\n                <dd>\n                  {olmTargetNamespaces === '' ? (\n                    'All Namespaces'\n                  ) : (\n                    <ResourceLink\n                      kind=\"Namespace\"\n                      name={props.obj.metadata.namespace}\n                      title={props.obj.metadata.uid}\n                    />\n                  )}\n                </dd>\n              </ResourceSummary>\n            </div>\n            <div className=\"col-sm-6\">\n              <dt>Status</dt>\n              <dd>\n                <Status status={status ? status.phase : 'Unknown'} />\n              </dd>\n              <dt>Status Reason</dt>\n              <dd>{status ? status.message : 'Unknown'}</dd>\n              <dt>Operator Deployments</dt>\n              {spec.install.spec.deployments.map(({ name }) => (\n                <dd key={name}>\n                  <ResourceLink\n                    name={name}\n                    kind=\"Deployment\"\n                    namespace={operatorNamespaceFor(props.obj)}\n                  />\n                </dd>\n              ))}\n              {_.get(spec.install.spec, 'permissions') && (\n                <>\n                  <dt>Operator Service Accounts</dt>\n                  {spec.install.spec.permissions.map(({ serviceAccountName }) => (\n                    <dd key={serviceAccountName}>\n                      <ResourceLink\n                        name={serviceAccountName}\n                        kind=\"ServiceAccount\"\n                        namespace={operatorNamespaceFor(props.obj)}\n                      />\n                    </dd>\n                  ))}\n                </>\n              )}\n              <dt>Operator Group</dt>\n              <dd>\n                {operatorGroupFor(props.obj) ? (\n                  <ResourceLink\n                    name={operatorGroupFor(props.obj)}\n                    namespace={operatorNamespaceFor(props.obj)}\n                    kind={referenceForModel(OperatorGroupModel)}\n                  />\n                ) : (\n                  '-'\n                )}\n              </dd>\n            </div>\n          </div>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text=\"Conditions\" />\n        <Conditions\n          conditions={_.get(status, 'conditions', []).map((c) => ({\n            ...c,\n            type: c.phase,\n            status: 'True',\n          }))}\n        />\n      </div>\n    </>\n  );\n};\n\nexport const CSVSubscription: React.FC<CSVSubscriptionProps> = ({\n  obj,\n  subscriptions = [],\n  ...rest\n}) => {\n  const EmptyMsg = () => (\n    <MsgBox title=\"No Operator Subscription\" detail=\"This Operator will not receive updates.\" />\n  );\n\n  const subscription = React.useMemo(() => subscriptionForCSV(subscriptions, obj), [\n    obj,\n    subscriptions,\n  ]);\n\n  return (\n    <StatusBox EmptyMsg={EmptyMsg} loaded data={subscription}>\n      <SubscriptionDetails {...rest} obj={subscription} clusterServiceVersions={[obj]} />\n    </StatusBox>\n  );\n};\n\nexport const ClusterServiceVersionsDetailsPage: React.FC<ClusterServiceVersionsDetailsPageProps> = (\n  props,\n) => {\n  const instancePagesFor = (obj: ClusterServiceVersionKind) => {\n    const internalObjects = getInternalObjects(obj);\n    const allInstancesPage: Page = {\n      href: 'instances',\n      name: 'All Instances',\n      component: ProvidedAPIsPage,\n    };\n\n    return (providedAPIsFor(obj).length > 1 ? [allInstancesPage] : ([] as Page[])).concat(\n      providedAPIsFor(obj).reduce(\n        (acc, desc: CRDDescription) =>\n          !isInternalObject(internalObjects, desc.name)\n            ? [\n                ...acc,\n                {\n                  href: referenceForProvidedAPI(desc),\n                  name: ['Details', 'YAML', 'Subscription', 'Events'].includes(desc.displayName)\n                    ? `${desc.displayName} Operand`\n                    : desc.displayName || desc.kind,\n                  component: ProvidedAPIPage,\n                  pageData: {\n                    csv: obj,\n                    kind: referenceForProvidedAPI(desc),\n                    namespace: obj.metadata.namespace,\n                  },\n                },\n              ]\n            : acc,\n        [],\n      ),\n    );\n  };\n\n  type ExtraResources = { subscriptions: SubscriptionKind[] };\n  const menuActions = (\n    model,\n    obj: ClusterServiceVersionKind,\n    { subscriptions }: ExtraResources,\n  ) => {\n    const subscription = subscriptionForCSV(subscriptions, obj);\n    return [\n      ...(_.isEmpty(subscription)\n        ? [Kebab.factory.Delete(model, obj)]\n        : [editSubscription(subscription), uninstall(subscription, obj)]),\n    ];\n  };\n\n  const canListSubscriptions = useAccessReview({\n    group: SubscriptionModel.apiGroup,\n    resource: SubscriptionModel.plural,\n    verb: 'list',\n  });\n\n  const pagesFor = React.useCallback(\n    (obj: ClusterServiceVersionKind) =>\n      _.compact([\n        navFactory.details(ClusterServiceVersionDetails),\n        navFactory.editYaml(),\n        canListSubscriptions\n          ? { href: 'subscription', name: 'Subscription', component: CSVSubscription }\n          : null,\n        navFactory.events(ResourceEventStream),\n        ...instancePagesFor(obj),\n      ]),\n    [canListSubscriptions],\n  );\n\n  return (\n    <DetailsPage\n      {...props}\n      breadcrumbsFor={() => [\n        {\n          name: 'Installed Operators',\n          path: `/k8s/ns/${props.match.params.ns}/${props.match.params.plural}`,\n        },\n        { name: 'Operator Details', path: props.match.url },\n      ]}\n      resources={[\n        { kind: referenceForModel(SubscriptionModel), isList: true, prop: 'subscriptions' },\n        { kind: referenceForModel(PackageManifestModel), isList: true, prop: 'packageManifests' },\n        { kind: referenceForModel(CatalogSourceModel), isList: true, prop: 'catalogSources' },\n        { kind: referenceForModel(InstallPlanModel), isList: true, prop: 'installPlans' },\n      ]}\n      icon={({ obj }) => (\n        <ClusterServiceVersionLogo\n          displayName={_.get(obj.spec, 'displayName')}\n          icon={_.get(obj.spec, 'icon[0]')}\n          provider={_.get(obj.spec, 'provider')}\n          version={_.get(obj.spec, 'version')}\n        />\n      )}\n      namespace={props.match.params.ns}\n      kind={referenceForModel(ClusterServiceVersionModel)}\n      name={props.match.params.name}\n      pagesFor={pagesFor}\n      menuActions={menuActions}\n    />\n  );\n};\n\ntype ClusterServiceVersionStatusProps = {\n  catalogSourceMissing: boolean;\n  obj: ClusterServiceVersionKind;\n  subscription: SubscriptionKind;\n};\n\nexport type ClusterServiceVersionsPageProps = {\n  kind: string;\n  namespace: string;\n  resourceDescriptions: CRDDescription[];\n};\n\nexport type ClusterServiceVersionListProps = {\n  loaded: boolean;\n  loadError?: string;\n  data: ClusterServiceVersionKind[];\n  subscriptions: FirehoseResult<SubscriptionKind[]>;\n  catalogSources: FirehoseResult<CatalogSourceKind[]>;\n  activeNamespace?: string;\n};\n\nexport type CRDCardProps = {\n  crd: CRDDescription | APIServiceDefinition;\n  csv: ClusterServiceVersionKind;\n  canCreate: boolean;\n};\n\nexport type CRDCardRowProps = {\n  crdDescs: (CRDDescription | APIServiceDefinition)[];\n  csv: ClusterServiceVersionKind;\n  createable: GroupVersionKind[];\n};\n\nexport type CRDCardRowState = {\n  expand: boolean;\n};\n\nexport type ClusterServiceVersionsDetailsPageProps = {\n  match: RouterMatch<any>;\n};\n\nexport type ClusterServiceVersionDetailsProps = {\n  obj: ClusterServiceVersionKind;\n};\n\ntype InstalledOperatorTableRowProps = {\n  obj: ClusterServiceVersionKind | SubscriptionKind;\n  index: number;\n  rowKey: string;\n  style: object;\n  catalogSources: CatalogSourceKind[];\n  subscriptions: SubscriptionKind[];\n};\n\nexport type ClusterServiceVersionTableRowProps = {\n  obj: ClusterServiceVersionKind;\n  index: number;\n  rowKey: string;\n  style: object;\n  catalogSourceMissing: boolean;\n  subscription: SubscriptionKind;\n  activeNamespace?: string;\n};\n\ntype SubscriptionTableRowProps = {\n  obj: SubscriptionKind;\n  index: number;\n  rowKey: string;\n  style: object;\n  catalogSourceMissing: boolean;\n  activeNamespace?: string;\n};\n\ntype ManagedNamespacesProps = {\n  obj: ClusterServiceVersionKind;\n};\n\nexport type CSVSubscriptionProps = {\n  catalogSources: CatalogSourceKind[];\n  installPlans: InstallPlanKind[];\n  obj: ClusterServiceVersionKind;\n  packageManifests: PackageManifestKind[];\n  subscriptions: SubscriptionKind[];\n};\n\ntype ClusterServiceVersionStateProps = {\n  activeNamespace?: string;\n};\n\ntype Header = {\n  title: string;\n  sortField?: string;\n  sortFunc?: string;\n  transforms?: any;\n  props: { className: string };\n};\n\n// TODO(alecmerdler): Find Webpack loader/plugin to add `displayName` to React components automagically\nClusterServiceVersionList.displayName = 'ClusterServiceVersionList';\nNamespacedClusterServiceVersionList.displayName = 'ClusterServiceVersionList';\nClusterServiceVersionsPage.displayName = 'ClusterServiceVersionsPage';\nClusterServiceVersionTableRow.displayName = 'ClusterServiceVersionTableRow';\nSingleProjectTableHeader.displayName = 'SingleProjectClusterServiceVersionTableHeader';\nAllProjectsTableHeader.displayName = 'AllProjectsClusterServiceVersionTableHeader';\nCRDCard.displayName = 'CRDCard';\nClusterServiceVersionsDetailsPage.displayName = 'ClusterServiceVersionsDetailsPage';\nClusterServiceVersionDetails.displayName = 'ClusterServiceVersionDetails';\nCSVSubscription.displayName = 'CSVSubscription';\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AAQA;AACA;AAUA;AACA;AACA;AAqBA;AAEA;AAQA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AAGA;AAEA;AAEA;AACA;AAEA;AAGA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAOA;AACA;AACA;AAGA;AACA;AAEA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AAKA;AAUA;AAEA;AAKA;AACA;AAIA;AACA;AACA;AASA;AAKA;AACA;AACA;AAEA;AAKA;AACA;AAQA;AACA;AAQA;AAEA;AAIA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AAGA;AAEA;AAGA;AACA;AACA;AAUA;AAEA;AAKA;AACA;AAIA;AAGA;AAKA;AACA;AAIA;AACA;AAIA;AAEA;AAIA;AAAA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAcA;AAEA;AAEA;AAAA;AAOA;AAEA;;AAEA;AAEA;;AACA;AACA;AAMA;AACA;;AACA;AACA;AAGA;AAEA;;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AAEA;AAoBA;AACA;AACA;AAsBA;AACA;AACA;AAGA;AAEA;AAIA;AACA;AACA;;AAGA;AACA;;AAIA;AACA;AAEA;AAGA;AAEA;AACA;AAGA;AAEA;AAGA;AASA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AAKA;AAQA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AAGA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAgBA;AAEA;AAGA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AAGA;AAAA;AACA;AAWA;AACA;AACA;AAGA;AAAA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAKA;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AACA;AAEA;AASA;AACA;AAeA;AACA;AACA;AAUA;AAEA;AAAA;AAKA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAGA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAgBA;AAmGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}