{"version":3,"file":"dev-console-edit~git-import-form~source-to-image-form-922eba9950802c1806ae.js","sources":["webpack:///./packages/dev-console/src/components/dropdown/SourceSecretDropdown.tsx","webpack:///./packages/dev-console/src/components/import/builder/BuilderImageSelector.tsx","webpack:///./packages/dev-console/src/components/import/builder/BuilderImageTagSelector.tsx","webpack:///./packages/dev-console/src/components/import/builder/BuilderSection.tsx","webpack:///./packages/dev-console/src/components/import/builder/ImageStreamInfo.tsx","webpack:///./packages/dev-console/src/components/import/git/AdvancedGitOptions.tsx","webpack:///./packages/dev-console/src/components/import/git/GitSection.tsx","webpack:///./packages/dev-console/src/components/import/git/SampleRepo.tsx","webpack:///./packages/dev-console/src/components/import/git/SourceSecretSelector.tsx","webpack:///./packages/dev-console/src/utils/safe-k8s-hook.tsx","webpack:///./packages/git-service/src/index.ts","webpack:///./packages/git-service/src/services/base-service.ts","webpack:///./packages/git-service/src/services/bitbucket-service.ts","webpack:///./packages/git-service/src/services/git-service.ts","webpack:///./packages/git-service/src/services/github-service.ts","webpack:///./packages/git-service/src/services/gitlab-service.ts","webpack:///./packages/git-service/src/services/index.ts","webpack:///./packages/git-service/src/types/build-tools.ts","webpack:///./packages/git-service/src/types/git.ts","webpack:///./packages/git-service/src/types/index.ts","webpack:///./packages/git-service/src/utils/build-tool-detector.ts","webpack:///./packages/git-service/src/utils/dockerfile-parser.ts","webpack:///./packages/git-service/src/utils/index.ts"],"sourcesContent":["import * as React from 'react';\nimport { SecretModel } from '@console/internal/models';\nimport { Firehose } from '@console/internal/components/utils';\nimport { ResourceDropdown } from '@console/shared';\n\ninterface SourceSecretDropdownProps {\n  dropDownClassName?: string;\n  menuClassName?: string;\n  namespace?: string;\n  actionItems?: {\n    actionTitle: string;\n    actionKey: string;\n  }[];\n  selectedKey: string;\n  onChange?: (key: string) => void;\n  title?: React.ReactNode;\n}\n\nconst SourceSecretDropdown: React.FC<SourceSecretDropdownProps> = (props) => {\n  const filterData = (item) => {\n    return item.type === 'kubernetes.io/basic-auth' || item.type === 'kubernetes.io/ssh-auth';\n  };\n  const resources = [\n    {\n      isList: true,\n      namespace: props.namespace,\n      kind: SecretModel.kind,\n      prop: 'secrets',\n    },\n  ];\n  return (\n    <Firehose resources={resources}>\n      <ResourceDropdown\n        {...props}\n        placeholder=\"Select Secret Name\"\n        resourceFilter={filterData}\n        dataSelector={['metadata', 'name']}\n      />\n    </Firehose>\n  );\n};\n\nexport default SourceSecretDropdown;\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { useFormikContext, FormikValues } from 'formik';\nimport { LoadingInline } from '@console/internal/components/utils';\nimport { FormGroup, Alert } from '@patternfly/react-core';\nimport { StarIcon } from '@patternfly/react-icons';\nimport { getFieldId, ItemSelectorField } from '@console/shared';\nimport { NormalizedBuilderImages } from '../../../utils/imagestream-utils';\n\nexport interface BuilderImageSelectorProps {\n  loadingImageStream: boolean;\n  builderImages: NormalizedBuilderImages;\n}\n\nconst BuilderImageSelector: React.FC<BuilderImageSelectorProps> = ({\n  loadingImageStream,\n  builderImages,\n}) => {\n  const { values, setFieldValue, setFieldTouched } = useFormikContext<FormikValues>();\n  const { selected, recommended, isRecommending, couldNotRecommend } = values.image;\n\n  React.useEffect(() => {\n    if (selected) {\n      setFieldValue('image.tag', _.get(builderImages, `${selected}.recentTag.name`, ''));\n      setFieldTouched('image.tag', true);\n    }\n  }, [selected, setFieldValue, setFieldTouched, builderImages]);\n\n  const fieldId = getFieldId('image.name', 'selector');\n\n  if (_.keys(builderImages).length === 1) {\n    return (\n      <ItemSelectorField\n        itemList={builderImages}\n        name=\"image.selected\"\n        loadingItems={loadingImageStream}\n        recommended={recommended}\n      />\n    );\n  }\n\n  return (\n    <FormGroup fieldId={fieldId} label=\"Builder Image\">\n      {isRecommending && (\n        <>\n          <LoadingInline /> Detecting recommended builder images...\n        </>\n      )}\n      {recommended && builderImages.hasOwnProperty(recommended) && (\n        <>\n          <Alert variant=\"success\" title=\"Builder image(s) detected.\" isInline>\n            Recommended builder images are represented by{' '}\n            <StarIcon style={{ color: 'var(--pf-global--primary-color--100)' }} /> icon.\n          </Alert>\n          <br />\n        </>\n      )}\n      {(couldNotRecommend || (recommended && !builderImages.hasOwnProperty(recommended))) && (\n        <>\n          <Alert variant=\"warning\" title=\"Unable to detect the builder image.\" isInline>\n            Select the most appropriate one from the list to continue.\n          </Alert>\n          <br />\n        </>\n      )}\n      <ItemSelectorField\n        itemList={builderImages}\n        name=\"image.selected\"\n        loadingItems={loadingImageStream}\n        recommended={values.image.recommended}\n      />\n    </FormGroup>\n  );\n};\n\nexport default BuilderImageSelector;\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { useFormikContext, FormikValues } from 'formik';\nimport { ResourceName } from '@console/internal/components/utils';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { ImageStreamTagModel } from '@console/internal/models';\nimport { DropdownField } from '@console/shared';\nimport {\n  BuilderImage,\n  getTagDataWithDisplayName,\n  getPorts,\n} from '../../../utils/imagestream-utils';\nimport { useSafeK8s } from '../../../utils/safe-k8s-hook';\nimport ImageStreamInfo from './ImageStreamInfo';\n\nexport interface BuilderImageTagSelectorProps {\n  selectedBuilderImage: BuilderImage;\n  selectedImageTag: string;\n}\n\nconst BuilderImageTagSelector: React.FC<BuilderImageTagSelectorProps> = ({\n  selectedBuilderImage,\n  selectedImageTag,\n}) => {\n  const { setFieldValue, setFieldError } = useFormikContext<FormikValues>();\n  const {\n    name: imageName,\n    tags: imageTags,\n    displayName: imageDisplayName,\n    imageStreamNamespace,\n  } = selectedBuilderImage;\n\n  const tagItems = {};\n  _.each(\n    imageTags,\n    ({ name }) => (tagItems[name] = <ResourceName kind=\"ImageStreamTag\" name={name} />),\n  );\n\n  const [imageTag, displayName] = getTagDataWithDisplayName(\n    imageTags,\n    selectedImageTag,\n    imageDisplayName,\n  );\n\n  const k8sGet = useSafeK8s();\n\n  React.useEffect(() => {\n    setFieldValue('image.tagObj', imageTag);\n    k8sGet(ImageStreamTagModel, `${imageName}:${selectedImageTag}`, imageStreamNamespace)\n      .then((imageStreamTag: K8sResourceKind) => {\n        const ports = getPorts(imageStreamTag);\n        setFieldValue('image.ports', ports);\n      })\n      .catch((err) => setFieldError('image.ports', err.message));\n    // Find a way to use useSafeK8s hooks without adding it to the deps array.\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [selectedImageTag, setFieldValue, setFieldError, imageName, imageStreamNamespace, imageTag]);\n\n  return (\n    <>\n      <DropdownField\n        name=\"image.tag\"\n        label=\"Builder Image Version\"\n        items={tagItems}\n        title={tagItems[selectedImageTag]}\n        fullWidth\n        required\n      />\n      {imageTag && <ImageStreamInfo displayName={displayName} tag={imageTag} />}\n    </>\n  );\n};\n\nexport default BuilderImageTagSelector;\n","import * as React from 'react';\nimport { NormalizedBuilderImages } from '../../../utils/imagestream-utils';\nimport { ImageData } from '../import-types';\nimport FormSection from '../section/FormSection';\nimport BuilderImageSelector from './BuilderImageSelector';\nimport BuilderImageTagSelector from './BuilderImageTagSelector';\n\nexport interface ImageSectionProps {\n  image: ImageData;\n  builderImages: NormalizedBuilderImages;\n}\n\nconst BuilderSection: React.FC<ImageSectionProps> = ({ image, builderImages }) => {\n  if (!builderImages) {\n    return null;\n  }\n\n  return (\n    <>\n      <FormSection title=\"Builder\" fullWidth>\n        <BuilderImageSelector loadingImageStream={!builderImages} builderImages={builderImages} />\n      </FormSection>\n      {image.tag && (\n        <FormSection>\n          <BuilderImageTagSelector\n            selectedBuilderImage={builderImages[image.selected]}\n            selectedImageTag={image.tag}\n          />\n        </FormSection>\n      )}\n    </>\n  );\n};\n\nexport default BuilderSection;\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { getAnnotationTags } from '@console/internal/components/image-stream';\nimport { ImageStreamIcon } from '@console/internal/components/catalog/catalog-item-icon';\nimport { ExternalLink } from '@console/internal/components/utils';\nimport { getSampleRepo } from '../../../utils/imagestream-utils';\n\nexport type ImageStreamInfoProps = {\n  displayName: string;\n  tag: object;\n};\n\nconst ImageStreamInfo: React.FC<ImageStreamInfoProps> = ({ displayName, tag }) => {\n  const annotationTags = getAnnotationTags(tag);\n  const description = _.get(tag, 'annotations.description');\n  const sampleRepo = getSampleRepo(tag);\n\n  return (\n    <div className=\"co-catalog-item-info\">\n      <div className=\"co-catalog-item-details\">\n        <ImageStreamIcon tag={tag} iconSize=\"large\" />\n        <div>\n          <h2 className=\"co-section-heading co-catalog-item-details__name\">{displayName}</h2>\n          {annotationTags && (\n            <p className=\"co-catalog-item-details__tags\">\n              {_.map(annotationTags, (annotationTag, i) => (\n                <span className=\"co-catalog-item-details__tag\" key={i}>\n                  {annotationTag}\n                </span>\n              ))}\n            </p>\n          )}\n        </div>\n      </div>\n      {description && <p className=\"co-catalog-item-details__description\">{description}</p>}\n      {sampleRepo && (\n        <p>\n          Sample repository: <ExternalLink href={sampleRepo} text={sampleRepo} />\n        </p>\n      )}\n    </div>\n  );\n};\n\nexport default ImageStreamInfo;\n","import * as React from 'react';\nimport { ExpandCollapse } from '@console/internal/components/utils';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField } from '@console/shared';\nimport FormSection from '../section/FormSection';\nimport SourceSecretSelector from './SourceSecretSelector';\n\nconst AdvancedGitOptions: React.FC = () => (\n  <ExpandCollapse\n    textExpanded=\"Hide Advanced Git Options\"\n    textCollapsed=\"Show Advanced Git Options\"\n  >\n    <FormSection>\n      <InputField\n        type={TextInputTypes.text}\n        name=\"git.ref\"\n        label=\"Git Reference\"\n        helpText=\"Optional branch, tag, or commit.\"\n      />\n      <InputField\n        type={TextInputTypes.text}\n        name=\"git.dir\"\n        label=\"Context Dir\"\n        helpText=\"Optional subdirectory for the application source code, used as a context directory for build.\"\n      />\n      <SourceSecretSelector />\n    </FormSection>\n  </ExpandCollapse>\n);\n\nexport default AdvancedGitOptions;\n","import * as React from 'react';\nimport { useFormikContext, FormikValues, FormikTouched } from 'formik';\nimport { Alert, TextInputTypes, ValidatedOptions } from '@patternfly/react-core';\nimport { getGitService, GitProvider } from '@console/git-service';\nimport {\n  InputField,\n  DropdownField,\n  useFormikValidationFix,\n  useDebounceCallback,\n} from '@console/shared';\nimport { GitReadableTypes, GitTypes } from '../import-types';\nimport { detectGitType, detectGitRepoName } from '../import-validation-utils';\nimport { getSampleRepo, getSampleRef, getSampleContextDir } from '../../../utils/imagestream-utils';\nimport FormSection from '../section/FormSection';\nimport SampleRepo from './SampleRepo';\nimport AdvancedGitOptions from './AdvancedGitOptions';\nimport { UNASSIGNED_KEY, CREATE_APPLICATION_KEY } from '../../../const';\n\nexport interface GitSectionProps {\n  showSample?: boolean;\n}\n\nconst GitSection: React.FC<GitSectionProps> = ({ showSample }) => {\n  const { values, setFieldValue, setFieldTouched, touched, dirty } = useFormikContext<\n    FormikValues\n  >();\n  const tag = values.image.tagObj;\n  const sampleRepo = showSample && getSampleRepo(tag);\n  const { application = {}, name: nameTouched, git = {}, image = {} } = touched;\n  const { type: gitTypeTouched } = git as FormikTouched<{ type: boolean }>;\n  const { name: applicationNameTouched } = application as FormikTouched<{ name: boolean }>;\n  const { selected: imageSelectorTouched } = image as FormikTouched<{ selected: boolean }>;\n  const [validated, setValidated] = React.useState<ValidatedOptions>(ValidatedOptions.default);\n\n  const handleGitUrlChange = React.useCallback(\n    async (url: string, ref: string) => {\n      setFieldValue('git.isUrlValidating', true);\n      setValidated(ValidatedOptions.default);\n\n      const gitType = detectGitType(url);\n      const gitRepoName = detectGitRepoName(url);\n      const showGitType = gitType === GitTypes.unsure;\n\n      setFieldValue('git.type', gitType);\n      setFieldValue('git.showGitType', showGitType);\n      showGitType && setFieldTouched('git.type', false);\n\n      const gitService = getGitService({ url, ref }, gitType as GitProvider);\n      const isReachable = gitService && (await gitService.isRepoReachable());\n      setFieldValue('git.isUrlValidating', false);\n      if (isReachable) {\n        setValidated(ValidatedOptions.success);\n        gitRepoName && !values.name && setFieldValue('name', gitRepoName);\n        gitRepoName &&\n          !values.application.name &&\n          values.application.selectedKey !== UNASSIGNED_KEY &&\n          setFieldValue('application.name', `${gitRepoName}-app`);\n        setFieldValue('image.isRecommending', true);\n        const buildTools = await gitService.detectBuildTypes();\n        setFieldValue('image.isRecommending', false);\n        if (buildTools.length > 0) {\n          const buildTool = buildTools[0].buildType;\n          setFieldValue('image.couldNotRecommend', false);\n          setFieldValue('image.recommended', buildTool);\n        } else {\n          setFieldValue('image.couldNotRecommend', true);\n          setFieldValue('image.recommended', '');\n        }\n      } else {\n        setFieldValue('image.recommended', '');\n        setFieldValue('image.couldNotRecommend', false);\n        setValidated(ValidatedOptions.error);\n      }\n    },\n    [\n      setFieldTouched,\n      setFieldValue,\n      values.application.name,\n      values.application.selectedKey,\n      values.name,\n    ],\n  );\n\n  const debouncedHandleGitUrlChange = useDebounceCallback(handleGitUrlChange, [handleGitUrlChange]);\n\n  const handleGitUrlBlur = React.useCallback(() => {\n    const { url } = values.git;\n    const gitRepoName = detectGitRepoName(url);\n    gitRepoName && setFieldValue('name', gitRepoName);\n    gitRepoName &&\n      !values.application.name &&\n      values.application.selectedKey !== UNASSIGNED_KEY &&\n      setFieldValue('application.name', `${gitRepoName}-app`);\n    setFieldTouched('git.url', true);\n  }, [\n    setFieldTouched,\n    setFieldValue,\n    values.application.name,\n    values.application.selectedKey,\n    values.git,\n  ]);\n\n  const fillSample: React.ReactEventHandler<HTMLButtonElement> = React.useCallback(() => {\n    const url = sampleRepo;\n    const ref = getSampleRef(tag);\n    const dir = getSampleContextDir(tag);\n    const gitType = detectGitType(url);\n    const name = values.name || values.image.selected;\n    values.name !== name && setFieldValue('name', name);\n    !values.application.name &&\n      values.application.selectedKey !== UNASSIGNED_KEY &&\n      setFieldValue('application.name', `${name}-app`);\n    setFieldValue('git.url', url);\n    setFieldValue('git.dir', dir);\n    setFieldValue('git.ref', ref);\n    setFieldValue('git.type', gitType);\n    setFieldTouched('git.url', true);\n  }, [\n    sampleRepo,\n    setFieldTouched,\n    setFieldValue,\n    tag,\n    values.application.name,\n    values.application.selectedKey,\n    values.image.selected,\n    values.name,\n  ]);\n\n  React.useEffect(() => {\n    const { url, ref } = values.git;\n    !dirty && url && handleGitUrlChange(url, ref);\n  }, [dirty, handleGitUrlChange, values.git]);\n\n  const getHelpText = () => {\n    if (values.git.isUrlValidating) {\n      return 'Validating...';\n    }\n\n    if (validated === ValidatedOptions.success) {\n      return 'Validated';\n    }\n    if (validated === ValidatedOptions.error) {\n      return 'Git repository is not reachable.';\n    }\n    return '';\n  };\n\n  const resetFields = () => {\n    if (!imageSelectorTouched) {\n      setFieldValue('image.selected', '');\n      setFieldValue('image.tag', '');\n    }\n    values.image.recommended && setFieldValue('image.recommended', '');\n    values.image.couldNotRecommend && setFieldValue('image.couldNotRecommend', false);\n    if (values.formType === 'edit') {\n      values.application.selectedKey !== UNASSIGNED_KEY &&\n        values.application.selectedKey === CREATE_APPLICATION_KEY &&\n        !applicationNameTouched &&\n        setFieldValue('application.name', '');\n      return;\n    }\n    !nameTouched && setFieldValue('name', '');\n    values.application.selectedKey !== UNASSIGNED_KEY &&\n      !applicationNameTouched &&\n      setFieldValue('application.name', '');\n  };\n\n  useFormikValidationFix(values.git.url);\n  return (\n    <FormSection title=\"Git\">\n      <InputField\n        type={TextInputTypes.text}\n        name=\"git.url\"\n        label=\"Git Repo URL\"\n        helpText={getHelpText()}\n        helpTextInvalid={getHelpText()}\n        validated={validated}\n        onChange={(e: React.SyntheticEvent) => {\n          resetFields();\n          setValidated(ValidatedOptions.default);\n          debouncedHandleGitUrlChange((e.target as HTMLInputElement).value, values.git.ref);\n        }}\n        onBlur={handleGitUrlBlur}\n        data-test-id=\"git-form-input-url\"\n        required\n      />\n      {values.git.showGitType && (\n        <>\n          <DropdownField\n            name=\"git.type\"\n            label=\"Git Type\"\n            items={GitReadableTypes}\n            title={GitReadableTypes[values.git.type]}\n            fullWidth\n            required\n          />\n          {!gitTypeTouched && (\n            <Alert isInline variant=\"info\" title=\"Defaulting Git Type to Other\">\n              We failed to detect the git type.\n            </Alert>\n          )}\n        </>\n      )}\n      {sampleRepo && <SampleRepo onClick={fillSample} />}\n      <AdvancedGitOptions />\n    </FormSection>\n  );\n};\n\nexport default GitSection;\n","import * as React from 'react';\nimport { LevelUpAltIcon } from '@patternfly/react-icons';\nimport { FormHelperText, Button, ButtonVariant } from '@patternfly/react-core';\n\nexport interface SampleRepoProps {\n  onClick: () => void;\n}\n\nconst SampleRepo = (props) => (\n  <FormHelperText isHidden={false}>\n    <Button {...props} type=\"button\" variant={ButtonVariant.link} isInline>\n      Try Sample <LevelUpAltIcon />\n    </Button>\n  </FormHelperText>\n);\n\nexport default SampleRepo;\n","import * as React from 'react';\nimport { useFormikContext, FormikValues, useField } from 'formik';\nimport { FormGroup } from '@patternfly/react-core';\nimport { SecretTypeAbstraction } from '@console/internal/components/secrets/create-secret';\nimport { getFieldId } from '@console/shared';\nimport SourceSecretDropdown from '../../dropdown/SourceSecretDropdown';\nimport { secretModalLauncher } from '../CreateSecretModal';\n\nconst CREATE_SOURCE_SECRET = 'create-source-secret';\n\nconst SourceSecretSelector: React.FC = () => {\n  const [secret] = useField('git.secret');\n  const { values, setFieldValue } = useFormikContext<FormikValues>();\n\n  const handleSave = (name: string) => {\n    setFieldValue('git.secret', name);\n  };\n\n  const handleDropdownChange = (key: string) => {\n    if (key === CREATE_SOURCE_SECRET) {\n      setFieldValue('git.secret', secret.value);\n      secretModalLauncher({\n        namespace: values.project.name,\n        save: handleSave,\n        secretType: SecretTypeAbstraction.source,\n      });\n    } else {\n      setFieldValue('git.secret', key);\n    }\n  };\n\n  return (\n    <>\n      <FormGroup\n        fieldId={getFieldId('source-secret', 'dropdown')}\n        label=\"Source Secret\"\n        helperText=\"Secret with credentials for pulling your source code.\"\n      >\n        <SourceSecretDropdown\n          dropDownClassName=\"dropdown--full-width\"\n          menuClassName=\"dropdown-menu--text-wrap\"\n          namespace={values.project.name}\n          actionItems={[\n            {\n              actionTitle: 'Create New Secret',\n              actionKey: CREATE_SOURCE_SECRET,\n            },\n          ]}\n          selectedKey={secret.value}\n          title={secret.value}\n          onChange={handleDropdownChange}\n        />\n      </FormGroup>\n    </>\n  );\n};\n\nexport default SourceSecretSelector;\n","import { useEffect, useRef } from 'react';\nimport { K8sResourceKind, k8sGet } from '@console/internal/module/k8s';\n\nexport const useSafeK8s = () => {\n  const controller = useRef<AbortController>();\n  const mounted = useRef(true);\n\n  useEffect(() => {\n    controller.current = new AbortController();\n    return () => {\n      mounted.current = false;\n      controller.current.abort();\n    };\n  }, []);\n\n  return (\n    kind: K8sResourceKind,\n    name: string,\n    ns: string,\n    opts: object = {},\n  ): Promise<K8sResourceKind> => {\n    return new Promise((resolve, reject) => {\n      k8sGet(\n        kind,\n        name,\n        ns,\n        Object.assign({ signal: controller.current.signal as AbortSignal }, opts),\n      )\n        .then((data) => mounted.current && resolve(data))\n        .catch((error) => mounted.current && reject(error));\n    });\n  };\n};\n","export * from './types';\nexport * from './services';\nexport * from './utils';\n","import { detectBuildTypes, isModernWebApp } from '../utils';\nimport {\n  BranchList,\n  BuildType,\n  GitSource,\n  RepoFileList,\n  RepoLanguageList,\n  RepoMetadata,\n} from '../types';\n\nexport abstract class BaseService {\n  protected gitsource: GitSource;\n\n  constructor(gitsource: GitSource) {\n    this.gitsource = gitsource;\n  }\n\n  /**\n   * Fetch metadata of the repository.\n   */\n  protected abstract getRepoMetadata(): RepoMetadata;\n\n  /**\n   * Get the auth providor for the git service.\n   */\n  protected abstract getAuthProvider(): any;\n\n  /**\n   * Returns if repo reachable or not along with the api response.\n   */\n  abstract async isRepoReachable(): Promise<boolean>;\n\n  /**\n   * Returns list of branches for given gitsource.\n   */\n  abstract async getRepoBranchList(): Promise<BranchList>;\n\n  /**\n   * Returns source code tree for given gitsource\n   */\n  abstract async getRepoFileList(): Promise<RepoFileList>;\n\n  /**\n   * Returns list of detected languages.\n   */\n  abstract async getRepoLanguageList(): Promise<RepoLanguageList>;\n\n  /**\n   * Check if Dockerfile present in the repo.\n   */\n  abstract async isDockerfilePresent(): Promise<boolean>;\n\n  /**\n   * Checks if dockerfile exist in the repo and returns dockerfile content\n   */\n  abstract async getDockerfileContent(): Promise<string>;\n\n  /**\n   * Checks if package.json exist in the repo and returns content of the file.\n   */\n  abstract async getPackageJsonContent(): Promise<string>;\n\n  /**\n   * Detect build types for given gitsource, It runs regular expressions on file list\n   * and returns list of build types matched.\n   */\n  async detectBuildTypes(): Promise<BuildType[]> {\n    try {\n      const fileList = await this.getRepoFileList();\n      const buildTypes = detectBuildTypes(fileList.files);\n      if (fileList.files.includes('package.json')) {\n        const packageJsonContent = await this.getPackageJsonContent();\n        if (isModernWebApp(packageJsonContent)) {\n          return buildTypes.sort((a, b) => {\n            if (b.buildType === 'modern-webapp') return 1;\n            if (a.buildType === 'modern-webapp') return -1;\n            return 0;\n          });\n        }\n      }\n      return buildTypes;\n    } catch (e) {\n      return [];\n    }\n  }\n}\n","import * as ParseBitbucketUrl from 'parse-bitbucket-url';\nimport {\n  GitSource,\n  SecretType,\n  RepoMetadata,\n  BranchList,\n  RepoLanguageList,\n  RepoFileList,\n} from '../types';\nimport { BaseService } from './base-service';\nimport { coFetchJSON } from '@console/internal/co-fetch';\n\nexport class BitbucketService extends BaseService {\n  private readonly metadata: RepoMetadata;\n\n  private readonly baseURL = 'https://api.bitbucket.org/2.0';\n\n  constructor(gitsource: GitSource) {\n    super(gitsource);\n    this.metadata = this.getRepoMetadata();\n  }\n\n  protected getAuthProvider = (): any => {\n    switch (this.gitsource.secretType) {\n      case SecretType.BASIC_AUTH: {\n        const { username, password } = this.gitsource.secretContent;\n        return { type: 'basic', username, password };\n      }\n      case SecretType.NO_AUTH:\n        return null;\n      default:\n        return null;\n    }\n  };\n\n  getRepoMetadata = (): RepoMetadata => {\n    const { name, owner, host, branch } = ParseBitbucketUrl(this.gitsource.url);\n    return { repoName: name, owner, host, defaultBranch: this.gitsource.ref || branch };\n  };\n\n  isRepoReachable = async (): Promise<boolean> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}`;\n    try {\n      const data = await coFetchJSON(url);\n      return data.slug === this.metadata.repoName;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  getRepoBranchList = async (): Promise<BranchList> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}/refs/branches`;\n    try {\n      const data = await coFetchJSON(url);\n      const list = data.values.map((b) => b.name);\n      return { branches: list };\n    } catch (e) {\n      return { branches: [] };\n    }\n  };\n\n  getRepoFileList = async (): Promise<RepoFileList> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}/src/${this.metadata.defaultBranch}/?pagelen=50`;\n    try {\n      const data = await coFetchJSON(url);\n      const files = data.values.map((f) => f.path);\n      return { files };\n    } catch (e) {\n      return { files: [] };\n    }\n  };\n\n  getRepoLanguageList = async (): Promise<RepoLanguageList> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}`;\n    try {\n      const data = await coFetchJSON(url);\n      return { languages: [data.language] };\n    } catch (e) {\n      return { languages: [] };\n    }\n  };\n\n  isDockerfilePresent = async (): Promise<boolean> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}/src/${this.metadata.defaultBranch}/Dockerfile`;\n    try {\n      await coFetchJSON(url);\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  getDockerfileContent = async (): Promise<string | null> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}/src/${this.metadata.defaultBranch}/Dockerfile`;\n    try {\n      const data = await coFetchJSON(url);\n      return data as string;\n    } catch (e) {\n      return null;\n    }\n  };\n\n  getPackageJsonContent = async (): Promise<string | null> => {\n    const url = `${this.baseURL}/repositories/${this.metadata.owner}/${this.metadata.repoName}/src/${this.metadata.defaultBranch}/package.json`;\n    try {\n      const data = await coFetchJSON(url);\n      return data as string;\n    } catch (e) {\n      return null;\n    }\n  };\n}\n","import { GitSource, GitProvider } from '../types';\nimport { GithubService } from './github-service';\nimport { BitbucketService } from './bitbucket-service';\nimport { BaseService } from './base-service';\nimport { GitlabService } from './gitlab-service';\n\nexport function getGitService(gitSource: GitSource, gitProvider: GitProvider): BaseService {\n  switch (gitProvider) {\n    case GitProvider.GITHUB:\n      return new GithubService(gitSource);\n    case GitProvider.BITBUCKET:\n      return new BitbucketService(gitSource);\n    case GitProvider.GITLAB:\n      return new GitlabService(gitSource);\n    default:\n      return null;\n  }\n}\n","import * as Octokit from '@octokit/rest';\nimport * as GitUrlParse from 'git-url-parse';\nimport {\n  GitSource,\n  SecretType,\n  RepoMetadata,\n  BranchList,\n  RepoLanguageList,\n  RepoFileList,\n} from '../types';\nimport { BaseService } from './base-service';\n\nexport class GithubService extends BaseService {\n  private readonly client: Octokit;\n\n  private readonly metadata: RepoMetadata;\n\n  constructor(gitsource: GitSource) {\n    super(gitsource);\n    const opts = this.getAuthProvider();\n    this.metadata = this.getRepoMetadata();\n    this.client = new Octokit({ auth: opts });\n  }\n\n  protected getAuthProvider = (): any => {\n    switch (this.gitsource.secretType) {\n      case SecretType.BASIC_AUTH: {\n        const { username, password } = this.gitsource.secretContent;\n        return { username, password };\n      }\n      case SecretType.NO_AUTH:\n        return null;\n      default:\n        return null;\n    }\n  };\n\n  protected getRepoMetadata = (): RepoMetadata => {\n    const { name, owner, source } = GitUrlParse(this.gitsource.url);\n    return { repoName: name, owner, host: source, defaultBranch: this.gitsource.ref || 'master' };\n  };\n\n  isRepoReachable = async (): Promise<boolean> => {\n    try {\n      const resp = await this.client.repos.get({\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n      });\n      return resp.status === 200;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  getRepoBranchList = async (): Promise<BranchList> => {\n    try {\n      const resp = await this.client.repos.listBranches({\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n      });\n      const list = resp.data.map((r) => {\n        return r.name;\n      });\n      return { branches: list };\n    } catch (e) {\n      return { branches: [] };\n    }\n  };\n\n  getRepoFileList = async (): Promise<RepoFileList> => {\n    try {\n      const resp = await this.client.git.getTree({\n        // eslint-disable-next-line @typescript-eslint/camelcase\n        tree_sha: this.metadata.defaultBranch,\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n      });\n      let files = [];\n      if (resp.status === 200) {\n        files = resp.data.tree.map((t) => t.path);\n      }\n      return { files };\n    } catch (e) {\n      return { files: [] };\n    }\n  };\n\n  getRepoLanguageList = async (): Promise<RepoLanguageList> => {\n    try {\n      const resp = await this.client.repos.listLanguages({\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n      });\n      if (resp.status === 200) {\n        return { languages: Object.keys(resp.data) };\n      }\n      return { languages: [] };\n    } catch (e) {\n      return { languages: [] };\n    }\n  };\n\n  isDockerfilePresent = async (): Promise<boolean> => {\n    try {\n      const resp = await this.client.repos.getContents({\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n        path: 'Dockerfile',\n      });\n      return resp.status === 200;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  getDockerfileContent = async (): Promise<string | null> => {\n    try {\n      const resp = await this.client.repos.getContents({\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n        path: 'Dockerfile',\n      });\n      if (resp.status === 200) {\n        // eslint-disable-next-line dot-notation\n        return Buffer.from(resp.data['content'], 'base64').toString();\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  };\n\n  getPackageJsonContent = async (): Promise<string | null> => {\n    try {\n      const resp = await this.client.repos.getContents({\n        owner: this.metadata.owner,\n        repo: this.metadata.repoName,\n        path: 'package.json',\n      });\n      if (resp.status === 200) {\n        // eslint-disable-next-line dot-notation\n        return Buffer.from(resp.data['content'], 'base64').toString();\n      }\n      return null;\n    } catch (e) {\n      return null;\n    }\n  };\n}\n","import { Gitlab } from 'gitlab';\nimport * as GitUrlParse from 'git-url-parse';\nimport {\n  GitSource,\n  SecretType,\n  RepoMetadata,\n  BranchList,\n  RepoLanguageList,\n  RepoFileList,\n} from '../types';\nimport { BaseService } from './base-service';\n\ntype GitlabRepo = {\n  id: number;\n  path_with_namespace: string;\n};\n\nexport class GitlabService extends BaseService {\n  private readonly client: any;\n\n  private readonly metadata: RepoMetadata;\n\n  private repo: GitlabRepo;\n\n  constructor(gitsource: GitSource) {\n    super(gitsource);\n    this.metadata = this.getRepoMetadata();\n    const token = this.getAuthProvider();\n    this.client = new Gitlab({\n      host: this.metadata.host,\n      token,\n    });\n    this.repo = null;\n  }\n\n  private getRepo = async (): Promise<GitlabRepo> => {\n    if (this.repo) {\n      return Promise.resolve(this.repo);\n    }\n    const repo: GitlabRepo = await this.client.Projects.show(this.metadata.fullName);\n    if (!repo || repo.path_with_namespace !== this.metadata.fullName) {\n      throw new Error('Unable to find repo');\n    }\n\n    this.repo = repo;\n    return Promise.resolve(this.repo);\n  };\n\n  getRepoMetadata(): RepoMetadata {\n    const { name, owner, protocol, source, full_name: fullName } = GitUrlParse(this.gitsource.url);\n    const host = `${protocol}://${source}`;\n    return {\n      repoName: name,\n      owner,\n      host,\n      defaultBranch: this.gitsource.ref || 'master',\n      fullName,\n    };\n  }\n\n  getAuthProvider = (): any => {\n    switch (this.gitsource.secretType) {\n      case SecretType.PERSONAL_ACCESS_TOKEN || SecretType.OAUTH:\n        return this.gitsource.secretContent;\n      default:\n        return null;\n    }\n  };\n\n  getProjectId = async (): Promise<any> => {\n    try {\n      const repo = await this.getRepo();\n      return repo.id;\n    } catch (e) {\n      throw e;\n    }\n  };\n\n  isRepoReachable = async (): Promise<boolean> => {\n    try {\n      await this.getRepo();\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  getRepoBranchList = async (): Promise<BranchList> => {\n    try {\n      const projectID = await this.getProjectId();\n      const resp = await this.client.Branches.all(projectID);\n      const list = resp.map((b) => b.name);\n      return { branches: list };\n    } catch (e) {\n      return { branches: [] };\n    }\n  };\n\n  getRepoFileList = async (): Promise<RepoFileList> => {\n    try {\n      const projectID = await this.getProjectId();\n      const resp = await this.client.Repositories.tree(projectID);\n      const files = resp.reduce((acc, file) => {\n        if (file.type === 'blob') acc.push(file.path);\n        return acc;\n      }, []);\n      return { files };\n    } catch (e) {\n      return { files: [] };\n    }\n  };\n\n  getRepoLanguageList = async (): Promise<RepoLanguageList> => {\n    try {\n      const projectID = await this.getProjectId();\n      const resp = await this.client.Projects.languages(projectID);\n      return { languages: Object.keys(resp) };\n    } catch (e) {\n      return { languages: [] };\n    }\n  };\n\n  isDockerfilePresent = async (): Promise<boolean> => {\n    try {\n      const projectID = await this.getProjectId();\n      await this.client.RepositoryFiles.showRaw(\n        projectID,\n        'Dockerfile',\n        this.metadata.defaultBranch,\n      );\n      return true;\n    } catch (e) {\n      return false;\n    }\n  };\n\n  getDockerfileContent = async (): Promise<string | null> => {\n    try {\n      const projectID = await this.getProjectId();\n      return await this.client.RepositoryFiles.showRaw(\n        projectID,\n        'Dockerfile',\n        this.metadata.defaultBranch,\n      );\n    } catch (e) {\n      return null;\n    }\n  };\n\n  getPackageJsonContent = async (): Promise<string | null> => {\n    try {\n      const projectID = await this.getProjectId();\n      return await this.client.RepositoryFiles.showRaw(\n        projectID,\n        'package.json',\n        this.metadata.defaultBranch,\n      );\n    } catch (e) {\n      return null;\n    }\n  };\n}\n","export * from './github-service';\nexport * from './bitbucket-service';\nexport * from './gitlab-service';\nexport * from './git-service';\n","export interface BuildTool {\n  name: string;\n  type: string;\n  language: string;\n  expectedRegexps: RegExp;\n  expectedFiles: string[];\n}\n\nexport interface BuildType {\n  buildType: string;\n  language: string;\n  files: string[];\n}\n\nexport const Maven: BuildTool = {\n  name: 'Maven',\n  type: 'java',\n  language: 'java',\n  expectedRegexps: RegExp([`pom.xml`].join('|')),\n  expectedFiles: ['pom.xml'],\n};\n\nexport const Gradle: BuildTool = {\n  name: 'Gradle',\n  type: 'java',\n  language: 'java',\n  expectedRegexps: RegExp([`.*gradle.*`].join('|')),\n  expectedFiles: ['build.gradle', 'gradlew', 'gradlew.bat'],\n};\n\nexport const Golang: BuildTool = {\n  name: 'Golang',\n  type: 'golang',\n  language: 'go',\n  expectedRegexps: RegExp([`main.go`, `Gopkg.toml`, `glide.yaml`].join('|')),\n  expectedFiles: ['main.go', 'Gopkg.toml', 'glide.yaml'],\n};\n\nexport const Ruby: BuildTool = {\n  name: 'Ruby',\n  type: 'ruby',\n  language: 'ruby',\n  expectedRegexps: RegExp([`Gemfile`, `Rakefile`, `config.ru`].join('|')),\n  expectedFiles: ['Gemfile', 'Rakefile', 'config.ru'],\n};\n\nexport const NodeJS: BuildTool = {\n  name: 'NodeJS',\n  type: 'nodejs',\n  language: 'javascript',\n  expectedRegexps: RegExp([`app.json`, `package.json`, `gulpfile.js`, `Gruntfile.js`].join('|')),\n  expectedFiles: ['app.json', 'package.json', 'gulpfile.js', 'Gruntfile.js'],\n};\n\nexport const ModernWebApp: BuildTool = {\n  name: 'Modern Web App',\n  type: 'modern-webapp',\n  language: 'javascript',\n  expectedRegexps: RegExp([`app.json`, `package.json`, `gulpfile.js`, `Gruntfile.js`].join('|')),\n  expectedFiles: ['app.json', 'package.json', 'gulpfile.js', 'Gruntfile.js'],\n};\n\nexport const PHP: BuildTool = {\n  name: 'PHP',\n  type: 'php',\n  language: 'php',\n  expectedRegexps: RegExp([`index.php`, `composer.json`].join('|')),\n  expectedFiles: ['index.php', 'composer.json'],\n};\n\nexport const Python: BuildTool = {\n  name: 'Python',\n  type: 'python',\n  language: 'python',\n  expectedRegexps: RegExp([`requirements.txt`, `setup.py`].join('|')),\n  expectedFiles: ['requirements.txt', 'setup.py'],\n};\n\nexport const Perl: BuildTool = {\n  name: 'Perl',\n  type: 'perl',\n  language: 'perl',\n  expectedRegexps: RegExp([`index.pl`, `cpanfile`].join('|')),\n  expectedFiles: ['index.pl', 'cpanfile'],\n};\n\nexport const Dotnet: BuildTool = {\n  name: 'Dotnet',\n  type: 'dotnet',\n  language: 'C#',\n  expectedRegexps: RegExp([`project.json`, `.*.csproj`].join('|')),\n  expectedFiles: ['project.json', 'app.csproj'],\n};\n\nexport const BuildTools = [\n  Dotnet,\n  Golang,\n  Gradle,\n  Maven,\n  NodeJS,\n  ModernWebApp,\n  Perl,\n  PHP,\n  Python,\n  Ruby,\n];\n\nexport const WebAppDependencies = [\n  'react',\n  'angular',\n  '@angular/core',\n  'vue',\n  'knockout',\n  'knockback',\n];\n","export enum SecretType {\n  NO_AUTH,\n  BASIC_AUTH,\n  SSH,\n  PERSONAL_ACCESS_TOKEN,\n  OAUTH,\n}\n\nexport interface GitSource {\n  url: string;\n  secretType?: SecretType;\n  secretContent?: any;\n  ref?: string;\n}\n\nexport enum GitProvider {\n  GITHUB = 'github',\n  BITBUCKET = 'bitbucket',\n  GITLAB = 'gitlab',\n}\n","export * from './auth';\nexport * from './repo';\nexport * from './git';\nexport * from './build-tools';\n","import { BuildTool, BuildTools, BuildType, WebAppDependencies } from '../types';\n\nexport function detectBuildTypes(files: string[]): BuildType[] {\n  const buildTypes = BuildTools.map((t: BuildTool) => {\n    const matchedFiles = files.filter((f: string) => t.expectedRegexps.test(f));\n    return { buildType: t.type, language: t.language, files: matchedFiles };\n  });\n  return buildTypes\n    .filter((b: BuildType) => b.files.length > 0)\n    .sort((a, b) => b.files.length - a.files.length);\n}\n\nexport function isModernWebApp(packageJsonContent: string): boolean {\n  const packageJson = JSON.parse(packageJsonContent);\n  let isWebApp = false;\n  WebAppDependencies.forEach((dep) => {\n    if (dep in packageJson.dependencies) {\n      isWebApp = true;\n    }\n  });\n\n  return isWebApp;\n}\n","import { CommandEntry, parse } from 'docker-file-parser';\n\nexport class DockerFileParser {\n  content: string;\n\n  parsedCommands: CommandEntry[];\n\n  constructor(content: string) {\n    this.content = content;\n    this.parsedCommands = this.parse();\n  }\n\n  parse(): CommandEntry[] {\n    return parse(this.content);\n  }\n\n  getContainerPort(): number {\n    const cmd = this.parsedCommands.filter((c: CommandEntry) => c.name === 'EXPOSE');\n    if (cmd.length > 0) {\n      const exposeCommand = cmd[0];\n      if (exposeCommand.args.length > 0) return Number(exposeCommand.args[0]);\n    }\n    return null;\n  }\n}\n","export * from './build-tool-detector';\nexport * from './dockerfile-parser';\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAEA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAQA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AAGA;AAEA;AAGA;AAGA;AAQA;AAEA;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAOA;AAIA;AACA;AAOA;AACA;AAKA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAQA;AAGA;AAEA;;;;;;;;;;;;;ACzEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAEA;AAQA;AAEA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAWA;AACA;;AAEA;AAKA;AAEA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAMA;AAMA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9BA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAQA;AACA;AACA;AACA;AAKA;AAEA;AAQA;AAOA;AACA;AAGA;AAEA;;;;;;;;;;;;;ACjNA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AAEA;;AACA;AAKA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAKA;AAKA;AACA;AACA;AACA;AACA;AAQA;AAEA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAUA;AAGA;AACA;AACA;AA+CA;;;AAGA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACrFA;AACA;AAQA;AACA;AAEA;AAKA;AACA;AAHA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AA3FA;AACA;AA2FA;;;;;;;;;;;;;AC/GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACjBA;AACA;AACA;AAQA;AAEA;AAKA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAhIA;AACA;AACA;AACA;AA8HA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpJA;AACA;AACA;AAQA;AAOA;AAOA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AAtIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuGA;;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACWA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACnBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACtBA;AAAA;AAAA;AAAA;AAAA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;A","sourceRoot":""}