{"version":3,"file":"storage-class-form-702638942ca7ca8bd268.js","sources":["webpack:///./public/components/storage-class-form.tsx"],"sourcesContent":["import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { Link } from 'react-router-dom';\nimport * as classNames from 'classnames';\nimport * as fuzzy from 'fuzzysearch';\nimport * as _ from 'lodash-es';\nimport { ActionGroup, Button } from '@patternfly/react-core';\nimport { getName } from '@console/shared';\nimport {\n  AsyncComponent,\n  ButtonBar,\n  Dropdown,\n  ExternalLink,\n  Firehose,\n  FirehoseResult,\n  NameValueEditorPair,\n  history,\n} from './utils';\nimport { k8sCreate, K8sResourceKind, referenceForModel } from './../module/k8s';\nimport * as k8sActions from '../actions/k8s';\nimport { CSIDriverModel, StorageClassModel } from './../models';\n\nconst NameValueEditorComponent = (props) => (\n  <AsyncComponent\n    loader={() => import('./utils/name-value-editor').then((c) => c.NameValueEditor)}\n    {...props}\n  />\n);\n\nconst defaultState = {\n  newStorageClass: {\n    name: '',\n    description: '',\n    type: null,\n    parameters: {},\n    reclaim: null,\n  },\n  customParams: [['', '']],\n  validationSuccessful: false,\n  loading: false,\n  error: null,\n  fieldErrors: { parameters: {} },\n};\n\nexport class StorageClassForm_ extends React.Component<\n  StorageClassFormProps,\n  StorageClassFormState\n> {\n  resources: Resources;\n  reduxId: string;\n  previousName: string;\n\n  constructor(props) {\n    super(props);\n    this.state = defaultState;\n    this.previousName = '';\n  }\n\n  defaultProvisionerObj = {\n    title: '',\n    provisioner: '',\n    parameters: {},\n  };\n\n  storageTypes = {};\n\n  CSIStorageTypes = Object.freeze({\n    'rbd.csi.ceph.com': {\n      title: 'Ceph RBD',\n      provisioner: 'rbd.csi.ceph.com',\n      documentationLink: 'https://rook.io/docs/rook/v1.1/',\n      parameters: {\n        clusterID: {\n          name: 'Cluster ID',\n          hintText: 'The namespace where Ceph is deployed',\n          required: true,\n        },\n        pool: {\n          name: 'Pool',\n          hintText: 'Ceph pool into which volume data shall be stored',\n          required: true,\n        },\n        imageFormat: {\n          name: 'Image Format',\n          hintText: 'RBD image format. Defaults to \"2\"',\n          values: { '2': '2' },\n          required: true,\n        },\n        imageFeatures: {\n          name: 'Image Features',\n          hintText: 'Ceph RBD image features',\n          values: { layering: 'layering' },\n          required: true,\n        },\n        'csi.storage.k8s.io/provisioner-secret-name': {\n          name: 'Provisioner Secret Name',\n          hintText: 'The name of provisioner secret',\n          required: true,\n        },\n        'csi.storage.k8s.io/provisioner-secret-namespace': {\n          name: 'Provisioner Secret Namespace',\n          hintText: 'The namespace where provisioner secret is created',\n          required: true,\n        },\n        'csi.storage.k8s.io/node-stage-secret-name': {\n          name: 'Node Stage Secret Name',\n          hintText: 'The name of Node Stage secret',\n          required: true,\n        },\n        'csi.storage.k8s.io/node-stage-secret-namespace': {\n          name: 'Node Stage Secret Namespace',\n          hintText: 'The namespace where provisioner secret is created',\n          required: true,\n        },\n        'csi.storage.k8s.io/fstype': {\n          name: 'Filesystem Type',\n          hintText: 'Ceph RBD filesystem type. Default set to ext4',\n          required: true,\n        },\n      },\n    },\n    'cephfs.csi.ceph.com': {\n      title: 'Ceph FS',\n      provisioner: 'cephfs.csi.ceph.com',\n      documentationLink: 'https://rook.io/docs/rook/v1.1/',\n      parameters: {\n        clusterID: {\n          name: 'Cluster ID',\n          hintText: 'The namespace where Ceph is deployed',\n          required: true,\n        },\n        pool: {\n          name: 'Pool',\n          hintText: 'Ceph pool into which volume data shall be stored',\n        },\n        fsName: {\n          name: 'Filesystem Name',\n          hintText: 'CephFS filesystem name into which the volume shall be created',\n          required: true,\n        },\n        'csi.storage.k8s.io/provisioner-secret-name': {\n          name: 'Provisioner Secret Name',\n          hintText: 'The name of provisioner secret',\n          required: true,\n        },\n        'csi.storage.k8s.io/provisioner-secret-namespace': {\n          name: 'Provisioner Secret Namespace',\n          hintText: 'The namespace where provisioner secret is created',\n          required: true,\n        },\n        'csi.storage.k8s.io/node-stage-secret-name': {\n          name: 'Node Stage Secret Name',\n          hintText: 'The name of Node Stage secret',\n          required: true,\n        },\n        'csi.storage.k8s.io/node-stage-secret-namespace': {\n          name: 'Node Stage Secret Namespace',\n          hintText: 'The namespace where provisioner secret is created',\n          required: true,\n        },\n      },\n    },\n  });\n\n  defaultStorageTypes = Object.freeze({\n    local: {\n      title: 'Local',\n      provisioner: 'kubernetes.io/no-provisioner',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#local',\n      parameters: {},\n      volumeBindingMode: 'WaitForFirstConsumer',\n    },\n    aws: {\n      title: 'AWS Elastic Block Storage',\n      provisioner: 'kubernetes.io/aws-ebs',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#aws-ebs',\n      parameters: {\n        type: {\n          name: 'Type',\n          values: { io1: 'io1', gp2: 'gp2', sc1: 'sc1', st1: 'st1' },\n          hintText: 'Select AWS Type',\n        },\n        iopsPerGB: {\n          name: 'IOPS Per GiB',\n          hintText: 'I/O operations per second per GiB',\n          validation: (params) => {\n            if (params.iopsPerGB.value !== '' && !params.iopsPerGB.value.match(/^[1-9]\\d*$/)) {\n              return 'IOPS per GiB must be a number';\n            }\n            return null;\n          },\n          visible: (params) => _.get(params, 'type.value') === 'io1',\n        },\n        fsType: {\n          name: 'Filesystem Type',\n          hintText: 'Filesystem to Be Laid Out',\n        },\n        encrypted: {\n          name: 'Encrypted',\n          type: 'checkbox',\n          format: (value) => value.toString(),\n        },\n        kmsKeyId: {\n          name: 'KMS Key ID',\n          hintText: 'The full Amazon Resource Name of the key to use when encrypting the volume',\n          visible: (params) => _.get(params, 'encrypted.value', false),\n        },\n      },\n    },\n    'gce-pd': {\n      title: 'GCE PD',\n      provisioner: 'kubernetes.io/gce-pd',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#gce',\n      parameters: {\n        type: {\n          name: 'Type',\n          values: { 'pd-standard': 'pd-standard', 'pd-ssd': 'pd-ssd' },\n          hintText: 'Select GCE type',\n        },\n        zone: {\n          name: 'Zone',\n          validation: (params) => {\n            if (params.zone.value !== '' && _.get(params, 'zones.value', '') !== '') {\n              return 'Zone and zones parameters must not be used at the same time';\n            }\n            return null;\n          },\n        },\n        zones: {\n          name: 'Zones',\n          validation: (params) => {\n            if (params.zones.value !== '' && _.get(params, 'zone.value', '') !== '') {\n              return 'Zone and zones parameters must not be used at the same time';\n            }\n            return null;\n          },\n        },\n        'replication-type': {\n          name: 'Replication Type',\n          values: { none: 'none', 'regional-pd': 'regional-pd' },\n          hintText: 'Select Replication Type',\n          validation: (params) => {\n            if (\n              params['replication-type'].value === 'regional-pd' &&\n              _.get(params, 'zone.value', '') !== ''\n            ) {\n              return 'Zone cannot be specified when Replication Type regional-pd is chosen, use zones instead';\n            }\n            return null;\n          },\n        },\n      },\n    },\n    glusterfs: {\n      title: 'Glusterfs',\n      provisioner: 'kubernetes.io/glusterfs',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#glusterfs',\n      parameters: {\n        resturl: {\n          name: 'Gluster REST/Heketi URL',\n          required: true,\n        },\n        restuser: {\n          name: 'Gluster REST/Heketi user',\n        },\n        secretNamespace: {\n          name: 'Secret Namespace',\n        },\n        secretName: {\n          name: 'Secret Name',\n        },\n        clusterid: {\n          name: 'Cluster ID',\n        },\n        gidMin: {\n          name: 'GID Min',\n          validation: (params) => {\n            if (params.gidMin.value !== '' && !params.gidMin.value.match(/^[1-9]\\d*$/)) {\n              return 'GID Min must be number';\n            }\n            return null;\n          },\n        },\n        gidMax: {\n          name: 'GID Max',\n          validation: (params) => {\n            if (params.gidMax.value !== '' && !params.gidMax.value.match(/^[1-9]\\d*$/)) {\n              return 'GID Max must be number';\n            }\n            return null;\n          },\n        },\n        volumetype: {\n          name: 'Volume Type',\n        },\n      },\n    },\n    openstackCinder: {\n      title: 'OpenStack Cinder',\n      provisioner: 'kubernetes.io/cinder',\n      documentationLink:\n        'https://kubernetes.io/docs/concepts/storage/storage-classes/#openstack-cinder',\n      parameters: {\n        type: {\n          name: 'Volume Type',\n        },\n        availability: {\n          name: 'Availability Zone',\n        },\n      },\n    },\n    azureFile: {\n      title: 'Azure File',\n      provisioner: 'kubernetes.io/azure-file',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#azure-file',\n      parameters: {\n        skuName: {\n          name: 'SKU Name',\n          hintText: 'Azure storage account SKU tier',\n        },\n        location: {\n          name: 'Location',\n          hintText: 'Azure storage account location',\n        },\n        storageAccount: {\n          name: 'Azure Storage Account Name',\n          hintText: 'Azure Storage Account Name',\n        },\n      },\n    },\n    azureDisk: {\n      title: 'Azure Disk',\n      provisioner: 'kubernetes.io/azure-disk',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#azure-disk',\n      parameters: {\n        storageaccounttype: {\n          name: 'Storage Account Type',\n          hintText: 'Storage Account Type',\n        },\n        kind: {\n          name: 'Account Kind',\n          values: { shared: 'shared', dedicated: 'dedicated', managed: 'managed' },\n          hintText: 'Select Account Kind',\n        },\n      },\n    },\n    quobyte: {\n      title: 'Quobyte',\n      provisioner: 'kubernetes.io/quobyte',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#quobyte',\n      parameters: {\n        quobyteAPIServer: {\n          name: 'Quobyte API Server',\n          hintText: 'Quobyte API Server',\n        },\n        registry: {\n          name: 'Registry Address(es)',\n          hintText: 'Registry Address(es)',\n        },\n        adminSecretName: {\n          name: 'Admin Secret Name',\n          hintText: 'Admin Secret Name',\n        },\n        adminSecretNamespace: {\n          name: 'Admin Secret Namespace',\n          hintText: 'Admin Secret Namespace',\n        },\n        user: {\n          name: 'User',\n          hintText: 'User',\n        },\n        group: {\n          name: 'Group',\n          hintText: 'Group',\n        },\n        quobyteConfig: {\n          name: 'Quobyte Configuration',\n          hintText: 'Quobyte Configuration',\n        },\n        quobyteTenant: {\n          name: 'Quobyte Tenant',\n          hintText: 'Quobyte tenant ID used to create/delete the volume',\n        },\n      },\n    },\n    vSphereVolume: {\n      title: 'vSphere Volume',\n      provisioner: 'kubernetes.io/vsphere-volume',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#vsphere',\n      parameters: {\n        diskformat: {\n          name: 'Disk Format',\n          values: {\n            thin: 'thin',\n            zeroedthick: 'zeroed thick',\n            eagerzeroedthick: 'eager zeroed thick',\n          },\n          hintText: 'Select Disk Format',\n        },\n        datastore: {\n          name: 'Datastore',\n          hintText: 'Datastore',\n        },\n      },\n    },\n    portworxVolume: {\n      title: 'Portworx Volume',\n      provisioner: 'kubernetes.io/portworx-volume',\n      documentationLink:\n        'https://kubernetes.io/docs/concepts/storage/storage-classes/#portworx-volume',\n      parameters: {\n        fs: {\n          name: 'Filesystem',\n          values: { none: 'none', xfs: 'xfs', ext4: 'ext4' },\n          hintText: 'Select Filesystem',\n        },\n        // eslint-disable-next-line camelcase\n        block_size: {\n          name: 'Block Size',\n          hintText: 'Block size in Kb',\n          validation: (params) => {\n            if (params.block_size.value !== '' && !params.block_size.value.match(/^[1-9]\\d*$/)) {\n              return 'Snapshot interval must be a number';\n            }\n            return null;\n          },\n        },\n        repl: {\n          name: 'Number of synchronous replicas to be provided in the form of replication factor',\n          hintText: 'Number of Replicas',\n          validation: (params) => {\n            if (params.repl.value !== '' && !params.repl.value.match(/^[1-9]\\d*$/)) {\n              return 'Number of replicas must be a number';\n            }\n            return null;\n          },\n        },\n        // eslint-disable-next-line camelcase\n        io_priority: {\n          name: 'I/O Priority',\n          values: { high: 'high', medium: 'medium', low: 'low' },\n          hintText: 'I/O Priority',\n        },\n        // eslint-disable-next-line camelcase\n        snap_interval: {\n          name: 'Snapshot Interval',\n          hintText: 'Clock/time interval in minutes for when to trigger snapshots',\n          validation: (params) => {\n            if (params.repl.value !== '' && !params.repl.value.match(/^[1-9]\\d*$/)) {\n              return 'Snapshot interval must be a number';\n            }\n            return null;\n          },\n          format: (value) => value.toString(),\n        },\n        // eslint-disable-next-line camelcase\n        aggregation_level: {\n          name: 'Aggregation Level',\n          hintText: 'The number of chunks the volume would be distributed into',\n          validation: (params) => {\n            if (\n              params.aggregation_level.value !== '' &&\n              !params.aggregation_level.value.match(/^[1-9]\\d*$/)\n            ) {\n              return 'Aggregation level must be a number';\n            }\n            return null;\n          },\n          format: (value) => value.toString(),\n        },\n        ephemeral: {\n          name: 'Ephemeral',\n          type: 'checkbox',\n          format: (value) => value.toString(),\n        },\n      },\n    },\n    scaleIo: {\n      title: 'ScaleIO',\n      provisioner: 'kubernetes.io/scaleio',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#scaleio',\n      parameters: {\n        gateway: {\n          name: 'API Gateway',\n          required: true,\n          hintText: 'ScaleIO API gateway address',\n        },\n        system: {\n          name: 'System Name',\n          required: true,\n          hintText: 'Name of the ScaleIO system',\n        },\n        protectionDomain: {\n          name: 'Protection Domain',\n          required: true,\n          hintText: 'Name of the ScaleIO protection domain',\n        },\n        storagePool: {\n          name: 'Storage Pool',\n          required: true,\n          hintText: 'Name of the volume storage pool',\n        },\n        storageMode: {\n          name: 'Storage Mode',\n          values: { thinProvisioned: 'ThinProvisioned', thickProvisioned: 'ThickProvisioned' },\n          hintText: 'Select Storage Provision Mode',\n        },\n        secretRef: {\n          name: 'Secret Reference',\n          required: true,\n          hintText: 'Reference to a configured Secret object',\n        },\n        readOnly: {\n          name: 'Read Only',\n          type: 'checkbox',\n        },\n        fsType: {\n          name: 'Filesystem Type',\n          hintText: 'Filesystem to use for the volume',\n        },\n      },\n    },\n    storageOs: {\n      title: 'StorageOS',\n      provisioner: 'kubernetes.io/storageos',\n      documentationLink: 'https://kubernetes.io/docs/concepts/storage/storage-classes/#storageos',\n      parameters: {\n        pool: {\n          name: 'Pool',\n          hintText:\n            'Name of the StorageOS distributed capacity pool from which to provision the volume',\n        },\n        description: {\n          name: 'Description',\n          hintText: 'Description to assign to volumes that were created dynamically',\n        },\n        fsType: {\n          name: 'Filesystem Type',\n          hintText: 'Default filesystem type to request',\n        },\n        adminSecretName: {\n          name: 'Admin Secret Name',\n          hintText: 'Name of the secret to use for obtaining the StorageOS API credentials',\n        },\n        adminSecretNamespace: {\n          name: 'Admin Secret Namespace',\n          hintText: 'Namespace where the API configuration secret is located',\n          required: (params) => {\n            const adminSecretName = _.get(params, 'adminSecretName.value', null);\n            return adminSecretName !== null && adminSecretName !== '';\n          },\n        },\n      },\n    },\n  });\n\n  reclaimPolicies = {\n    Retain: 'Retain',\n    Delete: 'Delete',\n  };\n\n  // Accepts a list of CSI provisioners and it checks if the\n  // provisioner is listed in CSIStorageTypes object\n  // if yes then return the provisioner with parameters that\n  // needs to be filled by user.\n  csiProvisionerMap = (csiData) => {\n    const csiListedProvisioner: string[] = _.keys(this.CSIStorageTypes);\n    csiData.map((csi) => {\n      _.each(csiListedProvisioner, (provisioner) => {\n        const hasProvisioner = getName(csi).includes(provisioner);\n        if (hasProvisioner) {\n          const provisionerData = _.cloneDeep(this.CSIStorageTypes[provisioner]);\n          provisionerData.provisioner = getName(csi);\n          this.storageTypes[getName(csi)] = provisionerData;\n          return false;\n        }\n        const provisionerData = _.cloneDeep(this.defaultProvisionerObj);\n        provisionerData.title = getName(csi);\n        provisionerData.provisioner = getName(csi);\n        this.storageTypes[getName(csi)] = provisionerData;\n      });\n    });\n  };\n\n  componentDidUpdate(prevProps) {\n    if (this.props !== prevProps) {\n      const { resources } = this.props;\n      const loaded = _.get(resources.sc, 'loaded');\n      const csiLoaded = _.get(resources.csi, 'loaded');\n      const scData = _.get(resources.sc, 'data', []) as K8sResourceKind[];\n      const csiData = _.get(resources.csi, 'data', []) as K8sResourceKind[];\n      if (loaded) {\n        this.resources = {\n          data: scData,\n          loadError: _.get(resources.sc, 'loadError'),\n          loaded,\n        };\n        this.validateForm();\n      }\n      if (csiLoaded) {\n        this.csiProvisionerMap(csiData);\n      }\n    }\n  }\n\n  componentDidMount() {\n    this.storageTypes = _.cloneDeep(this.defaultStorageTypes);\n  }\n\n  setParameterHandler = (param, event, checkbox) => {\n    const newParams = { ...this.state.newStorageClass.parameters };\n    if (checkbox) {\n      newParams[param] = { value: event.target.checked };\n    } else {\n      if (event.target) {\n        newParams[param] = { value: event.target.value };\n      } else {\n        newParams[param] = { value: event };\n      }\n    }\n\n    _.forOwn(newParams, (value, key) => {\n      if (newParams.hasOwnProperty(key)) {\n        const validation = _.get(\n          this.storageTypes[this.state.newStorageClass.type],\n          ['parameters', key, 'validation'],\n          null,\n        );\n        newParams[key].validationMsg = validation ? validation(newParams) : null;\n      }\n    });\n\n    this.updateNewStorage('parameters', newParams, true);\n  };\n\n  setStorageHandler(param, value) {\n    this.updateNewStorage(param, value, true);\n  }\n\n  updateNewStorage = (param, value, runValidation) => {\n    const newParams = {\n      ...this.state.newStorageClass,\n      [param]: value,\n    };\n\n    runValidation\n      ? this.setState({ newStorageClass: newParams }, this.validateForm)\n      : this.setState({ newStorageClass: newParams });\n  };\n\n  createStorageClass = (e: React.FormEvent<EventTarget>) => {\n    e.preventDefault();\n\n    this.setState({\n      loading: true,\n    });\n\n    const { description, type, reclaim } = this.state.newStorageClass;\n    const dataParameters = this.getFormParams();\n    const annotations = description ? { description } : {};\n    const data: StorageClass = {\n      metadata: {\n        name: this.state.newStorageClass.name,\n        annotations,\n      },\n      provisioner: this.storageTypes[type].provisioner,\n      parameters: dataParameters,\n    };\n\n    if (reclaim) {\n      data.reclaimPolicy = reclaim;\n    }\n\n    const volumeBindingMode = _.get(this.storageTypes[type], 'volumeBindingMode', null);\n    if (volumeBindingMode) {\n      data.volumeBindingMode = volumeBindingMode;\n    }\n\n    k8sCreate(StorageClassModel, data)\n      .then(() => {\n        this.setState({ loading: false });\n        history.push('/k8s/cluster/storageclasses');\n      })\n      .catch((error) => this.setState({ loading: false, error }));\n  };\n\n  getFormParams = () => {\n    const type = this.state.newStorageClass.type;\n    const dataParameters = _.pickBy(\n      _.mapValues(this.state.newStorageClass.parameters, (value, key) => {\n        let finalValue = value.value;\n        if (this.storageTypes[type].parameters[key].format) {\n          finalValue = this.storageTypes[type].parameters[key].format(value.value);\n        }\n        return finalValue;\n      }),\n      (value) => value !== '',\n    );\n\n    return _.merge(dataParameters, this.getCustomParams());\n  };\n\n  getCustomParams = () => {\n    // Discard any row whose key is blank\n    const customParams = _.reject(this.state.customParams, (t) =>\n      _.isEmpty(t[NameValueEditorPair.Name]),\n    );\n\n    // Display error if duplicate keys are found\n    const keys = customParams.map((t) => t[NameValueEditorPair.Name]);\n    if (_.uniq(keys).length !== keys.length) {\n      this.setState({ error: 'Duplicate keys found.' });\n      return;\n    }\n\n    // Convert any blank values to null\n    _.each(\n      customParams,\n      (t) =>\n        (t[NameValueEditorPair.Value] = _.isEmpty(t[NameValueEditorPair.Value])\n          ? null\n          : t[NameValueEditorPair.Value]),\n    );\n\n    return _.fromPairs(customParams);\n  };\n\n  updateCustomParams = (customParams) => {\n    this.setState({\n      customParams: customParams.nameValuePairs,\n    });\n  };\n\n  validateForm = () => {\n    // Clear error messages from previous validation attempts first\n    this.setState({ error: null, fieldErrors: {} }, () => {\n      const fieldErrors = this.state.fieldErrors;\n      let validationSuccessful = true;\n\n      const nameValidation = this.validateName();\n      if (!nameValidation.nameIsValid) {\n        fieldErrors.nameValidationMsg = nameValidation.error;\n        validationSuccessful = false;\n      }\n\n      if (this.state.newStorageClass.type === null) {\n        validationSuccessful = false;\n      } else if (!this.validateParameters()) {\n        validationSuccessful = false;\n      }\n\n      if (!this.allRequiredFieldsFilled()) {\n        validationSuccessful = false;\n      }\n\n      this.setState({ fieldErrors, validationSuccessful });\n    });\n  };\n\n  validateName = () => {\n    const updatedName = this.state.newStorageClass.name;\n    const nameUpdated = updatedName !== this.previousName;\n    const returnVal = {\n      error: null,\n      nameIsValid: true,\n    };\n\n    if (nameUpdated) {\n      if (updatedName.trim().length === 0) {\n        returnVal.error = 'Storage name is required';\n        returnVal.nameIsValid = false;\n      } else if (this.resources) {\n        _.each(this.resources.data, function(storageClass) {\n          if (storageClass.metadata.name === updatedName.toLowerCase()) {\n            returnVal.error = 'Storage name must be unique';\n            returnVal.nameIsValid = false;\n          }\n        });\n      }\n      this.previousName = updatedName;\n    }\n\n    return returnVal;\n  };\n\n  validateParameters = () => {\n    const params = this.state.newStorageClass.parameters;\n    const allParamsValid = !_.some(params, ({ validationMsg }) => validationMsg !== null);\n    return allParamsValid;\n  };\n\n  allRequiredFieldsFilled = () => {\n    if (this.state.newStorageClass.name.trim().length === 0) {\n      return false;\n    }\n\n    const { type: storageType, parameters: userEnteredParams } = this.state.newStorageClass;\n\n    if (storageType === null) {\n      return false;\n    }\n\n    const allParamsForType = this.storageTypes[storageType].parameters;\n\n    const requiredKeys = _.keys(allParamsForType).filter((key) => this.paramIsRequired(key));\n    const allReqdFieldsEntered = _.every(requiredKeys, (key) => {\n      const value = _.get(userEnteredParams, [key, 'value']);\n      return !_.isEmpty(value);\n    });\n\n    return allReqdFieldsEntered;\n  };\n\n  paramIsRequired = (paramKey, params = this.state.newStorageClass.parameters) => {\n    const requiredParam = _.get(\n      this.storageTypes[this.state.newStorageClass.type],\n      ['parameters', paramKey, 'required'],\n      null,\n    );\n    let isRequired = false;\n    if (requiredParam) {\n      isRequired = _.isFunction(requiredParam) ? requiredParam(params) : requiredParam;\n    }\n\n    return isRequired;\n  };\n\n  getProvisionerElements = () => {\n    const parameters = this.storageTypes[this.state.newStorageClass.type].parameters;\n\n    if (_.isEmpty(parameters)) {\n      return null;\n    }\n\n    const dynamicContent = _.map(parameters, (parameter, key) => {\n      const paramId = `storage-class-provisioner-${_.kebabCase(_.get(parameter, 'name', key))}`;\n      const validationMsg = _.get(parameter, 'validationMsg', null);\n      const isCheckbox = parameter.type === 'checkbox';\n      const selectedKey = ['newStorageClass', 'parameters', key, 'value'];\n\n      if (parameter.visible && !parameter.visible(this.state.newStorageClass.parameters)) {\n        return null;\n      }\n\n      const children = parameter.values ? (\n        <>\n          <label\n            className={classNames('control-label', { 'co-required': this.paramIsRequired(key) })}\n            htmlFor={paramId}\n          >\n            {_.get(parameter, 'name', key)}\n          </label>\n          <Dropdown\n            title={parameter.hintText}\n            items={parameter.values}\n            dropDownClassName=\"dropdown--full-width\"\n            selectedKey={_.get(this.state, selectedKey)}\n            onChange={(event) => this.setParameterHandler(key, event, false)}\n            id={paramId}\n          />\n          <span className=\"help-block\">{validationMsg ? validationMsg : null}</span>\n        </>\n      ) : (\n        <>\n          {isCheckbox ? (\n            <>\n              <div className=\"checkbox\">\n                <label>\n                  <input\n                    type=\"checkbox\"\n                    className=\"create-storage-class-form__checkbox\"\n                    onChange={(event) => this.setParameterHandler(key, event, isCheckbox)}\n                    checked={_.get(this.state, selectedKey, false)}\n                    id={`provisioner-settings-${key}-checkbox`}\n                  />\n                  {_.get(parameter, 'name', key)}\n                </label>\n              </div>\n            </>\n          ) : (\n            <>\n              <label\n                className={classNames('control-label', {\n                  'co-required': this.paramIsRequired(key),\n                })}\n                htmlFor={paramId}\n              >\n                {_.get(parameter, 'name', key)}\n              </label>\n              <input\n                type=\"text\"\n                className=\"pf-c-form-control\"\n                value={_.get(this.state, selectedKey, '')}\n                onChange={(event) => this.setParameterHandler(key, event, isCheckbox)}\n                id={paramId}\n              />\n            </>\n          )}\n          <span className=\"help-block\">{validationMsg ? validationMsg : parameter.hintText}</span>\n        </>\n      );\n\n      return (\n        <div\n          key={key}\n          className={classNames('form-group', {\n            'has-error': _.get(this.state.newStorageClass.parameters, `${key}.validationMsg`, null),\n          })}\n        >\n          {children}\n        </div>\n      );\n    });\n\n    return (\n      <>\n        {dynamicContent}\n\n        <div className=\"form-group\">\n          <label>Additional Parameters</label>\n          <p>\n            Specific fields for the selected provisioner. &nbsp;\n            <ExternalLink\n              href={this.storageTypes[this.state.newStorageClass.type].documentationLink}\n              text=\"What should I enter here?\"\n            />\n          </p>\n          <NameValueEditorComponent\n            nameValuePairs={this.state.customParams}\n            nameString=\"Parameter\"\n            valueString=\"Value\"\n            addString=\"Add Parameter\"\n            updateParentData={this.updateCustomParams}\n          />\n        </div>\n      </>\n    );\n  };\n\n  autocompleteFilter = (text, item) => fuzzy(text, item);\n\n  render() {\n    const { newStorageClass, fieldErrors } = this.state;\n    const reclaimPolicyKey =\n      newStorageClass.reclaim === null ? this.reclaimPolicies.Delete : newStorageClass.reclaim;\n\n    return (\n      <div className=\"co-m-pane__body co-m-pane__form\">\n        <h1 className=\"co-m-pane__heading co-m-pane__heading--baseline\">\n          <div className=\"co-m-pane__name\">Create Storage Class</div>\n          <div className=\"co-m-pane__heading-link\">\n            <Link to=\"/k8s/cluster/storageclasses/~new\" id=\"yaml-link\" replace>\n              Edit YAML\n            </Link>\n          </div>\n        </h1>\n        <form data-test-id=\"storage-class-form\">\n          <div className={classNames('form-group', { 'has-error': fieldErrors.nameValidationMsg })}>\n            <label className=\"control-label co-required\" htmlFor=\"storage-class-name\">\n              Name\n            </label>\n            <input\n              type=\"text\"\n              className=\"pf-c-form-control\"\n              placeholder={newStorageClass.name}\n              id=\"storage-class-name\"\n              onChange={(event) => this.setStorageHandler('name', event.target.value)}\n              value={_.get(newStorageClass, 'name', '')}\n            />\n            <span className=\"help-block\">\n              {fieldErrors.nameValidationMsg ? fieldErrors.nameValidationMsg : null}\n            </span>\n          </div>\n\n          <div className=\"form-group\">\n            <label htmlFor=\"storage-class-description\">Description</label>\n            <input\n              type=\"text\"\n              className=\"pf-c-form-control\"\n              id=\"storage-class-description\"\n              onChange={(event) => this.setStorageHandler('description', event.target.value)}\n              value={_.get(newStorageClass, 'description', '')}\n            />\n          </div>\n\n          <div className=\"form-group\">\n            <label className=\"co-required\" htmlFor=\"storage-class-reclaim-policy\">\n              Reclaim Policy\n            </label>\n            <Dropdown\n              title=\"Select Reclaim Policy\"\n              items={this.reclaimPolicies}\n              dropDownClassName=\"dropdown--full-width\"\n              selectedKey={reclaimPolicyKey}\n              onChange={(event) => this.setStorageHandler('reclaim', event)}\n              id=\"storage-class-reclaim-policy\"\n            />\n            <span className=\"help-block\">\n              Determines what happens to persistent volumes when the associated persistent volume\n              claim is deleted. Defaults to &lsquo;Delete&rsquo;\n            </span>\n          </div>\n\n          <div className=\"form-group\">\n            <label className=\"co-required\" htmlFor=\"storage-class-provisioner\">\n              Provisioner\n            </label>\n            <Dropdown\n              title=\"Select Provisioner\"\n              autocompleteFilter={this.autocompleteFilter}\n              autocompletePlaceholder={'Select Provisioner'}\n              items={_.mapValues(this.storageTypes, 'provisioner')}\n              dropDownClassName=\"dropdown--full-width\"\n              menuClassName=\"dropdown-menu--text-wrap\"\n              selectedKey={_.get(this.state, 'newStorageClass.type')}\n              onChange={(event) => this.setStorageHandler('type', event)}\n              id=\"storage-class-provisioner\"\n            />\n            <span className=\"help-block\">\n              Determines what volume plugin is used for provisioning persistent volumes.\n            </span>\n          </div>\n\n          <div className=\"co-form-subsection\">\n            {newStorageClass.type !== null ? this.getProvisionerElements() : null}\n          </div>\n\n          <ButtonBar\n            errorMessage={this.state.error ? this.state.error.message : ''}\n            inProgress={this.state.loading}\n          >\n            <ActionGroup className=\"pf-c-form\">\n              <Button\n                id=\"save-changes\"\n                isDisabled={!this.state.validationSuccessful}\n                onClick={this.createStorageClass}\n                type=\"submit\"\n                variant=\"primary\"\n              >\n                Create\n              </Button>\n              <Button\n                id=\"cancel\"\n                onClick={() => history.push('/k8s/cluster/storageclasses')}\n                type=\"button\"\n                variant=\"secondary\"\n              >\n                Cancel\n              </Button>\n            </ActionGroup>\n          </ButtonBar>\n        </form>\n      </div>\n    );\n  }\n}\n\nconst mapStateToProps = ({ k8s }, { onClose }) => ({\n  k8s,\n  onClose,\n});\n\nconst mapDispatchToProps = () => ({\n  stopK8sWatch: k8sActions.stopK8sWatch,\n  watchK8sList: k8sActions.watchK8sList,\n});\n\nexport type StorageClassFormProps = {\n  onClose: () => void;\n  watchK8sList: (id: string, query: object, kind: object) => void;\n  stopK8sWatch: (id: string) => void;\n  k8s: any;\n  resources?: {\n    [key: string]: FirehoseResult;\n  };\n};\n\nexport type StorageClassData = {\n  name: string;\n  type: string;\n  description: string;\n  parameters: any;\n  reclaim: string;\n};\n\nexport type StorageClass = {\n  metadata: object;\n  provisioner: string;\n  parameters: object;\n  reclaimPolicy?: string;\n  volumeBindingMode?: string;\n};\n\nexport type StorageClassFormState = {\n  newStorageClass: StorageClassData;\n  customParams: string[][];\n  validationSuccessful: boolean;\n  loading: boolean;\n  error: any;\n  fieldErrors: { [k: string]: any };\n};\n\nexport type Resources = {\n  loaded: boolean;\n  data: any[];\n  loadError: string;\n};\n\nexport const ConnectedStorageClassForm = connect(\n  mapStateToProps,\n  mapDispatchToProps,\n)(StorageClassForm_);\n\nexport const StorageClassForm = (props) => {\n  const resources = [\n    { kind: StorageClassModel.kind, isList: true, prop: 'sc' },\n    { kind: referenceForModel(CSIDriverModel), isList: true, prop: 'csi' },\n  ];\n  return (\n    <Firehose resources={resources}>\n      <ConnectedStorageClassForm {...props} />\n    </Firehose>\n  );\n};\n\nConnectedStorageClassForm.displayName = 'StorageClassForm';\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA2BA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAMA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAMA;AAQA;AAIA;AAEA;AACA;AACA;AAOA;AAMA;AAEA;AACA;AAKA;AASA;AAIA;AAIA;AACA;AAKA;AAEA;AAEA;AAEA;AACA;AACA;;AAEA;AAKA;AAUA;AAEA;AAr3BA;AACA;AACA;AAghBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AA4BA;AACA;AACA;AAgTA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAKA;AACA;AACA;AAGA;AAQA;AAKA;AACA;AACA;AASA;AACA;AAGA;AAQA;AAMA;AACA;AAGA;AAWA;AAKA;AAIA;AAIA;AACA;AASA;AAaA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AA2CA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;;;;A","sourceRoot":""}