{"version":3,"file":"ceph-storage-inventory-card-72a2ecb5b943bc85967b.js","sources":["webpack:///./packages/ceph-storage-plugin/src/components/dashboard-page/storage-dashboard/inventory-card.tsx","webpack:///./packages/ceph-storage-plugin/src/selectors/index.ts"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport DashboardCard from '@console/shared/src/components/dashboard/dashboard-card/DashboardCard';\nimport DashboardCardBody from '@console/shared/src/components/dashboard/dashboard-card/DashboardCardBody';\nimport DashboardCardHeader from '@console/shared/src/components/dashboard/dashboard-card/DashboardCardHeader';\nimport DashboardCardTitle from '@console/shared/src/components/dashboard/dashboard-card/DashboardCardTitle';\nimport {\n  DashboardItemProps,\n  withDashboardResources,\n} from '@console/internal/components/dashboard/with-dashboard-resources';\nimport { FirehoseResource } from '@console/internal/components/utils';\nimport {\n  getNodeStatusGroups,\n  getPVCStatusGroups,\n  getPVStatusGroups,\n} from '@console/shared/src/components/dashboard/inventory-card/utils';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport {\n  NodeModel,\n  PersistentVolumeClaimModel,\n  PersistentVolumeModel,\n  StorageClassModel,\n} from '@console/internal/models';\nimport { ResourceInventoryItem } from '@console/shared/src/components/dashboard/inventory-card/InventoryItem';\nimport {\n  getCephNodes,\n  getCephPVs,\n  getCephPVCs,\n  getCephSC,\n  cephStorageLabel,\n} from '../../../selectors';\n\nconst k8sResources: FirehoseResource[] = [\n  {\n    isList: true,\n    kind: PersistentVolumeModel.kind,\n    prop: 'pvs',\n  },\n  {\n    isList: true,\n    kind: NodeModel.kind,\n    prop: 'nodes',\n  },\n  {\n    isList: true,\n    kind: PersistentVolumeClaimModel.kind,\n    prop: 'pvcs',\n  },\n  {\n    isList: true,\n    kind: StorageClassModel.kind,\n    prop: 'sc',\n  },\n];\n\nconst InventoryCard: React.FC<DashboardItemProps> = ({\n  watchK8sResource,\n  stopWatchK8sResource,\n  resources,\n}) => {\n  React.useEffect(() => {\n    k8sResources.forEach((r) => watchK8sResource(r));\n    return () => {\n      k8sResources.forEach((r) => stopWatchK8sResource(r));\n    };\n  }, [watchK8sResource, stopWatchK8sResource]);\n\n  const nodesLoaded = _.get(resources.nodes, 'loaded');\n  const nodesLoadError = _.get(resources.nodes, 'loadError');\n  const nodesData = _.get(resources.nodes, 'data', []) as K8sResourceKind[];\n\n  const pvcsLoaded = _.get(resources.pvcs, 'loaded');\n  const pvcsLoadError = _.get(resources.pvcs, 'loadError');\n  const pvcsData = _.get(resources.pvcs, 'data', []) as K8sResourceKind[];\n\n  const pvsLoaded = _.get(resources.pvs, 'loaded');\n  const pvsLoadError = _.get(resources.pvs, 'loadError');\n  const pvsData = _.get(resources.pvs, 'data', []) as K8sResourceKind[];\n\n  const scData = _.get(resources.sc, 'data', []) as K8sResourceKind[];\n  const filteredCephSC = getCephSC(scData);\n  const filteredSCNames = filteredCephSC.map((sc) => _.get(sc, 'metadata.name'));\n  const ocsNodesHref = `/search?kind=${NodeModel.kind}&q=${cephStorageLabel}`;\n\n  return (\n    <DashboardCard>\n      <DashboardCardHeader>\n        <DashboardCardTitle>Inventory</DashboardCardTitle>\n      </DashboardCardHeader>\n      <DashboardCardBody>\n        <ResourceInventoryItem\n          isLoading={!nodesLoaded}\n          error={!!nodesLoadError}\n          kind={NodeModel}\n          resources={getCephNodes(nodesData)}\n          mapper={getNodeStatusGroups}\n          basePath={ocsNodesHref}\n        />\n        <ResourceInventoryItem\n          isLoading={!pvcsLoaded}\n          error={!!pvcsLoadError}\n          kind={PersistentVolumeClaimModel}\n          useAbbr\n          resources={getCephPVCs(filteredSCNames, pvcsData, pvsData)}\n          mapper={getPVCStatusGroups}\n          showLink={false}\n        />\n        <ResourceInventoryItem\n          isLoading={!pvsLoaded}\n          error={!!pvsLoadError}\n          kind={PersistentVolumeModel}\n          useAbbr\n          resources={getCephPVs(pvsData)}\n          mapper={getPVStatusGroups}\n          showLink={false}\n        />\n      </DashboardCardBody>\n    </DashboardCard>\n  );\n};\n\nexport default withDashboardResources(InventoryCard);\n","import * as _ from 'lodash';\nimport { Alert } from '@console/internal/components/monitoring';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { FirehoseResult, convertToBaseValue } from '@console/internal/components/utils';\nimport { cephStorageProvisioners } from '@console/shared/src/utils';\nimport { OCS_OPERATOR } from '../constants';\n\nexport const cephStorageLabel = 'cluster.ocs.openshift.io/openshift-storage';\n\nconst enum status {\n  BOUND = 'Bound',\n  AVAILABLE = 'Available',\n}\nexport const filterCephAlerts = (alerts: Alert[]): Alert[] =>\n  alerts.filter((alert) => _.get(alert, 'annotations.storage_type') === 'ceph');\n\nexport const getCephPVs = (pvsData: K8sResourceKind[] = []): K8sResourceKind[] =>\n  pvsData.filter((pv) => {\n    return cephStorageProvisioners.some((provisioner: string) =>\n      _.get(pv, 'metadata.annotations[\"pv.kubernetes.io/provisioned-by\"]', '').includes(\n        provisioner,\n      ),\n    );\n  });\n\nconst getPVStorageClass = (pv: K8sResourceKind) => _.get(pv, 'spec.storageClassName');\nconst getStorageClassName = (pvc: K8sResourceKind) =>\n  _.get(pvc, ['metadata', 'annotations', 'volume.beta.kubernetes.io/storage-class']) ||\n  _.get(pvc, 'spec.storageClassName');\nconst isBound = (pvc: K8sResourceKind) => pvc.status.phase === status.BOUND;\n\nexport const getCephPVCs = (\n  cephSCNames: string[] = [],\n  pvcsData: K8sResourceKind[] = [],\n  pvsData: K8sResourceKind[] = [],\n): K8sResourceKind[] => {\n  const cephPVs = getCephPVs(pvsData);\n  const cephSCNameSet = new Set<string>([...cephSCNames, ...cephPVs.map(getPVStorageClass)]);\n  const cephBoundPVCUIDSet = new Set<string>(_.map(cephPVs, 'spec.claimRef.uid'));\n  // If the PVC is bound use claim uid(links PVC to PV) else storage class to verify it's provisioned by ceph.\n  return pvcsData.filter((pvc: K8sResourceKind) =>\n    isBound(pvc)\n      ? cephBoundPVCUIDSet.has(pvc.metadata.uid)\n      : cephSCNameSet.has(getStorageClassName(pvc)),\n  );\n};\n\nexport const getCephNodes = (nodesData: K8sResourceKind[] = []): K8sResourceKind[] =>\n  nodesData.filter((node) => _.keys(_.get(node, 'metadata.labels')).includes(cephStorageLabel));\n\nexport const getCephSC = (scData: K8sResourceKind[]): K8sResourceKind[] =>\n  scData.filter((sc) => {\n    return cephStorageProvisioners.some((provisioner: string) =>\n      _.get(sc, 'provisioner', '').includes(provisioner),\n    );\n  });\n\nexport const getOCSVersion = (items: FirehoseResult): string => {\n  const itemsData: K8sResourceKind[] = _.get(items, 'data');\n  const operator: K8sResourceKind = _.find(\n    itemsData,\n    (item) => _.get(item, 'spec.name') === OCS_OPERATOR,\n  );\n  return _.get(operator, 'status.installedCSV');\n};\n\nexport const calcPVsCapacity = (pvs: K8sResourceKind[]): number =>\n  pvs.reduce((sum, pv) => {\n    const storage = Number(convertToBaseValue(pv.spec.capacity.storage));\n    return sum + storage;\n  }, 0);\n\nexport const getSCAvailablePVs = (pvsData: K8sResourceKind[], sc: string): K8sResourceKind[] =>\n  pvsData.filter((pv) => getPVStorageClass(pv) === sc && pv.status.phase === status.AVAILABLE);\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAMA;AAMA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAQA;AASA;AAYA;AAEA;;;;;;;;;;;;;ACzHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAKA;AAEA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;AAEA;AAGA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAEA;;;;;A","sourceRoot":""}