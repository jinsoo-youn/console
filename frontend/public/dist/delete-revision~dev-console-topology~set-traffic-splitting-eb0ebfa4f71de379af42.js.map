{"version":3,"file":"delete-revision~dev-console-topology~set-traffic-splitting-eb0ebfa4f71de379af42.js","sources":["webpack:///./packages/dev-console/src/actions/add-resources.tsx","webpack:///./packages/dev-console/src/components/import/render-utils.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/status/TaskStatusTooltip.scss?a429","webpack:///./packages/dev-console/src/components/pipelineruns/status/TaskStatusTooltip.tsx","webpack:///./packages/dev-console/src/components/svg/SvgBoxedText.tsx","webpack:///./packages/dev-console/src/components/svg/SvgCircledIcon.tsx","webpack:///./packages/dev-console/src/components/svg/SvgDropShadowFilter.tsx","webpack:///./packages/dev-console/src/components/svg/SvgResourceIcon.scss?350b","webpack:///./packages/dev-console/src/components/svg/SvgResourceIcon.tsx","webpack:///./packages/dev-console/src/components/topology/actions/graphActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/groupActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/nodeActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/regroupActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/workloadActions.ts","webpack:///./packages/dev-console/src/components/topology/components/AbstractSBRComponentFactory.ts","webpack:///./packages/dev-console/src/components/topology/components/ContextMenu.scss?29d3","webpack:///./packages/dev-console/src/components/topology/components/GraphComponent.scss?c6e3","webpack:///./packages/dev-console/src/components/topology/components/GraphComponent.tsx","webpack:///./packages/dev-console/src/components/topology/components/NodeShadows.tsx","webpack:///./packages/dev-console/src/components/topology/components/RegroupHint.scss?ed6e","webpack:///./packages/dev-console/src/components/topology/components/RegroupHint.tsx","webpack:///./packages/dev-console/src/components/topology/components/componentFactory.ts","webpack:///./packages/dev-console/src/components/topology/components/componentUtils.ts","webpack:///./packages/dev-console/src/components/topology/components/const.ts","webpack:///./packages/dev-console/src/components/topology/components/createConnection.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/AggregateEdge.scss?1c09","webpack:///./packages/dev-console/src/components/topology/components/edges/AggregateEdge.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/BaseEdge.scss?5801","webpack:///./packages/dev-console/src/components/topology/components/edges/BaseEdge.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/ConnectsTo.scss?1292","webpack:///./packages/dev-console/src/components/topology/components/edges/ConnectsTo.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/CreateConnector.scss?c25f","webpack:///./packages/dev-console/src/components/topology/components/edges/CreateConnector.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/ServiceBinding.scss?9b61","webpack:///./packages/dev-console/src/components/topology/components/edges/ServiceBinding.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/TrafficConnector.scss?63b6","webpack:///./packages/dev-console/src/components/topology/components/edges/TrafficConnector.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/index.ts","webpack:///./packages/dev-console/src/components/topology/components/groups/Application.scss?a31d","webpack:///./packages/dev-console/src/components/topology/components/groups/Application.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/ApplicationGroup.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/ApplicationNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/GroupNode.scss?0a5e","webpack:///./packages/dev-console/src/components/topology/components/groups/GroupNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/ResourceKindsInfo.scss?de36","webpack:///./packages/dev-console/src/components/topology/components/groups/ResourceKindsInfo.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/index.ts","webpack:///./packages/dev-console/src/components/topology/components/index.ts","webpack:///./packages/dev-console/src/components/topology/components/moveNodeToGroup.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodeContextMenu.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/BaseNode.scss?af32","webpack:///./packages/dev-console/src/components/topology/components/nodes/BaseNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/CheIcon.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/Decorator.scss?ede8","webpack:///./packages/dev-console/src/components/topology/components/nodes/Decorator.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/PodSet.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/WorkloadNode.scss?4778","webpack:///./packages/dev-console/src/components/topology/components/nodes/WorkloadNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/BuildDecorator.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/PipelineBuildDecoratorTooltip.scss?0c26","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/PipelineBuildDecoratorTooltip.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/build-decorator-utils.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/index.ts","webpack:///./packages/dev-console/src/components/topology/components/removeConnection.tsx","webpack:///./packages/dev-console/src/components/topology/components/withEditReviewAccess.tsx","webpack:///./packages/dev-console/src/components/topology/data-transforms/data-transformer.ts","webpack:///./packages/dev-console/src/components/topology/data-transforms/index.ts","webpack:///./packages/dev-console/src/components/topology/data-transforms/topology-model.ts","webpack:///./packages/dev-console/src/components/topology/data-transforms/transform-utils.ts","webpack:///./packages/dev-console/src/components/topology/filters/filter-types.ts","webpack:///./packages/dev-console/src/components/topology/filters/filter-utils.ts","webpack:///./packages/dev-console/src/components/topology/filters/index.ts","webpack:///./packages/dev-console/src/components/topology/filters/useDisplayFilters.ts","webpack:///./packages/dev-console/src/components/topology/filters/useSearchFilter.ts","webpack:///./packages/dev-console/src/components/topology/helm/components/const.ts","webpack:///./packages/dev-console/src/components/topology/helm/helm-data-transformer.ts","webpack:///./packages/dev-console/src/components/topology/helm/helm-topology-model.ts","webpack:///./packages/dev-console/src/components/topology/index.ts","webpack:///./packages/dev-console/src/components/topology/operators/components/const.ts","webpack:///./packages/dev-console/src/components/topology/operators/operators-data-transformer.ts","webpack:///./packages/dev-console/src/components/topology/operators/operators-topology-model.ts","webpack:///./packages/dev-console/src/components/topology/topology-types.ts","webpack:///./packages/dev-console/src/components/topology/topology-utils.ts","webpack:///./packages/knative-plugin/src/topology/const.ts","webpack:///./packages/knative-plugin/src/topology/data-transformer.ts","webpack:///./packages/knative-plugin/src/topology/knative-topology-model.ts","webpack:///./packages/knative-plugin/src/topology/knative-topology-utils.ts","webpack:///./packages/kubevirt-plugin/src/topology/components/const.ts","webpack:///./packages/kubevirt-plugin/src/topology/kubevirt-data-transformer.ts","webpack:///./packages/kubevirt-plugin/src/topology/kubevirt-topology-model.ts","webpack:///./public/components/daemon-set.tsx","webpack:///./public/components/deployment.tsx","webpack:///./public/components/stateful-set.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  GitAltIcon,\n  OsImageIcon,\n  CatalogIcon,\n  CubeIcon,\n  DatabaseIcon,\n} from '@patternfly/react-icons';\nimport { ImportOptions } from '../components/import/import-types';\nimport { KebabAction, createKebabAction } from '../utils/add-resources-menu-utils';\n\nexport const allImportResourceAccess = 'allImportResourceAccess';\nexport const allCatalogImageResourceAccess = 'allCatalogImageResourceAccess';\n\nexport const fromGit = createKebabAction(\n  'From Git',\n  <GitAltIcon />,\n  ImportOptions.GIT,\n  allImportResourceAccess,\n);\n\nexport const containerImage = createKebabAction(\n  'Container Image',\n  <OsImageIcon />,\n  ImportOptions.CONTAINER,\n  allCatalogImageResourceAccess,\n);\n\nexport const fromCatalog = createKebabAction(\n  'From Catalog',\n  <CatalogIcon />,\n  ImportOptions.CATALOG,\n);\n\nexport const fromDockerfile = createKebabAction(\n  'From Dockerfile',\n  <CubeIcon />,\n  ImportOptions.DOCKERFILE,\n  allImportResourceAccess,\n);\n\nexport const fromDatabaseCatalog = createKebabAction(\n  'Database',\n  <DatabaseIcon />,\n  ImportOptions.DATABASE,\n);\n\nexport const addResourceMenu: KebabAction[] = [\n  fromGit,\n  containerImage,\n  fromCatalog,\n  fromDockerfile,\n  fromDatabaseCatalog,\n];\n\nexport const addResourceMenuWithoutCatalog: KebabAction[] = [\n  fromGit,\n  containerImage,\n  fromDockerfile,\n];\n","import * as React from 'react';\nimport { BitbucketIcon, GitAltIcon, GithubIcon, GitlabIcon } from '@patternfly/react-icons';\nimport CheIcon from '../topology/components/nodes/CheIcon';\nimport { detectGitType } from './import-validation-utils';\nimport { GitTypes } from './import-types';\n\nexport const routeDecoratorIcon = (\n  routeURL: string,\n  radius: number,\n  cheEnabled?: boolean,\n): React.ReactElement => {\n  if (cheEnabled && routeURL) {\n    return <CheIcon style={{ fontSize: radius }} />;\n  }\n  switch (detectGitType(routeURL)) {\n    case GitTypes.invalid:\n      // Not a valid url and thus not safe to use\n      return null;\n    case GitTypes.github:\n      return <GithubIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n    case GitTypes.bitbucket:\n      return <BitbucketIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n    case GitTypes.gitlab:\n      return <GitlabIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n    default:\n      return <GitAltIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n  }\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { TaskStatus, runStatus, getRunStatusColor } from '../../../utils/pipeline-augment';\nimport './TaskStatusTooltip.scss';\n\ninterface TaskStatusToolTipProps {\n  taskStatus: TaskStatus;\n}\n\nconst TaskStatusToolTip: React.FC<TaskStatusToolTipProps> = ({ taskStatus }) => {\n  return (\n    <div className=\"odc-task-status-tooltip\">\n      {Object.keys(runStatus).map((status) => {\n        const { message, pftoken } = getRunStatusColor(status);\n        return taskStatus[status] ? (\n          <React.Fragment key={status}>\n            <div\n              className=\"odc-task-status-tooltip__legend\"\n              style={{ background: pftoken.value }}\n            />\n            <div>\n              {status === runStatus.PipelineNotStarted || status === runStatus.FailedToStart\n                ? message\n                : `${taskStatus[status]} ${message}`}\n            </div>\n          </React.Fragment>\n        ) : null;\n      })}\n    </div>\n  );\n};\n\nexport default TaskStatusToolTip;\n","import * as React from 'react';\nimport { useSize, useHover, WithDndDragProps, useCombineRefs, createSvgIdUrl } from '@console/topology';\nimport { truncateMiddle } from '@console/internal/components/utils';\nimport { RESOURCE_NAME_TRUNCATE_LENGTH } from '../../const';\nimport { SvgResourceIcon } from './SvgResourceIcon';\nimport SvgCircledIcon from './SvgCircledIcon';\nimport SvgDropShadowFilter from './SvgDropShadowFilter';\n\nexport interface SvgBoxedTextProps {\n  children?: string;\n  className?: string;\n  paddingX?: number;\n  paddingY?: number;\n  x?: number;\n  y?: number;\n  cornerRadius?: number;\n  kind?: string;\n  typeIconClass?: string;\n  typeIconPadding?: number;\n  truncate?: number;\n  dragRef?: WithDndDragProps['dndDragRef'];\n  // TODO remove with 2.0\n  onMouseEnter?: React.MouseEventHandler<SVGGElement>;\n  onMouseLeave?: React.MouseEventHandler<SVGGElement>;\n}\n\nconst FILTER_ID = 'SvgBoxedTextDropShadowFilterId';\n\n/**\n * Renders a `<text>` component with a `<rect>` box behind.\n */\nconst SvgBoxedText: React.FC<SvgBoxedTextProps> = ({ children, className, paddingX = 0, paddingY = 0, cornerRadius = 4, x = 0, y = 0, kind, typeIconClass, typeIconPadding = 4, onMouseEnter, onMouseLeave, truncate = RESOURCE_NAME_TRUNCATE_LENGTH, dragRef, ...other }) => {\n  const [labelHover, labelHoverRef] = useHover();\n  const [textSize, textRef] = useSize([children, className, labelHover]);\n  const [iconSize, iconRef] = useSize([kind]);\n  const iconSpace = kind && iconSize ? iconSize.width + paddingX : 0;\n  const refs = useCombineRefs(dragRef, typeof truncate === 'number' ? labelHoverRef : undefined);\n  const typedIconWidth = typeIconClass && iconSize ? iconSize.height + typeIconPadding * 2 : 0;\n  const midX = typedIconWidth ? x + typedIconWidth / 2 : x;\n\n  return (\n    <g className={className} ref={refs}>\n      <SvgDropShadowFilter id={FILTER_ID} />\n      {textSize && <rect filter={createSvgIdUrl(FILTER_ID)} x={midX - paddingX - textSize.width / 2 - iconSpace / 2 - (typeIconClass ? 10 : 0)} width={textSize.width + paddingX * 2 + iconSpace + (typeIconClass ? 10 : 0)} y={y - paddingY - textSize.height / 2} height={textSize.height + paddingY * 2} rx={cornerRadius} ry={cornerRadius} />}\n      {textSize && kind && <SvgResourceIcon ref={iconRef} x={midX - textSize.width / 2 - paddingX / 2} y={y} kind={kind} />}\n      {textSize && iconSize && typeIconClass && <SvgCircledIcon x={midX - (textSize.width + iconSpace) / 2 - paddingX} y={y - iconSize.height + paddingY * 1.5} width={iconSize.height + paddingY} height={iconSize.height + paddingY} iconClass={typeIconClass} padding={typeIconPadding} />}\n      <text {...other} ref={textRef} x={midX + iconSpace / 2} y={y} textAnchor=\"middle\" dy=\"0.35em\" onMouseEnter={onMouseEnter} onMouseLeave={onMouseLeave}>\n        {truncate > 0 ? (labelHover ? children : truncateMiddle(children, { length: truncate })) : children}\n      </text>\n    </g>\n  );\n};\n\nexport default SvgBoxedText;\n","import * as React from 'react';\nimport { useSize, createSvgIdUrl } from '@console/topology';\nimport { isIconUrl } from '@console/shared/';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport SvgDropShadowFilter from './SvgDropShadowFilter';\n\ninterface SvgTypedIconProps {\n  className?: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  padding?: number;\n  iconClass: string;\n}\n\nconst FILTER_ID = 'SvgTypedIconDropShadowFilterId';\n\nexport const CircledIcon: React.FC<SvgTypedIconProps> = ({ className, x, y, width, height, iconClass, padding = 4 }, circleRef) => {\n  const [typedIconSize, typedIconRef] = useSize([]);\n\n  let iconWidth = 0;\n  let iconHeight = 0;\n\n  if (typedIconSize) {\n    ({ width: iconWidth, height: iconHeight } = typedIconSize);\n  }\n\n  return (\n    <g className={className}>\n      <SvgDropShadowFilter id={FILTER_ID} />\n      <circle ref={circleRef} filter={createSvgIdUrl(FILTER_ID)} cx={x - iconWidth / 2} cy={y + iconHeight / 2} r={iconWidth / 2 + padding} />\n      <g ref={typedIconRef}>\n        <image x={x - iconWidth} y={y} width={width} height={height} xlinkHref={isIconUrl(iconClass) ? iconClass : getImageForIconClass(iconClass)} filter={createSvgIdUrl(FILTER_ID)} />\n      </g>\n    </g>\n  );\n};\n\nexport default React.forwardRef(CircledIcon);\n","import * as React from 'react';\nimport { SVGDefs } from '@console/topology';\n\nexport interface SvgDropShadowFilterProps {\n  // The unique ID that identifies the filter.\n  // It is also used to uniquely identify the def entry to prevent duplicates.\n  id: string;\n  dx?: number;\n  dy?: number;\n  stdDeviation?: number;\n  floodOpacity?: number;\n  floodColor?: string;\n}\n\nconst SvgDropShadowFilter: React.FC<SvgDropShadowFilterProps> = ({ id, dx = 0, dy = 1, stdDeviation = 2, floodColor = '#030303', floodOpacity = 0.2 }) => {\n  if (window.navigator.userAgent.includes('Edge')) {\n    // feDropShadow is not supported by Edge\n    return (\n      <SVGDefs id={id}>\n        <filter id={id} x={`-${stdDeviation * 12.5}%`} y={`-${stdDeviation * 12.5}%`} width={`${100 + stdDeviation * 25}%`} height={`${100 + stdDeviation * 25}%`}>\n          <feGaussianBlur in=\"SourceAlpha\" stdDeviation={stdDeviation} />\n          <feOffset dx={dx} dy={dy} result=\"offsetblur\" />\n          <feFlood floodColor={floodColor} floodOpacity={floodOpacity} />\n          <feComposite in2=\"offsetblur\" operator=\"in\" />\n          <feMerge>\n            <feMergeNode />\n            <feMergeNode in=\"SourceGraphic\" />\n          </feMerge>\n        </filter>\n      </SVGDefs>\n    );\n  }\n\n  return (\n    <SVGDefs id={id}>\n      <filter id={id} x={`-${stdDeviation * 12.5}%`} y={`-${stdDeviation * 12.5}%`} width={`${100 + stdDeviation * 25}%`} height={`${100 + stdDeviation * 25}%`}>\n        <feDropShadow dx={dx} dy={dy} stdDeviation={stdDeviation} floodColor={floodColor} floodOpacity={floodOpacity} />\n      </filter>\n    </SVGDefs>\n  );\n};\n\nexport default SvgDropShadowFilter;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport cx from 'classnames';\nimport { get } from 'lodash';\nimport { useSize } from '@console/topology';\nimport { modelFor, kindToAbbr } from '@console/internal/module/k8s';\nimport './SvgResourceIcon.scss';\n\ninterface ResourceIconProps {\n  x: number;\n  y: number;\n  kind: string;\n  leftJustified?: boolean;\n}\n\nfunction getKindStringAndAbbreviation(kind: string) {\n  const kindObj = modelFor(kind);\n  const kindStr = get(kindObj, 'kind', kind);\n  const kindColor = get(kindObj, 'color', undefined);\n  const kindAbbr = (kindObj && kindObj.abbr) || kindToAbbr(kindStr);\n  return { kindStr, kindAbbr, kindColor };\n}\n\nconst ForwardSvgResourceIcon: React.FC<ResourceIconProps> = ({ kind, x, y, leftJustified }, iconRef) => {\n  const { kindAbbr, kindStr, kindColor } = getKindStringAndAbbreviation(kind);\n  const [textSize, textRef] = useSize([]);\n\n  let rect = null;\n  let paddingX = 0;\n  let paddingY = 0;\n  let width = 0;\n  let height = 0;\n\n  if (textSize) {\n    ({ height, width } = textSize);\n    paddingX = height / 2;\n    paddingY = height / 14;\n    height += paddingY * 2;\n    rect = <rect fill={kindColor} ref={iconRef} x={x - (leftJustified ? 0 : paddingX + width / 2)} width={textSize.width + paddingX * 2} y={y - (leftJustified ? 0 : paddingY + textSize.height / 2)} height={height} rx={height / 2} ry={height / 2} />;\n  }\n\n  return (\n    <g\n      className={cx('odc-resource-icon', {\n        [`odc-resource-icon-${kindStr.toLowerCase()}`]: !kindColor,\n      })}\n    >\n      {rect}\n      <title>{kindStr}</title>\n      <text ref={textRef} x={x + (leftJustified ? paddingX + width / 2 : 0)} y={y + (leftJustified ? (paddingY + height) / 2 : 0)} textAnchor=\"middle\" dy=\"0.35em\">\n        {kindAbbr}\n      </text>\n    </g>\n  );\n};\n\nconst SvgResourceIcon = React.forwardRef(ForwardSvgResourceIcon);\nexport { SvgResourceIcon, getKindStringAndAbbreviation };\n","import * as _ from 'lodash';\nimport { Node } from '@console/topology';\nimport { ServiceModel, addEventSource } from '@console/knative-plugin';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { addResourceMenu, addResourceMenuWithoutCatalog } from '../../../actions/add-resources';\nimport { GraphData } from '../topology-types';\n\nexport const graphActions = (graphData: GraphData, connectorSource?: Node) => {\n  let resourceMenu = connectorSource ? addResourceMenuWithoutCatalog : addResourceMenu;\n  const isKnativeService = connectorSource?.getData()?.data?.kind === referenceForModel(ServiceModel);\n  if (isKnativeService && graphData.eventSourceEnabled) {\n    resourceMenu = [...addResourceMenuWithoutCatalog, addEventSource];\n  }\n  return _.reduce(\n    resourceMenu,\n    (menuItems, menuItem) => {\n      const item = menuItem(null, graphData.namespace, false, connectorSource?.getData()?.resources?.obj, graphData.createResourceAccess);\n      if (item) {\n        menuItems.push(item);\n      }\n      return menuItems;\n    },\n    [],\n  );\n};\n","import * as _ from 'lodash';\nimport { KebabOption } from '@console/internal/components/utils/kebab';\nimport { modelFor, referenceFor, referenceForModel } from '@console/internal/module/k8s';\nimport { Node } from '@console/topology';\nimport { asAccessReview } from '@console/internal/components/utils';\nimport { ServiceModel, addEventSource } from '@console/knative-plugin';\nimport { addResourceMenuWithoutCatalog } from '../../../actions/add-resources';\nimport { TopologyDataMap, TopologyApplicationObject, GraphData } from '../topology-types';\nimport { getTopologyResourceObject } from '../topology-utils';\nimport { deleteResourceModal } from '../../modals';\nimport { cleanUpWorkload } from '../../../utils/application-utils';\n\nexport const getGroupComponents = (groupId: string, topology: TopologyDataMap): TopologyApplicationObject => {\n  return _.values(topology).reduce(\n    (acc, val) => {\n      const dc = getTopologyResourceObject(val);\n      if (_.get(dc, ['metadata', 'labels', 'app.kubernetes.io/part-of']) === groupId) {\n        acc.resources.push(topology[dc.metadata.uid]);\n      }\n      return acc;\n    },\n    { id: groupId, name: groupId, resources: [] },\n  );\n};\n\nconst deleteGroup = (application: TopologyApplicationObject) => {\n  // accessReview needs a resource but group is not a k8s resource,\n  // so currently picking the first resource to do the rbac checks (might change in future)\n  const primaryResource = _.get(application.resources[0], ['resources', 'obj']);\n  const resourceModel = modelFor(primaryResource.kind) ? modelFor(primaryResource.kind) : modelFor(referenceFor(primaryResource));\n  return {\n    label: 'Delete Application',\n    callback: () => {\n      const reqs = [];\n      deleteResourceModal({\n        blocking: true,\n        resourceName: application.name,\n        resourceType: 'Application',\n        onSubmit: () => {\n          application.resources.forEach(workload => {\n            const resource = _.get(workload, ['resources', 'obj']);\n            reqs.push(cleanUpWorkload(resource, workload));\n          });\n          return Promise.all(reqs);\n        },\n      });\n    },\n    accessReview: asAccessReview(resourceModel, primaryResource, 'delete'),\n  };\n};\n\nconst addResourcesMenu = (graphData: GraphData, application: TopologyApplicationObject, connectorSource?: Node) => {\n  const primaryResource = application.resources[0]?.resources?.obj;\n  const connectorSourceObj = connectorSource?.getData()?.resources?.obj || {};\n  const isKnativeService = connectorSource?.getData()?.data?.kind === referenceForModel(ServiceModel);\n  let resourceMenu = addResourceMenuWithoutCatalog;\n  if (isKnativeService && graphData.eventSourceEnabled) {\n    resourceMenu = [...addResourceMenuWithoutCatalog, addEventSource];\n  }\n  return _.reduce(\n    resourceMenu,\n    (menuItems, menuItem) => {\n      const item = menuItem(primaryResource, application.resources[0]?.resources?.obj.metadata.namespace, true, connectorSourceObj, graphData.createResourceAccess);\n      if (item) {\n        menuItems.push(item);\n      }\n      return menuItems;\n    },\n    [],\n  );\n};\n\nexport const groupActions = (graphData: GraphData, application: TopologyApplicationObject, connectorSource?: Node): KebabOption[] => {\n  const addItems = addResourcesMenu(graphData, application, connectorSource);\n  return !connectorSource ? [deleteGroup(application), ...addItems] : addItems;\n};\n","import * as _ from 'lodash';\nimport { Kebab, KebabOption } from '@console/internal/components/utils';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { TopologyDataObject } from '../topology-types';\nimport { getTopologyResourceObject } from '../topology-utils';\n\nexport const nodeActions = (node: TopologyDataObject): KebabOption[] => {\n  const contextMenuResource = getTopologyResourceObject(node);\n  if (!contextMenuResource) {\n    return null;\n  }\n  const resourceKind = modelFor(referenceFor(contextMenuResource));\n  const menuActions = [...Kebab.getExtensionsActionsForKind(resourceKind), ...Kebab.factory.common];\n\n  return _.map(menuActions, a => a(resourceKind, contextMenuResource));\n};\n","import { KebabOption } from '@console/internal/components/utils/kebab';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { Node } from '@console/topology';\nimport { editApplicationModal, groupEditApplicationModal } from '../../modals';\n\nexport const regroupActions = (obj: Node, regroupChildren: boolean = false): KebabOption[] => {\n  if (regroupChildren) {\n    return [\n      {\n        label: 'Edit Application Grouping',\n        callback: () =>\n          groupEditApplicationModal({\n            group: obj,\n            blocking: true,\n          }),\n      },\n    ];\n  }\n  const resource = obj.getData()?.resources?.obj;\n  if (!resource) {\n    return [];\n  }\n  const resourceKind = modelFor(referenceFor(resource));\n  return [\n    {\n      label: 'Edit Application Grouping',\n      callback: () =>\n        editApplicationModal({\n          resourceKind,\n          resource,\n          blocking: true,\n        }),\n    },\n  ];\n};\n","import * as _ from 'lodash';\nimport { KebabAction, KebabOption } from '@console/internal/components/utils';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { menuActions as deploymentConfigMenuActions } from '@console/internal/components/deployment-config';\nimport { menuActions as deploymentMenuActions } from '@console/internal/components/deployment';\nimport { menuActions as statefulSetMenuActions } from '@console/internal/components/stateful-set';\nimport { menuActions as daemonSetMenuActions } from '@console/internal/components/daemon-set';\nimport { ModifyApplication } from '../../../actions/modify-application';\nimport { TopologyDataObject } from '../topology-types';\nimport { getTopologyResourceObject } from '../topology-utils';\n\nexport const workloadActions = (workload: TopologyDataObject, allowRegroup: boolean = true): KebabOption[] => {\n  const contextMenuResource = getTopologyResourceObject(workload);\n  if (!contextMenuResource) {\n    return null;\n  }\n\n  const menuActions: KebabAction[] = [];\n  if (allowRegroup) {\n    menuActions.push(ModifyApplication);\n  }\n  switch (contextMenuResource.kind) {\n    case 'DeploymentConfig':\n      menuActions.push(...deploymentConfigMenuActions);\n      break;\n    case 'Deployment':\n      menuActions.push(...deploymentMenuActions);\n      break;\n    case 'StatefulSet':\n      menuActions.push(...statefulSetMenuActions);\n      break;\n    case 'DaemonSet':\n      menuActions.push(...daemonSetMenuActions);\n      break;\n    default:\n      break;\n  }\n\n  return _.map(menuActions, a => a(modelFor(referenceFor(contextMenuResource)), contextMenuResource));\n};\n","import { createConnectorCallback } from './componentUtils';\nimport { CreateConnector } from './edges';\nimport { ComponentFactory as TopologyComponentFactory, withCreateConnector } from '@console/topology';\n\nabstract class AbstractSBRComponentFactory {\n  protected hasServiceBinding: boolean;\n\n  constructor(serviceBinding: boolean) {\n    this.hasServiceBinding = serviceBinding;\n  }\n\n  set serviceBinding(value: boolean) {\n    this.hasServiceBinding = value;\n  }\n\n  public withAddResourceConnector = () => withCreateConnector(createConnectorCallback(this.hasServiceBinding), CreateConnector);\n\n  abstract getFactory(): TopologyComponentFactory;\n}\n\nexport { AbstractSBRComponentFactory };\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { GraphComponent as BaseGraphComponent, WithContextMenuProps } from '@console/topology';\n\ntype GraphComponentProps = React.ComponentProps<typeof BaseGraphComponent> & {\n  dragEditInProgress?: boolean;\n  hasDropTarget?: boolean;\n  dragCreate?: boolean;\n} & WithContextMenuProps;\n\nconst DRAG_ACTIVE_CLASS = 'odc-m-drag-active';\nconst VALID_DROP_CLASS = 'odc-m-valid-drop-target';\n\nconst GraphComponent: React.FC<GraphComponentProps> = props => {\n  const { dragEditInProgress, hasDropTarget, dragCreate } = props;\n  const graphClasses = classNames('odc-graph', { 'odc-m-drag-create': dragCreate });\n\n  React.useEffect(() => {\n    const addClassList = [];\n    const removeClassList = [];\n\n    dragEditInProgress ? addClassList.push(DRAG_ACTIVE_CLASS) : removeClassList.push(DRAG_ACTIVE_CLASS);\n    hasDropTarget ? addClassList.push(VALID_DROP_CLASS) : removeClassList.push(VALID_DROP_CLASS);\n\n    if (addClassList.length) {\n      addClassList.forEach(className => document.body.classList.add(className));\n    }\n    if (removeClassList.length) {\n      removeClassList.forEach(className => document.body.classList.remove(className));\n    }\n  }, [dragEditInProgress, hasDropTarget]);\n  return (\n    <g className={graphClasses}>\n      <BaseGraphComponent {...props} />\n    </g>\n  );\n};\n\nexport default GraphComponent;\n","import * as React from 'react';\nimport SvgDropShadowFilter from '../../svg/SvgDropShadowFilter';\n\nexport const NODE_SHADOW_FILTER_ID = 'NodeShadowsFilterId';\nexport const NODE_SHADOW_FILTER_ID_HOVER = 'NodeShadowsFilterId--hover';\n\nconst NodeShadows: React.FC = () => (\n  <>\n    <SvgDropShadowFilter id={NODE_SHADOW_FILTER_ID} />\n    <SvgDropShadowFilter id={NODE_SHADOW_FILTER_ID_HOVER} dy={3} stdDeviation={7} floodOpacity={0.24} />\n  </>\n);\n\nexport { NodeShadows };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { InfoCircleIcon } from '@patternfly/react-icons';\nimport { ShortcutTable, Shortcut } from '@console/shared';\n\nimport './RegroupHint.scss';\n\nconst RegroupHint: React.FC = () => (\n  <div className=\"odc-regroup-hint\">\n    <InfoCircleIcon className=\"odc-regroup-hint__icon\" />\n    <span className=\"odc-regroup-hint__text\">\n      <ShortcutTable>\n        <Shortcut shift drag>\n          Edit application grouping\n        </Shortcut>\n      </ShortcutTable>\n    </span>\n  </div>\n);\n\nexport { RegroupHint };\n","import * as React from 'react';\nimport { GraphElement, ModelKind, ComponentFactory as TopologyComponentFactory, withPanZoom, withDragNode, withTargetDrag, withSelection, withDndDrop, withRemoveConnector } from '@console/topology';\nimport { Application } from './groups';\nimport { WorkloadNode } from './nodes';\nimport GraphComponent from './GraphComponent';\nimport { workloadContextMenu, groupContextMenu, graphContextMenu } from './nodeContextMenu';\nimport { NodeComponentProps, graphDropTargetSpec, nodeDragSourceSpec, nodeDropTargetSpec, applicationGroupDropTargetSpec, edgeDragSourceSpec, removeConnectorCallback, MOVE_CONNECTOR_DROP_TYPE, withContextMenu } from './componentUtils';\nimport './ContextMenu.scss';\nimport { TYPE_WORKLOAD, TYPE_CONNECTS_TO, TYPE_APPLICATION_GROUP, TYPE_AGGREGATE_EDGE, TYPE_SERVICE_BINDING, TYPE_TRAFFIC_CONNECTOR } from './const';\nimport { createConnection } from './createConnection';\nimport { withEditReviewAccess } from './withEditReviewAccess';\nimport { AggregateEdge, ConnectsTo, ServiceBinding, TrafficConnector } from './edges';\nimport { AbstractSBRComponentFactory } from './AbstractSBRComponentFactory';\n\nclass ComponentFactory extends AbstractSBRComponentFactory {\n  getFactory = (): TopologyComponentFactory => {\n    return (kind, type): React.ComponentType<{ element: GraphElement }> | undefined => {\n      switch (type) {\n        case TYPE_APPLICATION_GROUP:\n          return withDndDrop(applicationGroupDropTargetSpec)(withSelection(false, true)(withContextMenu(groupContextMenu)(Application)));\n        case TYPE_WORKLOAD:\n          return this.withAddResourceConnector()(withDndDrop<any, any, { droppable?: boolean; hover?: boolean; canDrop?: boolean }, NodeComponentProps>(nodeDropTargetSpec)(withEditReviewAccess('patch')(withDragNode(nodeDragSourceSpec(type))(withSelection(false, true)(withContextMenu(workloadContextMenu)(WorkloadNode))))));\n        case TYPE_CONNECTS_TO:\n          return withTargetDrag(edgeDragSourceSpec(MOVE_CONNECTOR_DROP_TYPE, this.serviceBinding, createConnection))(withRemoveConnector(removeConnectorCallback)(ConnectsTo));\n        case TYPE_SERVICE_BINDING:\n          return withRemoveConnector(removeConnectorCallback)(ServiceBinding);\n        case TYPE_AGGREGATE_EDGE:\n          return AggregateEdge;\n        case TYPE_TRAFFIC_CONNECTOR:\n          return TrafficConnector;\n        default:\n          switch (kind) {\n            case ModelKind.graph:\n              return withDndDrop(graphDropTargetSpec)(withPanZoom()(withSelection(false, true)(withContextMenu(graphContextMenu)(GraphComponent))));\n            default:\n              return undefined;\n          }\n      }\n    };\n  };\n}\n\nexport { ComponentFactory };\n","import * as React from 'react';\nimport { action } from 'mobx';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { errorModal } from '@console/internal/components/modals';\nimport { Modifiers, Edge, GraphElement, isEdge, isNode, Node, Graph, DragSourceSpec, DragObjectWithType, DropTargetSpec, DropTargetMonitor, DragSpecOperationType, CREATE_CONNECTOR_DROP_TYPE, CREATE_CONNECTOR_OPERATION, withContextMenu as withTopologyContextMenu, isGraph, withDndDrop } from '@console/topology';\nimport { createConnection } from './createConnection';\nimport { removeConnection } from './removeConnection';\nimport { moveNodeToGroup } from './moveNodeToGroup';\nimport { graphContextMenu, groupContextMenu } from './nodeContextMenu';\n\nimport './GraphComponent.scss';\n\nconst MOVE_CONNECTOR_DROP_TYPE = '#moveConnector#';\n\nconst NODE_DRAG_TYPE = '#node#';\nconst EDGE_DRAG_TYPE = '#edge#';\n\nconst MOVE_CONNECTOR_OPERATION = 'moveconnector';\nconst REGROUP_OPERATION = 'regroup';\n\ntype GraphComponentProps = {\n  element: Graph;\n};\n\ntype NodeComponentProps = {\n  element: Node;\n};\n\ntype EdgeComponentProps = {\n  element: Edge;\n};\n\n/**\n * type: the drag operation type\n * edit: true if the operation performs an edit, used to dim invalid drop targets\n * canDropOnNode: true if the drag object can be dropped on node, used to highlight valid drop nodes\n */\ntype EditableDragOperationType = {\n  type: string;\n  edit?: boolean;\n  canDropOnNode?: (operationType: string, dragElement: GraphElement, node: Node) => boolean;\n};\n\ntype DragNodeObject = {\n  element: GraphElement;\n  allowRegroup: boolean;\n};\n\nconst canDropEdgeOnNode = (operation: string, edge: Edge, node: Node): boolean => {\n  if (edge.getSource() === node) {\n    return false;\n  }\n\n  if (edge.getTarget() === node) {\n    return true;\n  }\n\n  return !node.getTargetEdges().find(e => e.getSource() === edge.getSource());\n};\n\nconst highlightNode = (monitor: DropTargetMonitor, element: Node): boolean => {\n  const operation = monitor.getOperation() as EditableDragOperationType;\n  if (!monitor.isDragging() || !operation) {\n    return false;\n  }\n\n  if (operation.type === CREATE_CONNECTOR_OPERATION) {\n    return (\n      monitor.getItem() !== element &&\n      !monitor\n        .getItem()\n        .getSourceEdges()\n        .find(e => e.getTarget() === element)\n    );\n  }\n\n  return operation.canDropOnNode && operation.canDropOnNode(operation.type, monitor.getItem(), element);\n};\n\nconst nodeDragSourceSpec = (\n  type: string,\n  allowRegroup: boolean = true,\n  canEdit: boolean = false,\n): DragSourceSpec<\n  DragObjectWithType,\n  DragSpecOperationType<EditableDragOperationType>,\n  Node,\n  {\n    dragging?: boolean;\n    regrouping?: boolean;\n  },\n  NodeComponentProps & { canEdit?: boolean }\n> => ({\n  item: { type: NODE_DRAG_TYPE },\n  operation: (monitor, props) => {\n    return (canEdit || props.canEdit) && allowRegroup\n      ? {\n          [Modifiers.SHIFT]: { type: REGROUP_OPERATION, edit: true },\n        }\n      : undefined;\n  },\n  canCancel: monitor => monitor.getOperation()?.type === REGROUP_OPERATION,\n  begin: (monitor, props): DragNodeObject => {\n    return {\n      element: props.element,\n      allowRegroup: (canEdit || props.canEdit) && allowRegroup,\n    };\n  },\n  end: async (dropResult, monitor, props) => {\n    if (!monitor.isCancelled() && monitor.getOperation()?.type === REGROUP_OPERATION) {\n      if (monitor.didDrop() && dropResult && props && props.element.getParent() !== dropResult) {\n        const controller = props.element.getController();\n        await moveNodeToGroup(props.element, isNode(dropResult) ? dropResult : null);\n\n        // perform the optimistic update in an action so as not to render too soon\n        action(() => {\n          // FIXME: check shouldn't be necessary if we handled the async and backend data refresh correctly\n          if (controller.getNodeById(props.element.getId())) {\n            dropResult.appendChild(props.element);\n          }\n        })();\n      } else {\n        // cancel operation\n        return Promise.reject();\n      }\n    }\n    return undefined;\n  },\n  collect: monitor => ({\n    dragging: monitor.isDragging(),\n    regrouping: monitor.getOperation()?.type === REGROUP_OPERATION,\n  }),\n});\n\nconst nodesEdgeIsDragging = (monitor, props) => {\n  if (!monitor.isDragging()) {\n    return false;\n  }\n  if (monitor.getOperation() === MOVE_CONNECTOR_OPERATION) {\n    return monitor.getItem().getSource() === props.element;\n  }\n  if (monitor.getOperation() === CREATE_CONNECTOR_OPERATION) {\n    return monitor.getItem() === props.element;\n  }\n  return false;\n};\n\nconst nodeDropTargetSpec: DropTargetSpec<GraphElement, any, { canDrop: boolean; dropTarget: boolean; edgeDragging: boolean }, NodeComponentProps> = {\n  accept: [EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: (item, monitor, props) => {\n    if (isEdge(item)) {\n      return canDropEdgeOnNode(monitor.getOperation()?.type, item, props.element);\n    }\n    if (item === props.element) {\n      return false;\n    }\n    return !props.element.getTargetEdges().find(e => e.getSource() === item);\n  },\n  collect: (monitor, props) => ({\n    canDrop: highlightNode(monitor, props.element),\n    dropTarget: monitor.isOver({ shallow: true }),\n    edgeDragging: nodesEdgeIsDragging(monitor, props),\n  }),\n};\n\nconst graphDropTargetSpec: DropTargetSpec<DragNodeObject, any, { dragEditInProgress: boolean }, GraphComponentProps> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  hitTest: () => true,\n  canDrop: (item, monitor, props) => {\n    return (\n      monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) &&\n      ((monitor.getOperation()?.type === REGROUP_OPERATION &&\n        // FIXME: the hasParent check is necessary due to model updates during async actions\n        item.element.hasParent() &&\n        item.element.getParent() !== props.element) ||\n        monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE)\n    );\n  },\n  collect: monitor => {\n    const operation = monitor.getOperation() as EditableDragOperationType;\n    const dragEditInProgress = monitor.isDragging() && (operation?.type === CREATE_CONNECTOR_OPERATION || operation?.edit);\n    const dragCreate = dragEditInProgress && (monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE || monitor.getItemType() === MOVE_CONNECTOR_DROP_TYPE);\n    return {\n      dragEditInProgress,\n      dragCreate,\n      hasDropTarget: dragEditInProgress && monitor.hasDropTarget(),\n    };\n  },\n  dropHint: 'create',\n};\n\nconst applicationGroupDropTargetSpec: DropTargetSpec<any, any, { droppable: boolean; dropTarget: boolean; canDrop: boolean }, any> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: (item, monitor) => monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) && (monitor.getOperation()?.type === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n  collect: monitor => {\n    return {\n      droppable: monitor.isDragging() && monitor.getOperation()?.type === REGROUP_OPERATION,\n      dropTarget: monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }),\n      canDrop: monitor.isDragging() && (monitor.getOperation()?.type === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n      dragRegroupable: monitor.isDragging() && monitor.getItem()?.allowRegroup,\n    };\n  },\n  dropHint: 'create',\n};\n\nconst edgeDragSourceSpec = (type: string, serviceBinding: boolean, callback: (sourceNode: Node, targetNode: Node, replaceTargetNode?: Node, serviceBindingFlag?: boolean) => Promise<K8sResourceKind[] | K8sResourceKind>, failureTitle: string = 'Error moving connection'): DragSourceSpec<DragObjectWithType, DragSpecOperationType<EditableDragOperationType>, Node, { dragging: boolean }, EdgeComponentProps> => ({\n  item: { type: EDGE_DRAG_TYPE },\n  operation: { type: MOVE_CONNECTOR_OPERATION, edit: true, canDropOnNode: canDropEdgeOnNode },\n  begin: (monitor, props) => {\n    props.element.raise();\n    return props.element;\n  },\n  drag: (event, monitor, props) => {\n    props.element.setEndPoint(event.x, event.y);\n  },\n  end: (dropResult, monitor, props) => {\n    props.element.setEndPoint();\n    if (monitor.didDrop() && dropResult && canDropEdgeOnNode(monitor.getOperation()?.type, props.element, dropResult)) {\n      callback(props.element.getSource(), dropResult, props.element.getTarget(), serviceBinding).catch(error => {\n        errorModal({ title: failureTitle, error: error.message, showIcon: true });\n      });\n    }\n  },\n  collect: monitor => ({\n    dragging: monitor.isDragging(),\n  }),\n});\n\nconst noDropTargetSpec: DropTargetSpec<GraphElement, any, {}, { element: GraphElement }> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: () => {\n    return false;\n  },\n};\n\nconst withNoDrop = () => {\n  return withDndDrop<any, any, {}, NodeComponentProps>(noDropTargetSpec);\n};\n\nconst withContextMenu = <E extends GraphElement>(actions: (element: E) => React.ReactElement[]) => {\n  return withTopologyContextMenu(actions, document.getElementById('popper-container'), 'odc-topology-context-menu');\n};\n\nconst createConnectorCallback = (serviceBinding: boolean) => (source: Node, target: Node | Graph): React.ReactElement[] | null => {\n  if (source === target) {\n    return null;\n  }\n\n  if (isGraph(target)) {\n    return graphContextMenu(target, source);\n  }\n  if (target.isGroup()) {\n    return groupContextMenu(target, source);\n  }\n  createConnection(source, target, null, serviceBinding).catch(error => {\n    errorModal({ title: 'Error creating connection', error: error.message });\n  });\n  return null;\n};\n\nconst removeConnectorCallback = (edge: Edge): void => {\n  removeConnection(edge).catch(error => {\n    errorModal({ title: 'Error removing connection', error: error.message });\n  });\n  return null;\n};\n\nexport { GraphComponentProps, NodeComponentProps, EdgeComponentProps, EditableDragOperationType, DragNodeObject, nodesEdgeIsDragging, nodeDragSourceSpec, nodeDropTargetSpec, graphDropTargetSpec, applicationGroupDropTargetSpec, edgeDragSourceSpec, noDropTargetSpec, createConnectorCallback, removeConnectorCallback, REGROUP_OPERATION, MOVE_CONNECTOR_DROP_TYPE, NODE_DRAG_TYPE, EDGE_DRAG_TYPE, withNoDrop, withContextMenu };\n","import { STORAGE_PREFIX } from '@console/shared';\n\nexport const TYPE_WORKLOAD = 'workload';\nexport const TYPE_CONNECTS_TO = 'connects-to';\nexport const TYPE_AGGREGATE_EDGE = 'aggregate-edge';\nexport const TYPE_SERVICE_BINDING = 'service-binding';\nexport const TYPE_APPLICATION_GROUP = 'part-of';\nexport const TYPE_TRAFFIC_CONNECTOR = 'traffic-connector';\nexport const LAST_TOPOLOGY_VIEW_LOCAL_STORAGE_KEY = `${STORAGE_PREFIX}/last-topology-view`;\n\nexport const DEFAULT_NODE_PAD = 20;\nexport const DEFAULT_GROUP_PAD = 40;\n\nexport const NODE_WIDTH = 104;\nexport const NODE_HEIGHT = 104;\nexport const NODE_PADDING = [0, DEFAULT_NODE_PAD];\n\nexport const GROUP_WIDTH = 300;\nexport const GROUP_HEIGHT = 180;\nexport const GROUP_PADDING = [DEFAULT_GROUP_PAD];\n","import { Node } from '@console/topology';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { createTopologyResourceConnection } from '../topology-utils';\n\nexport const createConnection = (sourceNode: Node, targetNode: Node, replaceTargetNode: Node = null, serviceBindingFlag: boolean = false): Promise<K8sResourceKind[] | K8sResourceKind> => {\n  return createTopologyResourceConnection(sourceNode.getData(), targetNode.getData(), replaceTargetNode ? replaceTargetNode.getData() : null, serviceBindingFlag);\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { Edge, Layer, useHover, EdgeConnectorArrow, observer } from '@console/topology';\n\nimport './AggregateEdge.scss';\n\ntype AggregateEdgeProps = {\n  element: Edge;\n};\n\nconst ObservedAggregateEdge: React.FC<AggregateEdgeProps> = ({ element }) => {\n  const [hover, hoverRef] = useHover();\n  const startPoint = element.getStartPoint();\n  const endPoint = element.getEndPoint();\n  const { bidirectional } = element.getData();\n\n  return (\n    <Layer id={hover ? 'top' : undefined}>\n      <g\n        ref={hoverRef}\n        data-test-id=\"edge-handler\"\n        className={classNames('odc-base-edge odc-aggregate-edge', {\n          'is-hover': hover,\n        })}\n      >\n        <line x1={startPoint.x} y1={startPoint.y} x2={endPoint.x} y2={endPoint.y} strokeWidth={10} stroke=\"transparent\" />\n        <line className=\"odc-base-edge__link\" x1={startPoint.x} y1={startPoint.y} x2={endPoint.x} y2={endPoint.y} />\n        {!bidirectional && (!element.getSource().isCollapsed() || !element.getTarget().isCollapsed()) && <EdgeConnectorArrow edge={element} />}\n      </g>\n    </Layer>\n  );\n};\n\nconst AggregateEdge = observer(ObservedAggregateEdge);\nexport { AggregateEdge };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { referenceFor, modelFor } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport { Layer, Edge, WithRemoveConnectorProps, observer, useHover, useSelection } from '@console/topology';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport './BaseEdge.scss';\n\ntype BaseEdgeProps = {\n  element: Edge;\n  dragging?: boolean;\n  className?: string;\n} & WithRemoveConnectorProps;\n\nconst ObservedBaseEdge: React.FC<BaseEdgeProps> = ({ element, dragging, onShowRemoveConnector, onHideRemoveConnector, children, className }) => {\n  const [hover, hoverRef] = useHover();\n  const [selected, onSelect] = useSelection(false, true);\n  const startPoint = element.getStartPoint();\n  const endPoint = element.getEndPoint();\n  const resourceObj = getTopologyResourceObject(element.getSource().getData());\n  const resourceModel = resourceObj && modelFor(referenceFor(resourceObj));\n\n  const editAccess = useAccessReview({\n    group: resourceModel?.apiGroup,\n    verb: 'patch',\n    resource: resourceModel?.plural,\n    name: resourceObj?.metadata.name,\n    namespace: resourceObj?.metadata.namespace,\n  });\n\n  React.useLayoutEffect(() => {\n    if (editAccess) {\n      if (hover && !dragging) {\n        onShowRemoveConnector && onShowRemoveConnector();\n      } else {\n        onHideRemoveConnector && onHideRemoveConnector();\n      }\n    }\n  }, [hover, dragging, onShowRemoveConnector, onHideRemoveConnector, editAccess]);\n\n  return (\n    <Layer id={dragging || hover ? 'top' : undefined}>\n      <g\n        ref={hoverRef}\n        data-test-id=\"edge-handler\"\n        className={classNames(className, 'odc-base-edge', {\n          'is-dragging': dragging,\n          'is-hover': hover,\n          'is-selected': selected,\n        })}\n        onClick={onSelect}\n      >\n        <line x1={startPoint.x} y1={startPoint.y} x2={endPoint.x} y2={endPoint.y} strokeWidth={10} stroke=\"transparent\" />\n        <line className=\"odc-base-edge__link\" x1={startPoint.x} y1={startPoint.y} x2={endPoint.x} y2={endPoint.y} />\n        {children}\n      </g>\n    </Layer>\n  );\n};\n\nconst BaseEdge = observer(ObservedBaseEdge);\nexport { BaseEdge };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { WithSourceDragProps, WithTargetDragProps, WithRemoveConnectorProps, Edge, observer, EdgeConnectorArrow } from '@console/topology';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { BaseEdge } from './BaseEdge';\nimport './ConnectsTo.scss';\n\ntype ConnectsToProps = {\n  element: Edge;\n  dragging?: boolean;\n} & WithSourceDragProps &\n  WithTargetDragProps &\n  WithRemoveConnectorProps;\n\nconst ObservedConnectsTo: React.FC<ConnectsToProps> = ({ element, targetDragRef, children, ...others }) => {\n  const childEdges = element.getChildren();\n  const sourceData = childEdges?.length > 0 ? (childEdges[0] as Edge).getSource().getData() : element.getSource().getData();\n  const resourceObj = getTopologyResourceObject(sourceData);\n  const resourceModel = modelFor(referenceFor(resourceObj));\n  const editAccess = useAccessReview({\n    group: resourceModel.apiGroup,\n    verb: 'patch',\n    resource: resourceModel.plural,\n    name: resourceObj.metadata.name,\n    namespace: resourceObj.metadata.namespace,\n  });\n  const edgeClasses = classNames('odc-connects-to', { 'odc-m-editable': editAccess });\n\n  return (\n    <BaseEdge className={edgeClasses} element={element} {...others}>\n      <EdgeConnectorArrow dragRef={editAccess ? targetDragRef : undefined} edge={element} />\n      {children}\n    </BaseEdge>\n  );\n};\n\nconst ConnectsTo = observer(ObservedConnectsTo);\nexport { ConnectsTo };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { DefaultCreateConnector, Point } from '@console/topology';\n\nimport './CreateConnector.scss';\n\ntype CreateConnectorProps = {\n  startPoint: Point;\n  endPoint: Point;\n  hints: string[];\n  dragging?: boolean;\n};\n\nconst CreateConnector: React.FC<CreateConnectorProps> = ({ startPoint, endPoint, dragging, hints }) => {\n  const [hover, setHover] = React.useState(false);\n  const unsetHandle = React.useRef<number>();\n\n  React.useEffect(() => {\n    setHover(false);\n    clearTimeout(unsetHandle.current);\n    unsetHandle.current = window.setTimeout(() => {\n      setHover(dragging);\n    }, 2000);\n    return () => {\n      clearTimeout(unsetHandle.current);\n    };\n  }, [endPoint.x, endPoint.y, dragging]);\n\n  const classes = classNames('odc-create-connector', { 'is-dragging': dragging });\n  return <DefaultCreateConnector className={classes} startPoint={startPoint} endPoint={endPoint} dragging={dragging} hints={hints} tipContents={hover && dragging ? 'Add Resources' : null} />;\n};\n\nexport { CreateConnector };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { WithSourceDragProps, WithTargetDragProps, WithRemoveConnectorProps, Edge, observer, EdgeConnectorArrow } from '@console/topology';\nimport { BaseEdge } from './BaseEdge';\nimport './ServiceBinding.scss';\n\ntype ServiceBindingProps = {\n  element: Edge;\n  dragging?: boolean;\n} & WithSourceDragProps &\n  WithTargetDragProps &\n  WithRemoveConnectorProps;\n\nconst ObservedServiceBinding: React.FC<ServiceBindingProps> = ({ element, targetDragRef, children, ...others }) => (\n  <BaseEdge element={element} {...others} className=\"odc-service-binding\">\n    <EdgeConnectorArrow dragRef={targetDragRef} edge={element} />\n    {children}\n  </BaseEdge>\n);\n\nconst ServiceBinding = observer(ObservedServiceBinding);\nexport { ServiceBinding };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Edge, EdgeConnectorArrow } from '@console/topology';\nimport { BaseEdge } from './BaseEdge';\nimport './TrafficConnector.scss';\n\ntype TrafficConnectorProps = {\n  element: Edge;\n};\n\nconst TrafficConnector: React.FC<TrafficConnectorProps> = ({ element }) => (\n  <BaseEdge element={element} className=\"odc-traffic-connector\">\n    <EdgeConnectorArrow edge={element} />\n  </BaseEdge>\n);\n\nexport { TrafficConnector };\n","export * from './BaseEdge';\nexport * from './AggregateEdge';\nexport * from './ConnectsTo';\nexport * from './CreateConnector';\nexport * from './ServiceBinding';\nexport * from './TrafficConnector';\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Node, observer, WithDndDropProps, WithSelectionProps, WithContextMenuProps } from '@console/topology';\nimport { SHOW_GROUPING_HINT_EVENT } from '../../topology-types';\nimport { RegroupHint } from '../RegroupHint';\nimport ApplicationNode from './ApplicationNode';\nimport ApplicationGroup from './ApplicationGroup';\n\nimport './Application.scss';\n\ntype ApplicationProps = {\n  element: Node;\n  droppable?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n  dragRegroupable?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\nconst ObservedApplication: React.FC<ApplicationProps> = ({ element, selected, onSelect, dndDropRef, droppable, canDrop, dropTarget, dragRegroupable, onContextMenu, contextMenuOpen, dragging }) => {\n  const needsHintRef = React.useRef<boolean>(false);\n  React.useEffect(() => {\n    const needsHint = dropTarget && !canDrop && dragRegroupable;\n    if (needsHint !== needsHintRef.current) {\n      needsHintRef.current = needsHint;\n      element.getController().fireEvent(SHOW_GROUPING_HINT_EVENT, element, needsHint ? <RegroupHint /> : null);\n    }\n  }, [dropTarget, canDrop, element, dragRegroupable]);\n\n  if (element.isCollapsed()) {\n    return <ApplicationNode element={element} selected={selected} onSelect={onSelect} dndDropRef={dndDropRef} canDrop={canDrop} dropTarget={dropTarget} onContextMenu={onContextMenu} contextMenuOpen={contextMenuOpen} dragging={dragging} />;\n  }\n\n  return <ApplicationGroup element={element} selected={selected} onSelect={onSelect} dndDropRef={dndDropRef} canDrop={canDrop} dropTarget={dropTarget} droppable={droppable} onContextMenu={onContextMenu} contextMenuOpen={contextMenuOpen} dragging={dragging} />;\n};\n\nconst Application = observer(ObservedApplication);\nexport { Application };\n","import * as React from 'react';\nimport { polygonHull } from 'd3-polygon';\nimport * as _ from 'lodash';\nimport { Layer, Node, PointTuple, NodeShape, NodeStyle, maxPadding, observer, useCombineRefs, useHover, useDragNode, WithDndDropProps, WithSelectionProps, WithContextMenuProps, createSvgIdUrl, hullPath } from '@console/topology';\nimport * as classNames from 'classnames';\nimport { useDisplayFilters, useSearchFilter } from '../../filters';\nimport SvgBoxedText from '../../../svg/SvgBoxedText';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID, NODE_SHADOW_FILTER_ID_HOVER } from '../NodeShadows';\n\ntype ApplicationGroupProps = {\n  element: Node;\n  droppable?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\ntype PointWithSize = [number, number, number];\n\n// Return the point whose Y is the largest value.\n// If multiple points are found, compute the center X between them\n// export for testing only\nexport function computeLabelLocation(points: PointWithSize[]): PointWithSize {\n  let lowPoints: PointWithSize[];\n  const threshold = 5;\n\n  _.forEach(points, p => {\n    const delta = !lowPoints ? Infinity : Math.round(p[1]) - Math.round(lowPoints[0][1]);\n    if (delta > threshold) {\n      lowPoints = [p];\n    } else if (Math.abs(delta) <= threshold) {\n      lowPoints.push(p);\n    }\n  });\n  return [\n    (_.minBy(lowPoints, p => p[0])[0] + _.maxBy(lowPoints, p => p[0])[0]) / 2,\n    lowPoints[0][1],\n    // use the max size value\n    _.maxBy(lowPoints, p => p[2])[2],\n  ];\n}\n\nconst ApplicationGroup: React.FC<ApplicationGroupProps> = ({ element, selected, onSelect, dndDropRef, droppable, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging }) => {\n  const [hover, hoverRef] = useHover();\n  const [labelHover, labelHoverRef] = useHover();\n  const labelLocation = React.useRef<PointWithSize>();\n  const pathRef = React.useRef<string>();\n  const dragNodeRef = useDragNode()[1];\n  const dragLabelRef = useDragNode()[1];\n  const refs = useCombineRefs<SVGPathElement>(hoverRef, dragNodeRef);\n  const [filtered] = useSearchFilter(element.getLabel());\n  const displayFilters = useDisplayFilters();\n  const showLabels = displayFilters.showLabels || hover;\n\n  // cast to number and coerce\n  const padding = maxPadding(element.getStyle<NodeStyle>().padding);\n  const hullPadding = (point: PointWithSize | PointTuple) => (point[2] || 0) + padding;\n\n  if (!droppable || !pathRef.current || !labelLocation.current) {\n    const children = element.getNodes().filter(c => c.isVisible());\n    if (children.length === 0) {\n      return null;\n    }\n    const points: (PointWithSize | PointTuple)[] = [];\n    _.forEach(children, c => {\n      if (c.getNodeShape() === NodeShape.circle) {\n        const bounds = c.getBounds();\n        const { width, height } = bounds;\n        const { x, y } = bounds.getCenter();\n        const radius = Math.max(width, height) / 2;\n        points.push([x, y, radius] as PointWithSize);\n      } else {\n        // add all 4 corners\n        const { width, height, x, y } = c.getBounds();\n        points.push([x, y, 0] as PointWithSize);\n        points.push([x + width, y, 0] as PointWithSize);\n        points.push([x, y + height, 0] as PointWithSize);\n        points.push([x + width, y + height, 0] as PointWithSize);\n      }\n    });\n    const hullPoints: (PointWithSize | PointTuple)[] = points.length > 2 ? polygonHull(points as PointTuple[]) : (points as PointTuple[]);\n    if (!hullPoints) {\n      return null;\n    }\n\n    // change the box only when not dragging\n    pathRef.current = hullPath(hullPoints as PointTuple[], hullPadding);\n\n    // Compute the location of the group label.\n    labelLocation.current = computeLabelLocation(hullPoints as PointWithSize[]);\n  }\n\n  return (\n    <g\n      ref={labelHoverRef}\n      onContextMenu={onContextMenu}\n      onClick={onSelect}\n      className={classNames('odc-application-group', {\n        'is-dragging': dragging,\n        'is-highlight': canDrop,\n        'is-filtered': filtered,\n      })}\n    >\n      <NodeShadows />\n      <Layer id=\"groups\">\n        <g\n          ref={refs}\n          onContextMenu={onContextMenu}\n          onClick={onSelect}\n          className={classNames('odc-application-group', {\n            'is-dragging': dragging,\n            'is-highlight': canDrop,\n            'is-selected': selected,\n            'is-dropTarget': canDrop && dropTarget,\n            'is-filtered': filtered,\n          })}\n        >\n          <path ref={dndDropRef} className=\"odc-application-group__bg\" filter={createSvgIdUrl(hover || labelHover || dragging || contextMenuOpen || dropTarget ? NODE_SHADOW_FILTER_ID_HOVER : NODE_SHADOW_FILTER_ID)} d={pathRef.current} />\n        </g>\n      </Layer>\n      {showLabels && (\n        <SvgBoxedText className=\"odc-application-group__label\" kind=\"application\" x={labelLocation.current[0]} y={labelLocation.current[1] + hullPadding(labelLocation.current) + 24} paddingX={8} paddingY={5} dragRef={dragLabelRef}>\n          {element.getLabel()}\n        </SvgBoxedText>\n      )}\n    </g>\n  );\n};\n\nexport default observer(ApplicationGroup);\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport * as classNames from 'classnames';\nimport { observer, Node, useAnchor, RectAnchor, useCombineRefs, useHover, useDragNode, WithDndDropProps, WithSelectionProps, WithContextMenuProps, createSvgIdUrl } from '@console/topology';\nimport { useSearchFilter } from '../../filters/useSearchFilter';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID, NODE_SHADOW_FILTER_ID_HOVER } from '../NodeShadows';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { GroupNode } from './GroupNode';\nimport { ApplicationModel } from '../../../../models';\n\ntype ApplicationGroupProps = {\n  element: Node;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\nconst ApplicationNode: React.FC<ApplicationGroupProps> = ({ element, selected, onSelect, dndDropRef, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging }) => {\n  useAnchor(React.useCallback((node: Node) => new RectAnchor(node, 1.5), []));\n  const [hover, hoverRef] = useHover();\n  const dragNodeRef = useDragNode()[1];\n  const refs = useCombineRefs<SVGRectElement>(dragNodeRef, hoverRef);\n  const [filtered] = useSearchFilter(element.getLabel());\n  const { width, height } = element.getDimensions();\n\n  const resourcesData = {};\n  _.forEach(element.getData().groupResources, res => {\n    const a = getTopologyResourceObject(res);\n    resourcesData[a.kind] = [...(resourcesData[a.kind] ? resourcesData[a.kind] : []), a];\n  });\n\n  return (\n    <g\n      ref={refs}\n      onContextMenu={onContextMenu}\n      onClick={onSelect}\n      className={classNames('odc-application-group', {\n        'is-highlight': canDrop,\n        'is-dragging': dragging,\n        'is-selected': selected,\n        'is-dropTarget': canDrop && dropTarget,\n        'is-filtered': filtered,\n      })}\n    >\n      <NodeShadows />\n      <rect ref={dndDropRef} filter={createSvgIdUrl(hover || dragging || contextMenuOpen || dropTarget ? NODE_SHADOW_FILTER_ID_HOVER : NODE_SHADOW_FILTER_ID)} className=\"odc-application-group__bg\" x={0} y={0} width={width} height={height} rx=\"5\" ry=\"5\" />\n      <GroupNode element={element} kind={ApplicationModel.kind} groupResources={element.getData().groupResources} />\n    </g>\n  );\n};\n\nexport default observer(ApplicationNode);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { truncateMiddle, shouldTruncate, TruncateOptions } from '@console/internal/components/utils';\nimport { Node, useSize, useHover } from '@console/topology';\nimport { RESOURCE_NAME_TRUNCATE_LENGTH } from '../../../../const';\nimport SvgCircledIcon from '../../../svg/SvgCircledIcon';\nimport { TopologyDataObject } from '../../topology-types';\nimport { SvgResourceIcon } from '../../../svg/SvgResourceIcon';\nimport { ResourceKindsInfo } from './ResourceKindsInfo';\n\nimport './GroupNode.scss';\n\nconst TOP_MARGIN = 20;\nconst LEFT_MARGIN = 20;\nconst TEXT_MARGIN = 10;\n\nconst truncateOptions: TruncateOptions = {\n  length: RESOURCE_NAME_TRUNCATE_LENGTH,\n};\n\ntype GroupNodeProps = {\n  element: Node;\n  kind?: string;\n  emptyValue?: React.ReactNode;\n  groupResources?: TopologyDataObject;\n  children?: React.ReactNode;\n  typeIconClass?: string;\n};\n\nconst GroupNode: React.FC<GroupNodeProps> = ({ element, groupResources, children, kind, emptyValue, typeIconClass }) => {\n  const [textHover, textHoverRef] = useHover();\n  const [iconSize, iconRef] = useSize([kind]);\n  const iconWidth = iconSize ? iconSize.width : 0;\n  const iconHeight = iconSize ? iconSize.height : 0;\n  const title = element.getLabel();\n  const { width, height } = element.getDimensions();\n  return (\n    <>\n      {typeIconClass && <SvgCircledIcon className=\"odc-group-node__type-icon\" x={10} y={-10} width={20} height={20} iconClass={typeIconClass} />}\n      <SvgResourceIcon ref={iconRef} x={LEFT_MARGIN} y={TOP_MARGIN - 2} kind={kind} leftJustified />\n      {title && (\n        <Tooltip content={title} position={TooltipPosition.top} trigger=\"manual\" isVisible={textHover && shouldTruncate(title)}>\n          <text ref={textHoverRef} className=\"odc-group-node__title\" x={LEFT_MARGIN + iconWidth + TEXT_MARGIN} y={TOP_MARGIN + iconHeight} textAnchor=\"start\" dy=\"-0.25em\">\n            {truncateMiddle(title, truncateOptions)}\n          </text>\n        </Tooltip>\n      )}\n      {(children || groupResources || emptyValue) && (\n        <g transform={`translate(${LEFT_MARGIN}, ${TOP_MARGIN + iconHeight})`}>\n          {(groupResources || emptyValue) && <ResourceKindsInfo groupResources={groupResources} emptyValue={emptyValue} width={width - LEFT_MARGIN} height={height - TOP_MARGIN - iconHeight} />}\n          {children}\n        </g>\n      )}\n    </>\n  );\n};\n\nexport { GroupNode };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { modelFor, referenceFor, referenceForModel } from '@console/internal/module/k8s';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { TopologyDataObject } from '../../topology-types';\nimport { ResourceIcon } from '@console/internal/components/utils';\n\nimport './ResourceKindsInfo.scss';\n\ntype ResourceKindsInfoProps = {\n  groupResources: TopologyDataObject;\n  emptyValue?: React.ReactNode;\n  width: number;\n  height: number;\n};\n\nconst ResourceKindsInfo: React.FC<ResourceKindsInfoProps> = ({ groupResources, emptyValue, width, height }) => {\n  const resourcesData = {};\n  _.forEach(groupResources, (res: TopologyDataObject) => {\n    const a = getTopologyResourceObject(res);\n    const kindObj = modelFor(referenceFor(a));\n    const key = kindObj.abbr || a.kind;\n    resourcesData[key] = [...(resourcesData[key] ? resourcesData[key] : []), a];\n  });\n  const resourceTypes = _.keys(resourcesData);\n\n  if (!resourceTypes.length) {\n    return (\n      <foreignObject width={width} height={height}>\n        <div className=\"odc-resource-kinds-info\">{emptyValue}</div>\n      </foreignObject>\n    );\n  }\n\n  return (\n    <foreignObject width={width} height={height}>\n      <div className=\"odc-resource-kinds-info\">\n        <table className=\"odc-resource-kinds-info__table\">\n          <tbody className=\"odc-resource-kinds-info__body\">\n            {resourceTypes.map(key => {\n              const kindObj = modelFor(referenceFor(resourcesData[key][0]));\n              return (\n                <tr key={key} className=\"odc-resource-kinds-info__row\">\n                  <td className=\"odc-resource-kinds-info__count\">{resourcesData[key].length}</td>\n                  <td className=\"odc-resource-kinds-info__resource-icon\">\n                    <ResourceIcon kind={kindObj.crd ? referenceForModel(kindObj) : kindObj.kind} />\n                  </td>\n                  <td className=\"odc-resource-kinds-info__kind\">{resourcesData[key].length > 1 ? kindObj.labelPlural : kindObj.label}</td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </foreignObject>\n  );\n};\n\nexport { ResourceKindsInfo };\n","export * from './GroupNode';\nexport * from './Application';\nexport * from './ResourceKindsInfo';\n","export * from './const';\nexport * from './AbstractSBRComponentFactory';\nexport * from './componentUtils';\nexport * from './componentFactory';\nexport * from './NodeShadows';\nexport * from './nodeContextMenu';\nexport * from './withEditReviewAccess';\nexport * from './moveNodeToGroup';\nexport * from './createConnection';\nexport * from './removeConnection';\nexport * from './nodes';\nexport * from './edges';\nexport * from './groups';\n","import * as React from 'react';\nimport { confirmModal, errorModal } from '@console/internal/components/modals';\nimport { Node } from '@console/topology';\nimport { updateTopologyResourceApplication } from '../topology-utils';\n\nexport const moveNodeToGroup = (node: Node, targetGroup: Node): Promise<void> => {\n  const sourceGroup = node.getParent() !== node.getGraph() ? (node.getParent() as Node) : undefined;\n  if (sourceGroup === targetGroup) {\n    return Promise.reject();\n  }\n\n  if (sourceGroup) {\n    const title = targetGroup ? 'Move Component Node' : 'Remove Component Node from Application';\n    const message = (\n      <>\n        Are you sure you want to {targetGroup ? 'move' : 'remove'} <strong>{node.getLabel()}</strong> from {sourceGroup.getLabel()}\n        {targetGroup ? ` to ${targetGroup.getLabel()}` : ''}?\n      </>\n    );\n    const btnText = targetGroup ? 'Move' : 'Remove';\n\n    return new Promise((resolve, reject) => {\n      confirmModal({\n        title,\n        message,\n        btnText,\n        close: () => {\n          reject();\n        },\n        cancel: () => {\n          reject();\n        },\n        executeFn: () => {\n          return updateTopologyResourceApplication(node.getData(), targetGroup ? targetGroup.getLabel() : null)\n            .then(resolve)\n            .catch(err => {\n              const error = err.message;\n              errorModal({ error });\n              reject(err);\n            });\n        },\n      });\n    });\n  }\n\n  return updateTopologyResourceApplication(node.getData(), targetGroup.getLabel()).catch(err => {\n    const error = err.message;\n    errorModal({ error });\n  });\n};\n","import * as React from 'react';\nimport { ContextMenuItem, ContextSubMenuItem, Node, Graph } from '@console/topology';\nimport { history, KebabItem, KebabOption, KebabMenuOption, kebabOptionsToMenu, isKebabSubMenu } from '@console/internal/components/utils';\nimport { workloadActions } from '../actions/workloadActions';\nimport { groupActions } from '../actions/groupActions';\nimport { nodeActions } from '../actions/nodeActions';\nimport { graphActions } from '../actions/graphActions';\nimport { TopologyApplicationObject } from '../topology-types';\nimport { regroupActions } from '../actions/regroupActions';\n\nconst onKebabOptionClick = (option: KebabOption) => {\n  if (option.callback) {\n    option.callback();\n  }\n  if (option.href) {\n    history.push(option.href);\n  }\n};\n\nexport const createMenuItems = (actions: KebabMenuOption[]) =>\n  actions.map(option =>\n    isKebabSubMenu(option) ? (\n      <ContextSubMenuItem label={option.label} key={option.label}>\n        {createMenuItems(option.children)}\n      </ContextSubMenuItem>\n    ) : (\n      <ContextMenuItem key={option.label} component={<KebabItem option={option} onClick={() => onKebabOptionClick(option)} />} />\n    ),\n  );\n\nexport const workloadContextMenu = (element: Node) => createMenuItems(kebabOptionsToMenu(workloadActions(element.getData())));\n\nexport const noRegroupWorkloadContextMenu = (element: Node) => createMenuItems(kebabOptionsToMenu(workloadActions(element.getData(), false)));\n\nexport const groupContextMenu = (element: Node, connectorSource?: Node) => {\n  const applicationData: TopologyApplicationObject = {\n    id: element.getId(),\n    name: element.getLabel(),\n    resources: element.getData().groupResources,\n  };\n\n  const graphData = element.getGraph().getData();\n  return createMenuItems(kebabOptionsToMenu(groupActions(graphData, applicationData, connectorSource)));\n};\nexport const nodeContextMenu = (element: Node) => createMenuItems(kebabOptionsToMenu(nodeActions(element.getData())));\n\nexport const graphContextMenu = (graph: Graph, connectorSource?: Node) => createMenuItems(kebabOptionsToMenu(graphActions(graph.getData(), connectorSource)));\n\nexport const regroupContextMenu = (element: Node) => createMenuItems(kebabOptionsToMenu(regroupActions(element)));\n\nexport const regroupGroupContextMenu = (element: Node) => createMenuItems(kebabOptionsToMenu(regroupActions(element, true)));\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { Node, useAnchor, EllipseAnchor, WithCreateConnectorProps, WithDndDropProps, WithDragNodeProps, WithSelectionProps, WithContextMenuProps, useCombineRefs, useHover, observer, createSvgIdUrl } from '@console/topology';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport SvgBoxedText from '../../../svg/SvgBoxedText';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { useDisplayFilters, useSearchFilter } from '../../filters';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID_HOVER, NODE_SHADOW_FILTER_ID } from '../NodeShadows';\n\nimport './BaseNode.scss';\n\nexport type BaseNodeProps = {\n  className: string;\n  outerRadius: number;\n  innerRadius?: number;\n  icon?: string;\n  kind?: string;\n  children?: React.ReactNode;\n  attachments?: React.ReactNode;\n  element: Node;\n  dragging?: boolean;\n  edgeDragging?: boolean;\n  dropTarget?: boolean;\n  canDrop?: boolean;\n} & WithSelectionProps &\n  WithDragNodeProps &\n  WithDndDropProps &\n  WithContextMenuProps &\n  WithCreateConnectorProps;\n\nconst ObservedBaseNode: React.FC<BaseNodeProps> = ({ className, outerRadius, innerRadius, icon, kind, element, selected, onSelect, children, attachments, dragNodeRef, dndDropRef, canDrop, dragging, edgeDragging, dropTarget, onHideCreateConnector, onShowCreateConnector, onContextMenu, contextMenuOpen }) => {\n  const [hover, hoverRef] = useHover();\n  useAnchor(EllipseAnchor);\n  const { width, height } = element.getDimensions();\n  const cx = width / 2;\n  const cy = height / 2;\n  const resourceObj = getTopologyResourceObject(element.getData());\n  const resourceModel = modelFor(referenceFor(resourceObj));\n  const iconRadius = innerRadius * 0.9;\n  const editAccess = useAccessReview({\n    group: resourceModel.apiGroup,\n    verb: 'patch',\n    resource: resourceModel.plural,\n    name: resourceObj.metadata.name,\n    namespace: resourceObj.metadata.namespace,\n  });\n  const [filtered] = useSearchFilter(element.getLabel());\n  const displayFilters = useDisplayFilters();\n  const showLabels = displayFilters.showLabels || hover;\n  const refs = useCombineRefs<SVGEllipseElement>(hoverRef, dragNodeRef);\n\n  React.useLayoutEffect(() => {\n    if (editAccess) {\n      if (hover) {\n        onShowCreateConnector && onShowCreateConnector();\n      } else {\n        onHideCreateConnector && onHideCreateConnector();\n      }\n    }\n  }, [hover, onShowCreateConnector, onHideCreateConnector, editAccess]);\n\n  return (\n    <g\n      className={classNames('odc-base-node', className, {\n        'is-hover': hover || contextMenuOpen,\n        'is-highlight': canDrop,\n        'is-dragging': dragging || edgeDragging,\n        'is-dropTarget': canDrop && dropTarget,\n        'is-filtered': filtered,\n        'is-selected': selected,\n      })}\n    >\n      <NodeShadows />\n      <g data-test-id=\"base-node-handler\" onClick={onSelect} onContextMenu={editAccess ? onContextMenu : null} ref={refs}>\n        <circle className=\"odc-base-node__bg\" ref={dndDropRef} cx={cx} cy={cy} r={outerRadius} filter={createSvgIdUrl(hover || dragging || edgeDragging || dropTarget || contextMenuOpen ? NODE_SHADOW_FILTER_ID_HOVER : NODE_SHADOW_FILTER_ID)} />\n        {icon && <image x={cx - iconRadius} y={cy - iconRadius} width={iconRadius * 2} height={iconRadius * 2} xlinkHref={icon} />}\n        {showLabels && (kind || element.getLabel()) && (\n          <SvgBoxedText className=\"odc-base-node__label\" x={cx} y={cy + outerRadius + 24} paddingX={8} paddingY={4} kind={kind}>\n            {element.getLabel()}\n          </SvgBoxedText>\n        )}\n        {children}\n      </g>\n      {attachments}\n    </g>\n  );\n};\n\nconst BaseNode = observer(ObservedBaseNode);\nexport { BaseNode };\n","import * as React from 'react';\n\nconst CheIcon: React.FC<React.HTMLProps<SVGElement>> = ({ style }): React.ReactElement => {\n  return (\n    <svg height=\"1em\" width=\"1em\" version=\"1.1\" viewBox=\"0 0 47 57\" style={style}>\n      <g fillRule=\"evenodd\" stroke=\"none\" strokeWidth=\"1\" fill=\"none\">\n        <path d=\"M0.032227,30.88l-0.032227-17.087,23.853-13.793,23.796,13.784-14.691,8.51-9.062-5.109-23.864,13.695z\" fill=\"#fdb940\" />\n        <path d=\"M0,43.355l23.876,13.622,23.974-13.937v-16.902l-23.974,13.506-23.876-13.506v17.217z\" fill=\"#525c86\" />\n      </g>\n    </svg>\n  );\n};\n\nexport default CheIcon;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { createSvgIdUrl, useHover } from '@console/topology';\nimport SvgDropShadowFilter from '../../../svg/SvgDropShadowFilter';\n\nimport './Decorator.scss';\n\ntype DecoratorTypes = {\n  x: number;\n  y: number;\n  radius: number;\n  onClick?(event: React.MouseEvent<SVGGElement, MouseEvent>): void;\n  href?: string;\n  external?: boolean;\n  circleRef?: React.Ref<SVGCircleElement>;\n};\n\nconst FILTER_ID = 'DecoratorDropShadowFilterId';\nconst HOVER_FILTER_ID = 'DecoratorDropShadowHoverFilterId';\n\nconst Decorator: React.FunctionComponent<DecoratorTypes> = ({ x, y, radius, onClick, children, href, external, circleRef }) => {\n  const [hover, hoverRef] = useHover();\n  const decorator = (\n    <g\n      className=\"odc-decorator\"\n      onClick={e => {\n        e.stopPropagation();\n        onClick && onClick(e);\n      }}\n      ref={hoverRef}\n    >\n      <SvgDropShadowFilter id={FILTER_ID} stdDeviation={1} floodOpacity={0.5} />\n      <SvgDropShadowFilter id={HOVER_FILTER_ID} dy={3} stdDeviation={5} floodOpacity={0.5} />\n      <circle ref={circleRef} className=\"odc-decorator__bg\" cx={x} cy={y} r={radius} filter={createSvgIdUrl(hover ? HOVER_FILTER_ID : FILTER_ID)} />\n      <g transform={`translate(${x}, ${y})`}>{children}</g>\n    </g>\n  );\n  if (href) {\n    return (\n      /*\n      // @ts-ignore */\n      // eslint-disable-next-line jsx-a11y/anchor-is-valid\n      <a className=\"odc-decorator__link\" xlinkHref={href} target={external ? '_blank' : null}>\n        {decorator}\n      </a>\n    );\n  }\n  return decorator;\n};\n\nexport { Decorator };\n","import * as React from 'react';\nimport { get } from 'lodash';\nimport { PodStatus, calculateRadius, getPodData, podRingLabel, podDataInProgress } from '@console/shared';\nimport { DonutStatusData } from '../../topology-types';\n\ninterface PodSetProps {\n  size: number;\n  data: DonutStatusData;\n  showPodCount?: boolean;\n  x?: number;\n  y?: number;\n}\n\ninterface InnerPodStatusRadius {\n  innerPodStatusOuterRadius: number;\n  innerPodStatusInnerRadius: number;\n}\n\nconst calculateInnerPodStatusRadius = (outerPodStatusInnerRadius: number, outerPodStatusWidth: number): InnerPodStatusRadius => {\n  const innerPodStatusWidth = outerPodStatusWidth * 0.6;\n  const spaceBwOuterAndInnerPodStatus = 3;\n  const innerPodStatusOuterRadius = outerPodStatusInnerRadius - spaceBwOuterAndInnerPodStatus;\n  const innerPodStatusInnerRadius = innerPodStatusOuterRadius - innerPodStatusWidth;\n\n  return { innerPodStatusOuterRadius, innerPodStatusInnerRadius };\n};\n\nexport const podSetInnerRadius = (size: number, data: DonutStatusData) => {\n  const { podStatusInnerRadius, podStatusStrokeWidth } = calculateRadius(size);\n  let radius = podStatusInnerRadius;\n\n  if (podDataInProgress(data.dc, data.current, data.isRollingOut)) {\n    const { innerPodStatusInnerRadius } = calculateInnerPodStatusRadius(radius, podStatusStrokeWidth);\n    radius = innerPodStatusInnerRadius;\n  }\n\n  const { podStatusStrokeWidth: innerStrokeWidth, podStatusInset } = calculateRadius(radius * 2);\n\n  return radius - innerStrokeWidth - podStatusInset;\n};\n\nconst PodSet: React.FC<PodSetProps> = ({ size, data, x = 0, y = 0, showPodCount }) => {\n  const { podStatusOuterRadius, podStatusInnerRadius, podStatusStrokeWidth } = calculateRadius(size);\n  const { innerPodStatusOuterRadius, innerPodStatusInnerRadius } = calculateInnerPodStatusRadius(podStatusInnerRadius, podStatusStrokeWidth);\n  const { inProgressDeploymentData, completedDeploymentData } = getPodData(data.dc, data.pods, data.current, data.previous, data.isRollingOut);\n\n  const obj = get(data, ['current', 'obj'], null) || data.dc;\n  const { title, subTitle, titleComponent } = podRingLabel(obj, data.dc.kind, data?.pods);\n  return (\n    <>\n      <PodStatus key={inProgressDeploymentData ? 'deploy' : 'notDeploy'} x={x - size / 2} y={y - size / 2} innerRadius={podStatusInnerRadius} outerRadius={podStatusOuterRadius} data={completedDeploymentData} size={size} subTitle={showPodCount && subTitle} title={showPodCount && title} titleComponent={showPodCount && titleComponent} />\n      {inProgressDeploymentData && <PodStatus x={x - size / 2} y={y - size / 2} innerRadius={innerPodStatusInnerRadius} outerRadius={innerPodStatusOuterRadius} data={inProgressDeploymentData} size={size} />}\n    </>\n  );\n};\n\nexport default PodSet;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { calculateRadius } from '@console/shared';\nimport { Node, observer, WithCreateConnectorProps, WithDragNodeProps, WithSelectionProps, WithDndDropProps, WithContextMenuProps } from '@console/topology';\nimport { RootState } from '@console/internal/redux';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { ExternalLinkAltIcon } from '@patternfly/react-icons';\nimport { routeDecoratorIcon } from '../../../import/render-utils';\nimport { Decorator } from './Decorator';\nimport PodSet, { podSetInnerRadius } from './PodSet';\nimport BuildDecorator from './build-decorators/BuildDecorator';\nimport { BaseNode } from './BaseNode';\nimport { getCheURL, getEditURL, getServiceBindingStatus } from '../../topology-utils';\nimport { useDisplayFilters } from '../../filters/useDisplayFilters';\n\nimport './WorkloadNode.scss';\n\ninterface StateProps {\n  serviceBinding: boolean;\n  cheURL: string;\n}\n\nexport type WorkloadNodeProps = {\n  element: Node;\n  hover?: boolean;\n  dragging?: boolean;\n  highlight?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  urlAnchorRef?: React.Ref<SVGCircleElement>;\n} & WithSelectionProps &\n  WithDragNodeProps &\n  WithDndDropProps &\n  WithContextMenuProps &\n  WithCreateConnectorProps &\n  StateProps;\n\nconst ObservedWorkloadNode: React.FC<WorkloadNodeProps> = ({ element, urlAnchorRef, canDrop, dropTarget, serviceBinding, cheURL, ...rest }) => {\n  const { width, height } = element.getDimensions();\n  const workloadData = element.getData().data;\n  const filters = useDisplayFilters();\n  const size = Math.min(width, height);\n  const { donutStatus, editURL, vcsURI } = workloadData;\n  const { radius, decoratorRadius } = calculateRadius(size);\n  const cheEnabled = !!cheURL;\n  const cx = width / 2;\n  const cy = height / 2;\n  const editUrl = editURL || getEditURL(vcsURI, cheURL);\n  const repoIcon = routeDecoratorIcon(editUrl, decoratorRadius, cheEnabled);\n  const tipContent = `Create a ${serviceBinding && element.getData().operatorBackedService ? 'binding' : 'visual'} connector`;\n\n  return (\n    <g>\n      <Tooltip content={tipContent} trigger=\"manual\" isVisible={dropTarget && canDrop} tippyProps={{ duration: 0, delay: 0 }}>\n        <BaseNode\n          className=\"odc-workload-node\"\n          outerRadius={radius}\n          innerRadius={podSetInnerRadius(size, donutStatus)}\n          icon={!filters.podCount ? workloadData.builderImage : undefined}\n          kind={workloadData.kind}\n          element={element}\n          dropTarget={dropTarget}\n          canDrop={canDrop}\n          {...rest}\n          attachments={[\n            repoIcon && (\n              <Tooltip key=\"edit\" content=\"Edit Source Code\" position={TooltipPosition.right}>\n                <Decorator x={cx + radius - decoratorRadius * 0.7} y={cy + radius - decoratorRadius * 0.7} radius={decoratorRadius} href={editUrl} external>\n                  <g transform={`translate(-${decoratorRadius / 2}, -${decoratorRadius / 2})`}>{repoIcon}</g>\n                </Decorator>\n              </Tooltip>\n            ),\n            workloadData.url && (\n              <Tooltip key=\"route\" content=\"Open URL\" position={TooltipPosition.right}>\n                <Decorator x={cx + radius - decoratorRadius * 0.7} y={cy + -radius + decoratorRadius * 0.7} radius={decoratorRadius} href={workloadData.url} external circleRef={urlAnchorRef}>\n                  <g transform={`translate(-${decoratorRadius / 2}, -${decoratorRadius / 2})`}>\n                    <ExternalLinkAltIcon style={{ fontSize: decoratorRadius }} alt=\"Open URL\" />\n                  </g>\n                </Decorator>\n              </Tooltip>\n            ),\n            <BuildDecorator key=\"build\" workloadData={workloadData} x={cx - radius + decoratorRadius * 0.7} y={cy + radius - decoratorRadius * 0.7} radius={decoratorRadius} />,\n          ]}\n        >\n          <PodSet size={size} x={cx} y={cy} data={donutStatus} showPodCount={filters.podCount} />\n        </BaseNode>\n      </Tooltip>\n    </g>\n  );\n};\n\nconst mapStateToProps = (state: RootState): StateProps => {\n  const consoleLinks = state.UI.get('consoleLinks');\n  return {\n    cheURL: getCheURL(consoleLinks),\n    serviceBinding: getServiceBindingStatus(state),\n  };\n};\n\nconst WorkloadNode = connect(mapStateToProps)(observer(ObservedWorkloadNode));\nexport { WorkloadNode };\n","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { WorkloadData } from '../../../topology-types';\nimport { Decorator } from '../Decorator';\nimport { getBuildDecoratorParts } from './build-decorator-utils';\n\nexport interface BuildDecoratorProps {\n  workloadData: WorkloadData;\n  radius: number;\n  x: number;\n  y: number;\n}\n\nconst BuildDecorator: React.FC<BuildDecoratorProps> = ({ workloadData, radius, x, y }) => {\n  const { decoratorIcon, linkRef, tooltipContent } = getBuildDecoratorParts(workloadData);\n\n  if (!decoratorIcon && !tooltipContent) {\n    return null;\n  }\n\n  let decoratorContent = (\n    <Decorator x={x} y={y} radius={radius}>\n      <g transform={`translate(-${radius / 2}, -${radius / 2})`}>\n        <foreignObject width={radius} height={radius} style={{ fontSize: radius }}>\n          {decoratorIcon}\n        </foreignObject>\n      </g>\n    </Decorator>\n  );\n\n  if (linkRef) {\n    decoratorContent = (\n      <Link to={linkRef} className=\"odc-decorator__link\">\n        {decoratorContent}\n      </Link>\n    );\n  }\n\n  return (\n    <Tooltip key=\"build\" content={tooltipContent} position={TooltipPosition.left}>\n      {decoratorContent}\n    </Tooltip>\n  );\n};\n\nexport default BuildDecorator;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport {\n  getRunStatusColor,\n  getTaskStatus,\n  Pipeline,\n  runStatus,\n} from '../../../../../utils/pipeline-augment';\nimport HorizontalStackedBars from '../../../../charts/HorizontalStackedBars';\nimport TaskStatusToolTip from '../../../../pipelineruns/status/TaskStatusTooltip';\nimport './PipelineBuildDecoratorTooltip.scss';\n\nexport interface PipelineBuildDecoratorTooltipProps {\n  pipeline: Pipeline;\n  status: string;\n}\n\nconst PipelineBuildDecoratorTooltip: React.FC<PipelineBuildDecoratorTooltipProps> = ({\n  pipeline,\n  status,\n}) => {\n  if (!pipeline || !status) {\n    return null;\n  }\n\n  const taskStatus = getTaskStatus(pipeline.latestRun, pipeline);\n  const pipelineBars = (\n    <HorizontalStackedBars\n      height=\"1em\"\n      inline\n      values={Object.keys(runStatus).map((rStatus) => ({\n        color: getRunStatusColor(runStatus[rStatus]).pftoken.value,\n        name: rStatus,\n        size: taskStatus[runStatus[rStatus]],\n      }))}\n    />\n  );\n  const breakdownInfo = <TaskStatusToolTip taskStatus={taskStatus} />;\n\n  return (\n    <div className=\"odc-pipeline-build-decorator-tooltip\">\n      <div className=\"odc-pipeline-build-decorator-tooltip__title\">Pipeline {status}</div>\n      <div className=\"odc-pipeline-build-decorator-tooltip__status-bars-wrapper\">\n        <div className=\"odc-pipeline-build-decorator-tooltip__status-bars-title\">Task Status</div>\n        <div className=\"odc-pipeline-build-decorator-tooltip__status-bars\">{pipelineBars}</div>\n      </div>\n      <div className=\"odc-pipeline-build-decorator-tooltip__status-breakdown\">{breakdownInfo}</div>\n    </div>\n  );\n};\n\nexport default PipelineBuildDecoratorTooltip;\n","import * as React from 'react';\nimport { Status } from '@console/shared';\nimport { resourcePathFromModel } from '@console/internal/components/utils';\nimport { BuildModel } from '@console/internal/models';\nimport { PipelineRunModel } from '../../../../../models';\nimport { constructCurrentPipeline } from '../../../../../utils/pipeline-utils';\nimport { WorkloadData } from '../../../topology-types';\nimport PipelineBuildDecoratorTooltip from './PipelineBuildDecoratorTooltip';\n\ntype BuildDecoratorData = {\n  decoratorIcon: React.ReactElement;\n  linkRef?: string;\n  tooltipContent: React.ReactElement;\n};\n\nexport const getBuildDecoratorParts = (workloadData: WorkloadData): BuildDecoratorData => {\n  const { build, connectedPipeline } = workloadData;\n\n  let tooltipContent = null;\n  let decoratorIcon = null;\n  let linkRef = null;\n\n  let currentPipelineStatus = null;\n  if (connectedPipeline) {\n    const { pipelineRuns, pipeline } = connectedPipeline;\n    currentPipelineStatus = constructCurrentPipeline(pipeline, pipelineRuns);\n  }\n\n  if (currentPipelineStatus) {\n    const { currentPipeline, status } = currentPipelineStatus;\n    tooltipContent = <PipelineBuildDecoratorTooltip pipeline={currentPipeline} status={status} />;\n    decoratorIcon = <Status status={status} iconOnly noTooltip />;\n    linkRef = `${resourcePathFromModel(\n      PipelineRunModel,\n      currentPipeline.latestRun.metadata.name,\n      currentPipeline.latestRun.metadata.namespace,\n    )}/logs`;\n  } else if (build) {\n    tooltipContent = `Build ${build.status && build.status.phase}`;\n    decoratorIcon = <Status status={build.status.phase} iconOnly noTooltip />;\n    linkRef = `${resourcePathFromModel(\n      BuildModel,\n      build.metadata.name,\n      build.metadata.namespace,\n    )}/logs`;\n  }\n\n  return {\n    tooltipContent,\n    decoratorIcon,\n    linkRef,\n  };\n};\n","export * from './BaseNode';\nexport * from './WorkloadNode';\nexport * from './Decorator';\n","import * as React from 'react';\nimport { Edge } from '@console/topology';\nimport { YellowExclamationTriangleIcon } from '@console/shared/src';\nimport { confirmModal, errorModal } from '@console/internal/components/modals';\nimport { removeTopologyResourceConnection } from '../topology-utils';\n\nexport const removeConnection = (edge: Edge): Promise<any> => {\n  const message = edge.getType() === 'service-binding' ? <p>Deleting the binding connector deletes the config details of the source and removes the binding resources. Are you sure you want to delete the binding connector?</p> : <p>Deleting the visual connector removes the `connects-to` annotation from the resources. Are you sure you want to delete the visual connector?</p>;\n\n  return confirmModal({\n    title: (\n      <>\n        <YellowExclamationTriangleIcon className=\"co-icon-space-r\" /> Delete Connector?\n      </>\n    ),\n    message,\n    btnText: 'Delete',\n    submitDanger: true,\n    executeFn: () => {\n      return removeTopologyResourceConnection(edge.getSource().getData(), edge.getTarget().getData(), edge.getData().data && edge.getData().data.sbr, edge.getType()).catch(err => {\n        err && errorModal({ error: err.message });\n      });\n    },\n  });\n};\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { modelFor, referenceFor, K8sVerb } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport { Node } from '@console/topology';\nimport { getTopologyResourceObject } from '../topology-utils';\n\ntype ComponentProps = {\n  element: Node;\n};\n\nexport const withEditReviewAccess = (verb: K8sVerb) => (WrappedComponent: React.ComponentType) => {\n  const Component: React.FC<ComponentProps> = props => {\n    const resourceObj = getTopologyResourceObject(props.element.getData());\n    const resourceModel = modelFor(referenceFor(resourceObj));\n    const editAccess = useAccessReview({\n      group: resourceModel.apiGroup,\n      verb,\n      resource: resourceModel.plural,\n      name: resourceObj.metadata.name,\n      namespace: resourceObj.metadata.namespace,\n    });\n    return <WrappedComponent {...(props as any)} canEdit={editAccess} />;\n  };\n  return observer(Component);\n};\n","import * as _ from 'lodash';\nimport { K8sResourceKind, isGroupVersionKind, kindForReference, apiVersionForReference } from '@console/internal/module/k8s';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { getKnativeTopologyDataModel } from '@console/knative-plugin/src/topology/data-transformer';\nimport { getKubevirtTopologyDataModel, kubevirtAllowedResources } from '@console/kubevirt-plugin/src/topology/kubevirt-data-transformer';\nimport { TopologyDataModel, TopologyDataResources, Edge, TrafficData, KialiNode } from '../topology-types';\nimport { TYPE_TRAFFIC_CONNECTOR, TYPE_WORKLOAD } from '../components/const';\nimport { HelmReleaseResourcesMap } from '../../helm/helm-types';\nimport { allowedResources } from '../topology-utils';\nimport { addToTopologyDataModel, createInstanceForResource, createTopologyNodeData, getTopologyEdgeItems, getTopologyGroupItems, getTopologyNodeItem, mergeGroup } from './transform-utils';\nimport { getOperatorTopologyDataModel } from '../operators/operators-data-transformer';\nimport { getHelmTopologyDataModel } from '../helm/helm-data-transformer';\n\nexport const getFilteredTrafficWorkload = (nodes: KialiNode[]): KialiNode[] => nodes.filter(({ data }) => data.nodeType === TYPE_WORKLOAD);\n\nexport const getTrafficConnectors = (trafficData: TrafficData, resources: K8sResourceKind[]): Edge[] => {\n  const filteredWorkload = getFilteredTrafficWorkload(trafficData.nodes);\n  return trafficData.edges.reduce((acc, { data }) => {\n    const { data: sourceTrafficNode } = filteredWorkload.find(wrkld => wrkld.data.id === data.source);\n    const { data: targetTrafficNode } = filteredWorkload.find(wrkld => wrkld.data.id === data.target);\n    const sourceResourceNode = resources.find(res => {\n      return res.metadata.name === sourceTrafficNode[sourceTrafficNode.nodeType];\n    });\n    const targetResourceNode = resources.find(res => res.metadata.name === targetTrafficNode[targetTrafficNode.nodeType]);\n    return sourceResourceNode && targetResourceNode\n      ? [\n          ...acc,\n          {\n            id: `${sourceResourceNode.metadata.uid}_${targetResourceNode.metadata.uid}`,\n            type: TYPE_TRAFFIC_CONNECTOR,\n            source: sourceResourceNode.metadata.uid,\n            target: targetResourceNode.metadata.uid,\n            data: data.traffic,\n          },\n        ]\n      : acc;\n  }, []);\n};\n\nconst getBaseTopologyDataModel = (resources: TopologyDataResources, allResources: K8sResourceKind[], installedOperators, utils: Function[], transformBy: string[], serviceBindingRequests: K8sResourceKind[]): TopologyDataModel => {\n  const baseDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  _.forEach(transformBy, key => {\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data).forEach(item => {\n        const { obj: deploymentConfig } = item;\n        const uid = _.get(deploymentConfig, ['metadata', 'uid']);\n        typedDataModel.topology[uid] = createTopologyNodeData(item, TYPE_WORKLOAD, getImageForIconClass(`icon-openshift`));\n        typedDataModel.graph.nodes.push(getTopologyNodeItem(deploymentConfig, TYPE_WORKLOAD));\n        typedDataModel.graph.edges.push(...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests));\n        mergeGroup(getTopologyGroupItems(deploymentConfig), typedDataModel.graph.groups);\n      });\n      addToTopologyDataModel(typedDataModel, baseDataModel);\n    }\n  });\n  return baseDataModel;\n};\n\n/**\n * Tranforms the k8s resources objects into topology data\n */\nexport const transformTopologyData = (resources: TopologyDataResources, transformBy: string[], utils?: Function[], trafficData?: TrafficData, helmResourcesMap?: HelmReleaseResourcesMap): TopologyDataModel => {\n  const installedOperators = _.get(resources, 'clusterServiceVersions.data');\n  const serviceBindingRequests = _.get(resources, 'serviceBindingRequests.data');\n  const topologyGraphAndNodeData: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  // TODO: plugin\n  const allResourceTypes = [...allowedResources, ...kubevirtAllowedResources];\n  const allResourcesList = _.flatten(\n    allResourceTypes.map(resourceKind => {\n      return resources[resourceKind]\n        ? resources[resourceKind].data.map(res => {\n            const resKind = resources[resourceKind].kind;\n            let kind = resKind;\n            let apiVersion;\n            if (resKind && isGroupVersionKind(resKind)) {\n              kind = kindForReference(resKind);\n              apiVersion = apiVersionForReference(resKind);\n            }\n            return {\n              kind,\n              apiVersion,\n              ...res,\n            };\n          })\n        : [];\n    }),\n  );\n  if (trafficData) {\n    topologyGraphAndNodeData.graph.edges = getTrafficConnectors(trafficData, allResourcesList);\n  }\n\n  // Copy the resources into a mutable list of resources, we don't want to effect the incoming lists\n  const dataResources: TopologyDataResources = Object.keys(resources).reduce((obj, key) => {\n    obj[key] = {\n      ...resources[key],\n      data: [...resources[key].data],\n    };\n    return obj;\n  }, {} as TopologyDataResources);\n\n  // TODO: plugins\n  const knativeModel = getKnativeTopologyDataModel(dataResources, allResourcesList, installedOperators, utils);\n  addToTopologyDataModel(knativeModel, topologyGraphAndNodeData);\n\n  const operatorsModel = getOperatorTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n  addToTopologyDataModel(operatorsModel, topologyGraphAndNodeData);\n\n  const helmModel = getHelmTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests, helmResourcesMap);\n  addToTopologyDataModel(helmModel, topologyGraphAndNodeData);\n\n  const vmsModel = getKubevirtTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n  addToTopologyDataModel(vmsModel, topologyGraphAndNodeData);\n\n  const baseModel = getBaseTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n  addToTopologyDataModel(baseModel, topologyGraphAndNodeData);\n\n  return topologyGraphAndNodeData;\n};\n","export * from './data-transformer';\nexport * from './transform-utils';\nexport * from './topology-model';\n","import { EdgeModel, Model, NodeModel, createAggregateEdges } from '@console/topology';\nimport { ALL_APPLICATIONS_KEY } from '@console/shared/src';\nimport { getKnativeNodeModel, getKnativeGroupModel, getKnativeEdgeModel } from '@console/knative-plugin/src/topology/knative-topology-model';\nimport { getKubevirtGroupModel, getKubevirtNodeModel, getKubevirtEdgeModel } from '@console/kubevirt-plugin/src/topology/kubevirt-topology-model';\nimport { getHelmEdgeModel, getHelmGroupModel, getHelmNodeModel } from '../helm/helm-topology-model';\nimport { getOperatorEdgeModel, getOperatorGroupModel, getOperatorNodeModel } from '../operators/operators-topology-model';\nimport { TopologyFilters } from '../filters';\nimport { TopologyDataModel, TopologyDataObject, Node } from '../topology-types';\nimport { TYPE_APPLICATION_GROUP, TYPE_AGGREGATE_EDGE, NODE_WIDTH, NODE_HEIGHT, NODE_PADDING, GROUP_WIDTH, GROUP_HEIGHT, GROUP_PADDING } from '../components/const';\nimport { dataObjectFromModel } from './transform-utils';\n\nconst getApplicationGroupForNode = (node: Node, groups: NodeModel[]): NodeModel => {\n  const group = groups.find(g => g.children.includes(node.id));\n  if (!group) {\n    return null;\n  }\n  if (group.type === TYPE_APPLICATION_GROUP) {\n    return group;\n  }\n  return getApplicationGroupForNode(group, groups);\n};\n\nexport const topologyModelFromDataModel = (dataModel: TopologyDataModel, application: string = ALL_APPLICATIONS_KEY, filters?: TopologyFilters): Model => {\n  const groupNodes: NodeModel[] = dataModel.graph.groups.map(d => {\n    // TODO: Change to use plugins\n    let node = getKnativeGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getKubevirtGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getHelmGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getOperatorGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    const data: TopologyDataObject = dataModel.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.nodes.map(id => dataModel.topology[id]);\n\n    return {\n      width: GROUP_WIDTH,\n      height: GROUP_HEIGHT,\n      id: d.id,\n      group: true,\n      type: d.type,\n      visible: d.type !== TYPE_APPLICATION_GROUP || application === ALL_APPLICATIONS_KEY || d.name === application,\n      collapsed: filters && d.type === TYPE_APPLICATION_GROUP && !filters.display.appGrouping,\n      data,\n      children: d.nodes,\n      label: d.name,\n      style: {\n        padding: GROUP_PADDING,\n      },\n    };\n  });\n\n  const nodes: NodeModel[] = dataModel.graph.nodes.map(d => {\n    // TODO: Change to use plugins\n    let node = getKnativeNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getKubevirtNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getHelmNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getOperatorNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: dataModel.topology[d.id].name,\n      data: dataModel.topology[d.id],\n      visible: true,\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  });\n\n  const allNodes = [...nodes, ...groupNodes];\n\n  // Flag any hidden nodes\n  if (application !== ALL_APPLICATIONS_KEY) {\n    const allGroups = [...groupNodes, ...nodes.filter(n => n.group)];\n    allNodes\n      .filter(g => g.type !== TYPE_APPLICATION_GROUP)\n      .forEach(g => {\n        const group = getApplicationGroupForNode(g, allGroups);\n        const hidden = application !== ALL_APPLICATIONS_KEY && (!group || application !== group.label);\n        g.visible = !hidden;\n      });\n  }\n\n  // create links from data, only include those which have a valid source and target\n  const edges = dataModel.graph.edges\n    .filter(d => {\n      return allNodes.find(n => n.id === d.source) && allNodes.find(n => n.id === d.target);\n    })\n    .map(\n      (d): EdgeModel => {\n        // TODO: Change to use plugins\n        let edge = getKnativeEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getKubevirtEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getHelmEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getOperatorEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n\n        return {\n          data: d,\n          source: d.source,\n          target: d.target,\n          id: `${d.source}_${d.target}`,\n          type: d.type,\n        };\n      },\n    );\n\n  // create topology model\n  const model: Model = {\n    nodes: allNodes,\n    edges: createAggregateEdges(TYPE_AGGREGATE_EDGE, edges, allNodes),\n  };\n\n  return model;\n};\n","import * as _ from 'lodash';\nimport { K8sResourceKind, referenceFor } from '@console/internal/module/k8s';\nimport { TransformResourceData, isKnativeServing } from '@console/shared';\nimport { ClusterServiceVersionKind } from '@console/operator-lifecycle-manager';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { TYPE_EVENT_SOURCE, TYPE_KNATIVE_REVISION } from '@console/knative-plugin/src/topology/const';\nimport { edgesFromAnnotations, edgesFromServiceBinding } from '../../../utils/application-utils';\nimport { TopologyDataModel, TopologyDataResources, TopologyDataObject, Node, Edge, Group, TopologyOverviewItem, ConnectsToData } from '../topology-types';\nimport { TYPE_APPLICATION_GROUP, TYPE_WORKLOAD, TYPE_CONNECTS_TO, TYPE_SERVICE_BINDING } from '../components/const';\nimport { getRoutesURL } from '../topology-utils';\n\nexport const dataObjectFromModel = (node: Node | Group): TopologyDataObject => {\n  return {\n    id: node.id,\n    name: node.name,\n    type: node.type,\n    resources: null,\n    operatorBackedService: false,\n    data: null,\n  };\n};\n\n/**\n * create instance of TransformResourceData, return object containing all methods\n */\nexport const createInstanceForResource = (resources: TopologyDataResources, utils?: Function[], installedOperators?: ClusterServiceVersionKind[]) => {\n  const transformResourceData = new TransformResourceData(resources, utils, installedOperators);\n\n  return {\n    deployments: transformResourceData.createDeploymentItems,\n    deploymentConfigs: transformResourceData.createDeploymentConfigItems,\n    daemonSets: transformResourceData.createDaemonSetItems,\n    statefulSets: transformResourceData.createStatefulSetItems,\n  };\n};\n\n/**\n * create all data that need to be shown on a topology data\n */\nexport const createTopologyNodeData = (dc: TopologyOverviewItem, type: string, defaultIcon: string, operatorBackedService: boolean = false): TopologyDataObject => {\n  const { obj: deploymentConfig, current, previous, isRollingOut, buildConfigs, pipelines = [], pipelineRuns = [] } = dc;\n  const dcUID = _.get(deploymentConfig, 'metadata.uid');\n  const deploymentsLabels = _.get(deploymentConfig, 'metadata.labels', {});\n  const deploymentsAnnotations = _.get(deploymentConfig, 'metadata.annotations', {});\n\n  const builderImageIcon = getImageForIconClass(`icon-${deploymentsLabels['app.openshift.io/runtime']}`) || getImageForIconClass(`icon-${deploymentsLabels['app.kubernetes.io/name']}`);\n  return {\n    id: dcUID,\n    name: _.get(deploymentConfig, 'metadata.name') || deploymentsLabels['app.kubernetes.io/instance'],\n    type,\n    resources: { ...dc, isOperatorBackedService: operatorBackedService },\n    pods: dc.pods,\n    operatorBackedService,\n    data: {\n      url: getRoutesURL(dc),\n      kind: referenceFor(deploymentConfig),\n      editURL: deploymentsAnnotations['app.openshift.io/edit-url'],\n      vcsURI: deploymentsAnnotations['app.openshift.io/vcs-uri'],\n      builderImage: builderImageIcon || defaultIcon,\n      isKnativeResource: type && (type === TYPE_EVENT_SOURCE || type === TYPE_KNATIVE_REVISION) ? true : isKnativeServing(deploymentConfig, 'metadata.labels'),\n      build: buildConfigs?.[0]?.builds?.[0],\n      connectedPipeline: {\n        pipeline: pipelines[0],\n        pipelineRuns,\n      },\n      donutStatus: {\n        pods: dc.pods,\n        current,\n        previous,\n        isRollingOut,\n        dc: deploymentConfig,\n      },\n    },\n  };\n};\n\n/**\n * create node data for graphs\n */\nexport const getTopologyNodeItem = (dc: K8sResourceKind, type?: string, children?: string[]): Node => {\n  const uid = _.get(dc, ['metadata', 'uid']);\n  const name = _.get(dc, ['metadata', 'name']);\n  const label = _.get(dc, ['metadata', 'labels', 'app.openshift.io/instance']);\n\n  return {\n    id: uid,\n    type: type || TYPE_WORKLOAD,\n    name: label || name,\n    ...(children && children.length && { children }),\n  };\n};\n\n/**\n * create edge data for graph\n */\nexport const getTopologyEdgeItems = (dc: K8sResourceKind, resources: K8sResourceKind[], sbrs: K8sResourceKind[]): Edge[] => {\n  const annotations = _.get(dc, 'metadata.annotations');\n  const edges = [];\n\n  _.forEach(edgesFromAnnotations(annotations), (edge: string | ConnectsToData) => {\n    // handles multiple edges\n    const targetNode = _.get(\n      _.find(resources, deployment => {\n        let name;\n        if (typeof edge === 'string') {\n          name = deployment.metadata?.labels?.['app.kubernetes.io/instance'] ?? deployment.metadata?.name;\n          return name === edge;\n        }\n        name = deployment.metadata?.name;\n        const { apiVersion: edgeApiVersion, kind: edgeKind, name: edgeName } = edge;\n        const { kind, apiVersion } = deployment;\n        let edgeExists = name === edgeName && kind === edgeKind;\n        if (apiVersion) {\n          edgeExists = edgeExists && apiVersion === edgeApiVersion;\n        }\n        return edgeExists;\n      }),\n      ['metadata', 'uid'],\n    );\n    const uid = _.get(dc, ['metadata', 'uid']);\n    if (targetNode) {\n      edges.push({\n        id: `${uid}_${targetNode}`,\n        type: TYPE_CONNECTS_TO,\n        source: uid,\n        target: targetNode,\n      });\n    }\n  });\n\n  _.forEach(edgesFromServiceBinding(dc, sbrs), sbr => {\n    // look for multiple backing services first in `backingServiceSelectors`\n    // followed by a fallback to the single reference in `backingServiceSelector`\n    _.forEach(sbr.spec.backingServiceSelectors || [sbr.spec.backingServiceSelector], bss => {\n      if (bss) {\n        // handles multiple edges\n        const targetResource = resources.find(deployment => deployment?.metadata?.ownerReferences?.[0]?.kind === bss.kind && deployment?.metadata?.ownerReferences?.[0]?.name === bss.resourceRef);\n        const target = targetResource?.metadata?.uid;\n        const source = dc?.metadata?.uid;\n        if (source && target) {\n          edges.push({\n            id: `${source}_${target}`,\n            type: TYPE_SERVICE_BINDING,\n            source,\n            target,\n            data: { sbr },\n          });\n        }\n      }\n    });\n  });\n\n  return edges;\n};\n\n/**\n * create groups data for graph\n */\nexport const getTopologyGroupItems = (dc: K8sResourceKind): Group => {\n  const groupName = _.get(dc, ['metadata', 'labels', 'app.kubernetes.io/part-of']);\n  if (!groupName) {\n    return null;\n  }\n\n  return {\n    id: `group:${groupName}`,\n    type: TYPE_APPLICATION_GROUP,\n    name: groupName,\n    nodes: [_.get(dc, ['metadata', 'uid'])],\n  };\n};\n\nexport const mergeGroup = (newGroup: Group, existingGroups: Group[]): void => {\n  if (!newGroup) {\n    return;\n  }\n\n  // find and add the groups\n  const existingGroup = existingGroups.find(g => g.id === newGroup.id);\n  if (!existingGroup) {\n    existingGroups.push(newGroup);\n  } else {\n    newGroup.nodes.forEach(id => {\n      if (!existingGroup.nodes.includes(id)) {\n        existingGroup.nodes.push(id);\n      }\n    });\n  }\n};\n\nexport const mergeGroups = (newGroups: Group[], existingGroups: Group[]): void => {\n  if (!newGroups || !newGroups.length) {\n    return;\n  }\n  newGroups.forEach(newGroup => {\n    mergeGroup(newGroup, existingGroups);\n  });\n};\n\nexport const addToTopologyDataModel = (newModel: TopologyDataModel, graphModel: TopologyDataModel) => {\n  graphModel.graph.nodes.push(...newModel.graph.nodes);\n  graphModel.graph.edges.push(...newModel.graph.edges);\n  mergeGroups(newModel.graph.groups, graphModel.graph.groups);\n  graphModel.topology = {\n    ...graphModel.topology,\n    ...newModel.topology,\n  };\n};\n","export const TOPOLOGY_SEARCH_FILTER_KEY = 'searchQuery';\nexport const FILTER_ACTIVE_CLASS = 'odc-m-filter-active';\n\nexport enum ShowFiltersKeyValue {\n  podCount = 'Pod Count',\n  eventSources = 'Event Sources',\n  virtualMachines = 'Virtual Machines',\n  showLabels = 'Show Labels',\n}\n\nexport enum ExpandFiltersKeyValue {\n  appGrouping = 'Application Groupings',\n  helmGrouping = 'Helm Releases',\n  knativeServices = 'Knative Services',\n  operatorGrouping = 'Operator Groupings',\n}\n\nexport type TopologyFilters = {\n  display: DisplayFilters;\n};\n\nexport type DisplayFilters = {\n  podCount: boolean;\n  eventSources: boolean;\n  virtualMachines: boolean;\n  showLabels: boolean;\n  knativeServices: boolean;\n  appGrouping: boolean;\n  operatorGrouping: boolean;\n  helmGrouping: boolean;\n};\n","import { RootState } from '@console/internal/redux';\nimport { getQueryArgument } from '@console/internal/components/utils';\nimport { getDefaultTopologyFilters } from '../redux/reducer';\nimport { TOPOLOGY_SEARCH_FILTER_KEY, TopologyFilters } from './filter-types';\n\nexport const getTopologyFilters = (state: RootState): TopologyFilters => {\n  const topology = state?.plugins?.devconsole?.topology;\n  return topology ? topology.get('filters') : getDefaultTopologyFilters();\n};\n\nexport const getTopologySearchQuery = () => getQueryArgument(TOPOLOGY_SEARCH_FILTER_KEY) ?? '';\n","export * from './filter-types';\nexport * from './filter-utils';\nexport * from './useSearchFilter';\nexport * from './useDisplayFilters';\n","// FIXME upgrading redux types is causing many errors at this time\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@console/internal/redux';\nimport { DisplayFilters } from './filter-types';\nimport { getTopologyFilters } from './filter-utils';\n\nconst useDisplayFilters = (): DisplayFilters => {\n  return useSelector((state: RootState) => getTopologyFilters(state).display);\n};\n\nexport { useDisplayFilters };\n","import * as React from 'react';\nimport * as fuzzy from 'fuzzysearch';\nimport { toLower } from 'lodash';\nimport { getTopologySearchQuery } from './filter-utils';\n\nconst fuzzyCaseInsensitive = (a: string, b: string): boolean => fuzzy(toLower(a), toLower(b));\n\nconst useSearchFilter = (text: string): [boolean, string] => {\n  const searchQuery = getTopologySearchQuery();\n  const filtered = React.useMemo(() => fuzzyCaseInsensitive(searchQuery, text), [searchQuery, text]);\n  return [filtered && !!searchQuery, searchQuery];\n};\n\nexport { useSearchFilter };\n","import { GROUP_HEIGHT, GROUP_PADDING, GROUP_WIDTH } from '../../components/const';\n\nexport const TYPE_HELM_RELEASE = 'helm-release';\nexport const TYPE_HELM_WORKLOAD = 'helm-workload';\n\nexport const HELM_GROUP_WIDTH = GROUP_WIDTH;\nexport const HELM_GROUP_HEIGHT = GROUP_HEIGHT;\nexport const HELM_GROUP_PADDING = GROUP_PADDING;\n","import * as _ from 'lodash';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { SecretModel } from '@console/internal/models';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { TopologyDataModel, TopologyDataResources, TopologyDataMap, Group } from '../topology-types';\nimport { TYPE_HELM_RELEASE, TYPE_HELM_WORKLOAD } from './components/const';\nimport { HelmReleaseResourcesMap } from '../../helm/helm-types';\nimport { getHelmReleaseKey } from '../topology-utils';\nimport { dataObjectFromModel, addToTopologyDataModel, createInstanceForResource, createTopologyNodeData, getTopologyEdgeItems, getTopologyGroupItems, getTopologyNodeItem, mergeGroup, mergeGroups } from '../data-transforms/transform-utils';\n\nexport const isHelmReleaseNode = (obj: K8sResourceKind, helmResourcesMap: HelmReleaseResourcesMap): boolean => {\n  if (helmResourcesMap) {\n    return helmResourcesMap.hasOwnProperty(getHelmReleaseKey(obj));\n  }\n  return false;\n};\n\nexport const getTopologyHelmReleaseGroupItem = (obj: K8sResourceKind, helmResourcesMap: HelmReleaseResourcesMap, secrets: K8sResourceKind[]): { groups: Group[]; dataModel: TopologyDataMap } => {\n  const resourceKindName = getHelmReleaseKey(obj);\n  const helmResources = helmResourcesMap[resourceKindName];\n  const releaseName = helmResources?.releaseName;\n  const releaseVersion = helmResources?.releaseVersion;\n  const releaseNotes = helmResources?.releaseNotes;\n  const uid = _.get(obj, ['metadata', 'uid'], null);\n  const returnData = { groups: [], dataModel: {} };\n\n  if (!releaseName) {\n    return returnData;\n  }\n\n  const secret = secrets.find(nextSecret => {\n    const { labels } = nextSecret.metadata;\n    return labels?.name?.includes(releaseName) && labels?.version === releaseVersion.toString();\n  });\n\n  if (secret) {\n    const appGroup = getTopologyGroupItems(secret);\n    if (appGroup) {\n      mergeGroup(appGroup, returnData.groups);\n    }\n  }\n\n  const helmGroup = {\n    id: secret ? secret.metadata.uid : `${TYPE_HELM_RELEASE}:${releaseName}`,\n    type: TYPE_HELM_RELEASE,\n    name: releaseName,\n    nodes: [uid],\n  };\n\n  const dataModel = dataObjectFromModel(helmGroup);\n  const { kind, apiVersion } = SecretModel;\n  dataModel.resources = {\n    obj: secret ? { ...secret, kind, apiVersion } : null,\n    buildConfigs: null,\n    services: null,\n    routes: null,\n  };\n  dataModel.data = {\n    chartIcon: helmResources?.chartIcon,\n    manifestResources: helmResources?.manifestResources || [],\n    releaseNotes,\n  };\n  returnData.dataModel[helmGroup.id] = dataModel;\n  returnData.groups.push(helmGroup);\n\n  return returnData;\n};\n\nexport const getHelmTopologyDataModel = (resources: TopologyDataResources, allResources: K8sResourceKind[], installedOperators, utils: Function[], transformBy: string[], serviceBindingRequests: K8sResourceKind[], helmResourcesMap?: HelmReleaseResourcesMap): TopologyDataModel => {\n  const helmDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const helmResources = {};\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  const secrets = _.get(resources, 'secrets.data', []);\n  _.forEach(transformBy, key => {\n    helmResources[key] = [];\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data).forEach(item => {\n        const { obj: deploymentConfig } = item;\n        const uid = _.get(deploymentConfig, ['metadata', 'uid']);\n        if (isHelmReleaseNode(deploymentConfig, helmResourcesMap)) {\n          helmResources[key].push(uid);\n          typedDataModel.topology[uid] = createTopologyNodeData(item, TYPE_HELM_WORKLOAD, getImageForIconClass(`icon-openshift`));\n          typedDataModel.graph.nodes.push(getTopologyNodeItem(deploymentConfig, TYPE_HELM_WORKLOAD));\n          typedDataModel.graph.edges.push(...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests));\n          const { groups, dataModel } = getTopologyHelmReleaseGroupItem(deploymentConfig, helmResourcesMap, secrets);\n          mergeGroups(groups, typedDataModel.graph.groups);\n          typedDataModel.topology = _.merge(typedDataModel.topology, dataModel);\n        }\n      });\n      addToTopologyDataModel(typedDataModel, helmDataModel);\n    }\n  });\n\n  _.forEach(transformBy, key => {\n    if (!_.isEmpty(resources[key].data) && !_.isEmpty(helmResources[key])) {\n      resources[key].data = resources[key].data.filter(resource => !helmResources[key].find(uid => uid === resource.metadata.uid));\n    }\n  });\n  return helmDataModel;\n};\n","import { NodeModel, EdgeModel } from '@console/topology';\nimport { TopologyFilters as Filters } from '../filters';\nimport { TopologyDataModel as DataModel, TopologyDataObject, Node, Group, Edge } from '../topology-types';\nimport { TYPE_HELM_RELEASE, HELM_GROUP_WIDTH, HELM_GROUP_HEIGHT, HELM_GROUP_PADDING } from './components/const';\nimport { dataObjectFromModel } from '../data-transforms/transform-utils';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getHelmGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_HELM_RELEASE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.nodes.map(id => model.topology[id]);\n\n    return {\n      width: HELM_GROUP_WIDTH,\n      height: HELM_GROUP_HEIGHT,\n      id: d.id,\n      group: true,\n      type: d.type,\n      visible: true,\n      collapsed: filters && !filters.display.helmGrouping,\n      data,\n      children: d.nodes,\n      label: d.name,\n      style: {\n        padding: HELM_GROUP_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getHelmNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getHelmEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","export * from './topology-types';\nexport * from './topology-utils';\nexport * from './data-transforms';\nexport * from './components';\nexport * from './filters';\n","import { GROUP_HEIGHT, GROUP_PADDING, GROUP_WIDTH } from '../../components/const';\n\nexport const TYPE_OPERATOR_BACKED_SERVICE = 'operator-backed-service';\nexport const TYPE_OPERATOR_WORKLOAD = 'operator-workload';\n\nexport const OPERATOR_GROUP_WIDTH = GROUP_WIDTH;\nexport const OPERATOR_GROUP_HEIGHT = GROUP_HEIGHT;\nexport const OPERATOR_GROUP_PADDING = GROUP_PADDING;\n","import * as _ from 'lodash';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { getDefaultOperatorIcon, getImageForCSVIcon, getOperatorBackedServiceKindMap } from '@console/shared/src';\nimport { ClusterServiceVersionKind } from '@console/operator-lifecycle-manager/src';\nimport { TopologyDataModel, TopologyDataResources } from '../topology-types';\nimport { TYPE_OPERATOR_BACKED_SERVICE, TYPE_OPERATOR_WORKLOAD } from './components/const';\nimport { addToTopologyDataModel, createInstanceForResource, createTopologyNodeData, getTopologyEdgeItems, getTopologyGroupItems, getTopologyNodeItem, mergeGroup } from '../data-transforms/transform-utils';\n\nexport const getOperatorTopologyDataModel = (resources: TopologyDataResources, allResources: K8sResourceKind[], installedOperators: ClusterServiceVersionKind[], utils: Function[], transformBy: string[], serviceBindingRequests: K8sResourceKind[]): TopologyDataModel => {\n  const operatorsDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(installedOperators);\n  const operatorMap = {};\n  const obsGroups = {};\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  _.forEach(transformBy, key => {\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data, true).forEach(item => {\n        const { obj: deploymentConfig } = item;\n        const uid = deploymentConfig?.metadata?.uid;\n        const ownerReference = deploymentConfig?.metadata?.ownerReferences?.[0];\n        const ownerUid = ownerReference?.uid;\n        const nodeResourceKind = ownerReference?.kind;\n        const operatorBackedServiceKind = operatorBackedServiceKindMap?.[nodeResourceKind];\n        const appGroup = deploymentConfig?.metadata?.labels?.['app.kubernetes.io/part-of'];\n        let operator: K8sResourceKind = _.find(installedOperators, {\n          metadata: { uid: ownerUid },\n        }) as K8sResourceKind;\n\n        if (_.isEmpty(operator)) {\n          operator = operatorBackedServiceKind;\n        }\n\n        const csvIcon = operatorBackedServiceKind?.spec?.icon?.[0] || operator?.spec?.icon?.[0];\n\n        const operatorName = appGroup ? `${appGroup}:${operator.metadata.name}` : operator.metadata.name;\n        typedDataModel.topology[uid] = createTopologyNodeData(item, TYPE_OPERATOR_BACKED_SERVICE, getImageForCSVIcon(csvIcon) || getDefaultOperatorIcon(), true);\n        typedDataModel.graph.nodes.push(getTopologyNodeItem(deploymentConfig, TYPE_OPERATOR_WORKLOAD));\n        typedDataModel.graph.edges.push(...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests));\n        operatorMap[operatorName] = _.merge({}, operator, {\n          metadata: {\n            uid: `${operatorName}:${operator.metadata.uid}`,\n          },\n        });\n        if (!(operatorName in obsGroups)) {\n          obsGroups[operatorName] = [];\n        }\n        obsGroups[operatorName].push(deploymentConfig.metadata.uid);\n        if (appGroup) {\n          const newGroup = getTopologyGroupItems(\n            _.merge({}, deploymentConfig, {\n              metadata: {\n                uid: `${operatorName}:${operator.metadata.uid}`,\n              },\n            }),\n          );\n          mergeGroup(newGroup, typedDataModel.graph.groups);\n        }\n      });\n      addToTopologyDataModel(typedDataModel, operatorsDataModel);\n    }\n  });\n\n  _.forIn(obsGroups, (children, grp) => {\n    const groupDataModel: TopologyDataModel = {\n      graph: { nodes: [], edges: [], groups: [] },\n      topology: {},\n    };\n    groupDataModel.graph.nodes.push(getTopologyNodeItem(operatorMap[grp], TYPE_OPERATOR_BACKED_SERVICE, children));\n\n    groupDataModel.topology[operatorMap[grp].metadata.uid] = {\n      id: operatorMap[grp].metadata.uid,\n      name: operatorMap[grp].metadata.name,\n      type: TYPE_OPERATOR_BACKED_SERVICE,\n      resources: {\n        obj: operatorMap[grp],\n        buildConfigs: [],\n        routes: [],\n        services: [],\n        isOperatorBackedService: true,\n      },\n      operatorBackedService: true,\n      data: {\n        builderImage: getImageForCSVIcon(operatorMap?.[grp]?.spec?.icon?.[0]) || getDefaultOperatorIcon(),\n      },\n    };\n    addToTopologyDataModel(groupDataModel, operatorsDataModel);\n  });\n\n  _.forEach(transformBy, key => {\n    const operatorResources = transformResourceData[key](resources[key].data, true);\n    if (!_.isEmpty(resources[key].data) && !_.isEmpty(operatorResources)) {\n      resources[key].data = resources[key].data.filter(resource => !operatorResources.find(operatorResource => operatorResource.obj.metadata.uid === resource.metadata.uid));\n    }\n  });\n\n  return operatorsDataModel;\n};\n","import { NodeModel, EdgeModel } from '@console/topology';\nimport { TopologyFilters as Filters } from '../filters';\nimport { TopologyDataModel as DataModel, TopologyDataObject, Node, Group, Edge } from '../topology-types';\nimport { TYPE_OPERATOR_BACKED_SERVICE, OPERATOR_GROUP_WIDTH, OPERATOR_GROUP_HEIGHT, OPERATOR_GROUP_PADDING } from './components/const';\nimport { dataObjectFromModel } from '../data-transforms/transform-utils';\nimport { NodeShape } from '@console/topology/src/types';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getOperatorGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getOperatorNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_OPERATOR_BACKED_SERVICE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.children && d.children.map(id => model.topology[id]);\n    return {\n      width: OPERATOR_GROUP_WIDTH,\n      height: OPERATOR_GROUP_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: model.topology[d.id].name,\n      data,\n      visible: true,\n      collapsed: filters && d.type === TYPE_OPERATOR_BACKED_SERVICE && !filters.display.operatorGrouping,\n      children: d.children,\n      group: true,\n      shape: NodeShape.rect,\n      style: {\n        padding: OPERATOR_GROUP_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getOperatorEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","import { ComponentType } from 'react';\nimport { FirehoseResult, KebabOption } from '@console/internal/components/utils';\nimport { ExtPodKind, OverviewItem, PodControllerOverviewItem } from '@console/shared';\nimport { DeploymentKind, K8sResourceKind, PodKind, EventKind } from '@console/internal/module/k8s';\nimport { Pipeline, PipelineRun } from '../../utils/pipeline-augment';\nimport { Node as TopologyNode, EventListener } from '@console/topology/src/types';\n\nexport type Point = [number, number];\n\nexport interface TopologyDataResources {\n  replicationControllers: FirehoseResult;\n  pods: FirehoseResult<PodKind[]>;\n  deploymentConfigs: FirehoseResult;\n  services: FirehoseResult;\n  routes: FirehoseResult;\n  deployments: FirehoseResult<DeploymentKind[]>;\n  replicaSets: FirehoseResult;\n  buildConfigs: FirehoseResult;\n  builds: FirehoseResult;\n  daemonSets?: FirehoseResult;\n  secrets?: FirehoseResult;\n  ksroutes?: FirehoseResult;\n  configurations?: FirehoseResult;\n  revisions?: FirehoseResult;\n  ksservices?: FirehoseResult;\n  statefulSets?: FirehoseResult;\n  pipelines?: FirehoseResult;\n  pipelineRuns?: FirehoseResult;\n  eventSourceCronjob?: FirehoseResult;\n  eventSourceContainers?: FirehoseResult;\n  eventSourceApiserver?: FirehoseResult;\n  eventSourceCamel?: FirehoseResult;\n  eventSourceKafka?: FirehoseResult;\n  eventSourceSinkbinding?: FirehoseResult;\n  clusterServiceVersions?: FirehoseResult;\n  events?: FirehoseResult<EventKind[]>;\n  // TODO: Plugin?\n  serviceBindingRequests?: FirehoseResult;\n  virtualmachines?: FirehoseResult;\n  virtualmachineinstances?: FirehoseResult;\n  virtualmachinetemplates?: FirehoseResult;\n  migrations?: FirehoseResult;\n  dataVolumes?: FirehoseResult;\n  vmImports?: FirehoseResult;\n}\n\nexport interface Node {\n  id: string;\n  type?: string;\n  name?: string;\n  children?: string[];\n  data?: {};\n}\n\nexport interface Edge {\n  id?: string;\n  type?: string;\n  source: string;\n  target: string;\n  data?: { [key: string]: any };\n}\n\nexport interface Group {\n  id?: string;\n  type?: string;\n  name: string;\n  nodes: string[];\n}\n\nexport interface GraphModel {\n  nodes: Node[];\n  edges: Edge[];\n  groups: Group[];\n}\n\nexport interface TopologyDataMap {\n  [id: string]: TopologyDataObject;\n}\n\nexport interface TopologyDataModel {\n  graph: GraphModel;\n  topology: TopologyDataMap;\n}\n\nexport type TopologyOverviewItem = OverviewItem & {\n  pipelines?: Pipeline[];\n  pipelineRuns?: PipelineRun[];\n};\n\nexport interface TopologyDataObject<D = {}> {\n  id: string;\n  name: string;\n  type: string;\n  resources: OverviewItem;\n  pods?: ExtPodKind[];\n  data: D;\n  operatorBackedService: boolean;\n  groupResources?: TopologyDataObject[];\n}\n\nexport interface TopologyApplicationObject {\n  id: string;\n  name: string;\n  resources: TopologyDataObject[];\n}\n\nexport interface ConnectedWorkloadPipeline {\n  pipeline: Pipeline;\n  pipelineRuns: PipelineRun[];\n}\n\nexport interface WorkloadData {\n  url?: string;\n  editURL?: string;\n  vcsURI?: string;\n  builderImage?: string;\n  kind?: string;\n  isKnativeResource?: boolean;\n  build: K8sResourceKind;\n  donutStatus: DonutStatusData;\n  connectedPipeline: ConnectedWorkloadPipeline;\n}\n\nexport interface DonutStatusData {\n  pods: ExtPodKind[];\n  current: PodControllerOverviewItem;\n  previous: PodControllerOverviewItem;\n  dc: K8sResourceKind;\n  isRollingOut: boolean;\n}\n\nexport interface GraphApi {\n  zoomIn(): void;\n  zoomOut(): void;\n  zoomReset(): void;\n  zoomFit(): void;\n  resetLayout(): void;\n}\n\nexport enum GraphElementType {\n  node = 'node',\n  edge = 'edge',\n  group = 'group',\n}\n\nexport interface Selectable {\n  selected?: boolean;\n  onSelect?(): void;\n}\n\nexport interface GroupElementInterface {\n  isPointInGroup: (p: Point) => boolean;\n}\n\nexport type ViewNode = {\n  id: string;\n  type?: string;\n  x: number;\n  y: number;\n  size: number;\n  name: string;\n  fx?: number;\n  fy?: number;\n};\n\nexport type ViewEdge = {\n  id: string;\n  type?: string;\n  nodeSize: number;\n  source: ViewNode;\n  target: ViewNode;\n};\n\nexport type ViewGroup = {\n  id: string;\n  type?: string;\n  name: string;\n  nodes: ViewNode[];\n  element?: GroupElementInterface;\n};\n\nexport type NodeProps<D = {}> = ViewNode &\n  Selectable & {\n    data?: TopologyDataObject<D>;\n    dragActive?: boolean;\n    isDragging?: boolean;\n    isTarget?: boolean;\n    onHover?(hovered: boolean): void;\n  };\n\nexport type DragConnectionProps = NodeProps & {\n  dragX: number;\n  dragY: number;\n  isDragging?: boolean;\n  onHover?(hovered: boolean): void;\n};\n\nexport type EdgeProps<D = {}> = ViewEdge & {\n  data?: TopologyDataObject<D>;\n  dragActive?: boolean;\n  isDragging?: boolean;\n  targetArrowRef?(ref: SVGPathElement): void;\n  onRemove?: () => void;\n};\n\nexport type GroupProps = ViewGroup &\n  Selectable & {\n    dragActive?: boolean;\n    dropSource?: boolean;\n    dropTarget?: boolean;\n    groupRef(element: GroupElementInterface): void;\n  };\n\nexport type TrafficData = {\n  nodes: KialiNode[];\n  edges: KialiEdge[];\n};\n\nexport type KialiNode = {\n  data: {\n    id: string;\n    nodeType: string;\n    namespace: string;\n    workload: string;\n    app: string;\n    version?: string;\n    destServices?: { [key: string]: any }[];\n    traffic?: { [key: string]: any }[];\n  };\n};\n\nexport type KialiEdge = {\n  data: {\n    id: string;\n    source: string;\n    target: string;\n    traffic: { [key: string]: any };\n  };\n};\n\nexport type ConnectsToData = { apiVersion: string; kind: string; name: string };\n\nexport type NodeProvider = (type: string) => ComponentType<NodeProps>;\n\nexport type EdgeProvider = (type: string) => ComponentType<EdgeProps>;\n\nexport type GroupProvider = (type: string) => ComponentType<GroupProps>;\n\nexport type ActionProvider = (type: GraphElementType, id: string) => KebabOption[];\n\nexport type ContextMenuProvider = {\n  open: (type: GraphElementType, id: string, eventX: number, eventY: number) => boolean;\n};\n\nexport type GraphData = {\n  namespace: string;\n  createResourceAccess: string[];\n  eventSourceEnabled: boolean;\n};\n\nexport const SHOW_GROUPING_HINT_EVENT = 'show-regroup-hint';\nexport type ShowGroupingHintEventListener = EventListener<[TopologyNode, string]>;\n","import * as _ from 'lodash';\nimport { K8sResourceKind, modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { RootState } from '@console/internal/redux';\nimport { getRouteWebURL } from '@console/internal/components/routes';\nimport { OverviewItem } from '@console/shared';\nimport { createResourceConnection, updateResourceApplication, removeResourceConnection, createServiceBinding, removeServiceBinding } from '../../utils/application-utils';\nimport { TopologyDataObject } from './topology-types';\nimport { TYPE_OPERATOR_BACKED_SERVICE } from './operators/components/const';\nimport { HelmReleaseResourcesMap } from '../helm/helm-types';\nimport { ALLOW_SERVICE_BINDING } from '../../const';\n\nexport const allowedResources = ['deployments', 'deploymentConfigs', 'daemonSets', 'statefulSets'];\n\nexport const getServiceBindingStatus = ({ FLAGS }: RootState): boolean => FLAGS.get(ALLOW_SERVICE_BINDING);\n\nexport const getCheURL = (consoleLinks: K8sResourceKind[]) => _.get(_.find(consoleLinks, ['metadata.name', 'che']), 'spec.href', '');\n\nexport const getEditURL = (gitURL: string, cheURL: string) => {\n  return gitURL && cheURL ? `${cheURL}/f?url=${gitURL}&policies.create=peruser` : gitURL;\n};\n\nexport const getHelmReleaseKey = resource => `${resource.kind}---${resource.metadata.name}`;\n\nexport const isHelmReleaseNode = (obj: K8sResourceKind, helmResourcesMap: HelmReleaseResourcesMap): boolean => {\n  if (helmResourcesMap) {\n    return helmResourcesMap.hasOwnProperty(getHelmReleaseKey(obj));\n  }\n  return false;\n};\n\nexport const getKialiLink = (consoleLinks: K8sResourceKind[], namespace: string): string => {\n  const kialiLink = _.find(consoleLinks, ['metadata.name', `kiali-namespace-${namespace}`])?.spec?.href;\n  return kialiLink || '';\n};\n\n/**\n * filter data based on the active application\n */\nexport const filterBasedOnActiveApplication = (data: K8sResourceKind[], application: string): K8sResourceKind[] => {\n  const PART_OF = 'app.kubernetes.io/part-of';\n  if (!application) {\n    return data;\n  }\n  return data.filter(dc => {\n    return _.get(dc, ['metadata', 'labels', PART_OF]) === application;\n  });\n};\n\n/**\n * get the route data\n */\nconst getRouteData = (ksroutes: K8sResourceKind[], resource: OverviewItem): string => {\n  if (ksroutes && ksroutes.length > 0 && !_.isEmpty(ksroutes[0].status)) {\n    const trafficData = _.find(ksroutes[0].status.traffic, {\n      revisionName: resource.obj.metadata.name,\n    });\n    return _.get(trafficData, 'url', ksroutes[0].status.url);\n  }\n  return null;\n};\n\n/**\n * get routes url\n */\nexport const getRoutesURL = (resource: OverviewItem): string => {\n  const { routes, ksroutes } = resource;\n  if (routes.length > 0 && !_.isEmpty(routes[0].spec)) {\n    return getRouteWebURL(routes[0]);\n  }\n  return getRouteData(ksroutes, resource);\n};\n\nexport const getTopologyResourceObject = (topologyObject: TopologyDataObject): K8sResourceKind => {\n  if (!topologyObject) {\n    return null;\n  }\n  return _.get(topologyObject, ['resources', 'obj']);\n};\n\nexport const updateTopologyResourceApplication = (item: TopologyDataObject, application: string): Promise<any> => {\n  if (!item || !_.size(item.resources)) {\n    return Promise.reject();\n  }\n\n  const resources: K8sResourceKind[] = [];\n  const updates: Promise<any>[] = [];\n\n  resources.push(getTopologyResourceObject(item));\n\n  if (item.type === TYPE_OPERATOR_BACKED_SERVICE) {\n    _.forEach(item.groupResources, groupResource => {\n      resources.push(getTopologyResourceObject(groupResource));\n    });\n  }\n\n  for (const resource of resources) {\n    const resourceKind = modelFor(referenceFor(resource));\n    if (!resourceKind) {\n      return Promise.reject(new Error(`Unable to update application, invalid resource type: ${resource.kind}`));\n    }\n    updates.push(updateResourceApplication(resourceKind, resource, application));\n  }\n\n  return Promise.all(updates);\n};\n\nexport const createTopologyResourceConnection = (source: TopologyDataObject, target: TopologyDataObject, replaceTarget: TopologyDataObject = null, serviceBindingFlag: boolean): Promise<K8sResourceKind[] | K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject(new Error('Can not create a connection from a node to itself.'));\n  }\n\n  const sourceObj = getTopologyResourceObject(source);\n  const targetObj = getTopologyResourceObject(target);\n  const replaceTargetObj = replaceTarget && getTopologyResourceObject(replaceTarget);\n\n  if (serviceBindingFlag && target.operatorBackedService) {\n    if (replaceTarget) {\n      return new Promise<K8sResourceKind[] | K8sResourceKind>((resolve, reject) => {\n        createServiceBinding(sourceObj, targetObj)\n          .then(() => {\n            // eslint-disable-next-line promise/no-nesting\n            removeResourceConnection(sourceObj, replaceTargetObj)\n              .then(resolve)\n              .catch(reject);\n          })\n          .catch(reject);\n      });\n    }\n\n    return createServiceBinding(sourceObj, targetObj);\n  }\n\n  return createResourceConnection(sourceObj, targetObj, replaceTargetObj);\n};\n\nexport const removeTopologyResourceConnection = (source: TopologyDataObject, target: TopologyDataObject, sbr: K8sResourceKind, edgeType: string): Promise<any> => {\n  if (!source || !target) {\n    return Promise.reject();\n  }\n\n  const sourceObj = getTopologyResourceObject(source);\n  const targetObj = getTopologyResourceObject(target);\n\n  if (edgeType === 'service-binding') {\n    return removeServiceBinding(sbr);\n  }\n\n  return removeResourceConnection(sourceObj, targetObj);\n};\n","import {\n  DEFAULT_GROUP_PAD,\n  GROUP_WIDTH,\n} from '@console/dev-console/src/components/topology/components/const';\n\nexport const TYPE_EVENT_SOURCE = 'event-source';\nexport const TYPE_EVENT_SOURCE_LINK = 'event-source-link';\nexport const TYPE_KNATIVE_SERVICE = 'knative-service';\nexport const TYPE_REVISION_TRAFFIC = 'revision-traffic';\nexport const TYPE_KNATIVE_REVISION = 'knative-revision';\n\nexport const KNATIVE_GROUP_NODE_WIDTH = GROUP_WIDTH;\nexport const KNATIVE_GROUP_NODE_HEIGHT = 100;\nexport const KNATIVE_GROUP_NODE_PADDING = [\n  DEFAULT_GROUP_PAD,\n  DEFAULT_GROUP_PAD,\n  DEFAULT_GROUP_PAD + 10,\n  DEFAULT_GROUP_PAD,\n];\n","import * as _ from 'lodash';\nimport { getOperatorBackedServiceKindMap, OperatorBackedServiceKindMap } from '@console/shared';\nimport { DeploymentKind, K8sResourceKind } from '@console/internal/module/k8s';\nimport { ClusterServiceVersionKind } from '@console/operator-lifecycle-manager';\nimport { TopologyDataModel, TopologyDataResources, addToTopologyDataModel } from '@console/dev-console/src/components/topology';\nimport { getDynamicEventSourcesModelRefs } from '../utils/fetch-dynamic-eventsources-utils';\nimport { NodeType, transformKnNodeData } from './knative-topology-utils';\n\n/**\n * Filter out deployments not created via revisions/eventsources\n */\nexport const filterNonKnativeDeployments = (resources: DeploymentKind[], eventSources?: K8sResourceKind[]): DeploymentKind[] => {\n  const KNATIVE_CONFIGURATION = 'serving.knative.dev/configuration';\n  const isEventSourceKind = (uid: string): boolean => uid && !!eventSources?.find(eventSource => eventSource.metadata?.uid === uid);\n  return _.filter(resources, d => {\n    return !_.get(d, ['metadata', 'labels', KNATIVE_CONFIGURATION], false) && !isEventSourceKind(d.metadata?.ownerReferences?.[0].uid);\n  });\n};\n\nconst addKnativeTopologyData = (topologyDataModel: TopologyDataModel, knativeResources: K8sResourceKind[], allResources: K8sResourceKind[], type: string, resources: TopologyDataResources, operatorBackedServiceKindMap: OperatorBackedServiceKindMap, utils: Function[]) => {\n  if (!knativeResources?.length) {\n    return;\n  }\n\n  const knativeResourceDataModel = transformKnNodeData(knativeResources, type, resources, allResources, operatorBackedServiceKindMap, utils);\n\n  addToTopologyDataModel(knativeResourceDataModel, topologyDataModel);\n};\n\nconst getKnativeEventSources = (resources: TopologyDataResources): K8sResourceKind[] => {\n  const evenSourceProps = getDynamicEventSourcesModelRefs();\n  return evenSourceProps.reduce((acc, currProp) => {\n    const currPropResource = resources[currProp]?.data ?? [];\n    return [...acc, ...currPropResource];\n  }, []);\n};\n\nexport const getKnativeTopologyDataModel = (resources: TopologyDataResources, allResources: K8sResourceKind[], installedOperators: ClusterServiceVersionKind[], utils?: Function[]): TopologyDataModel => {\n  const knativeTopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(installedOperators);\n  const knSvcResources: K8sResourceKind[] = _.get(resources, ['ksservices', 'data'], []);\n  const knEventSources: K8sResourceKind[] = getKnativeEventSources(resources);\n  const knRevResources: K8sResourceKind[] = _.get(resources, ['revisions', 'data'], []);\n\n  addKnativeTopologyData(knativeTopologyDataModel, knSvcResources, allResources, NodeType.KnService, resources, operatorBackedServiceKindMap, utils);\n  addKnativeTopologyData(knativeTopologyDataModel, knEventSources, allResources, NodeType.EventSource, resources, operatorBackedServiceKindMap, utils);\n  addKnativeTopologyData(knativeTopologyDataModel, knRevResources, allResources, NodeType.Revision, resources, operatorBackedServiceKindMap, utils);\n\n  const deploymentResources: DeploymentKind[] = _.get(resources, ['deployments', 'data'], []);\n  resources.deployments.data = filterNonKnativeDeployments(deploymentResources, knEventSources);\n\n  return knativeTopologyDataModel;\n};\n","import { EdgeModel, NodeModel, NodeShape } from '@console/topology';\nimport {\n  TopologyDataModel as DataModel,\n  TopologyDataObject,\n  dataObjectFromModel,\n  Group,\n  Node,\n  Edge,\n  NODE_HEIGHT,\n  NODE_PADDING,\n  NODE_WIDTH,\n  TopologyFilters as Filters,\n} from '@console/dev-console/src/components/topology';\nimport {\n  KNATIVE_GROUP_NODE_HEIGHT,\n  KNATIVE_GROUP_NODE_PADDING,\n  KNATIVE_GROUP_NODE_WIDTH,\n  TYPE_EVENT_SOURCE,\n  TYPE_KNATIVE_SERVICE,\n} from './const';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKnativeGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\nexport const getKnativeNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_EVENT_SOURCE) {\n    const hidden = filters && !filters.display.eventSources;\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      visible: !hidden,\n      label: model.topology[d.id].name,\n      data: model.topology[d.id],\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  }\n  if (d.type === TYPE_KNATIVE_SERVICE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.children && d.children.map((id) => model.topology[id]);\n    return {\n      width: KNATIVE_GROUP_NODE_WIDTH,\n      height: KNATIVE_GROUP_NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      visible: true,\n      label: model.topology[d.id].name,\n      data,\n      collapsed: filters && !filters.display.knativeServices,\n      children: d.children,\n      group: true,\n      shape: NodeShape.rect,\n      style: {\n        padding: KNATIVE_GROUP_NODE_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKnativeEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","import * as _ from 'lodash';\nimport { Node as TopologyNode } from '@console/topology';\nimport {\n  K8sResourceKind,\n  apiVersionForModel,\n  referenceFor,\n  modelFor,\n  k8sUpdate,\n  PodKind,\n} from '@console/internal/module/k8s';\nimport {\n  TransformResourceData,\n  getResourcePausedAlert,\n  getBuildAlerts,\n  getOwnedResources,\n  OperatorBackedServiceKindMap,\n  getBuildConfigsForResource,\n} from '@console/shared';\nimport {\n  Node,\n  Edge,\n  TopologyDataResources,\n  TopologyDataModel,\n  TopologyDataObject,\n  getTopologyGroupItems,\n  createTopologyNodeData,\n  getTopologyNodeItem,\n  getTopologyEdgeItems,\n  mergeGroup,\n  filterBasedOnActiveApplication,\n  getTopologyResourceObject,\n  TopologyOverviewItem,\n} from '@console/dev-console/src/components/topology';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { DeploymentModel } from '@console/internal/models';\nimport { RootState } from '@console/internal/redux';\nimport { FLAG_KNATIVE_EVENTING } from '../const';\nimport { ServiceModel as knServiceModel } from '../models';\nimport { KnativeItem } from '../utils/get-knative-resources';\n\nexport enum NodeType {\n  EventSource = 'event-source',\n  KnService = 'knative-service',\n  Revision = 'knative-revision',\n}\n\nexport enum EdgeType {\n  Traffic = 'revision-traffic',\n  EventSource = 'event-source-link',\n}\n\ntype RevK8sResourceKind = K8sResourceKind & {\n  resources?: { [key: string]: any };\n};\n/**\n * returns if event source is enabled or not\n * @param Flags\n */\nexport const getEventSourceStatus = ({ FLAGS }: RootState): boolean =>\n  FLAGS.get(FLAG_KNATIVE_EVENTING);\n\n/**\n * fetch the parent resource from a resource\n * @param resource\n * @param resources\n */\nexport const getParentResource = (\n  resource: K8sResourceKind,\n  resources: K8sResourceKind[],\n): K8sResourceKind => {\n  const parentUids = _.map(\n    _.get(resource, ['metadata', 'ownerReferences'], []),\n    (owner) => owner.uid,\n  );\n  const [resourcesParent] = _.filter(resources, ({ metadata: { uid } }) =>\n    parentUids.includes(uid),\n  );\n  return resourcesParent;\n};\n\n/**\n * Filters revision based on active application\n * @param revisions\n * @param resources\n * @param application\n */\nexport const filterRevisionsByActiveApplication = (\n  revisions: K8sResourceKind[],\n  resources: TopologyDataResources,\n  application: string,\n) => {\n  const filteredRevisions = [];\n  _.forEach(revisions, (revision) => {\n    const configuration = getParentResource(revision, resources.configurations.data);\n    const service = getParentResource(configuration, resources.ksservices.data);\n    const hasTraffic =\n      service &&\n      service.status &&\n      _.find(service.status.traffic, { revisionName: revision.metadata.name });\n    const isServicePartofGroup = filterBasedOnActiveApplication([service], application).length > 0;\n    if (hasTraffic && isServicePartofGroup) {\n      filteredRevisions.push(revision);\n    }\n  });\n  return filteredRevisions;\n};\n\n/**\n * Forms data with respective revisions, configurations, routes based on kntaive service\n */\nexport const getKnativeServiceData = (\n  resource: K8sResourceKind,\n  resources: TopologyDataResources,\n  utils?: Function[],\n): KnativeItem => {\n  const configurations = getOwnedResources(resource, resources.configurations.data);\n  const revisions =\n    configurations && configurations.length\n      ? getOwnedResources(configurations[0], resources.revisions.data)\n      : undefined;\n  const revisionsDeploymentData = _.reduce(\n    revisions,\n    (acc, revision) => {\n      let revisionDep: RevK8sResourceKind = revision;\n      let pods: PodKind[];\n      if (resources.deployments) {\n        const transformResourceData = new TransformResourceData(resources);\n        const associatedDeployment = getOwnedResources(revision, resources.deployments.data);\n        if (!_.isEmpty(associatedDeployment)) {\n          const depObj: K8sResourceKind = {\n            ...associatedDeployment[0],\n            apiVersion: apiVersionForModel(DeploymentModel),\n            kind: DeploymentModel.kind,\n          };\n          const replicaSets = transformResourceData.getReplicaSetsForResource(depObj);\n          const [current, previous] = replicaSets;\n          pods = [..._.get(current, 'pods', []), ..._.get(previous, 'pods', [])];\n          revisionDep = { ...revisionDep, resources: { pods, current } };\n        }\n      }\n      acc.revisionsDep.push(revisionDep);\n      pods && acc.allPods.push(...pods);\n      return acc;\n    },\n    { revisionsDep: [], allPods: [] },\n  );\n  const ksroutes = resources.ksroutes\n    ? getOwnedResources(resource, resources.ksroutes.data)\n    : undefined;\n  const buildConfigs = getBuildConfigsForResource(resource, resources);\n  const overviewItem = {\n    configurations,\n    revisions: revisionsDeploymentData.revisionsDep,\n    ksroutes,\n    buildConfigs,\n    pods: revisionsDeploymentData.allPods,\n  };\n  if (utils) {\n    return utils.reduce((acc, element) => {\n      return { ...acc, ...element(resource, resources) };\n    }, overviewItem);\n  }\n  return overviewItem;\n};\n\n/**\n * Rollup data for deployments for revisions/ event sources\n */\nconst createKnativeDeploymentItems = (\n  resource: K8sResourceKind,\n  resources: TopologyDataResources,\n  utils?: Function[],\n): TopologyOverviewItem => {\n  const transformResourceData = new TransformResourceData(resources, utils);\n  const associatedDeployment = getOwnedResources(resource, resources.deployments.data);\n  if (!_.isEmpty(associatedDeployment)) {\n    const depObj: K8sResourceKind = {\n      ...associatedDeployment[0],\n      apiVersion: apiVersionForModel(DeploymentModel),\n      kind: DeploymentModel.kind,\n    };\n    const replicaSets = transformResourceData.getReplicaSetsForResource(depObj);\n    const [current, previous] = replicaSets;\n    const isRollingOut = !!current && !!previous;\n    const buildConfigs = transformResourceData.getBuildConfigsForResource(depObj);\n    const services = transformResourceData.getServicesForResource(depObj);\n    const routes = transformResourceData.getRoutesForServices(services);\n    const alerts = {\n      ...getResourcePausedAlert(depObj),\n      ...getBuildAlerts(buildConfigs),\n    };\n    const overviewItems = {\n      obj: resource,\n      alerts,\n      buildConfigs,\n      current,\n      isRollingOut,\n      previous,\n      pods: [..._.get(current, 'pods', []), ..._.get(previous, 'pods', [])],\n      routes,\n      services,\n    };\n\n    if (utils) {\n      return utils.reduce((acc, element) => {\n        return { ...acc, ...element(depObj, resources) };\n      }, overviewItems);\n    }\n    return overviewItems;\n  }\n  const knResources = getKnativeServiceData(resource, resources, utils);\n  return {\n    obj: resource,\n    buildConfigs: [],\n    routes: [],\n    services: [],\n    ...knResources,\n  };\n};\n\n/**\n * only get revision which are included in traffic data\n */\nexport const filterRevisionsBaseOnTrafficStatus = (\n  resource: K8sResourceKind,\n  revisions: K8sResourceKind[],\n): K8sResourceKind[] => {\n  if (!_.get(resource, 'status.traffic', null)) return undefined;\n  return resource.status.traffic.reduce((acc, curr) => {\n    const el = revisions.find((rev) => curr.revisionName === rev.metadata.name);\n    return el ? [...acc, el] : acc;\n  }, []);\n};\n\n/**\n * Form Node data for revisions/event/service sources\n */\nexport const getKnativeTopologyNodeItems = (\n  resource: K8sResourceKind,\n  type: string,\n  resources?: TopologyDataResources,\n): Node[] => {\n  const nodes = [];\n  const children: string[] = [];\n  if (type === NodeType.KnService && resources && resources.configurations) {\n    const configurations = getOwnedResources(resource, resources.configurations.data);\n    const configUidData = _.get(configurations[0], ['metadata', 'uid']);\n    const ChildData = _.filter(resources.revisions.data, {\n      metadata: {\n        ownerReferences: [{ uid: configUidData }],\n      },\n    });\n    _.forEach(filterRevisionsBaseOnTrafficStatus(resource, ChildData), (c) => {\n      const uidRev = c.metadata.uid;\n      children.push(uidRev);\n      nodes.push(getTopologyNodeItem(c, NodeType.Revision));\n    });\n  }\n  nodes.push(getTopologyNodeItem(resource, type, children));\n  return nodes;\n};\n\n/**\n * Form Edge data for event sources\n */\nexport const getEventTopologyEdgeItems = (resource: K8sResourceKind, { data }): Edge[] => {\n  const uid = _.get(resource, ['metadata', 'uid']);\n  const sinkSvc = _.get(resource, 'spec.sink.ref', null) || _.get(resource, 'spec.sink', null);\n  const edges = [];\n  if (sinkSvc && sinkSvc.kind === knServiceModel.kind) {\n    _.forEach(data, (res) => {\n      const resname = _.get(res, ['metadata', 'name']);\n      const resUid = _.get(res, ['metadata', 'uid']);\n      if (resname === sinkSvc.name) {\n        edges.push({\n          id: `${uid}_${resUid}`,\n          type: EdgeType.EventSource,\n          source: uid,\n          target: resUid,\n        });\n      }\n    });\n  }\n  return edges;\n};\n\n/**\n * Form Edge data for service sources with traffic data\n */\nexport const getTrafficTopologyEdgeItems = (resource: K8sResourceKind, { data }): Edge[] => {\n  const uid = _.get(resource, ['metadata', 'uid']);\n  const trafficSvc = _.get(resource, ['status', 'traffic'], []);\n  const edges = [];\n  _.forEach(trafficSvc, (res) => {\n    const resname = _.get(res, ['revisionName']);\n    const trafficPercent = _.get(res, ['percent']);\n    const revisionObj = _.find(data, (rev) => {\n      const revname = _.get(rev, ['metadata', 'name']);\n      return revname === resname;\n    });\n    const resUid = _.get(revisionObj, ['metadata', 'uid'], null);\n    if (resUid) {\n      const revisionIndex = _.findIndex(edges, (edge) => edge.id === `${uid}_${resUid}`);\n      if (revisionIndex >= 0) {\n        edges[revisionIndex].data.percent += trafficPercent;\n      } else {\n        edges.push({\n          id: `${uid}_${resUid}`,\n          type: EdgeType.Traffic,\n          source: uid,\n          target: resUid,\n          data: { percent: trafficPercent },\n        });\n      }\n    }\n  });\n  return edges;\n};\n\n/**\n * create all data that need to be shown on a topology data for knative service\n */\nexport const createTopologyServiceNodeData = (\n  svcRes: TopologyOverviewItem,\n  operatorBackedServiceKindMap: OperatorBackedServiceKindMap,\n  type: string,\n): TopologyDataObject => {\n  const { pipelines = [], pipelineRuns = [] } = svcRes;\n  const { obj: knativeSvc } = svcRes;\n  const uid = _.get(knativeSvc, 'metadata.uid');\n  const labels = _.get(knativeSvc, 'metadata.labels', {});\n  const annotations = _.get(knativeSvc, 'metadata.annotations', {});\n  const nodeResourceKind = _.get(knativeSvc, 'metadata.ownerReferences[0].kind');\n  return {\n    id: uid,\n    name: _.get(knativeSvc, 'metadata.name') || labels['app.kubernetes.io/instance'],\n    type,\n    resources: { ...svcRes },\n    operatorBackedService: nodeResourceKind in operatorBackedServiceKindMap,\n    data: {\n      url: knativeSvc.status?.url || '',\n      kind: referenceFor(knativeSvc),\n      editURL: annotations['app.openshift.io/edit-url'],\n      vcsURI: annotations['app.openshift.io/vcs-uri'],\n      isKnativeResource: true,\n      connectedPipeline: {\n        pipeline: pipelines[0],\n        pipelineRuns,\n      },\n      build: svcRes.buildConfigs?.[0]?.builds?.[0],\n    },\n  };\n};\n\nexport const transformKnNodeData = (\n  knResourcesData: K8sResourceKind[],\n  type: string,\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  operatorBackedServiceKindMap: OperatorBackedServiceKindMap,\n  utils?: Function[],\n): TopologyDataModel => {\n  const knDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const serviceBindingRequests = _.get(resources, 'serviceBindingRequests.data');\n  _.forEach(knResourcesData, (res) => {\n    const { uid } = res.metadata;\n    const item = createKnativeDeploymentItems(res, resources, utils);\n    switch (type) {\n      case NodeType.EventSource: {\n        knDataModel.topology[uid] = createTopologyNodeData(\n          item,\n          type,\n          getImageForIconClass(`icon-openshift`),\n        );\n        knDataModel.graph.nodes.push(...getKnativeTopologyNodeItems(res, type, resources));\n        knDataModel.graph.edges.push(...getEventTopologyEdgeItems(res, resources.ksservices));\n        const newGroup = getTopologyGroupItems(res);\n        mergeGroup(newGroup, knDataModel.graph.groups);\n        break;\n      }\n      case NodeType.Revision: {\n        const revisionItem = _.omit(item, ['pipelines', 'pipelineRuns', 'buildConfigs']);\n        knDataModel.topology[uid] = createTopologyNodeData(\n          revisionItem,\n          type,\n          getImageForIconClass(`icon-openshift`),\n        );\n        break;\n      }\n      case NodeType.KnService: {\n        knDataModel.topology[uid] = createTopologyServiceNodeData(\n          item,\n          operatorBackedServiceKindMap,\n          type,\n        );\n        knDataModel.graph.nodes.push(...getKnativeTopologyNodeItems(res, type, resources));\n        knDataModel.graph.edges.push(\n          ...getTrafficTopologyEdgeItems(res, resources.revisions),\n          ...getTopologyEdgeItems(res, allResources, serviceBindingRequests),\n        );\n        const newGroup = getTopologyGroupItems(res);\n        mergeGroup(newGroup, knDataModel.graph.groups);\n        break;\n      }\n      default:\n        break;\n    }\n  });\n\n  return knDataModel;\n};\n\nexport const createKnativeEventSourceSink = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n  const targetName = _.get(target, 'metadata.name');\n  const eventSourceObj = _.omit(source, 'status');\n  const sink = {\n    ref: {\n      apiVersion: target.apiVersion,\n      kind: target.kind,\n      name: targetName,\n    },\n  };\n  const updatePayload = {\n    ...eventSourceObj,\n    spec: { ...eventSourceObj.spec, sink },\n  };\n  return k8sUpdate(modelFor(referenceFor(source)), updatePayload);\n};\n\nexport const createTopologySinkConnection = (\n  source: TopologyDataObject,\n  target: TopologyDataObject,\n): Promise<K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n  const sourceObj = getTopologyResourceObject(source);\n  const targetObj = getTopologyResourceObject(target);\n\n  return createKnativeEventSourceSink(sourceObj, targetObj);\n};\n\nexport const createSinkConnection = (\n  sourceNode: TopologyNode,\n  targetNode: TopologyNode,\n): Promise<K8sResourceKind> => {\n  return createTopologySinkConnection(sourceNode.getData(), targetNode.getData());\n};\n","export const TYPE_VIRTUAL_MACHINE = 'virtual-machine';\n","import { apiVersionForModel, K8sResourceKind, referenceFor } from '@console/internal/module/k8s';\nimport {\n  OverviewItem,\n  getRoutesForServices,\n  getBuildConfigsForResource,\n  getReplicationControllersForResource,\n  getServicesForResource,\n} from '@console/shared';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport {\n  TopologyDataModel,\n  TopologyDataObject,\n  TopologyDataResources,\n  getRoutesURL,\n  addToTopologyDataModel,\n  getTopologyEdgeItems,\n  getTopologyGroupItems,\n  getTopologyNodeItem,\n  mergeGroup,\n} from '@console/dev-console/src/components/topology';\nimport { VMIKind, VMKind } from '../types';\nimport { VirtualMachineModel } from '../models';\nimport { TYPE_VIRTUAL_MACHINE } from './components/const';\nimport { findVMIPod } from '../selectors/pod/selectors';\nimport { getVMStatus } from '../statuses/vm/vm-status';\nimport { V1alpha1DataVolume } from '../types/vm/disk/V1alpha1DataVolume';\nimport { VMImportKind } from '../types/vm-import/ovirt/vm-import';\nimport { VMNodeData } from './types';\n\nexport const kubevirtAllowedResources = ['virtualmachines'];\n\nexport const getOperatingSystemImage = (vm: VMKind, templates: K8sResourceKind[]): string => {\n  const templateName = vm.metadata?.labels?.['vm.kubevirt.io/template'];\n  const template = templateName && templates.find((t) => t.metadata.name === templateName);\n  if (!template) {\n    return '';\n  }\n\n  return getImageForIconClass(template.metadata.annotations.iconClass);\n};\n\nexport const createVMOverviewItem = (vm: VMKind, vmi: VMIKind, resources: any): OverviewItem => {\n  const obj: K8sResourceKind = {\n    ...vm,\n    apiVersion: apiVersionForModel(VirtualMachineModel),\n    kind: VirtualMachineModel.kind,\n  };\n  const { visibleReplicationControllers } = getReplicationControllersForResource(obj, resources);\n  const [current, previous] = visibleReplicationControllers;\n  const buildConfigs = getBuildConfigsForResource(obj, resources);\n  const services = getServicesForResource(obj, resources);\n  const routes = getRoutesForServices(services, resources);\n  const laucherPod = findVMIPod(vmi, resources.pods.data);\n  const pods = laucherPod ? [laucherPod] : [];\n  return {\n    buildConfigs,\n    current,\n    obj,\n    previous,\n    pods,\n    routes,\n    services,\n    isMonitorable: false,\n    isOperatorBackedService: false,\n  };\n};\n\nexport const createVMOverviewItems = (resources: any): OverviewItem[] => {\n  if (!resources.virtualmachines?.data.length) {\n    return [];\n  }\n\n  return resources.virtualmachines.data.map((vm: any) => {\n    const { name } = vm.metadata;\n    const vmis = resources.virtualmachineinstances.data;\n    const vmi = vmis.find((instance) => instance.metadata.name === name) as VMIKind;\n\n    return createVMOverviewItem(vm, vmi, resources);\n  });\n};\n\nconst createTopologyVMNodeData = (\n  vmOverview: OverviewItem,\n  resources: TopologyDataResources,\n): TopologyDataObject<VMNodeData> => {\n  const vm = vmOverview.obj as VMKind;\n  const { uid, name, labels } = vm.metadata;\n  const vmis = resources.virtualmachineinstances?.data;\n  const vmi = vmis.find((instance) => instance.metadata.name === name) as VMIKind;\n  const pods = resources.pods?.data;\n  const migrations = resources.migrations?.data;\n  const dataVolumes = resources.dataVolumes?.data as V1alpha1DataVolume[];\n  const vmImports = resources.vmImports?.data as VMImportKind[];\n\n  const vmStatusBundle = getVMStatus({\n    vm,\n    vmi,\n    pods,\n    migrations,\n    dataVolumes,\n    vmImports,\n  });\n\n  return {\n    id: uid,\n    name: name || labels['app.kubernetes.io/instance'],\n    type: TYPE_VIRTUAL_MACHINE,\n    resources: vmOverview,\n    operatorBackedService: false,\n    data: {\n      url: getRoutesURL(vmOverview),\n      kind: referenceFor(vm),\n      vmi,\n      vmStatusBundle,\n      osImage: getOperatingSystemImage(vm as VMKind, resources.virtualmachinetemplates.data),\n    },\n  };\n};\n\nexport const getKubevirtTopologyDataModel = (\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  installedOperators,\n  utils: Function[],\n  transformBy: string[],\n  serviceBindingRequests: K8sResourceKind[],\n): TopologyDataModel => {\n  const vmsDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const vmsResources = [];\n\n  if (resources.virtualmachines?.data.length) {\n    const typedDataModel: TopologyDataModel = {\n      graph: { nodes: [], edges: [], groups: [] },\n      topology: {},\n    };\n\n    const vmOverviewItems = createVMOverviewItems(resources);\n    vmOverviewItems.forEach((vmOverview: OverviewItem) => {\n      const vm = vmOverview.obj;\n      const { uid } = vm.metadata;\n      vmsResources.push(uid);\n      typedDataModel.topology[uid] = createTopologyVMNodeData(vmOverview, resources);\n      typedDataModel.graph.nodes.push(getTopologyNodeItem(vm, TYPE_VIRTUAL_MACHINE));\n      typedDataModel.graph.edges.push(\n        ...getTopologyEdgeItems(vm, allResources, serviceBindingRequests),\n      );\n      mergeGroup(getTopologyGroupItems(vm), typedDataModel.graph.groups);\n    });\n\n    addToTopologyDataModel(typedDataModel, vmsDataModel);\n  }\n\n  return vmsDataModel;\n};\n","import { NodeModel, EdgeModel } from '@console/topology';\nimport {\n  TopologyFilters as Filters,\n  TopologyDataModel as DataModel,\n  TopologyDataObject,\n  Node,\n  Group,\n  Edge,\n  dataObjectFromModel,\n  NODE_HEIGHT,\n  NODE_PADDING,\n  NODE_WIDTH,\n} from '@console/dev-console/src/components/topology';\nimport { TYPE_VIRTUAL_MACHINE } from './components/const';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKubevirtGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKubevirtNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_VIRTUAL_MACHINE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    const hidden = filters && !filters.display.virtualMachines;\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: model.topology[d.id].name,\n      data,\n      visible: !hidden,\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKubevirtEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport * as classNames from 'classnames';\nimport { sortable } from '@patternfly/react-table';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { AddHealthChecks, EditHealthChecks } from '@console/app/src/actions/modify-health-checks';\nimport { K8sResourceKind } from '../module/k8s';\nimport { DetailsPage, ListPage, Table, TableRow, TableData, RowFunction } from './factory';\nimport { AsyncComponent, DetailsItem, Kebab, KebabAction, ContainerTable, detailsPage, LabelList, navFactory, PodsComponent, ResourceKebab, ResourceLink, ResourceSummary, SectionHeading, Selector, LoadingInline } from './utils';\nimport { ResourceEventStream } from './events';\nimport { VolumesTable } from './volumes-table';\nimport { DaemonSetModel } from '../models';\nimport { PodRingController, PodRing } from '@console/shared';\nimport { ResourceLabel } from '../models/hypercloud/resource-plural';\n\nexport const menuActions: KebabAction[] = [AddHealthChecks, Kebab.factory.AddStorage, ...Kebab.getExtensionsActionsForKind(DaemonSetModel), EditHealthChecks, ...Kebab.factory.common];\n\nconst kind = 'DaemonSet';\n\nconst tableColumnClasses = ['', '', classNames('pf-m-hidden', 'pf-m-visible-on-sm', 'pf-u-w-16-on-lg'), classNames('pf-m-hidden', 'pf-m-visible-on-lg'), classNames('pf-m-hidden', 'pf-m-visible-on-lg'), Kebab.columnClass];\n\nconst DaemonSetTableHeader = (t?: TFunction) => {\n  return [\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_1'),\n      sortField: 'metadata.name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_2'),\n      sortField: 'metadata.namespace',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_3'),\n      sortFunc: 'daemonsetNumScheduled',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_15'),\n      sortField: 'metadata.labels',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_16'),\n      sortField: 'spec.selector',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[4] },\n    },\n    {\n      title: '',\n      props: { className: tableColumnClasses[5] },\n    },\n  ];\n};\nDaemonSetTableHeader.displayName = 'DaemonSetTableHeader';\n\nconst DaemonSetTableRow: RowFunction<K8sResourceKind> = ({ obj: daemonset, index, key, style }) => {\n  return (\n    <TableRow id={daemonset.metadata.uid} index={index} trKey={key} style={style}>\n      <TableData className={tableColumnClasses[0]}>\n        <ResourceLink kind={kind} name={daemonset.metadata.name} namespace={daemonset.metadata.namespace} title={daemonset.metadata.uid} />\n      </TableData>\n      <TableData className={classNames(tableColumnClasses[1], 'co-break-word')}>\n        <ResourceLink kind=\"Namespace\" name={daemonset.metadata.namespace} title={daemonset.metadata.namespace} />\n      </TableData>\n      <TableData className={tableColumnClasses[2]}>\n        <Link to={`/k8s/ns/${daemonset.metadata.namespace}/daemonsets/${daemonset.metadata.name}/pods`} title=\"pods\">\n          {daemonset.status.currentNumberScheduled} of {daemonset.status.desiredNumberScheduled} pods\n        </Link>\n      </TableData>\n      <TableData className={tableColumnClasses[3]}>\n        <LabelList kind={kind} labels={daemonset.metadata.labels} />\n      </TableData>\n      <TableData className={tableColumnClasses[4]}>\n        <Selector selector={daemonset.spec.selector} namespace={daemonset.metadata.namespace} />\n      </TableData>\n      <TableData className={tableColumnClasses[5]}>\n        <ResourceKebab actions={menuActions} kind={kind} resource={daemonset} />\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const DaemonSetDetailsList: React.FC<DaemonSetDetailsListProps> = ({ ds }) => {\n  const { t } = useTranslation();\n  return (\n    <dl className=\"co-m-pane__details\">\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_38')} obj={ds} path=\"status.currentNumberScheduled\" />\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_39')} obj={ds} path=\"status.desiredNumberScheduled\" />\n    </dl>\n  );\n};\n\nconst DaemonSetDetails: React.FC<DaemonSetDetailsProps> = ({ obj: daemonset }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', { 0: ResourceLabel(daemonset, t) })} />\n        <PodRingController\n          namespace={daemonset.metadata.namespace}\n          kind={daemonset.kind}\n          render={d => {\n            return d.loaded ? <PodRing key={daemonset.metadata.uid} pods={d.data[daemonset.metadata.uid].pods} obj={daemonset} resourceKind={DaemonSetModel} enableScaling={false} /> : <LoadingInline />;\n          }}\n        />\n        <div className=\"row\">\n          <div className=\"col-lg-6\">\n            <ResourceSummary resource={daemonset} showPodSelector showNodeSelector showTolerations />\n          </div>\n          <div className=\"col-lg-6\">\n            <DaemonSetDetailsList ds={daemonset} />\n          </div>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_1')} />\n        <ContainerTable containers={daemonset.spec.template.spec.containers} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <VolumesTable resource={daemonset} heading={t('COMMON:MSG_DETAILS_TABDETAILS_VOLUMES_TABLEHEADER_1')} />\n      </div>\n    </>\n  );\n};\n\nconst EnvironmentPage: React.FC<EnvironmentPageProps> = props => <AsyncComponent loader={() => import('./environment.jsx').then(c => c.EnvironmentPage)} {...props} />;\n\nconst envPath = ['spec', 'template', 'spec', 'containers'];\nconst EnvironmentTab: React.FC<EnvironmentTabProps> = props => <EnvironmentPage obj={props.obj} rawEnvData={props.obj.spec.template.spec} envPath={envPath} readOnly={false} />;\nconst { details, pods, editYaml, envEditor, events } = navFactory;\nexport const DaemonSets: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Daemon Sets\" Header={DaemonSetTableHeader.bind(null, t)} Row={DaemonSetTableRow} virtualize />;\n};\n\nexport const DaemonSetsPage: React.FC<DaemonSetsPageProps> = props => {\n  const { t } = useTranslation();\n  return <ListPage title={t('COMMON:MSG_LNB_MENU_30')} createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_30') })} canCreate={true} ListComponent={DaemonSets} kind={kind} {...props} />;\n};\n\nconst DaemonSetPods: React.FC<DaemonSetPodsProps> = props => <PodsComponent {...props} customData={{ showNodes: true }} />;\n\nexport const DaemonSetsDetailsPage: React.FC<DaemonSetsDetailsPageProps> = props => <DetailsPage {...props} kind={kind} menuActions={menuActions} pages={[details(detailsPage(DaemonSetDetails)), editYaml(), pods(DaemonSetPods), envEditor(EnvironmentTab), events(ResourceEventStream)]} />;\n\ntype DaemonSetDetailsListProps = {\n  ds: K8sResourceKind;\n};\n\ntype EnvironmentPageProps = {\n  obj: K8sResourceKind;\n  rawEnvData: any;\n  envPath: string[];\n  readOnly: boolean;\n};\n\ntype EnvironmentTabProps = {\n  obj: K8sResourceKind;\n};\n\ntype DaemonSetDetailsProps = {\n  obj: K8sResourceKind;\n};\n\ntype DaemonSetsPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype DaemonSetPodsProps = {\n  obj: K8sResourceKind;\n};\n\ntype DaemonSetsDetailsPageProps = {\n  match: any;\n};\n","import * as React from 'react';\n\nimport { Status, PodRingController } from '@console/shared';\nimport PodRingSet from '@console/shared/src/components/pod/PodRingSet';\nimport { AddHealthChecks, EditHealthChecks } from '@console/app/src/actions/modify-health-checks';\nimport { DeploymentModel } from '../models';\nimport { DeploymentKind, K8sKind, K8sResourceKindReference } from '../module/k8s';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { configureUpdateStrategyModal, errorModal } from './modals';\nimport { Conditions } from './conditions';\nimport { ResourceEventStream } from './events';\nimport { VolumesTable } from './volumes-table';\nimport { DetailsPage, ListPage, Table, RowFunction } from './factory';\nimport { AsyncComponent, DetailsItem, Kebab, KebabAction, ContainerTable, navFactory, pluralize, ResourceSummary, SectionHeading, togglePaused, WorkloadPausedAlert, LoadingInline } from './utils';\nimport { ReplicaSetsPage } from './replicaset';\nimport { WorkloadTableRow, WorkloadTableHeader } from './workload-table';\nimport { ResourceLabel } from '../models/hypercloud/resource-plural';\n\nconst deploymentsReference: K8sResourceKindReference = 'Deployment';\nconst { ModifyCount, AddStorage, common } = Kebab.factory;\n\nconst UpdateStrategy: KebabAction = (kind: K8sKind, deployment: DeploymentKind) => {\n  const { t } = useTranslation();\n  return {\n    label: t('COMMON:MSG_MAIN_ACTIONBUTTON_8'),\n    callback: () => configureUpdateStrategyModal({ deployment }),\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: deployment.metadata.name,\n      namespace: deployment.metadata.namespace,\n      verb: 'patch',\n    },\n  };\n};\n\nconst PauseAction: KebabAction = (kind: K8sKind, obj: DeploymentKind) => {\n  const { t } = useTranslation();\n  return {\n    label: obj.spec.paused ? t('COMMON:MSG_MAIN_ACTIONBUTTON_37') : t('COMMON:MSG_MAIN_ACTIONBUTTON_12'),\n    callback: () => togglePaused(kind, obj).catch(err => errorModal({ error: err.message })),\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: obj.metadata.name,\n      namespace: obj.metadata.namespace,\n      verb: 'patch',\n    },\n  };\n};\n\nexport const menuActions = [ModifyCount, PauseAction, AddHealthChecks, AddStorage, UpdateStrategy, ...Kebab.getExtensionsActionsForKind(DeploymentModel), EditHealthChecks, ...common];\n\nexport const DeploymentDetailsList: React.FC<DeploymentDetailsListProps> = ({ deployment }) => {\n  const { t } = useTranslation();\n  return (\n    <dl className=\"co-m-pane__details\">\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_25')} obj={deployment} path=\"spec.strategy.type\" />\n      {deployment.spec.strategy.type === 'RollingUpdate' && (\n        <>\n          <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_26')} obj={deployment} path=\"spec.strategy.rollingUpdate.maxUnavailable\">\n            {deployment.spec.strategy.rollingUpdate.maxUnavailable || 1} of {pluralize(deployment.spec.replicas, 'pod')}\n          </DetailsItem>\n          <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_27')} obj={deployment} path=\"spec.strategy.rollingUpdate.maxSurge\">\n            {deployment.spec.strategy.rollingUpdate.maxSurge || 1} greater than {pluralize(deployment.spec.replicas, 'pod')}\n          </DetailsItem>\n        </>\n      )}\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_28')} obj={deployment} path=\"spec.progressDeadlineSeconds\">\n        {deployment.spec.progressDeadlineSeconds ? pluralize(deployment.spec.progressDeadlineSeconds, 'second') : 'Not Configured'}\n      </DetailsItem>\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_29')} obj={deployment} path=\"spec.minReadySeconds\">\n        {deployment.spec.minReadySeconds ? pluralize(deployment.spec.minReadySeconds, 'second') : 'Not Configured'}\n      </DetailsItem>\n    </dl>\n  );\n};\nDeploymentDetailsList.displayName = 'DeploymentDetailsList';\n\nconst DeploymentDetails: React.FC<DeploymentDetailsProps> = ({ obj: deployment }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', { 0: ResourceLabel(deployment, t) })} />\n        {deployment.spec.paused && <WorkloadPausedAlert obj={deployment} model={DeploymentModel} />}\n        <PodRingController\n          namespace={deployment.metadata.namespace}\n          kind={deployment.kind}\n          render={d => {\n            return d.loaded ? <PodRingSet key={deployment.metadata.uid} podData={d.data[deployment.metadata.uid]} obj={deployment} resourceKind={DeploymentModel} path=\"/spec/replicas\" /> : <LoadingInline />;\n          }}\n        />\n        <div className=\"co-m-pane__body-group\">\n          <div className=\"row\">\n            <div className=\"col-sm-6\">\n              <ResourceSummary resource={deployment} showPodSelector showNodeSelector showTolerations>\n                <dt>{t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_13')}</dt>\n                <dd>{deployment.status.availableReplicas === deployment.status.updatedReplicas && deployment.spec.replicas === deployment.status.availableReplicas ? <Status status=\"Up to date\" /> : <Status status=\"Updating\" />}</dd>\n              </ResourceSummary>\n            </div>\n            <div className=\"col-sm-6\">\n              <DeploymentDetailsList deployment={deployment} />\n            </div>\n          </div>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_1')} />\n        <ContainerTable containers={deployment.spec.template.spec.containers} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <VolumesTable resource={deployment} heading={t('COMMON:MSG_DETAILS_TABDETAILS_VOLUMES_TABLEHEADER_1')} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONDITIONS_1')} />\n        <Conditions conditions={deployment.status.conditions} />\n      </div>\n    </>\n  );\n};\nDeploymentDetails.displayName = 'DeploymentDetails';\n\nconst EnvironmentPage = props => <AsyncComponent loader={() => import('./environment.jsx').then(c => c.EnvironmentPage)} {...props} />;\n\nconst envPath = ['spec', 'template', 'spec', 'containers'];\nconst environmentComponent = props => <EnvironmentPage obj={props.obj} rawEnvData={props.obj.spec.template.spec} envPath={envPath} readOnly={false} />;\n\nconst ReplicaSetsTab: React.FC<ReplicaSetsTabProps> = ({ obj }) => {\n  const {\n    metadata: { namespace },\n    spec: { selector },\n  } = obj;\n\n  // Hide the create button to avoid confusion when showing replica sets for an object.\n  return <ReplicaSetsPage showTitle={false} namespace={namespace} selector={selector} canCreate={false} />;\n};\n\nconst { details, editYaml, pods, envEditor, events } = navFactory;\nexport const DeploymentsDetailsPage: React.FC<DeploymentsDetailsPageProps> = props => {\n  const { t } = useTranslation();\n  return (\n    <DetailsPage\n      {...props}\n      kind={deploymentsReference}\n      menuActions={menuActions}\n      pages={[\n        details(DeploymentDetails),\n        editYaml(),\n        {\n          href: 'replicasets',\n          name: t('COMMON:MSG_LNB_MENU_31'),\n          component: ReplicaSetsTab,\n        },\n        pods(),\n        envEditor(environmentComponent),\n        events(ResourceEventStream),\n      ]}\n    />\n  );\n};\nDeploymentsDetailsPage.displayName = 'DeploymentsDetailsPage';\n\ntype DeploymentDetailsListProps = {\n  deployment: DeploymentKind;\n};\n\ntype DeploymentDetailsProps = {\n  obj: DeploymentKind;\n};\n\nconst kind = 'Deployment';\n\nconst DeploymentTableRow: RowFunction<DeploymentKind> = ({ obj, index, key, style }) => {\n  return <WorkloadTableRow obj={obj} index={index} rowKey={key} style={style} menuActions={menuActions} kind={kind} />;\n};\n\nconst DeploymentTableHeader = (t?: TFunction) => {\n  return WorkloadTableHeader(t);\n};\nDeploymentTableHeader.displayName = 'DeploymentTableHeader';\n\nexport const DeploymentsList: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Deployments\" Header={DeploymentTableHeader.bind(null, t)} Row={DeploymentTableRow} virtualize />;\n};\nDeploymentsList.displayName = 'DeploymentsList';\n\nexport const DeploymentsPage: React.FC<DeploymentsPageProps> = props => {\n  const { t } = useTranslation();\n  return <ListPage title={t('COMMON:MSG_LNB_MENU_24')} createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_24') })} kind={deploymentsReference} canCreate={true} ListComponent={DeploymentsList} {...props} />;\n};\nDeploymentsPage.displayName = 'DeploymentsPage';\n\ntype ReplicaSetsTabProps = {\n  obj: DeploymentKind;\n};\n\ntype DeploymentsPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype DeploymentsDetailsPageProps = {\n  match: any;\n};\n","import * as React from 'react';\n\nimport PodRingSet from '@console/shared/src/components/pod/PodRingSet';\nimport { PodRingController } from '@console/shared';\nimport { AddHealthChecks, EditHealthChecks } from '@console/app/src/actions/modify-health-checks';\nimport { K8sResourceKind } from '../module/k8s';\nimport { ResourceEventStream } from './events';\nimport { DetailsPage, ListPage, Table, RowFunction } from './factory';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { WorkloadTableRow, WorkloadTableHeader } from './workload-table';\n\nimport { AsyncComponent, Kebab, KebabAction, ContainerTable, ResourceSummary, SectionHeading, navFactory, LoadingInline, PodsComponent } from './utils';\nimport { VolumesTable } from './volumes-table';\nimport { StatefulSetModel } from '../models';\nimport { ResourceLabel } from '../models/hypercloud/resource-plural';\n\nconst { AddStorage, common, ModifyCount } = Kebab.factory;\nexport const menuActions: KebabAction[] = [AddHealthChecks, ModifyCount, AddStorage, ...Kebab.getExtensionsActionsForKind(StatefulSetModel), EditHealthChecks, ...common];\n\nconst kind = 'StatefulSet';\n\nconst StatefulSetTableRow: RowFunction<K8sResourceKind> = ({ obj, index, key, style }) => {\n  return <WorkloadTableRow obj={obj} index={index} rowKey={key} style={style} menuActions={menuActions} kind={kind} />;\n};\n\nconst StatefulSetTableHeader = (t?: TFunction) => {\n  return WorkloadTableHeader(t);\n};\nStatefulSetTableHeader.displayName = 'StatefulSetTableHeader';\n\nconst StatefulSetDetails: React.FC<StatefulSetDetailsProps> = ({ obj: ss }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', {0: ResourceLabel(ss, t)})} />\n        <PodRingController\n          namespace={ss.metadata.namespace}\n          kind={ss.kind}\n          render={d => {\n            return d.loaded ? <PodRingSet key={ss.metadata.uid} podData={d.data[ss.metadata.uid]} obj={ss} resourceKind={StatefulSetModel} path=\"/spec/replicas\" /> : <LoadingInline />;\n          }}\n        />\n        <ResourceSummary resource={ss} showPodSelector showNodeSelector showTolerations />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_1')} />\n        <ContainerTable containers={ss.spec.template.spec.containers} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <VolumesTable resource={ss} heading={t('COMMON:MSG_DETAILS_TABDETAILS_VOLUMES_TABLEHEADER_1')} />\n      </div>\n    </>\n  );\n};\n\nconst EnvironmentPage: React.FC<EnvironmentPageProps> = props => <AsyncComponent loader={() => import('./environment.jsx').then(c => c.EnvironmentPage)} {...props} />;\n\nconst envPath = ['spec', 'template', 'spec', 'containers'];\nconst EnvironmentTab: React.FC<EnvironmentTabProps> = props => <EnvironmentPage obj={props.obj} rawEnvData={props.obj.spec.template.spec} envPath={envPath} readOnly={false} />;\n\nexport const StatefulSetsList: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Stateful Sets\" Header={StatefulSetTableHeader.bind(null, t)} Row={StatefulSetTableRow} virtualize />;\n};\nexport const StatefulSetsPage: React.FC<StatefulSetsPageProps> = props => {\n  const { t } = useTranslation();\n  return <ListPage {...props} title={t('COMMON:MSG_LNB_MENU_25')} createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_25') })} ListComponent={StatefulSetsList} kind={kind} canCreate={true} />;\n};\n\nconst StatefulSetPods: React.FC<StatefulSetPodsProps> = props => <PodsComponent {...props} customData={{ showNodes: true }} />;\n\nconst pages = [navFactory.details(StatefulSetDetails), navFactory.editYaml(), navFactory.pods(StatefulSetPods), navFactory.envEditor(EnvironmentTab), navFactory.events(ResourceEventStream)];\n\nexport const StatefulSetsDetailsPage: React.FC<StatefulSetsDetailsPageProps> = props => <DetailsPage {...props} kind={kind} menuActions={menuActions} pages={pages} />;\n\ntype EnvironmentPageProps = {\n  obj: K8sResourceKind;\n  rawEnvData: any;\n  envPath: string[];\n  readOnly: boolean;\n};\n\ntype EnvironmentTabProps = {\n  obj: K8sResourceKind;\n};\n\ntype StatefulSetDetailsProps = {\n  obj: K8sResourceKind;\n};\n\ntype StatefulSetsPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype StatefulSetPodsProps = {\n  obj: K8sResourceKind;\n};\n\ntype StatefulSetsDetailsPageProps = {\n  match: any;\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAEA;AACA;AAEA;AAOA;AAOA;AAMA;AAOA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AAGA;AACA;AAEA;AAIA;AAEA;AACA;AAIA;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AACA;AACA;AACA;AACA;AAoBA;AAEA;;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAYA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AACA;AAaA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AAIA;AAEA;;;;;;;;;;;;AC1CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAKA;AAEA;AACA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAGA;AAQA;AAPA;AACA;AAEA;AACA;AACA;AAKA;AAEA;;;;;;;;;;;;ACpBA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAIA;;;;;;;;;;;;ACbA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzCA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AA8BA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AC3QA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;;;;ACNA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;;;;;;;;;;;;AClCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAGA;AACA;AACA;AAIA;AAEA;AACA;;;;;;;;;;;;AC7DA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;;;;;;;;;;;;ACvCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;AChCA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AASA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;ACpBA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAMA;AAEA;AAIA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAOA;AAEA;;;;;;;;;;;;;ACnIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AAEA;;;;;;;;;;;;ACrDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AAKA;AAEA;;;;;;;;;;;;ACzDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAMA;AAEA;;;;;;;;;;;;;AC1DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;AAAA;;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;;;;;;;;AClDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAGA;AAEA;AACA;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;ACbA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAYA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAgBA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;;;;;;;;;;;;ACxDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAsBA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAWA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACpGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AASA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AAKA;AAEA;AAKA;AAEA;;;;;;;;;;;;AC9CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AAOA;AAIA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAGA;AAEA;AAEA;;AAAA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;ACjIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACtJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACtGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACmGA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAqHA;;;;;;;;;;;;;ACpQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACpJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAYA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAQA;AAQA;AAeA;AACA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAKA;;;AAGA;AACA;AAGA;;;;AAIA;AACA;AAIA;AAIA;AAGA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;;AAEA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;;;;;;;;;;;;;ACxcA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAYA;AACA;AACA;AACA;AAKA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAAA;AAEA;AACA;;AAAA;AAIA;AAGA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;A","sourceRoot":""}