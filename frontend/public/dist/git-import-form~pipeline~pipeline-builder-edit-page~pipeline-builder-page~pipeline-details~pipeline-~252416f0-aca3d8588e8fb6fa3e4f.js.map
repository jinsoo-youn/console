{"version":3,"file":"git-import-form~pipeline~pipeline-builder-edit-page~pipeline-builder-page~pipeline-details~pipeline-~252416f0-aca3d8588e8fb6fa3e4f.js","sources":["webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualization.scss?2470","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualization.tsx","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualizationStepList.scss?0c61","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualizationStepList.tsx","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualizationTask.scss?4028","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualizationTask.tsx","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/StatusIcon.tsx","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/TaskComponentTaskStatus.tsx","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/pipeline-step-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/BuilderNode.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/ErrorNodeDecorator.scss?37f1","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/ErrorNodeDecorator.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/InvalidTaskListNode.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/PipelineTopologyGraph.scss?32fd","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/PipelineTopologyGraph.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/PipelineVisualizationSurface.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/PlusNodeDecorator.scss?dc56","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/PlusNodeDecorator.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/SpacerNode.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/TaskEdge.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/TaskListNode.scss?67df","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/TaskListNode.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/TaskNode.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/const.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/draw-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/factories.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-topology/utils.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Alert } from '@patternfly/react-core';\nimport { Pipeline, PipelineRun } from '../../../../utils/pipeline-augment';\nimport PipelineTopologyGraph from '../../pipeline-topology/PipelineTopologyGraph';\nimport { getTopologyNodesEdges } from '../../pipeline-topology/utils';\nimport { PipelineLayout } from '../../pipeline-topology/const';\n\nimport './PipelineVisualization.scss';\n\ninterface PipelineTopologyVisualizationProps {\n  pipeline: Pipeline;\n  pipelineRun?: PipelineRun;\n}\n\nconst PipelineVisualization: React.FC<PipelineTopologyVisualizationProps> = ({\n  pipeline,\n  pipelineRun,\n}) => {\n  const { nodes, edges } = getTopologyNodesEdges(pipeline, pipelineRun);\n\n  if (nodes.length === 0 && edges.length === 0) {\n    // Nothing to render\n    // TODO: Confirm wording with UX; ODC-1860\n    return <Alert variant=\"info\" isInline title=\"This Pipeline has no tasks to visualize.\" />;\n  }\n\n  return (\n    <div className=\"odc-pipeline-visualization\">\n      <PipelineTopologyGraph\n        id={pipelineRun?.metadata?.name || pipeline.metadata.name}\n        nodes={nodes}\n        edges={edges}\n        layout={PipelineLayout.DAGRE_VIEWER}\n      />\n    </div>\n  );\n};\n\nexport default PipelineVisualization;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport classNames from 'classnames';\nimport { getRunStatusColor, runStatus } from '../../../../utils/pipeline-augment';\nimport { StatusIcon } from './StatusIcon';\nimport { StepStatus } from './pipeline-step-utils';\n\nimport './PipelineVisualizationStepList.scss';\n\nexport interface PipelineVisualizationStepListProps {\n  isSpecOverview: boolean;\n  taskName: string;\n  steps: StepStatus[];\n}\n\nconst TooltipColoredStatusIcon = ({ status }) => {\n  const size = 18;\n  const sharedProps = {\n    height: size,\n    width: size,\n  };\n\n  const icon = <StatusIcon status={status} {...sharedProps} />;\n\n  if (status === runStatus.Succeeded || status === runStatus.Failed) {\n    // Succeeded and Failed icons have transparent centers shapes - in tooltips, this becomes an undesired black\n    // This will simply wrap the icon and place a white backdrop\n    return (\n      <div style={{ color: getRunStatusColor(status).pftoken.value }}>\n        <svg {...sharedProps}>\n          <circle\n            className=\"odc-pipeline-vis-steps-list__icon-backdrop\"\n            cx={size / 2}\n            cy={size / 2}\n            r={size / 2 - 1}\n          />\n          {icon}\n        </svg>\n      </div>\n    );\n  }\n\n  return icon;\n};\n\nexport const PipelineVisualizationStepList: React.FC<PipelineVisualizationStepListProps> = ({\n  isSpecOverview,\n  taskName,\n  steps,\n}) => (\n  <div className=\"odc-pipeline-vis-steps-list\">\n    <div className=\"odc-pipeline-vis-steps-list__task-name\">{taskName}</div>\n    {steps.map(({ duration, name, runStatus: status }) => {\n      return (\n        <div\n          className={classNames('odc-pipeline-vis-steps-list__step', {\n            'odc-pipeline-vis-steps-list__step--task-run': !isSpecOverview,\n          })}\n          key={name}\n        >\n          {!isSpecOverview ? (\n            <div className=\"odc-pipeline-vis-steps-list__icon\">\n              <TooltipColoredStatusIcon status={status} />\n            </div>\n          ) : (\n            <span className=\"odc-pipeline-vis-steps-list__bullet\">&bull;</span>\n          )}\n          <div className=\"odc-pipeline-vis-steps-list__name\">{name}</div>\n          {!isSpecOverview && (\n            <div className=\"odc-pipeline-vis-steps-list__duration\">{duration}</div>\n          )}\n        </div>\n      );\n    })}\n  </div>\n);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport * as cx from 'classnames';\nimport { Link } from 'react-router-dom';\nimport { Tooltip } from '@patternfly/react-core';\nimport { K8sResourceKind, referenceForModel } from '@console/internal/module/k8s';\nimport { Firehose, resourcePathFromModel } from '@console/internal/components/utils';\nimport { runStatus } from '../../../../utils/pipeline-augment';\nimport { PipelineRunModel, TaskModel, ClusterTaskModel } from '../../../../../../../../frontend/public/models/index';\nimport { ColoredStatusIcon } from './StatusIcon';\nimport { PipelineVisualizationStepList } from './PipelineVisualizationStepList';\nimport TaskComponentTaskStatus from './TaskComponentTaskStatus';\nimport { createStepStatus, StepStatus, TaskStatus } from './pipeline-step-utils';\n\nimport './PipelineVisualizationTask.scss';\n\ninterface TaskProps {\n  pipelineRunName?: string;\n  name: string;\n  loaded?: boolean;\n  task?: {\n    data: K8sResourceKind;\n  };\n  status?: TaskStatus;\n  namespace: string;\n  isPipelineRun: boolean;\n  disableTooltip?: boolean;\n  selected?: boolean;\n}\n\ninterface PipelineVisualizationTaskProp {\n  pipelineRunName?: string;\n  namespace: string;\n  task: {\n    name?: string;\n    taskRef: {\n      name: string;\n      kind?: string;\n    };\n    status?: TaskStatus;\n  };\n  taskRun?: string;\n  pipelineRunStatus?: string;\n  disableTooltip?: boolean;\n  selected?: boolean;\n}\n\nexport const PipelineVisualizationTask: React.FC<PipelineVisualizationTaskProp> = ({\n  pipelineRunName,\n  task,\n  namespace,\n  pipelineRunStatus,\n  disableTooltip,\n  selected,\n}) => {\n  const taskStatus = task.status || {\n    duration: '',\n    reason: runStatus.Idle,\n  };\n  if (pipelineRunStatus === runStatus.Failed || pipelineRunStatus === runStatus.Cancelled) {\n    if (\n      task.status &&\n      task.status.reason !== runStatus.Succeeded &&\n      task.status.reason !== runStatus.Failed\n    ) {\n      taskStatus.reason = runStatus.Cancelled;\n    }\n  }\n\n  const taskComponent = (\n    <TaskComponent\n      pipelineRunName={pipelineRunName}\n      name={task.name || ''}\n      namespace={namespace}\n      status={taskStatus}\n      isPipelineRun={!!pipelineRunStatus}\n      disableTooltip={disableTooltip}\n      selected={selected}\n    />\n  );\n\n  if (disableTooltip) {\n    return taskComponent;\n  }\n\n  let resources;\n  if (task.taskRef.kind === ClusterTaskModel.kind) {\n    resources = [\n      {\n        kind: referenceForModel(ClusterTaskModel),\n        name: task.taskRef.name,\n        prop: 'task',\n      },\n    ];\n  } else {\n    resources = [\n      {\n        kind: referenceForModel(TaskModel),\n        name: task.taskRef.name,\n        namespace,\n        prop: 'task',\n      },\n    ];\n  }\n  return <Firehose resources={resources}>{taskComponent}</Firehose>;\n};\nconst TaskComponent: React.FC<TaskProps> = ({\n  pipelineRunName,\n  namespace,\n  task,\n  status,\n  name,\n  isPipelineRun,\n  disableTooltip,\n  selected,\n}) => {\n  const stepList = _.get(task, ['data', 'spec', 'steps'], _.get(status, ['steps'], []));\n  const stepStatusList: StepStatus[] = stepList.map((step) => createStepStatus(step, status));\n  const showStatusState: boolean = isPipelineRun && !!status && !!status.reason;\n  const visualName = name || _.get(task, ['metadata', 'name'], '');\n  const path = pipelineRunName\n    ? `${resourcePathFromModel(PipelineRunModel, pipelineRunName, namespace)}/logs/${name}`\n    : undefined;\n\n  let taskPill = (\n    <div className={cx('odc-pipeline-vis-task__content', { 'is-selected': selected })}>\n      <div\n        className={cx('odc-pipeline-vis-task__title-wrapper', {\n          'is-text-center': !isPipelineRun,\n        })}\n      >\n        <div className=\"odc-pipeline-vis-task__title\">{visualName}</div>\n        {showStatusState && <TaskComponentTaskStatus steps={stepStatusList} />}\n      </div>\n      {isPipelineRun && (\n        <div className=\"odc-pipeline-vis-task__status\">\n          {showStatusState && <ColoredStatusIcon status={status.reason} height={18} width={18} />}\n        </div>\n      )}\n    </div>\n  );\n  if (!disableTooltip) {\n    taskPill = (\n      <Tooltip\n        position=\"bottom\"\n        enableFlip={false}\n        content={\n          <PipelineVisualizationStepList\n            isSpecOverview={!isPipelineRun}\n            taskName={visualName}\n            steps={stepStatusList}\n          />\n        }\n      >\n        {taskPill}\n      </Tooltip>\n    );\n  }\n\n  const visTask = (\n    <>\n      <div className=\"odc-pipeline-vis-task__connector\" />\n      {taskPill}\n    </>\n  );\n  return (\n    <div className=\"odc-pipeline-vis-task\">{path ? <Link to={path}>{visTask}</Link> : visTask}</div>\n  );\n};\n","import * as React from 'react';\nimport {\n  AngleDoubleRightIcon,\n  BanIcon,\n  CheckCircleIcon,\n  CircleIcon,\n  ExclamationCircleIcon,\n  PendingIcon,\n  SyncAltIcon,\n} from '@patternfly/react-icons';\nimport { getRunStatusColor, runStatus } from '../../../../utils/pipeline-augment';\n\ninterface StatusIconProps {\n  status: string;\n  height?: number;\n  width?: number;\n}\n\nexport const StatusIcon: React.FC<StatusIconProps> = ({ status, ...props }) => {\n  switch (status) {\n    case runStatus['In Progress']:\n    case runStatus.Running:\n      return <SyncAltIcon {...props} className=\"fa-spin\" />;\n\n    case runStatus.Succeeded:\n      return <CheckCircleIcon {...props} />;\n\n    case runStatus.Failed:\n      return <ExclamationCircleIcon {...props} />;\n\n    case runStatus.Idle:\n    case runStatus.Pending:\n      return <PendingIcon {...props} />;\n\n    case runStatus.Cancelled:\n      return <BanIcon {...props} />;\n\n    case runStatus.Skipped:\n      return <AngleDoubleRightIcon {...props} />;\n\n    default:\n      return <CircleIcon {...props} />;\n  }\n};\n\nexport const ColoredStatusIcon: React.FC<StatusIconProps> = ({ status, ...others }) => {\n  return (\n    <div\n      style={{\n        color: status\n          ? getRunStatusColor(status).pftoken.value\n          : getRunStatusColor(runStatus.Cancelled).pftoken.value,\n      }}\n    >\n      <StatusIcon status={status} {...others} />\n    </div>\n  );\n};\n","import * as React from 'react';\nimport { getRunStatusColor } from '../../../../utils/pipeline-augment';\nimport HorizontalStackedBars, { StackedValue } from '../../../charts/HorizontalStackedBars';\nimport { StepStatus } from './pipeline-step-utils';\n\ninterface TaskStatusProps {\n  steps: StepStatus[];\n}\n\nconst TaskComponentTaskStatus: React.FC<TaskStatusProps> = ({ steps }) => {\n  if (steps.length === 0) return null;\n\n  const visualValues: StackedValue[] = steps.map(({ name, runStatus }) => {\n    return {\n      color: getRunStatusColor(runStatus).pftoken.value,\n      name,\n      size: 1,\n    };\n  });\n\n  return <HorizontalStackedBars values={visualValues} barGap={2} height={2} />;\n};\n\nexport default TaskComponentTaskStatus;\n","import { runStatus } from '../../../../utils/pipeline-augment';\nimport { calculateRelativeTime } from '../../../../utils/pipeline-utils';\n\nenum TerminatedReasons {\n  Completed = 'Completed',\n}\n\nexport type TaskStatusStep = {\n  name: string;\n  running?: { startedAt: string };\n  terminated?: {\n    finishedAt: string;\n    reason: TerminatedReasons;\n    startedAt: string;\n  };\n  waiting?: {};\n};\n\nexport type TaskStatus = {\n  reason: runStatus;\n  duration?: string;\n  steps?: TaskStatusStep[];\n};\n\nconst getMatchingStep = (step, status: TaskStatus): TaskStatusStep => {\n  const statusSteps: TaskStatusStep[] = status.steps || [];\n  return statusSteps.find((statusStep) => {\n    // In rare occasions the status step name is prefixed with `step-`\n    // This is likely a bug but this workaround will be temporary as it's investigated separately\n    return statusStep.name === step.name || statusStep.name === `step-${step.name}`;\n  });\n};\n\nconst getMatchingStepDuration = (matchingStep?: TaskStatusStep) => {\n  if (!matchingStep) return '';\n\n  if (matchingStep.terminated) {\n    return calculateRelativeTime(matchingStep.terminated.startedAt);\n  }\n  if (matchingStep.running) {\n    return calculateRelativeTime(matchingStep.running.startedAt);\n  }\n\n  return '';\n};\n\nexport type StepStatus = {\n  duration: string | null;\n  name: string;\n  runStatus: runStatus;\n};\n\nexport const createStepStatus = (step: { name: string }, status: TaskStatus): StepStatus => {\n  let stepRunStatus: runStatus = runStatus.PipelineNotStarted;\n  let duration: string = null;\n\n  if (!status || !status.reason) {\n    stepRunStatus = runStatus.Cancelled;\n  } else if (status.reason === runStatus['In Progress']) {\n    // In progress, try to get granular statuses\n    const matchingStep: TaskStatusStep = getMatchingStep(step, status);\n\n    if (!matchingStep) {\n      stepRunStatus = runStatus.Pending;\n    } else if (matchingStep.terminated) {\n      stepRunStatus =\n        matchingStep.terminated.reason === TerminatedReasons.Completed\n          ? runStatus.Succeeded\n          : runStatus.Failed;\n      duration = getMatchingStepDuration(matchingStep);\n    } else if (matchingStep.running) {\n      stepRunStatus = runStatus['In Progress'];\n      duration = getMatchingStepDuration(matchingStep);\n    } else if (matchingStep.waiting) {\n      stepRunStatus = runStatus.Pending;\n    }\n  } else {\n    // Not in progress, just use the run status reason\n    stepRunStatus = status.reason;\n\n    duration = getMatchingStepDuration(getMatchingStep(step, status)) || status.duration;\n  }\n\n  return {\n    duration,\n    name: step.name,\n    runStatus: stepRunStatus,\n  };\n};\n","import * as React from 'react';\nimport { Node, NodeModel, observer } from '@console/topology';\nimport {\n  AddNodeDirection,\n  BUILDER_NODE_ADD_RADIUS,\n  BUILDER_NODE_ERROR_RADIUS,\n  BUILDER_NODE_ADD_PADDING,\n} from './const';\nimport ErrorNodeDecorator from './ErrorNodeDecorator';\nimport PlusNodeDecorator from './PlusNodeDecorator';\nimport TaskNode from './TaskNode';\nimport { BuilderNodeModelData } from './types';\nimport { TooltipPosition } from '@patternfly/react-core';\n\ntype BuilderNodeProps = {\n  element: Node<NodeModel, BuilderNodeModelData>;\n};\n\nconst BuilderNode: React.FC<BuilderNodeProps> = ({ element }) => {\n  const [showAdd, setShowAdd] = React.useState(false);\n  const { width, height } = element.getBounds();\n  const data = element.getData();\n  const { error, onAddNode, onNodeSelection } = data;\n\n  return (\n    <g\n      className=\"odc-builder-node\"\n      onFocus={() => setShowAdd(true)}\n      onBlur={() => setShowAdd(false)}\n      onMouseOver={() => setShowAdd(true)}\n      onMouseOut={() => setShowAdd(false)}\n    >\n      <rect\n        x={-BUILDER_NODE_ADD_RADIUS * 2}\n        y={0}\n        width={width + BUILDER_NODE_ADD_RADIUS * 4}\n        height={height + BUILDER_NODE_ADD_RADIUS * 2}\n        fill=\"transparent\"\n      />\n      <g onClick={() => onNodeSelection(data)}>\n        <TaskNode element={element} disableTooltip />\n        {error && (\n          <ErrorNodeDecorator\n            x={BUILDER_NODE_ERROR_RADIUS / 2}\n            y={BUILDER_NODE_ERROR_RADIUS / 4}\n            errorStr={error}\n          />\n        )}\n      </g>\n      <g style={{ display: showAdd ? 'block' : 'none' }}>\n        <PlusNodeDecorator\n          x={width + BUILDER_NODE_ADD_RADIUS + BUILDER_NODE_ADD_PADDING}\n          y={height / 2}\n          tooltip=\"Add a sequential task after this task\"\n          onClick={() => onAddNode(AddNodeDirection.AFTER)}\n        />\n        <PlusNodeDecorator\n          x={-BUILDER_NODE_ADD_RADIUS - BUILDER_NODE_ADD_PADDING}\n          y={height / 2}\n          tooltip=\"Add a sequential task before this task\"\n          onClick={() => onAddNode(AddNodeDirection.BEFORE)}\n        />\n        <PlusNodeDecorator\n          x={width / 2}\n          y={height + BUILDER_NODE_ADD_RADIUS + BUILDER_NODE_ADD_PADDING}\n          tooltip=\"Add a parallel task\"\n          tooltipPosition={TooltipPosition.bottom}\n          onClick={() => onAddNode(AddNodeDirection.PARALLEL)}\n        />\n      </g>\n    </g>\n  );\n};\n\nexport default observer(BuilderNode);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Tooltip } from '@patternfly/react-core';\nimport { ExclamationIcon } from '@patternfly/react-icons';\nimport { global_danger_color_100 as redColor } from '@patternfly/react-tokens';\nimport { BUILDER_NODE_ERROR_RADIUS } from './const';\n\nimport './ErrorNodeDecorator.scss';\n\ntype ErrorNodeDecoratorProps = {\n  errorStr: string;\n  x: number;\n  y: number;\n};\n\nconst ErrorNodeDecorator: React.FC<ErrorNodeDecoratorProps> = ({ errorStr, x, y }) => {\n  return (\n    <g className=\"odc-error-node-decorator\" transform={`translate(${x}, ${y})`}>\n      <circle cx={0} cy={0} r={BUILDER_NODE_ERROR_RADIUS} fill={redColor.value} />\n      <g transform=\"translate(-5, -7)\">\n        <foreignObject width={BUILDER_NODE_ERROR_RADIUS * 2} height={BUILDER_NODE_ERROR_RADIUS * 2}>\n          <Tooltip content={errorStr}>\n            <ExclamationIcon color=\"white\" />\n          </Tooltip>\n        </foreignObject>\n      </g>\n    </g>\n  );\n};\n\nexport default ErrorNodeDecorator;\n","import * as React from 'react';\nimport { Node, NodeModel, observer } from '@console/topology';\nimport { BUILDER_NODE_ERROR_RADIUS } from './const';\nimport ErrorNodeDecorator from './ErrorNodeDecorator';\nimport TaskListNode from './TaskListNode';\nimport { TaskListNodeModelData } from './types';\n\ntype InvalidTaskListNodeProps = {\n  element: Node<NodeModel, TaskListNodeModelData>;\n};\n\nconst InvalidTaskListNode: React.FC<InvalidTaskListNodeProps> = ({ element }) => {\n  const {\n    task: { name },\n  } = element.getData();\n\n  return (\n    <g>\n      <TaskListNode element={element} unselectedText={name} />\n      <ErrorNodeDecorator\n        x={BUILDER_NODE_ERROR_RADIUS / 2}\n        y={BUILDER_NODE_ERROR_RADIUS / 4}\n        errorStr=\"Task does not exist\"\n      />\n    </g>\n  );\n};\n\nexport default observer(InvalidTaskListNode);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { ModelKind } from '@console/topology';\nimport PipelineVisualizationSurface from './PipelineVisualizationSurface';\nimport { PipelineLayout } from './const';\nimport { PipelineEdgeModel, PipelineMixedNodeModel } from './types';\n\nimport './PipelineTopologyGraph.scss';\n\ntype PipelineTopologyGraphProps = {\n  id: string;\n  fluid?: boolean;\n  nodes: PipelineMixedNodeModel[];\n  edges: PipelineEdgeModel[];\n  layout: PipelineLayout;\n};\n\nconst PipelineTopologyGraph: React.FC<PipelineTopologyGraphProps> = ({\n  id,\n  fluid,\n  nodes,\n  edges,\n  layout,\n}) => {\n  return (\n    <div className=\"odc-pipeline-topology-graph\" style={{ display: fluid ? 'block' : undefined }}>\n      <PipelineVisualizationSurface\n        model={{\n          graph: {\n            id,\n            type: ModelKind.graph,\n            layout,\n          },\n          nodes,\n          edges,\n        }}\n      />\n    </div>\n  );\n};\n\nexport default PipelineTopologyGraph;\n","import * as React from 'react';\nimport {\n  GRAPH_LAYOUT_END_EVENT,\n  Model,\n  Node,\n  Visualization,\n  VisualizationSurface,\n} from '@console/topology';\nimport { componentFactory, layoutFactory } from './factories';\nimport { DROP_SHADOW_SPACING, NODE_WIDTH, NODE_HEIGHT, PipelineLayout } from './const';\nimport { getLayoutData } from './utils';\n\ntype PipelineVisualizationSurfaceProps = {\n  model: Model;\n};\n\nconst PipelineVisualizationSurface: React.FC<PipelineVisualizationSurfaceProps> = ({ model }) => {\n  const [vis, setVis] = React.useState(null);\n  const [maxSize, setMaxSize] = React.useState(null);\n\n  const layout: PipelineLayout = model.graph.layout as PipelineLayout;\n\n  const onLayoutUpdate = React.useCallback(\n    (nodes: Node[]) => {\n      const nodeBounds = nodes.map((node) => node.getBounds());\n      const maxX = Math.floor(\n        nodeBounds.map((bounds) => bounds.x).reduce((x1, x2) => Math.max(x1, x2), 0),\n      );\n      const maxY = Math.floor(\n        nodeBounds.map((bounds) => bounds.y).reduce((y1, y2) => Math.max(y1, y2), 0),\n      );\n\n      let horizontalMargin = 0;\n      let verticalMargin = 0;\n      if (layout) {\n        horizontalMargin = getLayoutData(layout).marginx || 0;\n        verticalMargin = getLayoutData(layout).marginy || 0;\n      }\n\n      setMaxSize({\n        // Nodes are rendered from the top-left\n        height: maxY + NODE_HEIGHT + DROP_SHADOW_SPACING + verticalMargin * 2,\n        width: maxX + NODE_WIDTH + horizontalMargin * 2,\n      });\n    },\n    [setMaxSize, layout],\n  );\n\n  React.useEffect(() => {\n    if (vis === null) {\n      const visualization = new Visualization();\n      visualization.registerLayoutFactory(layoutFactory);\n      visualization.registerComponentFactory(componentFactory);\n      visualization.fromModel(model);\n      visualization.addEventListener(GRAPH_LAYOUT_END_EVENT, () => {\n        onLayoutUpdate(visualization.getGraph().getNodes());\n      });\n      setVis(visualization);\n    } else {\n      vis.fromModel(model);\n      vis.getGraph().layout();\n    }\n  }, [vis, model, onLayoutUpdate]);\n\n  if (!vis) return null;\n\n  return (\n    <div style={{ height: maxSize?.height, width: maxSize?.width }}>\n      <VisualizationSurface visualization={vis} />\n    </div>\n  );\n};\n\nexport default PipelineVisualizationSurface;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { PlusIcon } from '@patternfly/react-icons';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { chart_color_blue_300 as blueColor } from '@patternfly/react-tokens';\nimport { BUILDER_NODE_ADD_RADIUS } from './const';\n\nimport './PlusNodeDecorator.scss';\n\ntype PlusNodeProps = {\n  x: number;\n  y: number;\n  tooltip: string;\n  tooltipPosition?: TooltipPosition;\n  onClick?: () => void;\n};\n\nconst PlusNodeDecorator: React.FC<PlusNodeProps> = ({\n  x,\n  y,\n  onClick,\n  tooltip,\n  tooltipPosition,\n}) => {\n  return (\n    <Tooltip content={tooltip} position={tooltipPosition}>\n      <g className=\"odc-plus-node-decorator\" onClick={onClick} transform={`translate(${x}, ${y})`}>\n        <circle cx={0} cy={0} r={BUILDER_NODE_ADD_RADIUS} fill={blueColor.value} />\n        <g transform=\"translate(-6, -6)\">\n          <PlusIcon color=\"white\" />\n        </g>\n      </g>\n    </Tooltip>\n  );\n};\n\nexport default PlusNodeDecorator;\n","import * as React from 'react';\nimport { observer, Node } from '@console/topology';\n\nconst SpacerNode: React.FC<{ element: Node }> = () => {\n  return <g />;\n};\n\nexport default observer(SpacerNode);\n","import * as React from 'react';\nimport { Edge, Point } from '@console/topology';\nimport { integralShapePath } from './draw-utils';\n\nconst TaskEdge: React.FC<{ element: Edge }> = ({ element }) => {\n  const startPoint: Point = element.getStartPoint();\n  const endPoint: Point = element.getEndPoint();\n  const sourceNode = element.getSource();\n  const targetNode = element.getTarget();\n\n  return (\n    <path\n      d={integralShapePath(\n        startPoint.clone().translate(sourceNode.getBounds().width / 2 - 1, 0),\n        endPoint.clone().translate(-targetNode.getBounds().width / 2, 0),\n      )}\n      stroke=\"var(--pf-global--BorderColor--light-100)\"\n      fill=\"none\"\n      transform=\"translate(0.5,0.5)\"\n    />\n  );\n};\n\nexport default TaskEdge;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as FocusTrap from 'focus-trap-react';\nimport { Button, Flex, FlexItem, FlexModifiers } from '@patternfly/react-core';\nimport { CaretDownIcon } from '@patternfly/react-icons';\nimport Popper from '@console/shared/src/components/popper/Popper';\nimport { KebabItem, KebabOption } from '@console/internal/components/utils';\nimport { observer, Node, NodeModel } from '@console/topology';\nimport { PipelineResourceTask } from '../../../utils/pipeline-augment';\nimport { NewTaskNodeCallback, TaskListNodeModelData } from './types';\n\nimport './TaskListNode.scss';\n\nconst taskToOption = (task: PipelineResourceTask, callback: NewTaskNodeCallback): KebabOption => {\n  const {\n    metadata: { name },\n  } = task;\n\n  return {\n    label: name,\n    callback: () => {\n      callback(task);\n    },\n  };\n};\n\ntype TaskListNodeProps = {\n  element: Node<NodeModel, TaskListNodeModelData>;\n  unselectedText?: string;\n};\n\nconst TaskListNode: React.FC<TaskListNodeProps> = ({ element, unselectedText }) => {\n  const triggerRef = React.useRef(null);\n  const [isMenuOpen, setMenuOpen] = React.useState(false);\n  const { height, width } = element.getBounds();\n  const { clusterTaskList, namespaceTaskList, onNewTask, onRemoveTask } = element.getData();\n\n  const options = [\n    ...namespaceTaskList.map((task) => taskToOption(task, onNewTask)),\n    ...clusterTaskList.map((task) => taskToOption(task, onNewTask)),\n  ];\n\n  return (\n    <foreignObject width={width} height={height} className=\"odc-task-list-node\">\n      <div className=\"odc-task-list-node__trigger-background\" ref={triggerRef}>\n        <Button\n          className=\"odc-task-list-node__trigger\"\n          isDisabled={options.length === 0}\n          onClick={() => {\n            setMenuOpen(!isMenuOpen);\n          }}\n          variant=\"control\"\n        >\n          {options.length === 0 ? (\n            'No Tasks'\n          ) : (\n            <Flex\n              breakpointMods={[\n                { modifier: FlexModifiers.nowrap },\n                { modifier: FlexModifiers['space-items-none'] },\n              ]}\n            >\n              <FlexItem\n                className=\"odc-task-list-node__label\"\n                breakpointMods={[{ modifier: FlexModifiers.grow }]}\n              >\n                {unselectedText || 'Select task'}\n              </FlexItem>\n              <FlexItem>\n                <CaretDownIcon />\n              </FlexItem>\n            </Flex>\n          )}\n        </Button>\n      </div>\n      <Popper\n        open={isMenuOpen}\n        placement=\"bottom-start\"\n        closeOnEsc\n        closeOnOutsideClick\n        onRequestClose={(e) => {\n          if (!e || !triggerRef?.current?.contains(e.target as Element)) {\n            setMenuOpen(false);\n          }\n        }}\n        reference={() => triggerRef.current}\n      >\n        <FocusTrap\n          focusTrapOptions={{ clickOutsideDeactivates: true, returnFocusOnDeactivate: false }}\n        >\n          <div className=\"pf-c-dropdown pf-m-expanded\">\n            <ul className=\"pf-c-dropdown__menu pf-m-align-right oc-kebab__popper-items odc-task-list-node__list-items\">\n              {options.map((option) => (\n                <li key={option.label}>\n                  <KebabItem\n                    option={option}\n                    onClick={() => {\n                      option.callback && option.callback();\n                    }}\n                  />\n                </li>\n              ))}\n              {onRemoveTask && (\n                <>\n                  <li>\n                    <hr className=\"odc-task-list-node__divider\" />\n                  </li>\n                  <li>\n                    <KebabItem\n                      option={{ label: 'Delete Task', callback: onRemoveTask }}\n                      onClick={onRemoveTask}\n                    />\n                  </li>\n                </>\n              )}\n            </ul>\n          </div>\n        </FocusTrap>\n      </Popper>\n    </foreignObject>\n  );\n};\n\nexport default observer(TaskListNode);\n","import * as React from 'react';\nimport { observer, Node, NodeModel } from '@console/topology';\nimport { pipelineRunFilterReducer } from '../../../utils/pipeline-filter-reducer';\nimport { PipelineVisualizationTask } from '../detail-page-tabs/pipeline-details/PipelineVisualizationTask';\nimport { DROP_SHADOW_SPACING } from './const';\nimport { TaskNodeModelData } from './types';\n\ntype TaskNodeProps = {\n  element: Node<NodeModel, TaskNodeModelData>;\n  disableTooltip?: boolean;\n};\n\nconst TaskNode: React.FC<TaskNodeProps> = ({ element, disableTooltip }) => {\n  const { height, width } = element.getBounds();\n  const { pipeline, pipelineRun, task, selected } = element.getData();\n\n  return (\n    <foreignObject width={width} height={height + DROP_SHADOW_SPACING}>\n      <PipelineVisualizationTask\n        pipelineRunName={pipelineRun?.metadata?.name}\n        task={task}\n        pipelineRunStatus={pipelineRun && pipelineRunFilterReducer(pipelineRun)}\n        namespace={pipeline?.metadata?.namespace ?? pipelineRun?.metadata?.namespace}\n        disableTooltip={disableTooltip}\n        selected={selected}\n      />\n    </foreignObject>\n  );\n};\n\nexport default observer(TaskNode);\n","import * as dagre from 'dagre';\n\nexport const NODE_SEPARATION_HORIZONTAL = 25;\nexport const NODE_SEPARATION_VERTICAL = 20;\nexport const DROP_SHADOW_SPACING = 5;\nexport const BUILDER_NODE_ADD_RADIUS = 9;\nexport const BUILDER_NODE_ERROR_RADIUS = 9;\nexport const BUILDER_NODE_ADD_PADDING = 4;\n\nexport const NODE_WIDTH = 120;\nexport const NODE_HEIGHT = 30;\n\nexport enum NodeType {\n  TASK_NODE = 'task',\n  SPACER_NODE = 'spacer',\n  TASK_LIST_NODE = 'task-list',\n  BUILDER_NODE = 'builder',\n  INVALID_TASK_LIST_NODE = 'invalid-task-list',\n}\nexport enum DrawDesign {\n  INTEGRAL_SHAPE = 'integral-shape',\n  STRAIGHT = 'line',\n}\nexport enum PipelineLayout {\n  DAGRE_BUILDER = 'dagre-builder',\n  DAGRE_VIEWER = 'dagre-viewer',\n}\n\nexport enum AddNodeDirection {\n  /**\n   * Rules today:\n   *  - the `relatedTask` is pointing at ONLY us\n   *  - we inherit all that `relatedTask` is pointing at\n   */\n  BEFORE = 'in-run-after',\n\n  /**\n   * Rules today:\n   *  - the `relatedTask` must be our ONLY runAfter\n   *  - we are added to all that is pointing at `relatedTask`\n   */\n  AFTER = 'has-run-after',\n\n  /**\n   * Rules today:\n   *  - we inherit all that `relatedTask` is pointing at\n   *  - we are added to all that is pointing at `relatedTask`\n   */\n  PARALLEL = 'shared-parallel',\n}\n\nconst DAGRE_SHARED_PROPS: dagre.GraphLabel = {\n  nodesep: NODE_SEPARATION_VERTICAL,\n  ranksep: NODE_SEPARATION_HORIZONTAL,\n  edgesep: 25,\n  ranker: 'longest-path',\n  rankdir: 'LR',\n  align: 'UL',\n  marginx: 20,\n  marginy: 20,\n};\nexport const DAGRE_VIEWER_PROPS: dagre.GraphLabel = {\n  ...DAGRE_SHARED_PROPS,\n};\nexport const DAGRE_BUILDER_PROPS: dagre.GraphLabel = {\n  ...DAGRE_SHARED_PROPS,\n  ranksep: NODE_SEPARATION_HORIZONTAL + BUILDER_NODE_ADD_RADIUS * 2,\n  nodesep: NODE_SEPARATION_VERTICAL + BUILDER_NODE_ADD_RADIUS,\n  marginx: DAGRE_SHARED_PROPS.marginx + BUILDER_NODE_ADD_RADIUS * 2,\n  marginy: DAGRE_SHARED_PROPS.marginy + BUILDER_NODE_ADD_RADIUS * 2,\n};\n","import { Point } from '@console/topology';\nimport { DrawDesign, NODE_SEPARATION_HORIZONTAL } from './const';\n\ntype SingleDraw = (p: Point) => string;\ntype DoubleDraw = (p1: Point, p2: Point) => string;\ntype TripleDraw = (p1: Point, p2: Point, p3: Point) => string;\ntype DetermineDirection = (p1: Point, p2: Point) => boolean;\n\nconst join = (...segments: string[]) => segments.filter((seg) => !!seg).join(' ');\n\nconst leftRight: DetermineDirection = (p1, p2) => p1.x < p2.x;\nconst topDown: DetermineDirection = (p1, p2) => p1.y < p2.y;\nconst bottomUp: DetermineDirection = (p1, p2) => p1.y > p2.y;\n\nconst point: SingleDraw = (p) => `${p.x},${p.y}`;\nconst moveTo: SingleDraw = (p) => `M ${point(p)}`;\nconst lineTo: SingleDraw = (p) => `L ${point(p)}`;\nconst quadTo: DoubleDraw = (corner, end) => `Q ${point(corner)} ${point(end)}`;\n\n// TODO: Try to simplify\n// x should not be greater than (NODE_SEPARATION_HORIZONTAL / 2)\nconst CURVE_SIZE = { x: 8, y: 10 };\nconst curve: TripleDraw = (fromPoint, cornerPoint, toPoint) => {\n  const topToBottom = topDown(fromPoint, toPoint);\n  if (topToBottom) {\n    const rightAndDown = leftRight(fromPoint, cornerPoint) && topDown(cornerPoint, toPoint);\n    const downAndRight = topDown(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);\n    if (rightAndDown) {\n      return join(\n        lineTo(cornerPoint.clone().translate(-CURVE_SIZE.x, 0)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(0, CURVE_SIZE.y)),\n      );\n    }\n    if (downAndRight) {\n      return join(\n        lineTo(cornerPoint.clone().translate(0, -CURVE_SIZE.y)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(CURVE_SIZE.x, 0)),\n      );\n    }\n  } else {\n    const rightAndUp = leftRight(fromPoint, cornerPoint) && bottomUp(cornerPoint, toPoint);\n    const upAndRight = bottomUp(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);\n    if (rightAndUp) {\n      return join(\n        lineTo(cornerPoint.clone().translate(-CURVE_SIZE.x, 0)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(0, -CURVE_SIZE.y)),\n      );\n    }\n    if (upAndRight) {\n      return join(\n        lineTo(cornerPoint.clone().translate(0, CURVE_SIZE.y)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(CURVE_SIZE.x, 0)),\n      );\n    }\n  }\n\n  return '';\n};\n\nexport const straightPath: DoubleDraw = (start, finish) => join(moveTo(start), lineTo(finish));\n\nexport const integralShapePath: DoubleDraw = (start, finish) => {\n  // Integral shape: âˆ«\n  let firstCurve: string = null;\n  let secondCurve: string = null;\n\n  if (start.y !== finish.y) {\n    const cornerX = Math.floor(start.x + NODE_SEPARATION_HORIZONTAL / 2);\n    const firstCorner = new Point(cornerX, start.y);\n    const secondCorner = new Point(cornerX, finish.y);\n\n    firstCurve = curve(start, firstCorner, secondCorner);\n    secondCurve = curve(firstCorner, secondCorner, finish);\n  }\n\n  return join(moveTo(start), firstCurve, secondCurve, lineTo(finish));\n};\n\nexport const path = (start: Point, finish: Point, drawDesign?: DrawDesign) => {\n  switch (drawDesign) {\n    case DrawDesign.INTEGRAL_SHAPE:\n      return integralShapePath(start, finish);\n    case DrawDesign.STRAIGHT:\n    default:\n      return straightPath(start, finish);\n  }\n};\n","import {\n  ComponentFactory,\n  DagreLayout,\n  GraphComponent,\n  LayoutFactory,\n  ModelKind,\n  Graph,\n} from '@console/topology';\nimport { NodeType, PipelineLayout } from './const';\nimport BuilderNode from './BuilderNode';\nimport InvalidTaskListNode from './InvalidTaskListNode';\nimport SpacerNode from './SpacerNode';\nimport TaskNode from './TaskNode';\nimport TaskEdge from './TaskEdge';\nimport TaskListNode from './TaskListNode';\nimport { getLayoutData } from './utils';\n\nexport const componentFactory: ComponentFactory = (kind: ModelKind, type: string) => {\n  switch (kind) {\n    case ModelKind.graph:\n      return GraphComponent;\n    case ModelKind.edge:\n      return TaskEdge;\n    case ModelKind.node:\n      switch (type) {\n        case NodeType.TASK_NODE:\n          return TaskNode;\n        case NodeType.SPACER_NODE:\n          return SpacerNode;\n        case NodeType.TASK_LIST_NODE:\n          return TaskListNode;\n        case NodeType.INVALID_TASK_LIST_NODE:\n          return InvalidTaskListNode;\n        case NodeType.BUILDER_NODE:\n          return BuilderNode;\n        default:\n          return undefined;\n      }\n    default:\n      return undefined;\n  }\n};\n\nexport const layoutFactory: LayoutFactory = (type: string, graph: Graph) => {\n  switch (type) {\n    case PipelineLayout.DAGRE_BUILDER:\n    case PipelineLayout.DAGRE_VIEWER:\n      return new DagreLayout(graph, {\n        // Hack to get around undesirable defaults\n        // TODO: fix this, it's not ideal but it works for now\n        linkDistance: 0,\n        nodeDistance: 0,\n        groupDistance: 0,\n        collideDistance: 0,\n        simulationSpeed: 0,\n        chargeStrength: 0,\n        allowDrag: false,\n        layoutOnDrag: false,\n        ...getLayoutData(type),\n      });\n    default:\n      return undefined;\n  }\n};\n","import * as dagre from 'dagre';\nimport * as _ from 'lodash';\nimport { Pipeline, PipelineRun } from '../../../utils/pipeline-augment';\nimport { getPipelineTasks, PipelineVisualizationTaskItem } from '../../../utils/pipeline-utils';\nimport {\n  NODE_HEIGHT,\n  NodeType,\n  NODE_WIDTH,\n  AddNodeDirection,\n  PipelineLayout,\n  DAGRE_BUILDER_PROPS,\n  DAGRE_VIEWER_PROPS,\n} from './const';\nimport {\n  PipelineEdgeModel,\n  NodeCreator,\n  NodeCreatorSetup,\n  SpacerNodeModelData,\n  TaskListNodeModelData,\n  TaskNodeModelData,\n  PipelineMixedNodeModel,\n  PipelineTaskNodeModel,\n  BuilderNodeModelData,\n  PipelineRunAfterNodeModelData,\n} from './types';\n\nconst createGenericNode: NodeCreatorSetup = (type, width?) => (name, data) => ({\n  id: name,\n  data,\n  height: NODE_HEIGHT,\n  width: width != null ? width : NODE_WIDTH,\n  type,\n});\n\n// Node variations\nexport const createTaskNode: NodeCreator<TaskNodeModelData> = createGenericNode(NodeType.TASK_NODE);\nexport const createSpacerNode: NodeCreator<SpacerNodeModelData> = createGenericNode(\n  NodeType.SPACER_NODE,\n  0,\n);\nexport const createTaskListNode: NodeCreator<TaskListNodeModelData> = createGenericNode(\n  NodeType.TASK_LIST_NODE,\n);\nexport const createInvalidTaskListNode: NodeCreator<TaskListNodeModelData> = createGenericNode(\n  NodeType.INVALID_TASK_LIST_NODE,\n);\nexport const createBuilderNode: NodeCreator<BuilderNodeModelData> = createGenericNode(\n  NodeType.BUILDER_NODE,\n);\n\nexport const getNodeCreator = (type: NodeType): NodeCreator<PipelineRunAfterNodeModelData> => {\n  switch (type) {\n    case NodeType.TASK_LIST_NODE:\n      return createTaskListNode;\n    case NodeType.BUILDER_NODE:\n      return createBuilderNode;\n    case NodeType.SPACER_NODE:\n      return createSpacerNode;\n    case NodeType.TASK_NODE:\n    default:\n      return createTaskNode;\n  }\n};\n\nexport const handleParallelToParallelNodes = (\n  nodes: PipelineMixedNodeModel[],\n): PipelineMixedNodeModel[] => {\n  type ParallelNodeReference = {\n    node: PipelineTaskNodeModel;\n    runAfter: string[];\n    atIndex: number;\n  };\n  type ParallelNodeMap = {\n    [id: string]: ParallelNodeReference[];\n  };\n\n  // Collect only multiple run-afters\n  const multipleRunBeforeMap: ParallelNodeMap = nodes.reduce((acc, node, idx) => {\n    const {\n      data: {\n        task: { runAfter },\n      },\n    } = node;\n    if (runAfter && runAfter.length > 1) {\n      const id: string = [...runAfter]\n        .sort((a, b) => a.localeCompare(b))\n        .reduce((str, ref) => `${str}|${ref}`);\n\n      if (!Array.isArray(acc[id])) {\n        acc[id] = [];\n      }\n      acc[id].push({\n        node,\n        runAfter,\n        atIndex: idx,\n      });\n    }\n    return acc;\n  }, {} as ParallelNodeMap);\n\n  // Trim out single occurrences\n  const multiParallelToParallelList: ParallelNodeReference[][] = Object.values(\n    multipleRunBeforeMap,\n  ).filter((data: ParallelNodeReference[]) => data.length > 1);\n\n  if (multiParallelToParallelList.length === 0) {\n    // No parallel to parallel\n    return nodes;\n  }\n\n  // Insert a spacer node between the multiple nodes on the sides of a parallel-to-parallel\n  const newNodes: PipelineMixedNodeModel[] = [];\n  const newRunAfterNodeMap: { [nodeId: string]: string[] } = {};\n  multiParallelToParallelList.forEach((p2p: ParallelNodeReference[]) => {\n    // All nodes in each array share their runAfters\n    const { runAfter } = p2p[0];\n\n    const names: string[] = p2p.map((p2pData) => p2pData.node.id);\n    const parallelSpacerName = `parallel-${names.join('-')}`;\n\n    names.forEach((p2pNodeId) => {\n      if (!Array.isArray(newRunAfterNodeMap[p2pNodeId])) {\n        newRunAfterNodeMap[p2pNodeId] = [];\n      }\n      newRunAfterNodeMap[p2pNodeId].push(parallelSpacerName);\n    });\n\n    newNodes.push(\n      createSpacerNode(parallelSpacerName, {\n        task: {\n          name: parallelSpacerName,\n          runAfter,\n        },\n      }),\n    );\n  });\n\n  // Update all impacted nodes to point at the spacer node as the spacer points at their original runAfters\n  nodes.forEach((node) => {\n    const newRunAfters: string[] | undefined = newRunAfterNodeMap[node.id];\n    if (newRunAfters && newRunAfters.length > 0) {\n      const {\n        data: { task },\n        type,\n      } = node;\n\n      const createNode: NodeCreator<PipelineRunAfterNodeModelData> = getNodeCreator(type);\n\n      // Recreate the node with the new runAfter pointing to the spacer node\n      newNodes.push(\n        createNode(node.id, {\n          ...node.data,\n          task: {\n            ...task,\n            runAfter: newRunAfters,\n          },\n        }),\n      );\n    } else {\n      // Unaffected node, just carry it over\n      newNodes.push(node);\n    }\n  });\n\n  return newNodes;\n};\n\nexport const tasksToNodes = (\n  taskList: PipelineVisualizationTaskItem[],\n  pipeline?: Pipeline,\n  pipelineRun?: PipelineRun,\n): PipelineMixedNodeModel[] => {\n  const nodeList: PipelineTaskNodeModel[] = taskList.map((task) =>\n    createTaskNode(task.name, {\n      task,\n      pipeline,\n      pipelineRun,\n    }),\n  );\n\n  return handleParallelToParallelNodes(nodeList);\n};\n\nexport const tasksToBuilderNodes = (\n  taskList: PipelineVisualizationTaskItem[],\n  onAddNode: (task: PipelineVisualizationTaskItem, direction: AddNodeDirection) => void,\n  onNodeSelection: (task: PipelineVisualizationTaskItem) => void,\n  getError: (taskName: string) => string,\n  selectedIds: string[],\n): PipelineMixedNodeModel[] => {\n  return taskList.map((task) => {\n    return createBuilderNode(task.name, {\n      error: getError(task.name),\n      task,\n      selected: selectedIds.includes(task.name),\n      onNodeSelection: () => {\n        onNodeSelection(task);\n      },\n      onAddNode: (direction: AddNodeDirection) => {\n        onAddNode(task, direction);\n      },\n    });\n  });\n};\n\nexport const getEdgesFromNodes = (nodes: PipelineMixedNodeModel[]): PipelineEdgeModel[] =>\n  _.flatten(\n    nodes.map((node) => {\n      const {\n        data: {\n          task: { name: target, runAfter = [] },\n        },\n      } = node;\n\n      if (runAfter.length === 0) return null;\n\n      return runAfter.map((source) => ({\n        id: `${source}~to~${target}`,\n        type: 'edge',\n        source,\n        target,\n      }));\n    }),\n  ).filter((edgeList) => !!edgeList);\n\nexport const getTopologyNodesEdges = (\n  pipeline: Pipeline,\n  pipelineRun?: PipelineRun,\n): { nodes: PipelineMixedNodeModel[]; edges: PipelineEdgeModel[] } => {\n  const taskList: PipelineVisualizationTaskItem[] = _.flatten(\n    getPipelineTasks(pipeline, pipelineRun),\n  );\n  const nodes: PipelineMixedNodeModel[] = tasksToNodes(taskList, pipeline, pipelineRun);\n  const edges: PipelineEdgeModel[] = getEdgesFromNodes(nodes);\n\n  return { nodes, edges };\n};\n\nexport const getLayoutData = (layout: PipelineLayout): dagre.GraphLabel => {\n  switch (layout) {\n    case PipelineLayout.DAGRE_BUILDER:\n      return DAGRE_BUILDER_PROPS;\n    case PipelineLayout.DAGRE_VIEWER:\n      return DAGRE_VIEWER_PROPS;\n    default:\n      return null;\n  }\n};\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AAOA;;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAQA;AAEA;;;;;;;;;;;;ACtCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAIA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAKA;AACA;AAKA;;;;;;;;;;;;ACxEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAiCA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAYA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAOA;AACA;AAeA;AAEA;AAEA;AACA;AAGA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxKA;AACA;AASA;AAQA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;AACA;AAGA;AACA;AACA;AACA;AAEA;AAGA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAOA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AAmBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAQA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAOA;AACA;AACA;AAQA;AACA;AAMA;AAMA;AAUA;AAEA;;;;;;;;;;;;AC1EA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AAEA;;;;;;;;;;;;;AC7BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AAIA;AAEA;AACA;AAOA;AAEA;;;;;;;;;;;;AC5BA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAUA;AAOA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAEA;AAGA;AAEA;;;;;;;;;;;;ACzEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAUA;AAOA;AAEA;AACA;AACA;AACA;AAKA;AAEA;;;;;;;;;;;;;ACnCA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAWA;AAEA;;;;;;;;;;;;ACvBA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AAQA;AACA;AACA;AAEA;AAMA;AACA;AAMA;;AAMA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAEA;AAGA;AACA;AAIA;AAEA;AACA;AAEA;AACA;AAaA;AAEA;;;;;;;;;;;;;AC1HA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAQA;;AACA;AACA;AAEA;AAEA;AAUA;AAEA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;;;;AAIA;AACA;AAEA;;;;AAIA;AACA;AAEA;;;;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;AChEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AAAA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;;;;;;;;;;;;;AC9DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAGA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AASA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAMA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAIA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}