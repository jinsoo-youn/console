{"version":3,"file":"dev-console-edit~dev-console-import~dev-console-projectDetails-66defd248907380e163f.js","sources":["webpack:///./packages/dev-console/src/components/import/import-submit-utils.ts","webpack:///./packages/dev-console/src/components/import/pipeline/pipeline-template-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/common/const.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/common/utils.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/pipelineResource-utils.ts"],"sourcesContent":["import * as _ from 'lodash';\nimport {\n  ImageStreamModel,\n  BuildConfigModel,\n  DeploymentModel,\n  DeploymentConfigModel,\n  ProjectRequestModel,\n  SecretModel,\n  ServiceModel,\n  RouteModel,\n} from '@console/internal/models';\nimport { k8sCreate, K8sResourceKind, k8sUpdate, K8sVerb } from '@console/internal/module/k8s';\nimport { ServiceModel as KnServiceModel } from '@console/knative-plugin';\nimport { getKnativeServiceDepResource } from '@console/knative-plugin/src/utils/create-knative-utils';\nimport { SecretType } from '@console/internal/components/secrets/create-secret';\nimport * as plugins from '@console/internal/plugins';\nimport { history } from '@console/internal/components/utils';\nimport { getRandomChars } from '@console/shared/src/utils';\nimport {\n  getAppLabels,\n  getPodLabels,\n  getGitAnnotations,\n  getCommonAnnotations,\n  getTriggerAnnotation,\n  mergeData,\n} from '../../utils/resource-label-utils';\nimport { createService, createRoute, dryRunOpt } from '../../utils/shared-submit-utils';\nimport { getProbesData } from '../health-checks/create-health-checks-probe-utils';\nimport { AppResources } from '../edit-application/edit-application-types';\nimport {\n  GitImportFormData,\n  ProjectData,\n  GitTypes,\n  GitReadableTypes,\n  Resources,\n} from './import-types';\nimport { createPipelineForImportFlow } from './pipeline/pipeline-template-utils';\n\nexport const generateSecret = () => {\n  // http://stackoverflow.com/questions/105034/create-guid-uuid-in-javascript\n  const s4 = () =>\n    Math.floor((1 + Math.random()) * 0x10000)\n      .toString(16)\n      .substring(1);\n  return s4() + s4() + s4() + s4();\n};\n\nexport const createProject = (projectData: ProjectData): Promise<K8sResourceKind> => {\n  const project = {\n    metadata: {\n      name: projectData.name,\n    },\n    displayName: projectData.displayName,\n    description: projectData.description,\n  };\n\n  return k8sCreate(ProjectRequestModel, project);\n};\n\nexport const createOrUpdateImageStream = (\n  formData: GitImportFormData,\n  imageStreamData: K8sResourceKind,\n  dryRun: boolean,\n  appResources: AppResources,\n  verb: K8sVerb = 'create',\n  generatedImageStreamName: string = '',\n): Promise<K8sResourceKind> => {\n  const imageStreamList = appResources?.imageStream?.data;\n  const imageStreamFilterData = _.orderBy(imageStreamList, ['metadata.resourceVersion'], ['desc']);\n  const originalImageStream = (imageStreamFilterData.length && imageStreamFilterData[0]) || {};\n  const {\n    name,\n    project: { name: namespace },\n    application: { name: application },\n    labels: userLabels,\n    git: { url: repository, ref },\n    image: { tag },\n  } = formData;\n  const imageStreamName = imageStreamData && imageStreamData.metadata.name;\n  const defaultLabels = getAppLabels(name, application, imageStreamName, tag);\n  const defaultAnnotations = { ...getGitAnnotations(repository, ref), ...getCommonAnnotations() };\n  const newImageStream = {\n    apiVersion: 'image.openshift.io/v1',\n    kind: 'ImageStream',\n    metadata: {\n      name: `${generatedImageStreamName || name}`,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n      annotations: defaultAnnotations,\n    },\n  };\n  const imageStream = mergeData(originalImageStream, newImageStream);\n  return verb === 'update'\n    ? k8sUpdate(ImageStreamModel, imageStream)\n    : k8sCreate(ImageStreamModel, newImageStream, dryRun ? dryRunOpt : {});\n};\n\nexport const createWebhookSecret = (\n  formData: GitImportFormData,\n  secretType: string,\n  dryRun: boolean,\n): Promise<K8sResourceKind> => {\n  const {\n    name,\n    project: { name: namespace },\n  } = formData;\n\n  const webhookSecret = {\n    apiVersion: 'v1',\n    data: {},\n    kind: 'Secret',\n    metadata: {\n      name: `${name}-${secretType}-webhook-secret`,\n      namespace,\n    },\n    stringData: { WebHookSecretKey: generateSecret() },\n    type: SecretType.opaque,\n  };\n\n  return k8sCreate(SecretModel, webhookSecret, dryRun ? dryRunOpt : {});\n};\n\nexport const createOrUpdateBuildConfig = (\n  formData: GitImportFormData,\n  imageStream: K8sResourceKind,\n  dryRun: boolean,\n  originalBuildConfig?: K8sResourceKind,\n  verb: K8sVerb = 'create',\n  generatedImageStreamName: string = '',\n): Promise<K8sResourceKind> => {\n  const {\n    name,\n    project: { name: namespace },\n    application: { name: application },\n    git: { url: repository, type: gitType, ref = 'master', dir: contextDir, secret: secretName },\n    docker: { dockerfilePath },\n    image: { tag: selectedTag },\n    build: { env, triggers, strategy: buildStrategy },\n    labels: userLabels,\n  } = formData;\n\n  const imageStreamName = imageStream && imageStream.metadata.name;\n  const imageStreamNamespace = imageStream && imageStream.metadata.namespace;\n\n  const defaultLabels = getAppLabels(name, application, imageStreamName, selectedTag);\n  const defaultAnnotations = { ...getGitAnnotations(repository, ref), ...getCommonAnnotations() };\n  let buildStrategyData;\n\n  switch (buildStrategy) {\n    case 'Docker':\n      buildStrategyData = {\n        dockerStrategy: { env, dockerfilePath },\n      };\n      break;\n    default:\n      buildStrategyData = {\n        sourceStrategy: {\n          env,\n          from: {\n            kind: 'ImageStreamTag',\n            name: `${imageStreamName}:${selectedTag}`,\n            namespace: imageStreamNamespace,\n          },\n        },\n      };\n      break;\n  }\n\n  const webhookTriggerData = {\n    type: GitReadableTypes[gitType],\n    [gitType]: {\n      secretReference: { name: `${name}-${gitType}-webhook-secret` },\n    },\n  };\n\n  const newBuildConfig = {\n    apiVersion: 'build.openshift.io/v1',\n    kind: 'BuildConfig',\n    metadata: {\n      name,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n      annotations: defaultAnnotations,\n    },\n    spec: {\n      output: {\n        to: {\n          kind: 'ImageStreamTag',\n          name: `${generatedImageStreamName || name}:latest`,\n        },\n      },\n      source: {\n        contextDir,\n        git: {\n          uri: repository,\n          ref,\n          type: 'Git',\n        },\n        ...(secretName ? { sourceSecret: { name: secretName } } : {}),\n      },\n      strategy: {\n        type: buildStrategy,\n        ...buildStrategyData,\n      },\n      triggers: [\n        {\n          type: 'Generic',\n          generic: {\n            secretReference: { name: `${name}-generic-webhook-secret` },\n          },\n        },\n        ...(triggers.webhook && gitType !== GitTypes.unsure ? [webhookTriggerData] : []),\n        ...(triggers.image ? [{ type: 'ImageChange', imageChange: {} }] : []),\n        ...(triggers.config ? [{ type: 'ConfigChange' }] : []),\n      ],\n    },\n  };\n\n  const buildConfig = mergeData(originalBuildConfig, newBuildConfig);\n\n  return verb === 'update'\n    ? k8sUpdate(BuildConfigModel, buildConfig)\n    : k8sCreate(BuildConfigModel, buildConfig, dryRun ? dryRunOpt : {});\n};\n\nexport const createOrUpdateDeployment = (\n  formData: GitImportFormData,\n  imageStream: K8sResourceKind,\n  dryRun: boolean,\n  originalDeployment?: K8sResourceKind,\n  verb: K8sVerb = 'create',\n): Promise<K8sResourceKind> => {\n  const {\n    name,\n    project: { name: namespace },\n    application: { name: application },\n    image: { ports, tag },\n    deployment: {\n      env,\n      replicas,\n      triggers: { image: imageChange },\n    },\n    labels: userLabels,\n    limits: { cpu, memory },\n    git: { url: repository, ref },\n    healthChecks,\n  } = formData;\n\n  const imageStreamName = imageStream && imageStream.metadata.name;\n  const defaultLabels = getAppLabels(name, application, imageStreamName, tag);\n  const annotations = {\n    ...getGitAnnotations(repository, ref),\n    ...getCommonAnnotations(),\n    'alpha.image.policy.openshift.io/resolve-names': '*',\n    ...getTriggerAnnotation(name, namespace, imageChange),\n  };\n  const podLabels = getPodLabels(name);\n\n  const newDeployment = {\n    apiVersion: 'apps/v1',\n    kind: 'Deployment',\n    metadata: {\n      name,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n      annotations,\n    },\n    spec: {\n      selector: {\n        matchLabels: {\n          app: name,\n        },\n      },\n      replicas,\n      template: {\n        metadata: {\n          labels: { ...userLabels, ...podLabels },\n        },\n        spec: {\n          containers: [\n            {\n              name,\n              image: `${name}:latest`,\n              ports,\n              env,\n              resources: {\n                ...((cpu.limit || memory.limit) && {\n                  limits: {\n                    ...(cpu.limit && { cpu: `${cpu.limit}${cpu.limitUnit}` }),\n                    ...(memory.limit && { memory: `${memory.limit}${memory.limitUnit}` }),\n                  },\n                }),\n                ...((cpu.request || memory.request) && {\n                  requests: {\n                    ...(cpu.request && { cpu: `${cpu.request}${cpu.requestUnit}` }),\n                    ...(memory.request && { memory: `${memory.request}${memory.requestUnit}` }),\n                  },\n                }),\n              },\n              ...getProbesData(healthChecks),\n            },\n          ],\n        },\n      },\n    },\n  };\n  const deployment = mergeData(originalDeployment, newDeployment);\n\n  return verb === 'update'\n    ? k8sUpdate(DeploymentModel, deployment)\n    : k8sCreate(DeploymentModel, deployment, dryRun ? dryRunOpt : {});\n};\n\nexport const createOrUpdateDeploymentConfig = (\n  formData: GitImportFormData,\n  imageStream: K8sResourceKind,\n  dryRun: boolean,\n  originalDeploymentConfig?: K8sResourceKind,\n  verb: K8sVerb = 'create',\n): Promise<K8sResourceKind> => {\n  const {\n    name,\n    project: { name: namespace },\n    application: { name: application },\n    image: { ports, tag },\n    deployment: { env, replicas, triggers },\n    labels: userLabels,\n    limits: { cpu, memory },\n    git: { url: repository, ref },\n    healthChecks,\n  } = formData;\n\n  const imageStreamName = imageStream && imageStream.metadata.name;\n  const defaultLabels = getAppLabels(name, application, imageStreamName, tag);\n  const defaultAnnotations = { ...getGitAnnotations(repository, ref), ...getCommonAnnotations() };\n  const podLabels = getPodLabels(name);\n\n  const newDeploymentConfig = {\n    apiVersion: 'apps.openshift.io/v1',\n    kind: 'DeploymentConfig',\n    metadata: {\n      name,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n      annotations: defaultAnnotations,\n    },\n    spec: {\n      selector: podLabels,\n      replicas,\n      template: {\n        metadata: {\n          labels: { ...userLabels, ...podLabels },\n        },\n        spec: {\n          containers: [\n            {\n              name,\n              image: `${name}:latest`,\n              ports,\n              env,\n              resources: {\n                ...((cpu.limit || memory.limit) && {\n                  limits: {\n                    ...(cpu.limit && { cpu: `${cpu.limit}${cpu.limitUnit}` }),\n                    ...(memory.limit && { memory: `${memory.limit}${memory.limitUnit}` }),\n                  },\n                }),\n                ...((cpu.request || memory.request) && {\n                  requests: {\n                    ...(cpu.request && { cpu: `${cpu.request}${cpu.requestUnit}` }),\n                    ...(memory.request && { memory: `${memory.request}${memory.requestUnit}` }),\n                  },\n                }),\n              },\n              ...getProbesData(healthChecks),\n            },\n          ],\n        },\n      },\n      triggers: [\n        {\n          type: 'ImageChange',\n          imageChangeParams: {\n            automatic: triggers.image,\n            containerNames: [name],\n            from: {\n              kind: 'ImageStreamTag',\n              name: `${name}:latest`,\n            },\n          },\n        },\n        ...(triggers.config ? [{ type: 'ConfigChange' }] : []),\n      ],\n    },\n  };\n  const deploymentConfig = mergeData(originalDeploymentConfig, newDeploymentConfig);\n\n  return verb === 'update'\n    ? k8sUpdate(DeploymentConfigModel, deploymentConfig)\n    : k8sCreate(DeploymentConfigModel, deploymentConfig, dryRun ? dryRunOpt : {});\n};\n\nexport const createOrUpdateResources = async (\n  formData: GitImportFormData,\n  imageStream: K8sResourceKind,\n  createNewProject?: boolean,\n  dryRun: boolean = false,\n  verb: K8sVerb = 'create',\n  appResources?: AppResources,\n): Promise<K8sResourceKind[]> => {\n  const {\n    name,\n    project: { name: namespace },\n    route: { create: canCreateRoute, disable },\n    image: { ports },\n    build: {\n      strategy: buildStrategy,\n      triggers: { webhook: webhookTrigger },\n    },\n    deployment: {\n      triggers: { image: imageChange },\n    },\n    git: { url: repository, type: gitType, ref },\n    pipeline,\n    resources,\n  } = formData;\n  const imageStreamName = _.get(imageStream, 'metadata.name');\n\n  createNewProject && (await createProject(formData.project));\n\n  const requests: Promise<K8sResourceKind>[] = [];\n  let generatedImageStreamName: string = '';\n  const imageStreamList = appResources?.imageStream?.data;\n  if (\n    resources === Resources.KnativeService &&\n    imageStreamList &&\n    imageStreamList.length &&\n    verb === 'update'\n  ) {\n    generatedImageStreamName = `${name}-${getRandomChars()}`;\n  }\n  requests.push(\n    createOrUpdateImageStream(\n      formData,\n      imageStream,\n      dryRun,\n      appResources,\n      generatedImageStreamName ? 'create' : verb,\n      generatedImageStreamName,\n    ),\n    createOrUpdateBuildConfig(\n      formData,\n      imageStream,\n      dryRun,\n      _.get(appResources, 'buildConfig.data'),\n      verb,\n      generatedImageStreamName,\n    ),\n  );\n\n  verb === 'create' && requests.push(createWebhookSecret(formData, 'generic', dryRun));\n\n  const defaultAnnotations = getGitAnnotations(repository, ref);\n\n  if (pipeline.enabled && pipeline.template && !dryRun) {\n    requests.push(createPipelineForImportFlow(formData));\n  }\n\n  if (formData.resources === Resources.KnativeService) {\n    // knative service doesn't have dry run capability so returning the promises.\n    if (dryRun) {\n      return Promise.all(requests);\n    }\n    const [imageStreamResponse] = await Promise.all(requests);\n    const imageStreamURL = imageStreamResponse.status.dockerImageRepository;\n\n    const originalAnnotations = appResources?.editAppResource?.data?.metadata?.annotations || {};\n    const triggerAnnotations = getTriggerAnnotation(\n      generatedImageStreamName || name,\n      namespace,\n      imageChange,\n    );\n    const annotations = {\n      ...originalAnnotations,\n      ...defaultAnnotations,\n      ...triggerAnnotations,\n    };\n    const knDeploymentResource = getKnativeServiceDepResource(\n      formData,\n      imageStreamURL,\n      imageStreamName,\n      undefined,\n      undefined,\n      annotations,\n      _.get(appResources, 'editAppResource.data'),\n    );\n    return Promise.all([\n      verb === 'update'\n        ? k8sUpdate(KnServiceModel, knDeploymentResource)\n        : k8sCreate(KnServiceModel, knDeploymentResource),\n    ]);\n  }\n\n  if (formData.resources === Resources.Kubernetes) {\n    requests.push(\n      createOrUpdateDeployment(\n        formData,\n        imageStream,\n        dryRun,\n        _.get(appResources, 'editAppResource.data'),\n        verb,\n      ),\n    );\n  } else if (formData.resources === Resources.OpenShift) {\n    requests.push(\n      createOrUpdateDeploymentConfig(\n        formData,\n        imageStream,\n        dryRun,\n        _.get(appResources, 'editAppResource.data'),\n        verb,\n      ),\n    );\n  }\n\n  if (!_.isEmpty(ports) || buildStrategy === 'Docker') {\n    const originalService = _.get(appResources, 'service.data');\n    const service = createService(formData, imageStream, originalService);\n    requests.push(\n      verb === 'update'\n        ? k8sUpdate(ServiceModel, service)\n        : k8sCreate(ServiceModel, service, dryRun ? dryRunOpt : {}),\n    );\n    const originalRoute = _.get(appResources, 'route.data');\n    const route = createRoute(formData, imageStream, originalRoute);\n    if (verb === 'update' && disable) {\n      requests.push(k8sUpdate(RouteModel, route, namespace, name));\n    } else if (canCreateRoute) {\n      requests.push(k8sCreate(RouteModel, route, dryRun ? dryRunOpt : {}));\n    }\n  }\n\n  if (webhookTrigger && verb === 'create') {\n    requests.push(createWebhookSecret(formData, gitType, dryRun));\n  }\n\n  return Promise.all(requests);\n};\n\nexport const handleRedirect = (project: string, perspective: string) => {\n  const perspectiveData = plugins.registry\n    .getPerspectives()\n    .find((item) => item.properties.id === perspective);\n  const redirectURL = perspectiveData.properties.getImportRedirectURL(project);\n  history.push(redirectURL);\n};\n","import * as _ from 'lodash';\nimport { k8sCreate } from '@console/internal/module/k8s';\nimport { PipelineModel } from '../../../models';\nimport { GitImportFormData } from '../import-types';\nimport { createPipelineResource } from '../../pipelines/pipeline-resource/pipelineResource-utils';\n\nexport const createGitResource = (url: string, namespace: string, ref: string = 'master') => {\n  const params = { url, revision: ref };\n  return createPipelineResource(params, 'git', namespace);\n};\n\nexport const createImageResource = (name: string, namespace: string) => {\n  const params = {\n    url: `image-registry.openshift-image-registry.svc:5000/${namespace}/${name}`,\n  };\n\n  return createPipelineResource(params, 'image', namespace);\n};\n\nexport const createPipelineForImportFlow = async (formData: GitImportFormData) => {\n  const {\n    name,\n    project: { name: namespace },\n    git,\n    pipeline,\n  } = formData;\n  const template = _.cloneDeep(pipeline.template);\n\n  template.metadata = {\n    name: `${name}`,\n    namespace,\n    labels: { ...template.metadata.labels, 'app.kubernetes.io/instance': name },\n  };\n\n  template.spec.params =\n    template.spec.params &&\n    template.spec.params.map((param) => {\n      if (param.name === 'APP_NAME') {\n        param.default = name;\n      }\n      return param;\n    });\n\n  try {\n    await createGitResource(git.url, namespace, git.ref);\n    await createImageResource(name, namespace);\n  } catch (err) {\n    throw err;\n  }\n\n  return k8sCreate(PipelineModel, template, { ns: namespace });\n};\n","import { PipelineResourceType } from '../../const';\n\nexport const CREATE_PIPELINE_RESOURCE = '#CREATE_PIPELINE_RESOURCE#';\n\nexport const initialResourceFormValues = {\n  [PipelineResourceType.git]: {\n    params: {\n      url: '',\n      revision: '',\n    },\n  },\n  [PipelineResourceType.image]: {\n    params: {\n      url: '',\n    },\n  },\n  [PipelineResourceType.storage]: {\n    params: {\n      type: '',\n      location: '',\n      dir: '',\n    },\n  },\n  [PipelineResourceType.cluster]: {\n    params: {\n      name: '',\n      url: '',\n      username: '',\n      password: '',\n      insecure: '',\n    },\n    secrets: {\n      cadata: '',\n      token: '',\n    },\n  },\n};\n","import * as _ from 'lodash';\nimport { getRandomChars } from '@console/shared';\nimport {\n  Pipeline,\n  PipelineResource,\n  PipelineRun,\n  PipelineRunInlineResource,\n  PipelineRunInlineResourceParam,\n  PipelineRunReferenceResource,\n  PipelineRunResource,\n} from '../../../../utils/pipeline-augment';\nimport { PipelineRunModel } from '../../../../models';\nimport { getPipelineRunParams, getPipelineRunWorkspaces } from '../../../../utils/pipeline-utils';\nimport { CREATE_PIPELINE_RESOURCE, initialResourceFormValues } from './const';\nimport { CommonPipelineModalFormikValues, PipelineModalFormResource } from './types';\n\n/**\n * Migrates a PipelineRun from one version to another to support auto-upgrades with old (and invalid) PipelineRuns.\n *\n * Note: Each check within this method should be driven by the apiVersion number if the API is properly up-versioned\n * for these breaking changes. (should be done moving from 0.10.x forward)\n */\nexport const migratePipelineRun = (pipelineRun: PipelineRun): PipelineRun => {\n  let newPipelineRun = pipelineRun;\n\n  const serviceAccountPath = 'spec.serviceAccount';\n  if (_.has(newPipelineRun, serviceAccountPath)) {\n    // .spec.serviceAccount was removed for .spec.serviceAccountName in 0.9.x\n    // Note: apiVersion was not updated for this change and thus we cannot gate this change behind a version number\n    const serviceAccountName = _.get(newPipelineRun, serviceAccountPath);\n    newPipelineRun = _.omit(newPipelineRun, [serviceAccountPath]);\n    newPipelineRun = _.merge(newPipelineRun, {\n      spec: {\n        serviceAccountName,\n      },\n    });\n  }\n\n  return newPipelineRun;\n};\n\nexport const getPipelineRunData = (\n  pipeline: Pipeline = null,\n  latestRun?: PipelineRun,\n): PipelineRun => {\n  if (!pipeline && !latestRun) {\n    // eslint-disable-next-line no-console\n    console.error('Missing parameters, unable to create new PipelineRun');\n    return null;\n  }\n\n  const pipelineName = pipeline ? pipeline.metadata.name : latestRun.spec.pipelineRef.name;\n\n  const resources = latestRun?.spec.resources;\n  const workspaces = latestRun?.spec.workspaces;\n\n  const latestRunParams = latestRun?.spec.params;\n  const pipelineParams = pipeline?.spec.params;\n  const params = latestRunParams || getPipelineRunParams(pipelineParams);\n\n  const newPipelineRun = {\n    apiVersion: pipeline ? pipeline.apiVersion : latestRun.apiVersion,\n    kind: PipelineRunModel.kind,\n    metadata: {\n      name: `${pipelineName}-${getRandomChars(6)}`,\n      namespace: pipeline ? pipeline.metadata.namespace : latestRun.metadata.namespace,\n      labels: _.merge({}, pipeline?.metadata?.labels, latestRun?.metadata?.labels, {\n        'tekton.dev/pipeline': pipelineName,\n      }),\n    },\n    spec: {\n      ...(latestRun?.spec || {}),\n      pipelineRef: {\n        name: pipelineName,\n      },\n      resources,\n      ...(params && { params }),\n      workspaces,\n      status: null,\n    },\n  };\n  return migratePipelineRun(newPipelineRun);\n};\n\nexport const convertPipelineToModalData = (\n  pipeline: Pipeline,\n  alwaysCreateResources: boolean = false,\n): CommonPipelineModalFormikValues => {\n  const {\n    metadata: { namespace },\n    spec: { params, resources },\n  } = pipeline;\n\n  return {\n    namespace,\n    parameters: params || [],\n    resources: (resources || []).map((resource: PipelineResource) => ({\n      name: resource.name,\n      selection: alwaysCreateResources ? CREATE_PIPELINE_RESOURCE : null,\n      data: {\n        ...initialResourceFormValues[resource.type],\n        type: resource.type,\n      },\n    })),\n  };\n};\n\nexport const convertMapToNameValueArray = (map: {\n  [key: string]: any;\n}): PipelineRunInlineResourceParam[] => {\n  return Object.keys(map).map((name) => {\n    const value = map[name];\n    return { name, value };\n  });\n};\n\nconst convertResources = (resource: PipelineModalFormResource): PipelineRunResource => {\n  if (resource.selection === CREATE_PIPELINE_RESOURCE) {\n    return {\n      name: resource.name,\n      resourceSpec: {\n        params: convertMapToNameValueArray(resource.data.params),\n        type: resource.data.type,\n      },\n    } as PipelineRunInlineResource;\n  }\n\n  return {\n    name: resource.name,\n    resourceRef: {\n      name: resource.selection,\n    },\n  } as PipelineRunReferenceResource;\n};\n\nexport const getPipelineRunFromForm = (\n  pipeline: Pipeline,\n  formValues: CommonPipelineModalFormikValues,\n  labels?: { [key: string]: string },\n) => {\n  const { parameters, resources, workspaces } = formValues;\n\n  const pipelineRunData: PipelineRun = {\n    metadata: {\n      labels,\n    },\n    spec: {\n      pipelineRef: {\n        name: pipeline.metadata.name,\n      },\n      params: getPipelineRunParams(parameters),\n      resources: resources.map(convertResources),\n      workspaces: getPipelineRunWorkspaces(workspaces),\n    },\n  };\n  return getPipelineRunData(pipeline, pipelineRunData);\n};\n","import * as _ from 'lodash';\nimport { k8sCreate, K8sResourceKind } from '@console/internal/module/k8s';\nimport { SecretModel } from '@console/internal/models';\nimport { getRandomChars } from '@console/shared/src/utils/utils';\nimport { PipelineResourceModel } from '../../../models';\nimport { convertMapToNameValueArray } from '../modals/common/utils';\n\nexport interface ParamData {\n  [key: string]: any;\n}\n\nexport const getDefinedObj = (objData: ParamData): ParamData => {\n  return _.omitBy(objData, (v) => _.isUndefined(v) || _.isNull(v) || v === '');\n};\n\nexport const createPipelineResource = (\n  params: ParamData,\n  type: string,\n  namespace: string,\n  secretResp?: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  const resourceName = `${type}-${getRandomChars(6)}`;\n  const pipelineResource: K8sResourceKind = {\n    apiVersion: 'tekton.dev/v1alpha1',\n    kind: PipelineResourceModel.kind,\n    metadata: {\n      name: resourceName,\n      namespace,\n    },\n    spec: {\n      type,\n      params: convertMapToNameValueArray(getDefinedObj(params)),\n      ...(secretResp && {\n        secrets: _.map(secretResp.data, (value, name) => {\n          return {\n            fieldName: name,\n            secretKey: name,\n            secretName: secretResp.metadata.name,\n          };\n        }),\n      }),\n    },\n  };\n\n  return k8sCreate(PipelineResourceModel, pipelineResource);\n};\n\nexport const createSecretResource = (\n  secret: ParamData,\n  type: string,\n  namespace: string,\n): Promise<K8sResourceKind> => {\n  const resourceName = `${type}-secret-${getRandomChars(6)}`;\n  const secretResource = {\n    apiVersion: 'v1',\n    kind: 'Secret',\n    metadata: {\n      name: resourceName,\n      namespace,\n    },\n    stringData: getDefinedObj(secret),\n  };\n  return k8sCreate(SecretModel, secretResource);\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAQA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAQA;AAWA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AAgBA;AACA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAIA;AAEA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AAYA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AAIA;AAEA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAQA;AAgBA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAmBA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAKA;AAKA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AASA;AAAA;AACA;AASA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC3iBA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAUA;AACA;AACA;AAGA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAMA;AACA;AACA;AAEA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}