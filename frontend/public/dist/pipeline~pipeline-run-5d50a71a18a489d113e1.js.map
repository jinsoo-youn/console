{"version":3,"file":"pipeline~pipeline-run-5d50a71a18a489d113e1.js","sources":["webpack:///./public/components/hypercloud/pipeline-run.tsx","webpack:///./public/components/hypercloud/pipelineruns/linked-pipeline-run-task-status.tsx","webpack:///./public/components/hypercloud/pipelineruns/pipeline-bars.tsx","webpack:///./public/components/hypercloud/pipelineruns/pipeline-task-status.tsx","webpack:///./public/components/hypercloud/pipelineruns/task-status-tooltip.scss?01ce","webpack:///./public/components/hypercloud/pipelineruns/task-status-tooltip.tsx","webpack:///./public/components/hypercloud/pipelines/const.ts","webpack:///./public/components/hypercloud/pipelines/modals/const.ts","webpack:///./public/components/hypercloud/pipelines/modals/utils.ts","webpack:///./public/components/hypercloud/utils/horizontal-stacked-bars.scss?bdcb","webpack:///./public/components/hypercloud/utils/horizontal-stacked-bars.tsx","webpack:///./public/components/hypercloud/utils/pipeline-actions.tsx","webpack:///./public/components/hypercloud/utils/pipeline-augment.ts","webpack:///./public/components/hypercloud/utils/pipeline-utils.ts"],"sourcesContent":["import * as _ from 'lodash-es';\nimport * as React from 'react';\nimport * as classNames from 'classnames';\nimport { sortable } from '@patternfly/react-table';\n\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { DetailsPage, ListPage, Table, TableRow, TableData, RowFunction } from '../factory';\nimport { Kebab, detailsPage, Timestamp, navFactory, ResourceKebab, ResourceLink, ResourceSummary, SectionHeading } from '../utils';\nimport { PipelineRunModel, PipelineModel, PipelineResourceModel } from '../../models';\nimport { pipelineRunDuration } from './utils/pipeline-utils';\nimport { PipelineRun, pipelineRefExists, PipelineRunReferenceResource } from './utils/pipeline-augment';\nimport { pipelineRunFilterReducer } from './utils/pipeline-filter-reducer';\nimport LinkedPipelineRunTaskStatus from './pipelineruns/linked-pipeline-run-task-status';\nimport { getPipelineRunKebabActions } from './utils/pipeline-actions';\nimport { PipelineRunLogsWithActiveTask } from '../../../packages/dev-console/src/components/pipelineruns/detail-page-tabs/PipelineRunLogs';\nimport PipelineRunVisualization from '../../../packages/dev-console/src/components/pipelineruns/detail-page-tabs/PipelineRunVisualization';\nimport ResourceLinkList from '../../../packages/dev-console/src/components/pipelines/resource-overview/ResourceLinkList';\nimport TriggeredBySection from '../../../packages/dev-console/src/components/pipelineruns/detail-page-tabs/TriggeredBySection';\nimport { Status } from '@console/shared';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { ResourceLabel } from '../../models/hypercloud/resource-plural';\n\nconst kind = PipelineRunModel.kind;\n\nconst tableColumnClasses = [\n  '', // name\n  '', // namespace\n  'pf-m-hidden pf-m-visible-on-sm', // status\n  'pf-m-hidden pf-m-visible-on-lg', // task status\n  'pf-m-hidden pf-m-visible-on-lg', // started\n  'pf-m-hidden pf-m-visible-on-xl', // duration\n  Kebab.columnClass,\n];\n\n\nconst PipelineRunTableHeader = (t?: TFunction) => {\n  return [\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_1'),\n      sortField: 'metadata.name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_2'),\n      sortField: 'metadata.namespace',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_3'),\n      sortField: 'status.conditions[0].reason',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_78'),\n      sortField: 'status.conditions[0].reason',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_6'),\n      sortField: 'status.startTime',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[4] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_81'),\n      sortField: 'status.completionTime',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[5] },\n    },\n    {\n      title: '',\n      props: { className: tableColumnClasses[6] },\n    },\n  ];\n};\n\nPipelineRunTableHeader.displayName = 'PipelineRunTableHeader';\n\n\nconst PipelineRunTableRow: RowFunction<PipelineRun> = ({ obj: pipelineRun, index, key, style }) => {\n  return (\n    <TableRow id={pipelineRun.metadata.uid} index={index} trKey={key} style={style}>\n      <TableData className={tableColumnClasses[0]}>\n        <ResourceLink kind={kind} name={pipelineRun.metadata.name} namespace={pipelineRun.metadata.namespace} title={pipelineRun.metadata.uid} />\n      </TableData>\n      <TableData className={classNames(tableColumnClasses[1], 'co-break-word')}>\n        <ResourceLink kind=\"Namespace\" name={pipelineRun.metadata.namespace} title={pipelineRun.metadata.namespace} />\n      </TableData>\n      <TableData className={tableColumnClasses[2]}>\n        <Status status={pipelineRunFilterReducer(pipelineRun)} />\n      </TableData>\n      <TableData className={tableColumnClasses[3]}>\n        <LinkedPipelineRunTaskStatus pipelineRun={pipelineRun} />\n      </TableData>\n      <TableData className={tableColumnClasses[4]}>\n        <Timestamp timestamp={pipelineRun.status && pipelineRun.status.startTime} />\n      </TableData>\n      <TableData className={tableColumnClasses[5]}>{pipelineRunDuration(pipelineRun)}</TableData>\n      <TableData className={tableColumnClasses[6]}>\n        <ResourceKebab actions={getPipelineRunKebabActions()} kind={kind} resource={pipelineRun} />\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const PipelineRunDetailsList: React.FC<PipelineRunDetailsListProps> = ({ pipelineRun }) => {\n  const unfilteredResources = pipelineRun.spec.resources as PipelineRunReferenceResource[];\n  const renderResources =\n    unfilteredResources\n      ?.filter(({ resourceRef }) => !!resourceRef)\n      .map((resource) => resource.resourceRef.name) || [];\n\n  return (\n    <div className=\"col-sm-6 odc-pipeline-run-details__customDetails\">\n      {pipelineRefExists(pipelineRun) && (\n        <dl>\n          <dt>Pipeline</dt>\n          <dd>\n            <ResourceLink\n              kind={referenceForModel(PipelineModel)}\n              name={pipelineRun.spec.pipelineRef.name}\n              namespace={pipelineRun.metadata.namespace}\n            />\n          </dd>\n        </dl>\n      )}\n      <TriggeredBySection pipelineRun={pipelineRun} />\n      <br />\n      <ResourceLinkList\n        model={PipelineResourceModel}\n        links={renderResources}\n        namespace={pipelineRun.metadata.namespace}\n      />\n    </div>\n  );\n}\n\nconst PipelineRunDetails: React.FC<PipelineRunDetailsProps> = ({ obj: pipelineRun }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', { 0: ResourceLabel(pipelineRun, t) })} />\n        <PipelineRunVisualization pipelineRun={pipelineRun} />\n        <div className=\"row\">\n          <div className=\"col-lg-6\">\n            <ResourceSummary resource={pipelineRun} />\n          </div>\n          <div className=\"col-lg-6\">\n            <PipelineRunDetailsList pipelineRun={pipelineRun} />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n}\n\n\nconst { details, editYaml } = navFactory;\n\nconst filters = [\n  {\n    filterGroupName: 'Status',\n    type: 'pipeline-run-status',\n    reducer: pipelineRunFilterReducer,\n    items: [\n      { id: 'Succeeded', title: 'Succeeded' },\n      { id: 'Running', title: 'Running' },\n      { id: 'Failed', title: 'Failed' },\n      { id: 'Cancelled', title: 'Cancelled' },\n    ],\n  },\n];\n\nexport const PipelineRuns: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Pipeline Runs\" Header={PipelineRunTableHeader.bind(null, t)} Row={PipelineRunTableRow} virtualize />;\n}\n\nexport const PipelineRunsPage: React.FC<PipelineRunsPageProps> = props => {\n  const { t } = useTranslation();\n\n  return <ListPage\n    title={t('COMMON:MSG_LNB_MENU_60')}\n    createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_60') })}\n    canCreate={true}\n    ListComponent={PipelineRuns}\n    kind={kind}\n    rowFilters={filters}\n    {...props}\n  />;\n}\n\nexport const PipelineRunsDetailsPage: React.FC<PipelineRunsDetailsPageProps> = props => <DetailsPage {...props} kind={kind} menuActions={getPipelineRunKebabActions()} pages={[details(detailsPage(PipelineRunDetails)), editYaml(), {\n  href: 'logs',\n  path: 'logs/:name?',\n  name: 'Logs',\n  component: PipelineRunLogsWithActiveTask,\n},]} />;\n\n\ntype PipelineRunDetailsListProps = {\n  pipelineRun: PipelineRun;\n};\n\ntype PipelineRunsPageProps = {\n  canCreate?: boolean;\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype PipelineRunDetailsProps = {\n  obj: PipelineRun;\n};\n\ntype PipelineRunsDetailsPageProps = {\n  match: any;\n};","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport { resourcePathFromModel } from '@console/internal/components/utils';\nimport { Pipeline, PipelineRun } from '../utils/pipeline-augment';\nimport { PipelineRunModel } from '../../../models';\nimport { PipelineTaskStatus } from './pipeline-task-status';\n\nexport interface LinkedPipelineRunTaskStatusProps {\n  pipeline?: Pipeline;\n  pipelineRun: PipelineRun;\n}\n\n/**\n * Will attempt to render a link to the log file associated with the pipelineRun if it has the data.\n * If it does not, it'll just render the pipeline status.\n */\nconst LinkedPipelineRunTaskStatus: React.FC<LinkedPipelineRunTaskStatusProps> = ({\n  pipeline,\n  pipelineRun,\n}) => {\n  const pipelineStatus = (\n    <PipelineTaskStatus\n      key={pipelineRun.metadata?.name}\n      pipeline={pipeline}\n      pipelinerun={pipelineRun}\n    />\n  );\n\n  if (pipelineRun.metadata?.name && pipelineRun.metadata?.namespace) {\n    return (\n      <Link\n        to={`${resourcePathFromModel(\n          PipelineRunModel,\n          pipelineRun.metadata.name,\n          pipelineRun.metadata.namespace,\n        )}/logs`}\n      >\n        {pipelineStatus}\n      </Link>\n    );\n  }\n\n  return pipelineStatus;\n};\n\nexport default LinkedPipelineRunTaskStatus;\n","import * as React from 'react';\nimport { Tooltip } from '@patternfly/react-core';\nimport HorizontalStackedBars from '../utils/horizontal-stacked-bars';\nimport {\n  getTaskStatus,\n  runStatus,\n  getRunStatusColor,\n  Pipeline,\n  PipelineRun,\n} from '../utils/pipeline-augment';\nimport TaskStatusToolTip from './task-status-tooltip';\n\nexport interface PipelineBarProps {\n  pipelinerun: PipelineRun;\n  pipeline?: { data: Pipeline };\n}\n\nexport const PipelineBars: React.FC<PipelineBarProps> = ({ pipelinerun, pipeline }) => {\n  const taskStatus = getTaskStatus(pipelinerun, pipeline?.data);\n\n  return (\n    <Tooltip content={<TaskStatusToolTip taskStatus={taskStatus} />}>\n      <HorizontalStackedBars\n        height=\"1em\"\n        inline\n        values={Object.keys(runStatus).map((status) => ({\n          color: getRunStatusColor(runStatus[status]).pftoken.value,\n          name: status,\n          size: taskStatus[runStatus[status]],\n        }))}\n      />\n    </Tooltip>\n  );\n};\n","import * as React from 'react';\nimport { Firehose } from '@console/internal/components/utils';\nimport { PipelineRun, Pipeline } from '../utils/pipeline-augment';\nimport { PipelineModel } from '../../../models';\nimport { PipelineBars } from './pipeline-bars';\n\nexport interface PipelineTaskStatusProps {\n  pipelinerun: PipelineRun;\n  pipeline?: Pipeline;\n}\n\nexport const PipelineTaskStatus: React.FC<PipelineTaskStatusProps> = ({\n  pipelinerun,\n  pipeline,\n}) => {\n  return !pipeline && pipelinerun.spec?.pipelineRef?.name && pipelinerun.metadata?.namespace ? (\n    <Firehose\n      resources={[\n        {\n          name: pipelinerun.spec.pipelineRef.name,\n          namespace: pipelinerun.metadata.namespace,\n          kind: PipelineModel.kind,\n          isList: false,\n          prop: 'pipeline',\n        },\n      ]}\n    >\n      <PipelineBars pipelinerun={pipelinerun} />\n    </Firehose>\n  ) : (\n    <PipelineBars pipelinerun={pipelinerun} pipeline={{ data: pipeline }} />\n  );\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { TaskStatus, runStatus, getRunStatusColor } from '../utils/pipeline-augment';\nimport './task-status-tooltip.scss';\n\ninterface TaskStatusToolTipProps {\n  taskStatus: TaskStatus;\n}\n\nconst TaskStatusToolTip: React.FC<TaskStatusToolTipProps> = ({ taskStatus }) => {\n  return (\n    <div className=\"odc-task-status-tooltip\">\n      {Object.keys(runStatus).map((status) => {\n        const { message, pftoken } = getRunStatusColor(status);\n        return taskStatus[status] ? (\n          <React.Fragment key={status}>\n            <div\n              className=\"odc-task-status-tooltip__legend\"\n              style={{ background: pftoken.value }}\n            />\n            <div>\n              {status === runStatus.PipelineNotStarted || status === runStatus.FailedToStart\n                ? message\n                : `${taskStatus[status]} ${message}`}\n            </div>\n          </React.Fragment>\n        ) : null;\n      })}\n    </div>\n  );\n};\n\nexport default TaskStatusToolTip;\n","export enum StartedByLabel {\n  user = 'pipeline.openshift.io/started-by',\n  triggers = 'triggers.tekton.dev/eventlistener',\n}\n\nexport enum PipelineResourceType {\n  git = 'git',\n  image = 'image',\n  cluster = 'cluster',\n  storage = 'storage',\n}\n\nexport const pipelineResourceTypeSelections = {\n  '': 'Select resource type',\n  [PipelineResourceType.git]: 'Git',\n  [PipelineResourceType.image]: 'Image',\n  [PipelineResourceType.cluster]: 'Cluster',\n  [PipelineResourceType.storage]: 'Storage',\n};\n\nexport enum VolumeTypes {\n  EmptyDirectory = 'Empty Directory',\n  ConfigMap = 'Config Map',\n  Secret = 'Secret',\n  PVC = 'PVC',\n}\n\nexport enum SecretAnnotationId {\n  Git = 'git',\n  Image = 'docker',\n}\n\nexport const SecretAnnotationType = {\n  [SecretAnnotationId.Git]: 'Git Server',\n  [SecretAnnotationId.Image]: 'Docker Registry',\n};\n\nexport const PIPELINE_SERVICE_ACCOUNT = 'pipeline';\n","import { PipelineResourceType } from '../const';\n\nexport const CREATE_PIPELINE_RESOURCE = '#CREATE_PIPELINE_RESOURCE#';\n\nexport const initialResourceFormValues = {\n  [PipelineResourceType.git]: {\n    params: {\n      url: '',\n      revision: '',\n    },\n  },\n  [PipelineResourceType.image]: {\n    params: {\n      url: '',\n    },\n  },\n  [PipelineResourceType.storage]: {\n    params: {\n      type: '',\n      location: '',\n      dir: '',\n    },\n  },\n  [PipelineResourceType.cluster]: {\n    params: {\n      name: '',\n      url: '',\n      username: '',\n      password: '',\n      insecure: '',\n    },\n    secrets: {\n      cadata: '',\n      token: '',\n    },\n  },\n};\n","import * as _ from 'lodash';\nimport { getRandomChars } from '@console/shared';\nimport {\n  Pipeline,\n  PipelineResource,\n  PipelineRun,\n  PipelineRunInlineResource,\n  PipelineRunInlineResourceParam,\n  PipelineRunReferenceResource,\n  PipelineRunResource,\n} from '../../utils/pipeline-augment';\nimport { PipelineRunModel } from '../../../../models';\nimport { getPipelineRunParams, getPipelineRunWorkspaces } from '../../utils/pipeline-utils';\nimport { CREATE_PIPELINE_RESOURCE, initialResourceFormValues } from './const';\nimport { CommonPipelineModalFormikValues, PipelineModalFormResource } from './types';\n\n/**\n * Migrates a PipelineRun from one version to another to support auto-upgrades with old (and invalid) PipelineRuns.\n *\n * Note: Each check within this method should be driven by the apiVersion number if the API is properly up-versioned\n * for these breaking changes. (should be done moving from 0.10.x forward)\n */\nexport const migratePipelineRun = (pipelineRun: PipelineRun): PipelineRun => {\n  let newPipelineRun = pipelineRun;\n\n  const serviceAccountPath = 'spec.serviceAccount';\n  if (_.has(newPipelineRun, serviceAccountPath)) {\n    // .spec.serviceAccount was removed for .spec.serviceAccountName in 0.9.x\n    // Note: apiVersion was not updated for this change and thus we cannot gate this change behind a version number\n    const serviceAccountName = _.get(newPipelineRun, serviceAccountPath);\n    newPipelineRun = _.omit(newPipelineRun, [serviceAccountPath]);\n    newPipelineRun = _.merge(newPipelineRun, {\n      spec: {\n        serviceAccountName,\n      },\n    });\n  }\n\n  return newPipelineRun;\n};\n\nexport const getPipelineRunData = (\n  pipeline: Pipeline = null,\n  latestRun?: PipelineRun,\n): PipelineRun => {\n  if (!pipeline && !latestRun) {\n    // eslint-disable-next-line no-console\n    console.error('Missing parameters, unable to create new PipelineRun');\n    return null;\n  }\n\n  const pipelineName = pipeline ? pipeline.metadata.name : latestRun.spec.pipelineRef.name;\n\n  const resources = latestRun?.spec.resources;\n  const workspaces = latestRun?.spec.workspaces;\n\n  const latestRunParams = latestRun?.spec.params;\n  const pipelineParams = pipeline?.spec.params;\n  const params = latestRunParams || getPipelineRunParams(pipelineParams);\n\n  const newPipelineRun = {\n    apiVersion: pipeline ? pipeline.apiVersion : latestRun.apiVersion,\n    kind: PipelineRunModel.kind,\n    metadata: {\n      name: `${pipelineName}-${getRandomChars(6)}`,\n      namespace: pipeline ? pipeline.metadata.namespace : latestRun.metadata.namespace,\n      labels: _.merge({}, pipeline?.metadata?.labels, latestRun?.metadata?.labels, {\n        'tekton.dev/pipeline': pipelineName,\n      }),\n    },\n    spec: {\n      ...(latestRun?.spec || {}),\n      pipelineRef: {\n        name: pipelineName,\n      },\n      resources,\n      ...(params && { params }),\n      workspaces,\n      status: null,\n    },\n  };\n  return migratePipelineRun(newPipelineRun);\n};\n\nexport const convertPipelineToModalData = (\n  pipeline: Pipeline,\n  alwaysCreateResources: boolean = false,\n): CommonPipelineModalFormikValues => {\n  const {\n    metadata: { namespace },\n    spec: { params, resources },\n  } = pipeline;\n\n  return {\n    namespace,\n    parameters: params || [],\n    resources: (resources || []).map((resource: PipelineResource) => ({\n      name: resource.name,\n      selection: alwaysCreateResources ? CREATE_PIPELINE_RESOURCE : null,\n      data: {\n        ...initialResourceFormValues[resource.type],\n        type: resource.type,\n      },\n    })),\n  };\n};\n\nexport const convertMapToNameValueArray = (map: {\n  [key: string]: any;\n}): PipelineRunInlineResourceParam[] => {\n  return Object.keys(map).map((name) => {\n    const value = map[name];\n    return { name, value };\n  });\n};\n\nconst convertResources = (resource: PipelineModalFormResource): PipelineRunResource => {\n  if (resource.selection === CREATE_PIPELINE_RESOURCE) {\n    return {\n      name: resource.name,\n      resourceSpec: {\n        params: convertMapToNameValueArray(resource.data.params),\n        type: resource.data.type,\n      },\n    } as PipelineRunInlineResource;\n  }\n\n  return {\n    name: resource.name,\n    resourceRef: {\n      name: resource.selection,\n    },\n  } as PipelineRunReferenceResource;\n};\n\nexport const getPipelineRunFromForm = (\n  pipeline: Pipeline,\n  formValues: CommonPipelineModalFormikValues,\n  labels?: { [key: string]: string },\n) => {\n  const { parameters, resources, workspaces } = formValues;\n\n  const pipelineRunData: PipelineRun = {\n    metadata: {\n      labels,\n    },\n    spec: {\n      pipelineRef: {\n        name: pipeline.metadata.name,\n      },\n      params: getPipelineRunParams(parameters),\n      resources: resources.map(convertResources),\n      workspaces: getPipelineRunWorkspaces(workspaces),\n    },\n  };\n  return getPipelineRunData(pipeline, pipelineRunData);\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport classNames from 'classnames';\nimport './horizontal-stacked-bars.scss';\n\nexport type StackedValue = {\n  color: string;\n  name: string;\n  size: number;\n};\n\nexport type HorizontalStackedBarsProps = {\n  barGap?: number;\n  height?: number | string;\n  inline?: boolean;\n  values: StackedValue[];\n  width?: number | string;\n};\n\nconst HorizontalStackedBars: React.FC<HorizontalStackedBarsProps> = ({\n  barGap,\n  height,\n  inline,\n  values,\n  width,\n}) => {\n  return (\n    <div\n      className={classNames('odc-horizontal-stacked-bars', { 'is-inline': inline })}\n      style={{ height, width, ['--bar-gap' as any]: barGap && `${barGap}px` }}\n    >\n      <div className=\"odc-horizontal-stacked-bars__bars\">\n        {values.map(({ color, name, size }) => (\n          <div\n            key={name}\n            className=\"odc-horizontal-stacked-bars__data-bar\"\n            style={{\n              background: color,\n              flexGrow: size,\n            }}\n          />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default HorizontalStackedBars;\n","import * as _ from 'lodash';\nimport {\n  history,\n  resourcePathFromModel,\n  Kebab,\n  KebabAction,\n} from '@console/internal/components/utils';\nimport { k8sCreate, K8sKind, k8sPatch, referenceForModel } from '@console/internal/module/k8s';\nimport { errorModal } from '@console/internal/components/modals';\n// import {\n//   addTriggerModal,\n//   startPipelineModal,\n//   removeTriggerModal,\n// } from '../pipelines/modals';\nimport { startPipelineModal } from '../../../../packages/dev-console/src/components/pipelines/modals';\nimport { getPipelineRunData } from '../pipelines/modals/utils';\n//import { StartedByLabel } from '../pipelines/const';\nimport { EventListenerModel, PipelineModel, PipelineRunModel } from '../../../models';\nimport { Pipeline, PipelineRun } from './pipeline-augment';\nimport { pipelineRunFilterReducer } from './pipeline-filter-reducer';\n\nexport const handlePipelineRunSubmit = (pipelineRun: PipelineRun) => {\n  history.push(\n    resourcePathFromModel(\n      PipelineRunModel,\n      pipelineRun.metadata.name,\n      pipelineRun.metadata.namespace,\n    ),\n  );\n};\n\nexport const triggerPipeline = (\n  pipeline: Pipeline,\n  onSubmit?: (pipelineRun: PipelineRun) => void,\n) => {\n  k8sCreate(PipelineRunModel, getPipelineRunData(pipeline))\n    .then(onSubmit)\n    .catch((err) => errorModal({ error: err.message }));\n};\n\nexport const reRunPipelineRun: KebabAction = (kind: K8sKind, pipelineRun: PipelineRun) => ({\n  label: 'Rerun',\n  callback: () => {\n    const namespace = _.get(pipelineRun, 'metadata.namespace');\n    const pipelineRef = _.get(pipelineRun, 'spec.pipelineRef.name');\n    if (namespace && pipelineRef) {\n      k8sCreate(PipelineRunModel, getPipelineRunData(null, pipelineRun));\n    } else {\n      errorModal({ error: 'Invalid Pipeline Run configuration, unable to start Pipeline.' });\n    }\n  },\n  accessReview: {\n    group: kind.apiGroup,\n    resource: kind.plural,\n    name: pipelineRun.metadata.name,\n    namespace: pipelineRun.metadata.namespace,\n    verb: 'create',\n  },\n});\n\nexport const editPipeline: KebabAction = (kind: K8sKind, pipeline: Pipeline) => ({\n  label: 'Edit Pipeline',\n  callback: () => {\n    const {\n      metadata: { name, namespace },\n    } = pipeline;\n    history.push(`/k8s/ns/${namespace}/${referenceForModel(PipelineModel)}/${name}/builder`);\n  },\n  accessReview: {\n    group: kind.apiGroup,\n    resource: kind.plural,\n    name: pipeline.metadata.name,\n    namespace: pipeline.metadata.namespace,\n    verb: 'update',\n  },\n});\n\nexport const startPipeline: KebabAction = (\n  kind: K8sKind,\n  pipeline: Pipeline,\n  onSubmit?: (pipelineRun: PipelineRun) => void,\n) => ({\n  label: 'Start',\n  callback: () => {\n    const params = _.get(pipeline, ['spec', 'params'], []);\n    const resources = _.get(pipeline, ['spec', 'resources'], []);\n    const workspaces = _.get(pipeline, ['spec', 'workspaces'], []);\n\n    if (!_.isEmpty(params) || !_.isEmpty(resources) || !_.isEmpty(workspaces)) {\n      startPipelineModal({\n        pipeline,\n        modalClassName: 'modal-lg',\n        onSubmit,\n      });\n    } else {\n      triggerPipeline(pipeline, onSubmit);\n    }\n  },\n  accessReview: {\n    group: kind.apiGroup,\n    resource: kind.plural,\n    name: pipeline.metadata.name,\n    namespace: pipeline.metadata.namespace,\n    verb: 'create',\n  },\n});\n\ntype RerunPipelineData = {\n  onComplete?: (pipelineRun: PipelineRun) => void;\n  label?: string;\n};\nconst rerunPipeline: KebabAction = (\n  kind: K8sKind,\n  pipelineRun: PipelineRun,\n  resources: any,\n  customData: RerunPipelineData = { label: 'Start Last Run' },\n) => {\n  const { onComplete } = customData;\n\n  const sharedProps = { label: customData.label, accessReview: {} };\n\n  if (\n    !pipelineRun ||\n    !_.has(pipelineRun, 'metadata.name') ||\n    !_.has(pipelineRun, 'metadata.namespace')\n  ) {\n    return sharedProps;\n  }\n\n  return {\n    ...sharedProps,\n    callback: () => {\n      k8sCreate(PipelineRunModel, getPipelineRunData(null, pipelineRun))\n        .then(typeof onComplete === 'function' ? onComplete : () => {})\n        .catch((err) => errorModal({ error: err.message }));\n    },\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: pipelineRun.metadata.name,\n      namespace: pipelineRun.metadata.namespace,\n      verb: 'create',\n    },\n  };\n};\n\nexport const rerunPipelineAndStay: KebabAction = (kind: K8sKind, pipelineRun: PipelineRun) => {\n  return rerunPipeline(kind, pipelineRun);\n};\n\nexport const rerunPipelineAndRedirect: KebabAction = (kind: K8sKind, pipelineRun: PipelineRun) => {\n  return rerunPipeline(kind, pipelineRun, null, {\n    onComplete: handlePipelineRunSubmit,\n    label: 'Start Last Run',\n  });\n};\n\nexport const rerunPipelineRunAndRedirect: KebabAction = (\n  kind: K8sKind,\n  pipelineRun: PipelineRun,\n) => {\n  return rerunPipeline(kind, pipelineRun, null, {\n    onComplete: handlePipelineRunSubmit,\n    label: 'Rerun',\n  });\n};\n\nexport const stopPipelineRun: KebabAction = (kind: K8sKind, pipelineRun: PipelineRun) => {\n  // The returned function will be called using the 'kind' and 'obj' in Kebab Actions\n  return {\n    label: 'Stop',\n    callback: () => {\n      k8sPatch(\n        PipelineRunModel,\n        {\n          metadata: { name: pipelineRun.metadata.name, namespace: pipelineRun.metadata.namespace },\n        },\n        [\n          {\n            op: 'replace',\n            path: `/spec/status`,\n            value: 'PipelineRunCancelled',\n          },\n        ],\n      );\n    },\n    hidden: !(pipelineRun && pipelineRunFilterReducer(pipelineRun) === 'Running'),\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: pipelineRun.metadata.name,\n      namespace: pipelineRun.metadata.namespace,\n      verb: 'update',\n    },\n  };\n};\n\n// const addTrigger: KebabAction = (kind: K8sKind, pipeline: Pipeline) => ({\n//   label: 'Add Trigger',\n//   callback: () => {\n//     const cleanPipeline: Pipeline = {\n//       ...pipeline,\n//       metadata: {\n//         ...pipeline.metadata,\n//         labels: _.omit(pipeline.metadata.labels, [StartedByLabel.user]),\n//       },\n//     };\n//     addTriggerModal({ pipeline: cleanPipeline, modalClassName: 'modal-lg' });\n//   },\n//   accessReview: {\n//     group: kind.apiGroup,\n//     resource: kind.plural,\n//     name: pipeline.metadata.name,\n//     namespace: pipeline.metadata.namespace,\n//     verb: 'create',\n//   },\n// });\n\nconst removeTrigger: KebabAction = (kind: K8sKind, pipeline: Pipeline) => ({\n  label: 'Remove Trigger',\n  callback: () => {\n    //removeTriggerModal({ pipeline });\n  },\n  accessReview: {\n    group: kind.apiGroup,\n    resource: kind.plural,\n    name: pipeline.metadata.name,\n    namespace: pipeline.metadata.namespace,\n    verb: 'delete',\n  },\n});\nexport const getPipelineKebabActions = (\n  pipelineRun?: PipelineRun,\n  isTriggerPresent?: boolean,\n): KebabAction[] => [\n  (model, resource: Pipeline) => startPipeline(model, resource, handlePipelineRunSubmit),\n  ...(pipelineRun ? [() => rerunPipelineAndRedirect(PipelineRunModel, pipelineRun)] : []),\n  //(model, pipeline) => addTrigger(EventListenerModel, pipeline),\n  ...(isTriggerPresent ? [(model, pipeline) => removeTrigger(EventListenerModel, pipeline)] : []),\n  editPipeline,\n  Kebab.factory.Delete,\n];\n\nexport const getPipelineRunKebabActions = (redirectReRun?: boolean): KebabAction[] => [\n  redirectReRun ? rerunPipelineRunAndRedirect : reRunPipelineRun,\n  stopPipelineRun,\n  Kebab.factory.Delete,\n];\n","import {\n  chart_color_green_400 as successColor,\n  chart_color_blue_300 as runningColor,\n  global_danger_color_100 as failureColor,\n  chart_color_blue_100 as pendingColor,\n  chart_color_black_400 as skippedColor,\n  chart_color_black_500 as cancelledColor,\n} from '@patternfly/react-tokens';\nimport { K8sKind, K8sResourceKind, referenceForModel } from '@console/internal/module/k8s';\nimport {\n  ClusterTaskModel,\n  PipelineRunModel,\n  TaskModel,\n} from '../../../models';\nimport { pipelineRunFilterReducer } from './pipeline-filter-reducer';\n\ninterface Metadata {\n  name: string;\n  namespace?: string;\n}\n\nexport interface PropPipelineData {\n  metadata: Metadata;\n  latestRun?: PipelineRun;\n}\n\ninterface StatusMessage {\n  message: string;\n  pftoken: { name: string; value: string; var: string };\n}\n\nexport interface TaskStatus {\n  PipelineNotStarted: number;\n  Pending: number;\n  Running: number;\n  Succeeded: number;\n  Cancelled: number;\n  Failed: number;\n}\n\nexport interface PipelineTaskRef {\n  kind?: string;\n  name: string;\n}\n\nexport interface PipelineTaskParam {\n  name: string;\n  value: any;\n}\nexport interface PipelineTaskResources {\n  inputs?: PipelineTaskResource[];\n  outputs?: PipelineTaskResource[];\n}\nexport interface PipelineTaskResource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport interface PipelineTask {\n  name: string;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n}\n\nexport interface Resource {\n  propsReferenceForRuns: string[];\n  resources: FirehoseResource[];\n}\n\nexport interface PipelineResource {\n  name: string;\n  type: string;\n}\n\ntype PipelineRunResourceCommonProperties = {\n  name: string;\n};\nexport type PipelineRunInlineResourceParam = { name: string; value: string };\nexport type PipelineRunInlineResource = PipelineRunResourceCommonProperties & {\n  resourceSpec: {\n    params: PipelineRunInlineResourceParam[];\n    type: string;\n  };\n};\nexport type PipelineRunReferenceResource = PipelineRunResourceCommonProperties & {\n  resourceRef: {\n    name: string;\n  };\n};\nexport type PipelineRunResource = PipelineRunReferenceResource | PipelineRunInlineResource;\n\nexport interface Runs {\n  data?: PipelineRun[];\n}\n\nexport type KeyedRuns = { [key: string]: Runs };\n\nexport interface Pipeline extends K8sResourceKind {\n  latestRun?: PipelineRun;\n  spec: {\n    params?: PipelineParam[];\n    resources?: PipelineResource[];\n    workspaces?: PipelineWorkspace[];\n    tasks: PipelineTask[];\n    serviceAccountName?: string;\n  };\n}\n\nexport type TaskRunKind = { pipelineTaskName?: string } & K8sResourceKind;\n\nexport interface TaskRuns {\n  [key: string]: TaskRunKind;\n}\n\nexport interface PipelineSpecTaskRef {\n  kind?: string;\n  name?: string;\n  apiVersion?: string;\n}\n\nexport interface PipelineSpecTaskSpec {\n  metadata?: {};\n  steps?: {\n    // TODO: Figure out required fields\n    env?: PipelineTaskParam[];\n    image?: string;\n    name?: string;\n    resources?: {};\n    script?: string;\n    securityContext?: {\n      privileged: boolean;\n      [key: string]: any;\n    }\n    imagePullPolicy?: string;\n    workingDir?: string;\n  }[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpecTask {\n  name: string;\n  runAfter?: string[];\n  taskRef?: PipelineSpecTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n  taskSpec?: PipelineSpecTaskSpec;\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpec extends K8sResourceKind {\n  tasks: PipelineSpecTask[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineRun extends K8sResourceKind {\n  spec?: {\n    pipelineRef?: { name: string };\n    params?: PipelineRunParam[];\n    workspaces?: PipelineRunWorkspace[];\n    resources?: PipelineRunResource[];\n    serviceAccountName?: string;\n    // Odd status value that only appears in a single case - cancelling a pipeline\n    status?: 'PipelineRunCancelled';\n    timeout?: string;\n    pipelineSpec?: PipelineSpec;\n  };\n  status?: {\n    succeededCondition?: string;\n    creationTimestamp?: string;\n    conditions?: Condition[];\n    startTime?: string;\n    completionTime?: string;\n    taskRuns?: TaskRuns;\n    runs?: TaskRuns; \n  };\n}\n\nexport type PipelineResourceKind = K8sResourceKind & {\n  spec: {\n    params: { name: string; value: string }[];\n    type: string;\n  };\n};\n\nexport interface PipelineResourceTaskParam extends PipelineParam {\n  type: string;\n}\nexport interface PipelineResourceTaskResource {\n  name: string;\n  type: string;\n  optional?: boolean;\n}\nexport interface PipelineResourceTask extends K8sResourceKind {\n  spec: {\n    params?: PipelineResourceTaskParam[];\n    resources?: {\n      inputs?: PipelineResourceTaskResource[];\n      outputs?: PipelineResourceTaskResource[];\n    };\n\n    steps: {\n      // TODO: Figure out required fields\n      args?: string[];\n      command?: string[];\n      image?: string;\n      resources?: {}[];\n    }[];\n  };\n}\n\nexport interface Condition {\n  type: string;\n  status: string;\n  reason?: string;\n  message?: string;\n  lastTransitionTime?: string;\n}\n\nexport interface Param {\n  name: string;\n}\n\nexport interface PipelineParam extends Param {\n  default?: string | string[];\n  description?: string;\n}\n\nexport interface PipelineRunParam extends Param {\n  value: string | string[];\n  input?: string;\n  output?: string;\n  resource?: object;\n}\n\nexport interface PipelineWorkspace extends Param {\n  type: string;\n  data?: {\n    [key: string]: string;\n  };\n}\n\nexport interface PipelineRunWorkspace extends Param {\n  [key: string]: string;\n}\n\ninterface FirehoseResource {\n  kind: string;\n  namespace?: string;\n  isList?: boolean;\n  selector?: object;\n}\n\nexport const getResources = (data: PropPipelineData[]): Resource => {\n  const resources = [];\n  const propsReferenceForRuns = [];\n  if (data && data.length > 0) {\n    data.forEach((pipeline, i) => {\n      if (pipeline.metadata && pipeline.metadata.namespace && pipeline.metadata.name) {\n        propsReferenceForRuns.push(`PipelineRun_${i}`);\n        resources.push({\n          kind: referenceForModel(PipelineRunModel),\n          namespace: pipeline.metadata.namespace,\n          isList: true,\n          prop: `PipelineRun_${i}`,\n          selector: {\n            'tekton.dev/pipeline': pipeline.metadata.name,\n          },\n        });\n      }\n    });\n    return { propsReferenceForRuns, resources };\n  }\n  return { propsReferenceForRuns: null, resources: null };\n};\n\nexport const getLatestRun = (runs: Runs, field: string): PipelineRun => {\n  if (!runs || !runs.data || !(runs.data.length > 0) || !field) {\n    return null;\n  }\n  let latestRun = runs.data[0];\n  if (field === 'creationTimestamp') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].metadata &&\n        runs.data[i].metadata[field] &&\n        new Date(runs.data[i].metadata[field]) > new Date(latestRun.metadata[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else if (field === 'startTime' || field === 'completionTime') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].status &&\n        runs.data[i].status[field] &&\n        new Date(runs.data[i].status[field]) > new Date(latestRun.status[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else {\n    latestRun = runs.data[runs.data.length - 1];\n  }\n  if (!latestRun.status) {\n    latestRun = { ...latestRun, status: {} };\n  }\n  if (!latestRun.status.succeededCondition) {\n    latestRun.status = { ...latestRun.status, succeededCondition: '' };\n  }\n  latestRun.status.succeededCondition = pipelineRunFilterReducer(latestRun);\n  return latestRun;\n};\n\nexport const augmentRunsToData = (\n  data: PropPipelineData[],\n  propsReferenceForRuns: string[],\n  runs: { [key: string]: Runs },\n): PropPipelineData[] => {\n  if (propsReferenceForRuns) {\n    const newData: PropPipelineData[] = [];\n    propsReferenceForRuns.forEach((reference, i) => {\n      const latestRun = getLatestRun(runs[reference], 'creationTimestamp');\n      if (latestRun !== data[i].latestRun) {\n        // ensure we create a new data object if the latestRun has changed so that shallow compare fails\n        newData.push({ ...data[i], latestRun });\n      } else {\n        newData.push(data[i]);\n      }\n    });\n    return newData;\n  }\n  return data;\n};\n\nexport enum runStatus {\n  Succeeded = 'Succeeded',\n  Failed = 'Failed',\n  Running = 'Running',\n  'In Progress' = 'In Progress',\n  FailedToStart = 'FailedToStart',\n  PipelineNotStarted = 'PipelineNotStarted',\n  Skipped = 'Skipped',\n  Cancelled = 'Cancelled',\n  Pending = 'Pending',\n  Idle = 'Idle',\n}\n\nexport const getRunStatusColor = (status: string): StatusMessage => {\n  switch (status) {\n    case runStatus.Succeeded:\n      return { message: 'Succeeded', pftoken: successColor };\n    case runStatus.Failed:\n      return { message: 'Failed', pftoken: failureColor };\n    case runStatus.FailedToStart:\n      return {\n        message: 'PipelineRun failed to start',\n        pftoken: failureColor,\n      };\n    case runStatus.Running:\n      return { message: 'Running', pftoken: runningColor };\n    case runStatus['In Progress']:\n      return { message: 'Running', pftoken: runningColor };\n\n    case runStatus.Skipped:\n      return { message: 'Skipped', pftoken: skippedColor };\n    case runStatus.Cancelled:\n      return { message: 'Cancelled', pftoken: cancelledColor };\n    case runStatus.Idle:\n    case runStatus.Pending:\n      return { message: 'Pending', pftoken: pendingColor };\n    default:\n      return { message: 'PipelineRun not started yet', pftoken: pendingColor };\n  }\n};\n\nexport const truncateName = (name: string, length: number): string =>\n  name.length < length ? name : `${name.slice(0, length - 1)}...`;\n\nexport const getTaskStatus = (pipelinerun: PipelineRun, pipeline: Pipeline): TaskStatus => {\n  const totalTasks =\n    pipeline && pipeline.spec && pipeline.spec.tasks ? pipeline.spec.tasks.length \n    : pipelinerun?.spec?.pipelineSpec?.tasks?.length ?? 0;\n  const plrTasks =\n    pipelinerun && pipelinerun.status && pipelinerun.status.taskRuns\n      ? pipelinerun.status.runs ? Object.keys(pipelinerun.status.runs).concat(Object.keys(pipelinerun.status.taskRuns))\n        : Object.keys(pipelinerun.status.taskRuns)\n      : [];\n  const plrTaskLength = plrTasks.length;\n  const taskStatus: TaskStatus = {\n    PipelineNotStarted: 0,\n    Pending: 0,\n    Running: 0,\n    Succeeded: 0,\n    Failed: 0,\n    Cancelled: 0,\n  };\n  if (plrTasks) {\n    plrTasks.forEach((taskRun) => {\n      const status = pipelineRunFilterReducer(pipelinerun.status.taskRuns[taskRun] ?? pipelinerun.status.runs[taskRun]);\n      if (status === 'Succeeded' || status === 'Completed' || status === 'Complete') {\n        taskStatus[runStatus.Succeeded]++;\n      } else if (status === 'Running') {\n        taskStatus[runStatus.Running]++;\n      } else if (status === 'Failed') {\n        taskStatus[runStatus.Failed]++;\n      } else if (status === 'Cancelled') {\n        taskStatus[runStatus.Cancelled]++;\n      } else {\n        taskStatus[runStatus.Pending]++;\n      }\n    });\n    taskStatus[runStatus.Failed] > 0 || taskStatus[runStatus.Cancelled] > 0\n      ? (taskStatus[runStatus.Cancelled] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks)\n      : (taskStatus[runStatus.Pending] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks);\n  } else if (\n    pipelinerun &&\n    pipelinerun.status &&\n    pipelinerun.status.conditions &&\n    pipelinerun.status.conditions[0].status === 'False'\n  ) {\n    taskStatus[runStatus.Cancelled] = totalTasks;\n  } else {\n    taskStatus[runStatus.PipelineNotStarted]++;\n  }\n  return taskStatus;\n};\n\nexport const getResourceModelFromTaskKind = (kind: string): K8sKind =>\n  kind === ClusterTaskModel.kind ? ClusterTaskModel : TaskModel;\n\n//   export const getResourceModelFromBindingKind = (kind: string): K8sKind =>\n//     kind === ClusterTriggerBindingModel.kind ? ClusterTriggerBindingModel : TriggerBindingModel;\n\nexport const getResourceModelFromTask = (task: PipelineTask): K8sKind => {\n  const {\n    taskRef: { kind },\n  } = task;\n\n  return getResourceModelFromTaskKind(kind);\n};\n\nexport const pipelineRefExists = (pipelineRun: PipelineRun): boolean =>\n  !!pipelineRun.spec.pipelineRef?.name;\n","import * as _ from 'lodash';\nimport { formatDuration } from '@console/internal/components/utils/datetime';\nimport {\n  ContainerStatus,\n  K8sResourceKind,\n  k8sUpdate,\n  // k8sGet,\n  // SecretKind,\n  K8sResourceCommon,\n} from '@console/internal/module/k8s';\nimport {\n  LOG_SOURCE_RESTARTING,\n  LOG_SOURCE_WAITING,\n  LOG_SOURCE_RUNNING,\n  LOG_SOURCE_TERMINATED,\n} from '@console/internal/components/utils';\nimport { ServiceAccountModel } from '@console/internal/models';\n// import { errorModal } from '@console/internal/components/modals/error-modal';\n// import { PIPELINE_SERVICE_ACCOUNT, SecretAnnotationId } from '../components/pipelines/const';\nimport {\n  getLatestRun,\n  Pipeline,\n  PipelineRun,\n  runStatus,\n  PipelineParam,\n  PipelineRunParam,\n  PipelineTaskRef,\n  PipelineWorkspace,\n  PipelineRunWorkspace,\n} from './pipeline-augment';\nimport { pipelineFilterReducer, pipelineRunStatus } from './pipeline-filter-reducer';\n\ninterface Resources {\n  inputs?: Resource[];\n  outputs?: Resource[];\n}\n\ninterface Resource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport type ServiceAccountType = {\n  secrets: { [name: string]: string }[];\n} & K8sResourceCommon;\n\nexport interface PipelineVisualizationTaskItem {\n  name: string;\n  resources?: Resources;\n  params?: object;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n}\n\nexport const TaskStatusClassNameMap = {\n  'In Progress': 'is-running',\n  Succeeded: 'is-done',\n  Failed: 'is-error',\n  Idle: 'is-idle',\n};\n\nexport const conditions = {\n  hasFromDependency: (task: PipelineVisualizationTaskItem): boolean =>\n    task.resources &&\n    task.resources.inputs &&\n    task.resources.inputs.length > 0 &&\n    !!task.resources.inputs[0].from,\n  hasRunAfterDependency: (task: PipelineVisualizationTaskItem): boolean =>\n    task.runAfter && task.runAfter.length > 0,\n};\n\nexport enum ListFilterId {\n  Running = 'Running',\n  Failed = 'Failed',\n  Succeeded = 'Succeeded',\n  Cancelled = 'Cancelled',\n  Other = '-',\n}\n\nexport const ListFilterLabels = {\n  [ListFilterId.Running]: 'Running',\n  [ListFilterId.Failed]: 'Failed',\n  [ListFilterId.Succeeded]: 'Complete',\n  [ListFilterId.Cancelled]: 'Cancelled',\n  [ListFilterId.Other]: 'Other',\n};\n\n// to be used by both Pipeline and Pipelinerun visualisation\nconst sortTasksByRunAfterAndFrom = (\n  tasks: PipelineVisualizationTaskItem[],\n): PipelineVisualizationTaskItem[] => {\n  // check and sort tasks by 'runAfter' and 'from' dependency\n  const output = tasks;\n  for (let i = 0; i < output.length; i++) {\n    let flag = -1;\n    if (conditions.hasRunAfterDependency(output[i])) {\n      for (let j = 0; j < output.length; j++) {\n        if (i < j && output[j].taskRef.name === output[i].runAfter[output[i].runAfter.length - 1]) {\n          flag = j;\n        }\n      }\n    } else if (conditions.hasFromDependency(output[i])) {\n      for (let j = i + 1; j < output.length; j++) {\n        if (output[j].taskRef.name === output[i].resources.inputs[0].from[0]) {\n          flag = j;\n        }\n      }\n    }\n    if (flag > -1) {\n      // swap with last matching task\n      const temp = output[flag];\n      output[flag] = output[i];\n      output[i] = temp;\n    }\n  }\n  return output;\n};\n\n/**\n * Appends the pipeline run status to each tasks in the pipeline.\n * @param pipeline\n * @param pipelineRun\n */\nconst appendPipelineRunStatus = (pipeline, pipelineRun) => {\n  return _.map(pipeline.spec.tasks, (task) => {\n    if (!pipelineRun.status) {\n      return task;\n    }\n    if (pipelineRun.status && !pipelineRun.status.taskRuns) {\n      return _.merge(task, { status: { reason: runStatus.Failed } });\n    }\n    const mTask = _.merge(task, {\n      status: _.get(_.find(pipelineRun.status.taskRuns, { pipelineTaskName: task.name }), 'status'),\n    });\n    // append task duration\n    if (mTask.status && mTask.status.completionTime && mTask.status.startTime) {\n      const date =\n        new Date(mTask.status.completionTime).getTime() -\n        new Date(mTask.status.startTime).getTime();\n      mTask.status.duration = formatDuration(date);\n    }\n    // append task status\n    if (!mTask.status) {\n      mTask.status = { reason: runStatus.Idle };\n    } else if (mTask.status && mTask.status.conditions) {\n      mTask.status.reason = pipelineRunStatus(mTask) || runStatus.Idle;\n    }\n    return mTask;\n  });\n};\n\nexport const getPipelineTasks = (\n  pipeline: K8sResourceKind,\n  pipelineRun: K8sResourceKind = {\n    apiVersion: '',\n    metadata: {},\n    kind: 'PipelineRun',\n  },\n): PipelineVisualizationTaskItem[][] => {\n  // Each unit in 'out' array is termed as stage | out = [stage1 = [task1], stage2 = [task2,task3], stage3 = [task4]]\n  const out = [];\n  if (!pipeline.spec || !pipeline.spec.tasks) {\n    return out;\n  }\n  const taskList = appendPipelineRunStatus(pipeline, pipelineRun);\n  // Step 1: Sort Tasks to get in correct order\n  const tasks = sortTasksByRunAfterAndFrom(taskList);\n\n  // Step 2: Push all nodes without any dependencies in different stages\n  tasks.forEach((task) => {\n    if (!conditions.hasFromDependency(task) && !conditions.hasRunAfterDependency(task)) {\n      if (out.length === 0) {\n        out.push([]);\n      }\n      out[0].push(task);\n    }\n  });\n\n  // Step 3: Push nodes with 'from' dependency and stack similar tasks in a stage\n  tasks.forEach((task) => {\n    if (!conditions.hasRunAfterDependency(task) && conditions.hasFromDependency(task)) {\n      let flag = out.length - 1;\n      for (let i = 0; i < out.length; i++) {\n        for (const t of out[i]) {\n          if (\n            t.taskRef.name === task.resources.inputs[0].from[0] ||\n            t.name === task.resources.inputs[0].from[0]\n          ) {\n            flag = i;\n          }\n        }\n      }\n      const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n      if (\n        nextToFlag &&\n        nextToFlag[0] &&\n        nextToFlag[0].resources &&\n        nextToFlag[0].resources.inputs &&\n        nextToFlag[0].resources.inputs[0] &&\n        nextToFlag[0].resources.inputs[0].from &&\n        nextToFlag[0].resources.inputs[0].from[0] &&\n        nextToFlag[0].resources.inputs[0].from[0] === task.resources.inputs[0].from[0]\n      ) {\n        nextToFlag.push(task);\n      } else {\n        out.splice(flag + 1, 0, [task]);\n      }\n    }\n  });\n\n  // Step 4: Push nodes with 'runAfter' dependencies and stack similar tasks in a stage\n  tasks.forEach((task) => {\n    if (conditions.hasRunAfterDependency(task)) {\n      let flag = out.length - 1;\n      for (let i = 0; i < out.length; i++) {\n        for (const t of out[i]) {\n          if (t.taskRef.name === task.runAfter[0] || t.name === task.runAfter[0]) {\n            flag = i;\n          }\n        }\n      }\n      const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n      if (\n        nextToFlag &&\n        nextToFlag[0].runAfter &&\n        nextToFlag[0].runAfter[0] &&\n        nextToFlag[0].runAfter[0] === task.runAfter[0]\n      ) {\n        nextToFlag.push(task);\n      } else {\n        out.splice(flag + 1, 0, [task]);\n      }\n    }\n  });\n  return out;\n};\n\nexport const containerToLogSourceStatus = (container: ContainerStatus): string => {\n  if (!container) {\n    return LOG_SOURCE_WAITING;\n  }\n  const { state, lastState } = container;\n  if (state.waiting && !_.isEmpty(lastState)) {\n    return LOG_SOURCE_RESTARTING;\n  }\n  if (state.waiting) {\n    return LOG_SOURCE_WAITING;\n  }\n  if (state.terminated) {\n    return LOG_SOURCE_TERMINATED;\n  }\n  return LOG_SOURCE_RUNNING;\n};\n\ntype CurrentPipelineStatus = {\n  currentPipeline: Pipeline;\n  status: string;\n};\n\n/**\n * Takes a pipeline and a series of matching pipeline runs and produces a current pipeline state.\n */\nexport const constructCurrentPipeline = (\n  pipeline: Pipeline,\n  pipelineRuns: PipelineRun[],\n): CurrentPipelineStatus => {\n  if (!pipeline || !pipelineRuns || pipelineRuns.length === 0) {\n    // Not enough data to build the current state\n    return null;\n  }\n\n  const latestRun = getLatestRun({ data: pipelineRuns }, 'creationTimestamp');\n\n  if (!latestRun) {\n    // Without the latestRun we will not have progress to show\n    return null;\n  }\n\n  const currentPipeline: Pipeline = {\n    ...pipeline,\n    latestRun,\n  };\n\n  let status: string = pipelineFilterReducer(currentPipeline);\n  if (status === '-') {\n    status = runStatus.Pending;\n  }\n\n  return {\n    currentPipeline,\n    status,\n  };\n};\n\nexport const getPipelineRunParams = (pipelineParams: PipelineParam[]): PipelineRunParam[] => {\n  return (\n    pipelineParams &&\n    pipelineParams.map((param) => ({\n      name: param.name,\n      value: param.default,\n    }))\n  );\n};\n\nexport const getPipelineRunWorkspaces = (\n  pipelineWorkspaces: PipelineWorkspace[],\n): PipelineRunWorkspace[] => {\n  return (\n    pipelineWorkspaces &&\n    pipelineWorkspaces.map((workspace) => ({\n      name: workspace.name,\n      ...workspace.data,\n    }))\n  );\n};\n\nexport const calculateRelativeTime = (startTime: string, completionTime?: string) => {\n  const start = new Date(startTime).getTime();\n  const end = completionTime ? new Date(completionTime).getTime() : new Date().getTime();\n  const secondsAgo = (end - start) / 1000;\n  const minutesAgo = secondsAgo / 60;\n  const hoursAgo = minutesAgo / 60;\n\n  if (minutesAgo > 90) {\n    const count = Math.round(hoursAgo);\n    return `about ${count} hours`;\n  }\n  if (minutesAgo > 45) {\n    return 'about an hour';\n  }\n  if (secondsAgo > 90) {\n    const count = Math.round(minutesAgo);\n    return `about ${count} minutes`;\n  }\n  if (secondsAgo > 45) {\n    return 'about a minute';\n  }\n  return 'a few seconds';\n};\n\nexport const pipelineRunDuration = (run: PipelineRun): string => {\n  const startTime = _.get(run, ['status', 'startTime'], null);\n  const completionTime = _.get(run, ['status', 'completionTime'], null);\n\n  // Duration cannot be computed if start time is missing or a completed/failed pipeline has no end time\n  if (!startTime || (!completionTime && pipelineRunStatus(run) !== 'Running')) {\n    return '-';\n  }\n  return calculateRelativeTime(startTime, completionTime);\n};\n\nexport const updateServiceAccount = (\n  secretName: string,\n  originalServiceAccount: ServiceAccountType,\n): Promise<ServiceAccountType> => {\n  const updatedServiceAccount = _.cloneDeep(originalServiceAccount);\n  updatedServiceAccount.secrets = [...updatedServiceAccount.secrets, { name: secretName }];\n  return k8sUpdate(ServiceAccountModel, updatedServiceAccount);\n};\n\n// export const associateServiceAccountToSecret = (secret: SecretKind, namespace: string) => {\n//   k8sGet(ServiceAccountModel, PIPELINE_SERVICE_ACCOUNT, namespace)\n//     .then((serviceAccount) => {\n//       if (_.find(serviceAccount.secrets, (s) => s.name === secret.metadata.name) === undefined) {\n//         updateServiceAccount(secret.metadata.name, serviceAccount);\n//       }\n//     })\n//     .catch((err) => {\n//       errorModal({ error: err.message });\n//     });\n// };\n\n// type KeyValuePair = {\n//   key: string;\n//   value: string;\n// };\n// export const getSecretAnnotations = (annotation: KeyValuePair) => {\n//   const annotations = {};\n//   const annotationPrefix = 'tekton.dev';\n//   if (annotation?.key === SecretAnnotationId.Git) {\n//     annotations[`${annotationPrefix}/${SecretAnnotationId.Git}-0`] = annotation?.value;\n//   } else if (annotation?.key === SecretAnnotationId.Image) {\n//     annotations[`${annotationPrefix}/${SecretAnnotationId.Image}-0`] = annotation?.value;\n//   }\n//   return annotations;\n// };\n"],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAKA;AAEA;AAEA;AACA;AACA;AAQA;AACA;AACA;AAOA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AASA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAOA;;;AAGA;AACA;;AAIA;AAQA;AACA;AAWA;AAEA;AACA;AAEA;;;;;;;;;;;;;AC7CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAOA;AAOA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAOA;;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;;;;;;;;;;;;AChCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AAGA;AACA;AAEA;AAIA;AAEA;AACA;AAIA;AAGA;AAEA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAUA;AACA;AACA;AAGA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAMA;AACA;AACA;AAEA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC5JA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAgBA;AAOA;AAKA;AAMA;AACA;AACA;AAMA;AAEA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAMA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAKA;AAgPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAIA;AACA;AAEA;;;;;;;;;;;;;AC7bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AAMA;AACA;AACA;AACA;AAWA;AAwBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}