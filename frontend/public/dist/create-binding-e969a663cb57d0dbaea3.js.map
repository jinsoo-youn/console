{"version":3,"file":"create-binding-e969a663cb57d0dbaea3.js","sources":["webpack:///./public/components/service-catalog/create-binding.tsx","webpack:///./public/components/service-catalog/schema-form.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport { Helmet } from 'react-helmet';\nimport { ActionGroup, Button } from '@patternfly/react-core';\nimport { IChangeEvent, ISubmitEvent } from 'react-jsonschema-form';\nimport { JSONSchema6 } from 'json-schema';\n\nimport { LoadingBox } from '../utils/status-box';\nimport { ServiceInstanceModel, ServiceBindingModel, ClusterServicePlanModel } from '../../models';\nimport { k8sCreate, K8sResourceKind, referenceForModel } from '../../module/k8s';\nimport { ButtonBar } from '../utils/button-bar';\nimport {\n  createParametersSecret,\n  getBindingCreateSchema,\n  getBindingParametersForm,\n  getUISchema,\n  ServiceCatalogParametersForm,\n} from './schema-form';\nimport { Firehose, history, PageHeading, resourcePathFromModel } from '../utils';\n\nconst PARAMETERS_SECRET_KEY = 'parameters';\n\nconst BindingParametersForm: React.SFC<BindingParametersFormProps> = ({ plan, ...rest }) => {\n  if (!plan.loaded) {\n    return <LoadingBox />;\n  }\n\n  const schema: JSONSchema6 = getBindingCreateSchema(plan.data);\n  const parametersForm = getBindingParametersForm(plan.data);\n  const uiSchema = getUISchema(parametersForm);\n  return <ServiceCatalogParametersForm schema={schema} uiSchema={uiSchema} {...rest} />;\n};\n\nconst BindingParameters: React.SFC<BindingParametersProps> = (props) => {\n  const planName = _.get(props.instance, 'spec.clusterServicePlanRef.name');\n  if (!planName) {\n    return null;\n  }\n\n  const resources = [\n    { kind: referenceForModel(ClusterServicePlanModel), name: planName, prop: 'plan' },\n  ];\n  return (\n    <Firehose resources={resources}>\n      <BindingParametersForm {...(props as any)} />\n    </Firehose>\n  );\n};\n\nclass CreateBindingForm extends React.Component<CreateBindingProps, CreateBindingState> {\n  constructor(props) {\n    super(props);\n\n    this.state = {\n      name: props.match.params.name,\n      formData: {},\n      inProgress: false,\n    };\n  }\n\n  onNameChange: React.ReactEventHandler<HTMLInputElement> = (event) => {\n    this.setState({ name: event.currentTarget.value });\n  };\n\n  createBinding = (secretName: string): Promise<K8sResourceKind> => {\n    const parametersFrom = secretName\n      ? [{ secretKeyRef: { name: secretName, key: PARAMETERS_SECRET_KEY } }]\n      : [];\n    const serviceBinding = {\n      apiVersion: 'servicecatalog.k8s.io/v1beta1',\n      kind: 'ServiceBinding',\n      metadata: {\n        name: this.state.name,\n        namespace: _.get(this.props.obj, 'data.metadata.namespace'),\n      },\n      spec: {\n        instanceRef: {\n          name: _.get(this.props.obj, 'data.metadata.name'),\n        },\n        parametersFrom,\n      },\n    };\n\n    return k8sCreate(ServiceBindingModel, serviceBinding);\n  };\n\n  onFormChange = ({ formData }: IChangeEvent) => this.setState({ formData });\n\n  save = ({ formData }: ISubmitEvent<any>) => {\n    const { name: bindingName } = this.state;\n    if (!bindingName) {\n      this.setState({ error: 'Please complete all fields.' });\n      return;\n    }\n    this.setState({ inProgress: true });\n    const secretName = _.isEmpty(formData) ? null : `${bindingName}-bind-parameters`;\n    this.createBinding(secretName)\n      .then((binding) =>\n        secretName\n          ? createParametersSecret(secretName, PARAMETERS_SECRET_KEY, formData, binding)\n          : null,\n      )\n      .then(\n        () => {\n          this.setState({ inProgress: false });\n          const instance = this.props.obj.data;\n          history.push(\n            resourcePathFromModel(ServiceBindingModel, bindingName, instance.metadata.namespace),\n          );\n        },\n        (err) => this.setState({ error: err.message, inProgress: false }),\n      );\n  };\n\n  render() {\n    const { obj, match } = this.props;\n    const { name, formData, inProgress, error } = this.state;\n    const serviceInstance = _.get(obj, 'data');\n    const title = 'Create Service Binding';\n\n    if (!obj.loaded) {\n      return <LoadingBox />;\n    }\n\n    return (\n      <>\n        <Helmet>\n          <title>{title}</title>\n        </Helmet>\n        <PageHeading\n          title={title}\n          obj={obj}\n          breadcrumbsFor={() => [\n            {\n              name: serviceInstance.metadata.name,\n              path: resourcePathFromModel(\n                ServiceInstanceModel,\n                serviceInstance.metadata.name,\n                serviceInstance.metadata.namespace,\n              ),\n            },\n            { name: `${title}`, path: `${match.url}` },\n          ]}\n        />\n        <div className=\"co-m-pane__body\">\n          <p className=\"co-m-pane__explanation\">\n            Service bindings create a secret containing the necessary information for an application\n            to use a service.\n          </p>\n          <div className=\"row\">\n            <div className=\"col-md-5\">\n              <p>\n                Create a binding for <strong>{serviceInstance.metadata.name}</strong> in{' '}\n                <strong>{serviceInstance.metadata.namespace}</strong>.\n              </p>\n              <form className=\"co-create-service-binding co-m-pane__form\">\n                <div className=\"form-group co-create-service-binding__name\">\n                  <label className=\"control-label co-required\" htmlFor=\"name\">\n                    Service Binding Name\n                  </label>\n                  <input\n                    className=\"pf-c-form-control\"\n                    type=\"text\"\n                    onChange={this.onNameChange}\n                    value={name}\n                    id=\"name\"\n                    required\n                  />\n                </div>\n              </form>\n              <BindingParameters\n                instance={serviceInstance}\n                onSubmit={this.save}\n                formData={formData}\n                onChange={this.onFormChange}\n              >\n                <ButtonBar errorMessage={error} inProgress={inProgress}>\n                  <ActionGroup className=\"pf-c-form\">\n                    <Button type=\"submit\" variant=\"primary\">\n                      Create\n                    </Button>\n                    <Button type=\"button\" id=\"cancel\" onClick={history.goBack} variant=\"secondary\">\n                      Cancel\n                    </Button>\n                  </ActionGroup>\n                </ButtonBar>\n              </BindingParameters>\n            </div>\n          </div>\n        </div>\n      </>\n    );\n  }\n}\n\nexport const CreateBindingPage: React.SFC<CreateBindingPageProps> = (props) => {\n  const resources = [\n    {\n      kind: referenceForModel(ServiceInstanceModel),\n      name: props.match.params.name,\n      namespace: props.match.params.ns,\n      isList: false,\n      prop: 'obj',\n    },\n  ];\n  return (\n    <Firehose resources={resources}>\n      <CreateBindingForm {...(props as any)} />\n    </Firehose>\n  );\n};\n\nexport type BindingParametersFormProps = {\n  plan: any;\n  formData: any;\n  onChange: (e: IChangeEvent) => void;\n  onSubmit: (e: ISubmitEvent<any>) => void;\n};\n\nexport type BindingParametersProps = {\n  instance: any;\n  formData: any;\n  onChange: (e: IChangeEvent) => void;\n  onSubmit: (e: ISubmitEvent<any>) => void;\n};\n\nexport type CreateBindingProps = {\n  obj: any;\n  match: any;\n};\n\nexport type CreateBindingState = {\n  name: string;\n  formData: any;\n  inProgress: boolean;\n  error?: any;\n};\n\nexport type CreateBindingPageProps = {\n  match: any;\n};\n","import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport * as classNames from 'classnames';\nimport { JSONSchema6 } from 'json-schema';\nimport Form, { FieldTemplateProps, FormProps, UiSchema } from 'react-jsonschema-form';\n\nimport { SecretModel } from '../../models';\nimport { k8sCreate, K8sResourceKind } from '../../module/k8s';\n\nconst getSchema = (plan: K8sResourceKind, path: string): JSONSchema6 => {\n  const schema = _.get(plan, path);\n  // Make sure there is `properties` in the schema, even if empty, or `Form` displays an error.\n  return _.assign({ type: 'object', properties: {} }, schema);\n};\n\nexport const getInstanceCreateSchema = (plan: K8sResourceKind) =>\n  getSchema(plan, 'spec.instanceCreateParameterSchema');\nexport const getInstanceCreateParametersForm = (plan: K8sResourceKind) =>\n  _.get(plan, 'spec.externalMetadata.schemas.service_instance.create.openshift_form_definition');\n\nexport const getBindingCreateSchema = (plan: K8sResourceKind) =>\n  getSchema(plan, 'spec.serviceBindingCreateParameterSchema');\nexport const getBindingParametersForm = (plan: K8sResourceKind) =>\n  _.get(plan, 'spec.externalMetadata.schemas.service_binding.create.openshift_form_definition');\n\n// Flatten items from fieldsets into a single list of parameters. Fieldsets aren't supported.\nconst flattenParameters = (parametersForm: ParameterFormItem[]): ParameterFormItem[] => {\n  return parametersForm.reduce((result: ParameterFormItem[], param: ParameterFormItem) => {\n    // If param has an `items` array, it's a fieldset. Add the fieldset parameters to the top-level array (preserving order).\n    const fieldsetItems = _.get(param, 'items');\n    const values = _.isEmpty(fieldsetItems) ? param : fieldsetItems;\n    return result.concat(values);\n  }, []);\n};\n\nconst UI_ORDER = 'ui:order';\nconst UI_WIDGET = 'ui:widget';\n\n// The whitelist of types for openshift_form_defintion items are textarea, password, checkbox, select.\n// Map these to the `ui:widget` value expected by react-jsonschema-form.\nconst widgetForType = Object.freeze({\n  checkbox: 'checkboxes',\n  password: 'password',\n  select: 'select',\n  textarea: 'textarea',\n});\n\n// Convert from the broker parameters form definition to the UI schema expected by react-jsonschema-form:\n// https://github.com/mozilla-services/react-jsonschema-form#form-customization\n//\n// The parameters form definition is a small subset of what was supported by angular-schema-form in the previous AngularJS catalog implementation:\n// https://github.com/json-schema-form/angular-schema-form\nexport const getUISchema = (parametersForm: ParameterFormItem[]): UiSchema => {\n  if (_.isEmpty(parametersForm)) {\n    return {};\n  }\n\n  const flatParams = flattenParameters(parametersForm);\n  return flatParams.reduce(\n    (result: UiSchema, param: ParameterFormItem) => {\n      if (_.isString(param)) {\n        result[UI_ORDER].push(param);\n      } else if (param.key) {\n        result[UI_ORDER].push(param.key);\n        const widget = widgetForType[param.type];\n        if (widget) {\n          _.set(result, [param.key, UI_WIDGET], widget);\n        }\n      }\n      return result;\n    },\n    { [UI_ORDER]: [] },\n  );\n};\n\nexport const createParametersSecret = (\n  secretName: string,\n  key: string,\n  parameters: any,\n  owner: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  const secret = {\n    apiVersion: 'v1',\n    kind: 'Secret',\n    metadata: {\n      name: secretName,\n      namespace: owner.metadata.namespace,\n      ownerReferences: [\n        {\n          apiVersion: owner.apiVersion,\n          kind: owner.kind,\n          name: owner.metadata.name,\n          uid: owner.metadata.uid,\n          controller: false,\n          blockOwnerDeletion: false,\n        },\n      ],\n    },\n    stringData: {\n      [key]: JSON.stringify(parameters),\n    },\n  };\n\n  return k8sCreate(SecretModel, secret);\n};\n\n// Override react-jsonschema-form rendering of fields so we can use different required and description styles.\n// https://github.com/mozilla-services/react-jsonschema-form#field-template\nconst CustomFieldTemplate: React.SFC<FieldTemplateProps> = ({\n  id,\n  classNames: klass,\n  displayLabel,\n  label,\n  help,\n  required,\n  description,\n  errors,\n  children,\n}) => (\n  <div className={klass}>\n    {displayLabel && (\n      <label htmlFor={id} className={classNames('control-label', { 'co-required': required })}>\n        {label}\n      </label>\n    )}\n    {children}\n    <div className=\"help-block\">{description}</div>\n    {help}\n    {errors}\n  </div>\n);\n\n// Override the base input `onChange` handler to return an empty string instead of undefined when a user clears a string input.\n// https://github.com/mozilla-services/react-jsonschema-form#customizing-widgets-text-input\n// https://github.com/mozilla-services/react-jsonschema-form/blob/master/src/components/widgets/BaseInput.js\nconst CustomBaseInput = (props) => {\n  // Note: since React 15.2.0 we can't forward unknown element attributes, so we\n  // exclude the \"options\" and \"schema\" ones here.\n  if (!props.id) {\n    // eslint-disable-next-line no-console\n    console.log('No id for', props);\n    throw new Error(`no id for props ${JSON.stringify(props)}`);\n  }\n  const {\n    value,\n    readonly,\n    disabled,\n    autofocus,\n    onChange,\n    onBlur,\n    onFocus,\n    options,\n    ...inputProps\n  } = props;\n  inputProps.type = options.inputType || inputProps.type || 'text';\n\n  return (\n    <input\n      className=\"pf-c-form-control\"\n      readOnly={readonly}\n      disabled={disabled}\n      autoFocus={autofocus}\n      value={value == null ? '' : value}\n      {...inputProps}\n      onChange={(event) => onChange(event.target.value)}\n      onBlur={onBlur && ((event) => onBlur(inputProps.id, event.target.value))}\n      onFocus={onFocus && ((event) => onFocus(inputProps.id, event.target.value))}\n    />\n  );\n};\n\n// Create a custom checkbox widget to prevent any checkbox from receiving a `required` attribute.\n// With HTML5 form validation, a required checkbox has to be checked to submit the form.\nconst CustomCheckbox = ({ onChange, label, value }) => (\n  <div className=\"checkbox\">\n    <label className=\"control-label\">\n      <input type=\"checkbox\" onClick={() => onChange(!value)} checked={value} />\n      {label}\n    </label>\n  </div>\n);\n\nconst widgets: any = {\n  BaseInput: CustomBaseInput,\n  CheckboxWidget: CustomCheckbox,\n};\n\nexport const ServiceCatalogParametersForm: React.SFC<FormProps<any>> = (props) => (\n  <Form\n    className=\"co-service-catalog-parameters\"\n    FieldTemplate={CustomFieldTemplate}\n    widgets={widgets}\n    {...props}\n  />\n);\n\nexport type ParameterFormItem =\n  | {\n      key: string;\n      type?: string;\n      items?: any[];\n    }\n  | string;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAOA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAGA;AA3DA;AACA;AACA;AACA;AACA;AACA;AAwDA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;;AACA;;AAAA;AACA;AACA;AACA;AACA;AACA;AAGA;AAUA;AAMA;AACA;AACA;AAGA;AAWA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClNA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAYA;AAKA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAEA;AAaA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;;;;;A","sourceRoot":""}