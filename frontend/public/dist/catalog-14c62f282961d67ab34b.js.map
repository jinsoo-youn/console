{"version":3,"file":"catalog-14c62f282961d67ab34b.js","sources":["webpack:///./public/components/catalog/catalog-item-details.jsx","webpack:///./public/components/catalog/catalog-items.tsx","webpack:///./public/components/catalog/catalog-page.tsx","webpack:///./public/components/markdown-view.tsx","webpack:///util (ignored)","webpack:///util (ignored)?6194","webpack:///readable-stream (ignored)","webpack:///supports-color (ignored)","webpack:///chalk (ignored)","webpack:///fs (ignored)"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport * as PropTypes from 'prop-types';\nimport { PropertiesSidePanel, PropertyItem } from '@patternfly/react-catalog-view-extension';\n\nimport { ClusterServicePlanModel } from '../../models';\nimport { k8sGet } from '../../module/k8s';\nimport { Timestamp, ExternalLink, SectionHeading, LoadingBox } from '../utils';\nimport { SyncMarkdownView } from '../markdown-view';\n\nexport class CatalogTileDetails extends React.Component {\n  state = {\n    plans: [],\n    markdown: '',\n    markdownLoading: false,\n  };\n\n  componentDidMount() {\n    const { obj, kind, markdownDescription } = this.props.item;\n    if (kind === 'ClusterServiceClass') {\n      this.getPlans(obj);\n    }\n\n    if (_.isFunction(markdownDescription)) {\n      this.setState({ markdownLoading: true });\n      markdownDescription()\n        .then((md) => this.setState({ markdown: md, markdownLoading: false }))\n        .catch(() => this.setState({ markdownLoading: false }));\n    } else {\n      this.setState({ markdown: markdownDescription });\n    }\n  }\n\n  getPlans(obj) {\n    k8sGet(ClusterServicePlanModel, null, null, {\n      queryParams: { fieldSelector: `spec.clusterServiceClassRef.name=${obj.metadata.name}` },\n    }).then(({ items: plans }) => {\n      this.setState({\n        plans: _.orderBy(plans, ['spec.externalMetadata.displayName', 'metadata.name']),\n      });\n    });\n  }\n\n  render() {\n    const {\n      obj,\n      kind,\n      tileProvider,\n      tileDescription,\n      supportUrl,\n      longDescription,\n      documentationUrl,\n      sampleRepo,\n      customProperties,\n    } = this.props.item;\n    const { plans, markdown, markdownLoading } = this.state;\n\n    const creationTimestamp = _.get(obj, 'metadata.creationTimestamp');\n\n    const supportUrlLink = <ExternalLink href={supportUrl} text=\"Get support\" />;\n    const documentationUrlLink = (\n      <ExternalLink\n        href={documentationUrl}\n        additionalClassName=\"co-break-all\"\n        text={documentationUrl}\n      />\n    );\n    const sampleRepoLink = (\n      <ExternalLink href={sampleRepo} additionalClassName=\"co-break-all\" text={sampleRepo} />\n    );\n    const planItems = _.map(plans, (plan) => (\n      <li key={plan.metadata.uid}>{plan.spec.description || plan.spec.externalName}</li>\n    ));\n    return (\n      <div className=\"modal-body modal-body-border\">\n        <div className=\"modal-body-content\">\n          <div className=\"modal-body-inner-shadow-covers\">\n            <div className=\"co-catalog-page__overlay-body\">\n              <PropertiesSidePanel>\n                {customProperties}\n                {tileProvider && <PropertyItem label=\"Provider\" value={tileProvider} />}\n                {supportUrl && <PropertyItem label=\"Support\" value={supportUrlLink} />}\n                {creationTimestamp && (\n                  <PropertyItem\n                    label=\"Created At\"\n                    value={<Timestamp timestamp={creationTimestamp} />}\n                  />\n                )}\n              </PropertiesSidePanel>\n              <div className=\"co-catalog-page__overlay-description\">\n                <SectionHeading text=\"Description\" />\n                {tileDescription && <p>{tileDescription}</p>}\n                {markdownLoading && <LoadingBox message=\"Loading Markdown...\" />}\n                {markdown && <SyncMarkdownView content={markdown} />}\n                {longDescription && <p>{longDescription}</p>}\n                {sampleRepo && <p>Sample repository: {sampleRepoLink}</p>}\n                {documentationUrl && (\n                  <>\n                    <h2 className=\"h5\">Documentation</h2>\n                    <p>{documentationUrlLink}</p>\n                  </>\n                )}\n                {!_.isEmpty(plans) && (\n                  <>\n                    <h2 className=\"h5\">Service Plans</h2>\n                    <ul>{planItems}</ul>\n                  </>\n                )}\n                {kind === 'ImageStream' && (\n                  <>\n                    <hr />\n                    <p>The following resources will be created:</p>\n                    <ul>\n                      <li>\n                        A <span className=\"co-catalog-item-details__kind-label\">build config</span>{' '}\n                        to build source from a Git repository.\n                      </li>\n                      <li>\n                        An <span className=\"co-catalog-item-details__kind-label\">image stream</span>{' '}\n                        to track built images.\n                      </li>\n                      <li>\n                        A{' '}\n                        <span className=\"co-catalog-item-details__kind-label\">\n                          deployment config\n                        </span>{' '}\n                        to rollout new revisions when the image changes.\n                      </li>\n                      <li>\n                        A <span className=\"co-catalog-item-details__kind-label\">service</span> to\n                        expose your workload inside the cluster.\n                      </li>\n                      <li>\n                        An optional{' '}\n                        <span className=\"co-catalog-item-details__kind-label\">route</span> to expose\n                        your workload outside the cluster.\n                      </li>\n                    </ul>\n                  </>\n                )}\n              </div>\n            </div>\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nCatalogTileDetails.displayName = 'CatalogTileDetails';\nCatalogTileDetails.propTypes = {\n  items: PropTypes.array,\n  overlayClose: PropTypes.func,\n};\n","import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport { Link } from 'react-router-dom';\nimport * as catalogImg from '../../imgs/logos/catalog-icon.svg';\nimport { Badge, Modal } from '@patternfly/react-core';\nimport { CatalogItemHeader, CatalogTile, CatalogTileBadge } from '@patternfly/react-catalog-view-extension';\n\nimport { DEV_CATALOG_FILTER_KEY as filterKey } from '@console/shared';\nimport { history } from '../utils/router';\nimport { normalizeIconClass } from './catalog-item-icon';\nimport { CatalogTileDetails } from './catalog-item-details';\nimport { TileViewPage } from '../utils/tile-view-page';\n\ntype Metadata = { uid?: string; name?: string; namespace?: string };\n\nexport type Item = {\n  obj?: {\n    metadata?: Metadata;\n    csv?: { kind?: string; spec: { displayName: string }; metadata?: Metadata };\n  };\n  createLabel: string;\n  href: string;\n  kind?: string;\n  tileName?: string;\n  tileImgUrl?: string;\n  tileIconClass?: string;\n  tileProvider?: string;\n  tileDescription?: string;\n  tags?: string[];\n  longDescription?: string;\n  documentationUrl?: string;\n  supportUrl?: string;\n  markdownDescription?: () => Promise<string>;\n  customProperties?: React.ReactElement;\n};\n\nexport type CatalogTileViewPageProps = {\n  items: Item[];\n};\nexport type CatalogTileViewPageState = {\n  detailsItem: Item;\n};\n\nexport type FilterItem = {\n  label: string;\n  value: string;\n  active: boolean;\n};\n\ntype TypeFilters = {\n  ClusterServiceVersion: FilterItem;\n  HelmChart: FilterItem;\n  ImageStream: FilterItem;\n  Template: FilterItem;\n  ClusterServiceClass: FilterItem;\n  ServiceClass: FilterItem;\n};\n\ntype CapabilityFilters = {\n  BasicInstall: FilterItem;\n  SeamlessUpgrades: FilterItem;\n  FullLifecycle: FilterItem;\n  DeepInsights: FilterItem;\n  AutoPilot: FilterItem;\n};\n\ntype PageFilters = {\n  kind: TypeFilters;\n  capabilityLevel: CapabilityFilters;\n};\n\nexport const catalogCategories: Record<string, Record<string, string | Record<string, string | Record<string, any>>>> = {\n  languages: {\n    id: 'languages',\n    label: 'Languages',\n    field: 'tags',\n    subcategories: {\n      java: { id: 'java', label: 'Java', values: ['java'] },\n      javascript: {\n        id: 'javascript',\n        label: 'JavaScript',\n        field: 'tags',\n        values: ['javascript', 'nodejs', 'js'],\n      },\n      dotnet: { id: 'dotnet', label: '.NET', field: 'tags', values: ['dotnet'] },\n      perl: { id: 'perl', label: 'Perl', field: 'tags', values: ['perl'] },\n      ruby: { id: 'ruby', label: 'Ruby', field: 'tags', values: ['ruby'] },\n      php: { id: 'php', label: 'PHP', field: 'tags', values: ['php'] },\n      python: { id: 'python', label: 'Python', field: 'tags', values: ['python'] },\n      golang: { id: 'golang', label: 'Go', field: 'tags', values: ['golang', 'go'] },\n    },\n  },\n  databases: {\n    id: 'databases',\n    label: 'Databases',\n    field: 'tags',\n    subcategories: {\n      mongodb: { id: 'mongodb', label: 'Mongo', field: 'tags', values: ['mongodb'] },\n      mysql: { id: 'mysql', label: 'MySQL', field: 'tags', values: ['mysql'] },\n      postgresql: { id: 'postgresql', label: 'Postgres', field: 'tags', values: ['postgresql'] },\n      mariadb: { id: 'mariadb', label: 'MariaDB', field: 'tags', values: ['mariadb'] },\n    },\n  },\n  middleware: {\n    id: 'middleware',\n    label: 'Middleware',\n    field: 'tags',\n    subcategories: {\n      integration: {\n        id: 'integration',\n        label: 'Integration',\n        field: 'tags',\n        values: ['amq', 'fuse', 'jboss-fuse', 'sso', '3scale'],\n      },\n      processAutomation: {\n        id: 'processAutomation',\n        label: 'Process Automation',\n        field: 'tags',\n        values: ['decisionserver', 'processserver'],\n      },\n      analyticsData: {\n        id: 'analyticsData',\n        label: 'Analytics & Data',\n        field: 'tags',\n        values: ['datagrid', 'datavirt'],\n      },\n      runtimes: {\n        id: 'runtimes',\n        label: 'Runtimes & Frameworks',\n        field: 'tags',\n        values: ['eap', 'httpd', 'tomcat'],\n      },\n    },\n  },\n  cicd: {\n    id: 'cicd',\n    label: 'CI/CD',\n    field: 'tags',\n    subcategories: {\n      jenkins: { id: 'jenkins', label: 'Jenkins', field: 'tags', values: ['jenkins'] },\n      pipelines: { id: 'pipelines', label: 'Pipelines', field: 'tags', values: ['pipelines'] },\n    },\n  },\n  virtualization: {\n    id: 'virtualization',\n    label: 'Virtualization',\n    field: 'tags',\n    subcategories: {\n      vms: { id: 'vms', label: 'Virtual Machines', field: 'tags', values: ['virtualmachine'] },\n    },\n  },\n};\n\nconst pageDescription = 'Add shared apps, services, or source-to-image builders to your project from the Developer ' + 'Catalog. Cluster admins can install additional apps which will show up here automatically.';\n\n// Filter property white list\nconst filterGroups = ['kind'];\n\n// initialFilters cannot be typed as it has multiple usages\nconst getAvailableFilters = (initialFilters): PageFilters => {\n  const filters: PageFilters = _.cloneDeep(initialFilters);\n  filters.kind = {\n    ClusterServiceVersion: {\n      label: 'Operator Backed',\n      value: 'InstalledOperator',\n      active: true,\n    },\n    HelmChart: {\n      label: 'Helm Charts',\n      value: 'HelmChart',\n      active: false,\n    },\n    ImageStream: {\n      label: 'Builder Image',\n      value: 'ImageStream',\n      active: false,\n    },\n    Template: {\n      label: 'Template',\n      value: 'Template',\n      active: false,\n    },\n    ClusterServiceClass: {\n      label: 'Cluster Service Class',\n      value: 'ClusterServiceClass',\n      active: false,\n    },\n    ServiceClass: {\n      label: 'Service Class',\n      value: 'ServiceClass',\n      active: false,\n    },\n  };\n\n  return filters;\n};\n\nconst filterPreference = ['kind'];\nconst filterGroupNameMap: Record<string, string> = {\n  kind: 'Type',\n};\n\nconst GroupByTypes: Record<string, string> = {\n  Operator: 'Operator',\n  None: 'None',\n};\n\nconst keywordCompare = (filterString: string, item: Item): boolean => {\n  if (!filterString) {\n    return true;\n  }\n  if (!item) {\n    return false;\n  }\n\n  return item.tileName.toLowerCase().includes(filterString) || (item.tileDescription && item.tileDescription.toLowerCase().includes(filterString)) || (item.tags && item.tags.includes(filterString));\n};\n\nconst setURLParams = (params): void => {\n  const url = new URL(window.location.href);\n  const searchParams = `?${params.toString()}${url.hash}`;\n\n  history.replace(`${url.pathname}${searchParams}`);\n};\n\nconst sortByOperators = (items: Record<string, Item[]>): Record<string, Item[]> => {\n  const sortedItemsByOperators = {};\n  _.forEach(Object.keys(items).sort(), key => (sortedItemsByOperators[key] = items[key]));\n  return sortedItemsByOperators;\n};\n\nexport const groupItems = (items: Item[], groupBy: string): Item[] | Record<string, Item[]> => {\n  if (groupBy === GroupByTypes.Operator) {\n    const installedOperators = _.filter(items, item => item.kind === 'InstalledOperator');\n    const nonOperators = _.filter(items, item => item.kind !== 'InstalledOperator');\n    let groupedOperators = _.groupBy(installedOperators, item => item.obj.csv.spec.displayName);\n    groupedOperators = sortByOperators(groupedOperators);\n    const groupAllItems = { ...groupedOperators, 'Non Operators': nonOperators };\n    return groupAllItems;\n  }\n  return items;\n};\n\nexport class CatalogTileViewPage extends React.Component<CatalogTileViewPageProps, CatalogTileViewPageState> {\n  static displayName = `CatalogTileViewPage`;\n\n  constructor(props) {\n    super(props);\n\n    this.state = { detailsItem: null };\n  }\n\n  componentDidMount() {\n    const { items } = this.props;\n    const searchParams = new URLSearchParams(window.location.search);\n    const detailsItemID = searchParams.get('details-item');\n    const detailsItem = detailsItemID && _.find(items, item => detailsItemID === _.get(item, 'obj.metadata.uid'));\n    this.setState({ detailsItem });\n  }\n\n  openOverlay = (detailsItem: Item): void => {\n    const params = new URLSearchParams(window.location.search);\n    params.set('details-item', _.get(detailsItem, 'obj.metadata.uid'));\n    setURLParams(params);\n\n    this.setState({ detailsItem });\n  };\n\n  closeOverlay = (): void => {\n    const params = new URLSearchParams(window.location.search);\n    params.delete('details-item');\n    setURLParams(params);\n\n    this.setState({ detailsItem: null });\n  };\n\n  render() {\n    const { items } = this.props;\n    const { detailsItem } = this.state;\n    return (\n      <>\n        <TileViewPage\n          items={items}\n          itemsSorter={itemsToSort => _.sortBy(itemsToSort, ({ tileName }) => tileName.toLowerCase())}\n          getAvailableCategories={() => catalogCategories}\n          // TODO(alecmerdler): Dynamic filters for each Operator and its provided APIs\n          getAvailableFilters={getAvailableFilters}\n          filterGroups={filterGroups}\n          storeFilterKey={filterKey}\n          filterGroupNameMap={filterGroupNameMap}\n          keywordCompare={keywordCompare}\n          filterRetentionPreference={filterPreference}\n          renderTile={this.renderTile}\n          pageDescription={pageDescription}\n          emptyStateInfo=\"No developer catalog items are being shown due to the filters being applied.\"\n          groupItems={groupItems}\n          groupByTypes={GroupByTypes}\n        />\n        {this.renderModal(detailsItem)}\n      </>\n    );\n  }\n\n  renderTile = (item: Item): React.ReactElement => {\n    if (!item) {\n      return null;\n    }\n    const { obj, tileName, tileProvider, tileDescription, kind } = item;\n    const uid = obj.metadata.uid;\n    const vendor = tileProvider ? `provided by ${tileProvider}` : null;\n    const { kind: filters } = getAvailableFilters({ kind });\n    const filter = _.find(filters, ['value', kind]);\n    return (\n      <CatalogTile\n        className=\"co-catalog-tile\"\n        key={uid}\n        onClick={() => this.openOverlay(item)}\n        title={tileName}\n        badges={[\n          <CatalogTileBadge key=\"type\">\n            <Badge isRead>{filter?.label}</Badge>\n          </CatalogTileBadge>,\n        ]}\n        {...this.getIconProps(item)}\n        vendor={vendor}\n        description={tileDescription}\n        data-test={`${kind}-${obj.metadata.name}`}\n      />\n    );\n  };\n\n  renderModal = (detailsItem: Item) => {\n    if (!detailsItem) {\n      return null;\n    }\n    return (\n      <Modal\n        className=\"co-catalog-page__overlay co-catalog-page__overlay--right\"\n        header={\n          <>\n            <CatalogItemHeader title={detailsItem.tileName} vendor={detailsItem.tileProvider ? `Provided by ${detailsItem.tileProvider}` : null} {...this.getIconProps(detailsItem)} />\n            <div className=\"co-catalog-page__overlay-actions\">\n              <Link className=\"pf-c-button pf-m-primary co-catalog-page__overlay-action\" to={detailsItem.href} role=\"button\" title={detailsItem.createLabel} onClick={this.closeOverlay}>\n                {detailsItem.createLabel}\n              </Link>\n            </div>\n          </>\n        }\n        isOpen={!!detailsItem}\n        onClose={this.closeOverlay}\n        title={detailsItem.tileName}\n      >\n        <CatalogTileDetails item={detailsItem} closeOverlay={this.closeOverlay} />\n      </Modal>\n    );\n  };\n\n  getIconProps = (item: Item) => {\n    const { tileImgUrl, tileIconClass } = item;\n    if (tileImgUrl) {\n      return { iconImg: tileImgUrl, iconClass: null };\n    } else if (tileIconClass) {\n      return { iconImg: null, iconClass: normalizeIconClass(tileIconClass) };\n    }\n    return { iconImg: catalogImg, iconClass: null };\n  };\n}\n","import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport { Helmet } from 'react-helmet';\nimport { safeLoad } from 'js-yaml';\n\nimport { PropertyItem } from '@patternfly/react-catalog-view-extension';\nimport { ANNOTATIONS, FLAGS, APIError } from '@console/shared';\nimport { CatalogTileViewPage, Item } from './catalog-items';\nimport { k8sListPartialMetadata, referenceForModel, serviceClassDisplayName, K8sResourceCommon, K8sResourceKind, PartialObjectMetadata, TemplateKind } from '../../module/k8s';\nimport { withStartGuide } from '../start-guide';\nimport { connectToFlags, flagPending, FlagsObject } from '../../reducers/features';\nimport { Firehose, LoadError, PageHeading, skeletonCatalog, StatusBox, FirehoseResult, ExternalLink } from '../utils';\nimport { getAnnotationTags, getMostRecentBuilderTag, isBuilder } from '../image-stream';\nimport { getImageForIconClass, getImageStreamIcon, getServiceClassIcon, getServiceClassImage, getTemplateIcon } from './catalog-item-icon';\nimport { ClusterServiceClassModel, TemplateModel, ServiceClassModel } from '../../models';\nimport * as plugins from '../../plugins';\nimport { coFetch, coFetchJSON } from '../../co-fetch';\n\nexport class CatalogListPage extends React.Component<CatalogListPageProps, CatalogListPageState> {\n  constructor(props: CatalogListPageProps) {\n    super(props);\n\n    const items = this.getItems();\n    this.state = { items };\n  }\n\n  componentDidUpdate(prevProps) {\n    const { serviceClasses, clusterServiceClasses, templateMetadata, projectTemplateMetadata, imageStreams, helmCharts, namespace, loaded } = this.props;\n    if ((!prevProps.loaded && loaded) || !_.isEqual(namespace, prevProps.namespace) || !_.isEqual(serviceClasses, prevProps.serviceClasses) || !_.isEqual(clusterServiceClasses, prevProps.clusterServiceClasses) || !_.isEqual(templateMetadata, prevProps.templateMetadata) || !_.isEqual(projectTemplateMetadata, prevProps.projectTemplateMetadata) || !_.isEqual(imageStreams, prevProps.imageStreams) || !_.isEqual(helmCharts, prevProps.helmCharts)) {\n      const items = this.getItems();\n      this.setState({ items });\n    }\n  }\n\n  getItems(): Item[] {\n    const extensionItems = _.flatten(\n      plugins.registry\n        .getDevCatalogModels()\n        .filter(({ properties }) => _.get(this.props, referenceForModel(properties.model)))\n        .map(({ properties }) => properties.normalize(_.get(this.props, [referenceForModel(properties.model), 'data']))),\n    ) as Item[];\n\n    const { serviceClasses, clusterServiceClasses, imageStreams, templateMetadata, projectTemplateMetadata, helmCharts, loaded } = this.props;\n    let serviceClassItems: Item[] = [];\n    let clusterServiceClassItems: Item[] = [];\n    let imageStreamItems: Item[] = [];\n    let templateItems: Item[] = [];\n    let projectTemplateItems: Item[] = [];\n    let helmChartItems: Item[] = [];\n\n    if (!loaded) {\n      return [];\n    }\n\n    if (serviceClasses) {\n      serviceClassItems = this.normalizeServiceClasses(serviceClasses.data);\n    }\n\n    if (clusterServiceClasses) {\n      clusterServiceClassItems = this.normalizeClusterServiceClasses(clusterServiceClasses.data);\n    }\n\n    if (imageStreams) {\n      imageStreamItems = this.normalizeImageStreams(imageStreams.data);\n    }\n\n    // Templates are not passed as a Firehose item since we only request template metadata.\n    if (templateMetadata) {\n      templateItems = this.normalizeTemplates(templateMetadata);\n    }\n\n    // Templates are not passed as a Firehose item since we only request template metadata.\n    if (projectTemplateMetadata) {\n      projectTemplateItems = this.normalizeTemplates(projectTemplateMetadata);\n    }\n\n    if (helmCharts) {\n      helmChartItems = this.normalizeHelmCharts(helmCharts);\n    }\n\n    const items: Item[] = [...serviceClassItems, ...clusterServiceClassItems, ...imageStreamItems, ...templateItems, ...extensionItems, ...projectTemplateItems, ...helmChartItems];\n\n    return _.sortBy(items, 'tileName');\n  }\n\n  normalizeServiceClasses(serviceClasses: K8sResourceKind[]) {\n    // TODO : namespace가 없을 경우(all-namespace로 선택된 경우) 일단 default로 namespace설정되게 해놨는데 어떻게 처리할지 정해지면 수정하기\n    const { namespace = 'default' } = this.props;\n    return _.reduce(\n      serviceClasses,\n      (acc, serviceClass) => {\n        const iconClass = getServiceClassIcon(serviceClass);\n        const tileImgUrl = getServiceClassImage(serviceClass);\n\n        // TODO : service class를 사용한 service instance 기획이 나오면 해당 페이지로 이동시켜주도록 href 수정하기\n        acc.push({\n          obj: serviceClass,\n          kind: 'ServiceClass',\n          tileName: serviceClassDisplayName(serviceClass),\n          tileIconClass: tileImgUrl ? null : iconClass,\n          tileImgUrl: tileImgUrl == 'example.com/example.gif' ? null : tileImgUrl, // MEMO : example주소엔 이미지 없어서 기본아이콘으로 뜨게하려고 임시로 조건문 넣어놓음\n          tileDescription: serviceClass.spec.description,\n          tileProvider: _.get(serviceClass, 'spec.externalMetadata.providerDisplayName'),\n          tags: serviceClass.spec.tags,\n          createLabel: 'Create Service Instance',\n          // href: `/catalog/create-service-instance?service-class=${serviceClass.metadata.name}&preselected-ns=${namespace}`,\n          href: `/k8s/ns/${namespace}/serviceinstances/~new`,\n          supportUrl: _.get(serviceClass, 'spec.externalMetadata.supportUrl'),\n          longDescription: _.get(serviceClass, 'spec.externalMetadata.longDescription'),\n          documentationUrl: _.get(serviceClass, 'spec.externalMetadata.urlDescription'),\n        });\n        return acc;\n      },\n      [] as Item[],\n    );\n  }\n\n  normalizeClusterServiceClasses(clusterServiceClasses: K8sResourceKind[]) {\n    return _.reduce(\n      clusterServiceClasses,\n      (acc, clusterServiceClass) => {\n        // Prefer native templates to template-service-broker service classes.\n        // if (serviceClass.status.removedFromBrokerCatalog || serviceClass.spec.clusterServiceBrokerName === 'template-service-broker') {\n        //   return acc;\n        // }\n\n        const iconClass = getServiceClassIcon(clusterServiceClass);\n        const tileImgUrl = getServiceClassImage(clusterServiceClass);\n\n        // TODO : service class를 사용한 service instance 기획이 나오면 해당 페이지로 이동시켜주도록 href 수정하기\n        // 지금은 cluster service class 선택하고 create 누르면 default네임스페이스의 서비스인스턴스생성 페이지로 이동하게 해놓음\n        acc.push({\n          obj: clusterServiceClass,\n          kind: 'ClusterServiceClass',\n          tileName: serviceClassDisplayName(clusterServiceClass),\n          tileIconClass: tileImgUrl ? null : iconClass,\n          tileImgUrl: tileImgUrl == 'example.com/example.gif' ? null : tileImgUrl, // MEMO : example주소엔 이미지 없어서 기본아이콘으로 뜨게하려고 임시로 조건문 넣어놓음\n          tileDescription: clusterServiceClass.spec.description,\n          tileProvider: _.get(clusterServiceClass, 'spec.externalMetadata.providerDisplayName'),\n          tags: clusterServiceClass.spec.tags,\n          createLabel: 'Create Service Instance',\n          // href: `/catalog/create-service-instance?cluster-service-class=${clusterServiceClass.metadata.name}&preselected-ns=${namespace}`,\n          href: `/k8s/ns/default/serviceinstances/~new`,\n          supportUrl: _.get(clusterServiceClass, 'spec.externalMetadata.supportUrl'),\n          longDescription: _.get(clusterServiceClass, 'spec.externalMetadata.longDescription'),\n          documentationUrl: _.get(clusterServiceClass, 'spec.externalMetadata.documentationUrl'),\n        });\n        return acc;\n      },\n      [] as Item[],\n    );\n  }\n\n  normalizeTemplates(templates: Array<TemplateKind | PartialObjectMetadata>): Item[] {\n    return _.reduce(\n      templates,\n      (acc, template) => {\n        const { name, namespace, annotations = {} } = template.metadata;\n        const tags = (annotations.tags || '').split(/\\s*,\\s*/);\n        if (tags.includes('hidden')) {\n          return acc;\n        }\n        const iconClass = getTemplateIcon(template);\n        const tileImgUrl = getImageForIconClass(iconClass);\n        const tileIconClass = tileImgUrl ? null : iconClass;\n        acc.push({\n          obj: template,\n          kind: 'Template',\n          tileName: annotations[ANNOTATIONS.displayName] || name,\n          tileIconClass,\n          tileImgUrl,\n          tileDescription: annotations.description,\n          tags,\n          createLabel: 'Instantiate Template',\n          tileProvider: annotations[ANNOTATIONS.providerDisplayName],\n          documentationUrl: annotations[ANNOTATIONS.documentationURL],\n          supportUrl: annotations[ANNOTATIONS.supportURL],\n          href: `/catalog/instantiate-template?template=${name}&template-ns=${namespace}&preselected-ns=${this.props.namespace || ''}`,\n        });\n        return acc;\n      },\n      [] as Item[],\n    );\n  }\n\n  normalizeHelmCharts(chartEntries: HelmChartEntries): Item[] {\n    const { namespace: currentNamespace = '' } = this.props;\n\n    return _.reduce(\n      chartEntries,\n      (normalizedCharts, charts) => {\n        charts.forEach((chart: HelmChart) => {\n          const tags = chart.keywords;\n          const chartName = chart.name;\n          const chartVersion = chart.version;\n          const appVersion = chart.appVersion;\n          const tileName = `${_.startCase(chartName)} v${chart.version}`;\n          const tileImgUrl = chart.icon || getImageForIconClass('icon-helm');\n          const chartURL = _.get(chart, 'urls.0');\n          const encodedChartURL = encodeURIComponent(chartURL);\n          const markdownDescription = async () => {\n            let chartData;\n            try {\n              chartData = await coFetchJSON(`/api/helm/chart?url=${chartURL}`);\n            } catch {\n              return null;\n            }\n            const readmeFile = chartData?.files?.find(file => file.name === 'README.md');\n            const readmeData = readmeFile?.data && atob(readmeFile?.data);\n            return readmeData && `## README\\n${readmeData}`;\n          };\n\n          const maintainers = chart.maintainers?.length > 0 && (\n            <>\n              {chart.maintainers?.map(maintainer => (\n                <>\n                  {maintainer.name}\n                  <br />\n                  <a href={`mailto:${maintainer.email}`}>{maintainer.email}</a>\n                  <br />\n                </>\n              ))}\n            </>\n          );\n\n          const homePage = chart.home && <ExternalLink href={chart.home} additionalClassName=\"co-break-all\" text={chart.home} />;\n\n          const customProperties = (\n            <>\n              <PropertyItem label=\"Chart Version\" value={chartVersion} />\n              <PropertyItem label=\"App Version\" value={appVersion} />\n              {homePage && <PropertyItem label=\"Home Page\" value={homePage} />}\n              {maintainers && <PropertyItem label=\"Maintainers\" value={maintainers} />}\n            </>\n          );\n\n          const obj = {\n            ...chart,\n            ...{ metadata: { uid: chart.digest, creationTimestamp: chart.created } },\n          };\n\n          normalizedCharts.push({\n            obj,\n            kind: 'HelmChart',\n            tileName,\n            tileIconClass: null,\n            tileImgUrl,\n            tileDescription: chart.description,\n            tags,\n            createLabel: 'Install Helm Chart',\n            markdownDescription,\n            customProperties,\n            href: `/catalog/helm-install?chartName=${chartName}&chartURL=${encodedChartURL}&preselected-ns=${currentNamespace}`,\n          });\n        });\n        return normalizedCharts;\n      },\n      [] as Item[],\n    );\n  }\n\n  normalizeImageStreams(imageStreams: K8sResourceKind[]): Item[] {\n    const builderimageStreams = _.filter(imageStreams, isBuilder);\n    return _.map(builderimageStreams, imageStream => {\n      const { namespace: currentNamespace = '' } = this.props;\n      const { name, namespace } = imageStream.metadata;\n      const tag = getMostRecentBuilderTag(imageStream);\n      const tileName = _.get(imageStream, ['metadata', 'annotations', ANNOTATIONS.displayName]) || name;\n      const iconClass = getImageStreamIcon(tag);\n      const tileImgUrl = getImageForIconClass(iconClass);\n      const tileIconClass = tileImgUrl ? null : iconClass;\n      const tileDescription = _.get(tag, 'annotations.description');\n      const tags = getAnnotationTags(tag);\n      const createLabel = 'Create Application';\n      const tileProvider = _.get(tag, ['annotations', ANNOTATIONS.providerDisplayName]);\n      const href = `/catalog/source-to-image?imagestream=${name}&imagestream-ns=${namespace}&preselected-ns=${currentNamespace}`;\n      const builderImageTag = _.head(_.get(imageStream, 'spec.tags'));\n      const sampleRepo = _.get(builderImageTag, 'annotations.sampleRepo');\n      return {\n        obj: imageStream,\n        kind: 'ImageStream',\n        tileName,\n        tileIconClass,\n        tileImgUrl,\n        tileDescription,\n        tags,\n        createLabel,\n        tileProvider,\n        href,\n        sampleRepo,\n      };\n    });\n  }\n\n  render() {\n    const { loaded, loadError } = this.props;\n    const { items } = this.state;\n\n    return (\n      <StatusBox skeleton={skeletonCatalog} data={items} loaded={loaded} loadError={loadError} label=\"Resources\">\n        <CatalogTileViewPage items={items} />\n      </StatusBox>\n    );\n  }\n}\n\nexport const Catalog = connectToFlags<CatalogProps>(\n  FLAGS.OPENSHIFT,\n  FLAGS.SERVICE_CATALOG,\n  ...plugins.registry.getDevCatalogModels().map(({ properties }) => properties.flag),\n)(props => {\n  const { flags, mock, namespace } = props;\n  const openshiftFlag = flags[FLAGS.OPENSHIFT];\n  const serviceCatalogFlag = flags[FLAGS.SERVICE_CATALOG];\n  const [templateMetadata, setTemplateMetadata] = React.useState<K8sResourceCommon>();\n  const [templateError, setTemplateError] = React.useState<APIError>();\n  const [projectTemplateMetadata, setProjectTemplateMetadata] = React.useState<K8sResourceCommon[]>(null);\n  const [projectTemplateError, setProjectTemplateError] = React.useState<APIError>();\n  const [helmCharts, setHelmCharts] = React.useState<HelmChartEntries>();\n\n  const loadTemplates = openshiftFlag && !mock;\n\n  // Load templates from the shared `openshift` namespace. Don't use Firehose\n  // for templates so that we can request only metadata. This keeps the request\n  // much smaller.\n  React.useEffect(() => {\n    if (!loadTemplates) {\n      return;\n    }\n    k8sListPartialMetadata(TemplateModel, { ns: 'openshift' })\n      .then(metadata => {\n        setTemplateMetadata(metadata);\n        setTemplateError(null);\n      })\n      .catch(setTemplateError);\n  }, [loadTemplates]);\n\n  // Load templates for the current project.\n  React.useEffect(() => {\n    if (!loadTemplates) {\n      return;\n    }\n    // Don't load templates from the `openshift` namespace twice if it's the current namespace\n    if (!namespace || namespace === 'openshift') {\n      setProjectTemplateMetadata([]);\n      setProjectTemplateError(null);\n    } else {\n      k8sListPartialMetadata(TemplateModel, { ns: namespace })\n        .then(metadata => {\n          setProjectTemplateMetadata(metadata);\n          setProjectTemplateError(null);\n        })\n        .catch(setTemplateError);\n    }\n  }, [loadTemplates, namespace]);\n\n  React.useEffect(() => {\n    coFetch('/api/helm/charts/index.yaml').then(async res => {\n      const yaml = await res.text();\n      const json = safeLoad(yaml);\n      setHelmCharts(json.entries);\n    });\n  }, []);\n\n  const error = templateError || projectTemplateError;\n  if (error) {\n    return <LoadError message={error.message} label=\"Templates\" className=\"loading-box loading-box__errored\" />;\n  }\n\n  if (_.some(flags, flag => flagPending(flag))) {\n    return null;\n  }\n\n  const resources = [\n    ...(serviceCatalogFlag\n      ? [\n          {\n            isList: true,\n            kind: referenceForModel(ClusterServiceClassModel),\n            namespaced: false,\n            prop: 'clusterServiceClasses',\n          },\n        ]\n      : []),\n    ...[\n      {\n        isList: true,\n        kind: referenceForModel(ServiceClassModel),\n        namespaced: true,\n        namespace,\n        prop: 'serviceClasses',\n      },\n    ],\n    ...(openshiftFlag\n      ? [\n          {\n            isList: true,\n            kind: 'ImageStream',\n            namespace: 'openshift',\n            prop: 'imageStreams',\n          },\n        ]\n      : []),\n    ...plugins.registry\n      .getDevCatalogModels()\n      .filter(({ properties }) => !properties.flag || flags[properties.flag])\n      .map(({ properties }) => ({\n        isList: true,\n        kind: referenceForModel(properties.model),\n        namespaced: properties.model.namespaced,\n        namespace,\n        prop: referenceForModel(properties.model),\n      })),\n  ];\n\n  return (\n    <div className=\"co-catalog__body\">\n      <Firehose resources={mock ? [] : resources}>\n        <CatalogListPage namespace={namespace} templateMetadata={templateMetadata} projectTemplateMetadata={projectTemplateMetadata} helmCharts={helmCharts} {...(props as any)} />\n      </Firehose>\n    </div>\n  );\n});\n\nexport const CatalogPage = withStartGuide(({ match, noProjectsAvailable }) => {\n  const namespace = _.get(match, 'params.ns');\n  return (\n    <>\n      <Helmet>\n        <title>Developer Catalog</title>\n      </Helmet>\n      <div className=\"co-m-page__body\">\n        <div className=\"co-catalog\">\n          <PageHeading title=\"Developer Catalog\" />\n          <p className=\"co-catalog-page__description\">Add shared apps, services, or source-to-image builders to your project from the Developer Catalog. Cluster admins can install additional apps which will show up here automatically.</p>\n          <Catalog namespace={namespace} mock={noProjectsAvailable} />\n        </div>\n      </div>\n    </>\n  );\n});\n\nexport type CatalogListPageProps = {\n  serviceClasses?: FirehoseResult<K8sResourceKind[]>;\n  clusterServiceClasses?: FirehoseResult<K8sResourceKind[]>;\n  imageStreams?: FirehoseResult<K8sResourceKind[]>;\n  templateMetadata?: PartialObjectMetadata[];\n  projectTemplateMetadata?: PartialObjectMetadata[];\n  helmCharts?: HelmChartEntries;\n  loaded: boolean;\n  loadError?: string;\n  namespace?: string;\n};\n\nexport type CatalogListPageState = {\n  items: Item[];\n};\n\nexport type CatalogProps = {\n  flags: FlagsObject;\n  namespace?: string;\n  mock: boolean;\n};\n\nexport type HelmChartEntries = {\n  [name: string]: Array<HelmChart>;\n};\n\nexport type HelmChart = {\n  apiVersion: string;\n  appVersion: string;\n  created: string;\n  description: string;\n  digest: string;\n  home: string;\n  icon: string;\n  keywords: string[];\n  maintainers: Array<{ email: string; name: string }>;\n  name: string;\n  tillerVersion: string;\n  urls: string[];\n  version: string;\n};\n\nCatalogPage.displayName = 'CatalogPage';\nCatalog.displayName = 'Catalog';\n","import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport { Converter } from 'showdown';\nimport * as sanitizeHtml from 'sanitize-html';\n\nconst tableTags = ['table', 'thead', 'tbody', 'tr', 'th', 'td'];\n\nconst markdownConvert = (markdown) => {\n  const unsafeHtml = new Converter({\n    tables: true,\n    openLinksInNewWindow: true,\n    strikethrough: true,\n    emoji: true,\n  }).makeHtml(markdown);\n\n  return sanitizeHtml(unsafeHtml, {\n    allowedTags: [\n      'b',\n      'i',\n      'strike',\n      's',\n      'del',\n      'em',\n      'strong',\n      'a',\n      'p',\n      'h1',\n      'h2',\n      'h3',\n      'h4',\n      'ul',\n      'ol',\n      'li',\n      'code',\n      'pre',\n      ...tableTags,\n    ],\n    allowedAttributes: {\n      a: ['href', 'target', 'rel'],\n    },\n    allowedSchemes: ['http', 'https', 'mailto'],\n    transformTags: {\n      a: sanitizeHtml.simpleTransform('a', { rel: 'noopener noreferrer' }, true),\n    },\n  });\n};\n\nexport class SyncMarkdownView extends React.Component<\n  { content: string; styles?: string; exactHeight?: boolean },\n  {}\n> {\n  private frame: any;\n\n  constructor(props) {\n    super(props);\n  }\n\n  componentDidMount() {\n    this.updateDimensions();\n  }\n\n  updateDimensions() {\n    if (!this.frame?.contentWindow?.document.body.firstChild) {\n      return;\n    }\n    this.frame.style.height = `${this.frame.contentWindow.document.body.firstChild.scrollHeight}px`;\n\n    // Let the new height take effect, then reset again once we recompute\n    setTimeout(() => {\n      if (this.props.exactHeight) {\n        this.frame.style.height = `${this.frame.contentWindow.document.body.firstChild.scrollHeight}px`;\n      } else {\n        // Increase by 15px for the case where a horizontal scrollbar might appear\n        this.frame.style.height = `${this.frame.contentWindow.document.body.firstChild\n          .scrollHeight + 15}px`;\n      }\n    });\n  }\n\n  render() {\n    // Find the app's stylesheets and inject them into the frame to ensure consistent styling.\n    const filteredLinks = Array.from(document.getElementsByTagName('link')).filter((l) =>\n      _.includes(l.href, 'app-bundle'),\n    );\n\n    const linkRefs = _.reduce(\n      filteredLinks,\n      (refs, link) => `${refs}\n        <link rel=\"stylesheet\" href=\"${link.href}\">`,\n      '',\n    );\n\n    const contents = `\n      ${linkRefs}\n      <style type=\"text/css\">\n      body {\n        background-color: transparent !important;\n        color: ${this.props.content ? '#333' : '#999'};\n        font-family: var(--pf-global--FontFamily--sans-serif);\n        min-width: auto !important;\n      }\n      table {\n        display: block;\n        margin-bottom: 11.5px;\n        overflow-x: auto;\n      }\n      td,\n      th {\n        border-bottom: 1px solid #ededed;\n        padding: 10px;\n        vertical-align: top;\n      }\n      th {\n        padding-top: 0;\n      }\n      ${this.props.styles ? this.props.styles : ''}\n      </style>\n      <body class=\"pf-m-redhat-font\"><div style=\"overflow-y: auto;\">${markdownConvert(\n        this.props.content || 'Not available',\n      )}</div></body>`;\n    return (\n      <iframe\n        sandbox=\"allow-popups allow-same-origin\"\n        srcDoc={contents}\n        style={{ border: '0px', display: 'block', width: '100%', height: '0' }}\n        ref={(r) => (this.frame = r)}\n        onLoad={() => this.updateDimensions()}\n      />\n    );\n  }\n}\n","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */","/* (ignored) */"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAoIA;AAlIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAWA;AAEA;AAEA;AACA;AAOA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;;AACA;AAAA;AAEA;AACA;;AACA;AAAA;AAEA;AACA;;AACA;AACA;AAEA;AAEA;AACA;;AACA;AAEA;AACA;;AACA;AACA;AAEA;AAUA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAaA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AA6BA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAOA;AAEA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AAUA;AAGA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AApHA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAYA;AAGA;;AAzDA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpPA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAGA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AA4CA;AACA;;;;;;;;;;;;;ACreA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAGA;AAIA;AACA;;;;AAIA;;;;;;;;;;;;;;;;;;AAkBA;;AAEA;AAGA;AASA;AACA;;;;;;;;;;;;AClIA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;;;;;;;;ACAA;;;;A","sourceRoot":""}