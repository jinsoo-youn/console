{"version":3,"file":"delete-revision~dev-console-edit~dev-console-import~dev-console-projectDetails~dev-console-topology~~1015c5b1-a69c7af007fba308229b.js","sources":["webpack:///./packages/dev-console/src/components/pipelines/const.ts","webpack:///./packages/dev-console/src/utils/pipeline-augment.ts","webpack:///./packages/dev-console/src/utils/pipeline-filter-reducer.ts","webpack:///./packages/dev-console/src/utils/pipeline-utils.ts"],"sourcesContent":["export enum StartedByLabel {\n  user = 'pipeline.openshift.io/started-by',\n  triggers = 'triggers.tekton.dev/eventlistener',\n}\n\nexport enum PipelineResourceType {\n  git = 'git',\n  image = 'image',\n  cluster = 'cluster',\n  storage = 'storage',\n}\n\nexport const pipelineResourceTypeSelections = {\n  '': 'Select resource type',\n  [PipelineResourceType.git]: 'Git',\n  [PipelineResourceType.image]: 'Image',\n  [PipelineResourceType.cluster]: 'Cluster',\n  [PipelineResourceType.storage]: 'Storage',\n};\n\nexport enum VolumeTypes {\n  EmptyDirectory = 'Empty Directory',\n  ConfigMap = 'Config Map',\n  Secret = 'Secret',\n  PVC = 'PVC',\n}\n\nexport enum SecretAnnotationId {\n  Git = 'git',\n  Image = 'docker',\n}\n\nexport const SecretAnnotationType = {\n  [SecretAnnotationId.Git]: 'Git Server',\n  [SecretAnnotationId.Image]: 'Docker Registry',\n};\n\nexport const PIPELINE_SERVICE_ACCOUNT = 'pipeline';\n","import {\n  chart_color_green_400 as successColor,\n  chart_color_blue_300 as runningColor,\n  global_danger_color_100 as failureColor,\n  chart_color_blue_100 as pendingColor,\n  chart_color_black_400 as skippedColor,\n  chart_color_black_500 as cancelledColor,\n} from '@patternfly/react-tokens';\nimport { K8sKind, K8sResourceKind, referenceForModel } from '@console/internal/module/k8s';\nimport {\n  ClusterTaskModel,\n  ClusterTriggerBindingModel,\n  PipelineRunModel,\n  TaskModel,\n  TriggerBindingModel,\n} from '../models';\nimport { pipelineRunFilterReducer } from './pipeline-filter-reducer';\n\ninterface Metadata {\n  name: string;\n  namespace?: string;\n}\n\nexport interface PropPipelineData {\n  metadata: Metadata;\n  latestRun?: PipelineRun;\n}\n\ninterface StatusMessage {\n  message: string;\n  pftoken: { name: string; value: string; var: string };\n}\n\nexport interface TaskStatus {\n  PipelineNotStarted: number;\n  Pending: number;\n  Running: number;\n  Succeeded: number;\n  Cancelled: number;\n  Failed: number;\n}\n\nexport interface PipelineTaskRef {\n  kind?: string;\n  name: string;\n}\n\nexport interface PipelineTaskParam {\n  name: string;\n  value: any;\n}\nexport interface PipelineTaskResources {\n  inputs?: PipelineTaskResource[];\n  outputs?: PipelineTaskResource[];\n}\nexport interface PipelineTaskResource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport interface PipelineTask {\n  name: string;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n}\n\nexport interface Resource {\n  propsReferenceForRuns: string[];\n  resources: FirehoseResource[];\n}\n\nexport interface PipelineResource {\n  name: string;\n  type: string;\n}\n\ntype PipelineRunResourceCommonProperties = {\n  name: string;\n};\nexport type PipelineRunInlineResourceParam = { name: string; value: string };\nexport type PipelineRunInlineResource = PipelineRunResourceCommonProperties & {\n  resourceSpec: {\n    params: PipelineRunInlineResourceParam[];\n    type: string;\n  };\n};\nexport type PipelineRunReferenceResource = PipelineRunResourceCommonProperties & {\n  resourceRef: {\n    name: string;\n  };\n};\nexport type PipelineRunResource = PipelineRunReferenceResource | PipelineRunInlineResource;\n\nexport interface Runs {\n  data?: PipelineRun[];\n}\n\nexport type KeyedRuns = { [key: string]: Runs };\n\nexport interface Pipeline extends K8sResourceKind {\n  latestRun?: PipelineRun;\n  spec: {\n    params?: PipelineParam[];\n    resources?: PipelineResource[];\n    workspaces?: PipelineWorkspace[];\n    tasks: PipelineTask[];\n    serviceAccountName?: string;\n  };\n}\n\nexport type TaskRunKind = { pipelineTaskName?: string } & K8sResourceKind;\n\nexport interface TaskRuns {\n  [key: string]: TaskRunKind;\n}\n\nexport interface PipelineSpecTaskRef {\n  kind?: string;\n  name?: string;\n  apiVersion?: string;\n}\n\nexport interface PipelineSpecTaskSpec {\n  metadata?: {};\n  steps?: {\n    // TODO: Figure out required fields\n    env?: PipelineTaskParam[];\n    image?: string;\n    name?: string;\n    resources?: {};\n    script?: string;\n    securityContext?: {\n      privileged: boolean;\n      [key: string]: any;\n    }\n    imagePullPolicy?: string;\n    workingDir?: string;\n  }[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpecTask {\n  name: string;\n  runAfter?: string[];\n  taskRef?: PipelineSpecTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n  taskSpec?: PipelineSpecTaskSpec;\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpec extends K8sResourceKind {\n  tasks: PipelineSpecTask[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineRun extends K8sResourceKind {\n  spec?: {\n    pipelineRef?: { name: string };\n    params?: PipelineRunParam[];\n    workspaces?: PipelineRunWorkspace[];\n    resources?: PipelineRunResource[];\n    serviceAccountName?: string;\n    // Odd status value that only appears in a single case - cancelling a pipeline\n    status?: 'PipelineRunCancelled';\n    timeout?: string;\n    pipelineSpec?: PipelineSpec;\n  };\n  status?: {\n    succeededCondition?: string;\n    creationTimestamp?: string;\n    conditions?: Condition[];\n    startTime?: string;\n    completionTime?: string;\n    taskRuns?: TaskRuns;\n    runs?: TaskRuns; \n  };\n}\n\nexport type PipelineResourceKind = K8sResourceKind & {\n  spec: {\n    params: { name: string; value: string }[];\n    type: string;\n  };\n};\n\nexport interface PipelineResourceTaskParam extends PipelineParam {\n  type: string;\n}\nexport interface PipelineResourceTaskResource {\n  name: string;\n  type: string;\n  optional?: boolean;\n}\nexport interface PipelineResourceTask extends K8sResourceKind {\n  spec: {\n    params?: PipelineResourceTaskParam[];\n    resources?: {\n      inputs?: PipelineResourceTaskResource[];\n      outputs?: PipelineResourceTaskResource[];\n    };\n\n    steps: {\n      // TODO: Figure out required fields\n      args?: string[];\n      command?: string[];\n      image?: string;\n      resources?: {}[];\n    }[];\n  };\n}\n\nexport interface Condition {\n  type: string;\n  status: string;\n  reason?: string;\n  message?: string;\n  lastTransitionTime?: string;\n}\n\nexport interface Param {\n  name: string;\n}\n\nexport interface PipelineParam extends Param {\n  default?: string | string[];\n  description?: string;\n}\n\nexport interface PipelineRunParam extends Param {\n  value: string | string[];\n  input?: string;\n  output?: string;\n  resource?: object;\n}\n\nexport interface PipelineWorkspace extends Param {\n  type: string;\n  data?: {\n    [key: string]: string;\n  };\n}\n\nexport interface PipelineRunWorkspace extends Param {\n  [key: string]: string;\n}\n\ninterface FirehoseResource {\n  kind: string;\n  namespace?: string;\n  isList?: boolean;\n  selector?: object;\n}\n\nexport const getResources = (data: PropPipelineData[]): Resource => {\n  const resources = [];\n  const propsReferenceForRuns = [];\n  if (data && data.length > 0) {\n    data.forEach((pipeline, i) => {\n      if (pipeline.metadata && pipeline.metadata.namespace && pipeline.metadata.name) {\n        propsReferenceForRuns.push(`PipelineRun_${i}`);\n        resources.push({\n          kind: referenceForModel(PipelineRunModel),\n          namespace: pipeline.metadata.namespace,\n          isList: true,\n          prop: `PipelineRun_${i}`,\n          selector: {\n            'tekton.dev/pipeline': pipeline.metadata.name,\n          },\n        });\n      }\n    });\n    return { propsReferenceForRuns, resources };\n  }\n  return { propsReferenceForRuns: null, resources: null };\n};\n\nexport const getLatestRun = (runs: Runs, field: string): PipelineRun => {\n  if (!runs || !runs.data || !(runs.data.length > 0) || !field) {\n    return null;\n  }\n  let latestRun = runs.data[0];\n  if (field === 'creationTimestamp') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].metadata &&\n        runs.data[i].metadata[field] &&\n        new Date(runs.data[i].metadata[field]) > new Date(latestRun.metadata[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else if (field === 'startTime' || field === 'completionTime') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].status &&\n        runs.data[i].status[field] &&\n        new Date(runs.data[i].status[field]) > new Date(latestRun.status[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else {\n    latestRun = runs.data[runs.data.length - 1];\n  }\n  if (!latestRun.status) {\n    latestRun = { ...latestRun, status: {} };\n  }\n  if (!latestRun.status.succeededCondition) {\n    latestRun.status = { ...latestRun.status, succeededCondition: '' };\n  }\n  latestRun.status.succeededCondition = pipelineRunFilterReducer(latestRun);\n  return latestRun;\n};\n\nexport const augmentRunsToData = (\n  data: PropPipelineData[],\n  propsReferenceForRuns: string[],\n  runs: { [key: string]: Runs },\n): PropPipelineData[] => {\n  if (propsReferenceForRuns) {\n    const newData: PropPipelineData[] = [];\n    propsReferenceForRuns.forEach((reference, i) => {\n      const latestRun = getLatestRun(runs[reference], 'creationTimestamp');\n      if (latestRun !== data[i].latestRun) {\n        // ensure we create a new data object if the latestRun has changed so that shallow compare fails\n        newData.push({ ...data[i], latestRun });\n      } else {\n        newData.push(data[i]);\n      }\n    });\n    return newData;\n  }\n  return data;\n};\n\nexport enum runStatus {\n  Succeeded = 'Succeeded',\n  Failed = 'Failed',\n  Running = 'Running',\n  'In Progress' = 'In Progress',\n  FailedToStart = 'FailedToStart',\n  PipelineNotStarted = 'PipelineNotStarted',\n  Skipped = 'Skipped',\n  Cancelled = 'Cancelled',\n  Pending = 'Pending',\n  Idle = 'Idle',\n}\n\nexport const getRunStatusColor = (status: string): StatusMessage => {\n  switch (status) {\n    case runStatus.Succeeded:\n      return { message: 'Succeeded', pftoken: successColor };\n    case runStatus.Failed:\n      return { message: 'Failed', pftoken: failureColor };\n    case runStatus.FailedToStart:\n      return {\n        message: 'PipelineRun failed to start',\n        pftoken: failureColor,\n      };\n    case runStatus.Running:\n      return { message: 'Running', pftoken: runningColor };\n    case runStatus['In Progress']:\n      return { message: 'Running', pftoken: runningColor };\n\n    case runStatus.Skipped:\n      return { message: 'Skipped', pftoken: skippedColor };\n    case runStatus.Cancelled:\n      return { message: 'Cancelled', pftoken: cancelledColor };\n    case runStatus.Idle:\n    case runStatus.Pending:\n      return { message: 'Pending', pftoken: pendingColor };\n    default:\n      return { message: 'PipelineRun not started yet', pftoken: pendingColor };\n  }\n};\n\nexport const truncateName = (name: string, length: number): string =>\n  name.length < length ? name : `${name.slice(0, length - 1)}...`;\n\nexport const getTaskStatus = (pipelinerun: PipelineRun, pipeline: Pipeline): TaskStatus => {\n  const totalTasks =\n    pipeline && pipeline.spec && pipeline.spec.tasks ? pipeline.spec.tasks.length : 0;\n  const plrTasks =\n    pipelinerun && pipelinerun.status && pipelinerun.status.taskRuns\n      ? pipelinerun.status.runs ? Object.keys(pipelinerun.status.runs).concat(Object.keys(pipelinerun.status.taskRuns))\n        : Object.keys(pipelinerun.status.taskRuns)\n      : [];\n  const plrTaskLength = plrTasks.length;\n  const taskStatus: TaskStatus = {\n    PipelineNotStarted: 0,\n    Pending: 0,\n    Running: 0,\n    Succeeded: 0,\n    Failed: 0,\n    Cancelled: 0,\n  };\n  if (plrTasks) {\n    plrTasks.forEach((taskRun) => {\n      const status = pipelineRunFilterReducer(pipelinerun.status.taskRuns[taskRun] ?? pipelinerun.status.runs[taskRun]);\n      if (status === 'Succeeded' || status === 'Completed' || status === 'Complete') {\n        taskStatus[runStatus.Succeeded]++;\n      } else if (status === 'Running') {\n        taskStatus[runStatus.Running]++;\n      } else if (status === 'Failed') {\n        taskStatus[runStatus.Failed]++;\n      } else if (status === 'Cancelled') {\n        taskStatus[runStatus.Cancelled]++;\n      } else {\n        taskStatus[runStatus.Pending]++;\n      }\n    });\n    taskStatus[runStatus.Failed] > 0 || taskStatus[runStatus.Cancelled] > 0\n      ? (taskStatus[runStatus.Cancelled] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks)\n      : (taskStatus[runStatus.Pending] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks);\n  } else if (\n    pipelinerun &&\n    pipelinerun.status &&\n    pipelinerun.status.conditions &&\n    pipelinerun.status.conditions[0].status === 'False'\n  ) {\n    taskStatus[runStatus.Cancelled] = totalTasks;\n  } else {\n    taskStatus[runStatus.PipelineNotStarted]++;\n  }\n  return taskStatus;\n};\n\nexport const getResourceModelFromTaskKind = (kind: string): K8sKind =>\n  kind === ClusterTaskModel.kind ? ClusterTaskModel : TaskModel;\n\nexport const getResourceModelFromBindingKind = (kind: string): K8sKind =>\n  kind === ClusterTriggerBindingModel.kind ? ClusterTriggerBindingModel : TriggerBindingModel;\n\nexport const getResourceModelFromTask = (task: PipelineTask): K8sKind => {\n  const {\n    taskRef: { kind },\n  } = task;\n\n  return getResourceModelFromTaskKind(kind);\n};\n\nexport const pipelineRefExists = (pipelineRun: PipelineRun): boolean =>\n  !!pipelineRun.spec.pipelineRef?.name;\n","import * as _ from 'lodash';\n\nexport const pipelineRunStatus = (pipelineRun): string => {\n  const conditions = _.get(pipelineRun, ['status', 'conditions'], []);\n  const isCancelled = conditions.find((c) =>\n    ['PipelineRunCancelled', 'TaskRunCancelled'].some((cancel) => cancel === c.reason),\n  );\n  if (isCancelled) {\n    return 'Cancelled';\n  }\n  if (conditions.length === 0) return null;\n\n  const condition = conditions.find((c) => c.type === 'Succeeded');\n  return !condition || !condition.status\n    ? null\n    : condition.status === 'True'\n    ? 'Succeeded'\n    : condition.status === 'False'\n    ? 'Failed'\n    : 'Running';\n};\n\nexport const pipelineFilterReducer = (pipeline): string => {\n  if (!pipeline.latestRun) return '-';\n  return pipelineRunStatus(pipeline.latestRun) || '-';\n};\n\nexport const pipelineRunFilterReducer = (pipelineRun): string => {\n  const status = pipelineRunStatus(pipelineRun);\n  return status || '-';\n};\n\nexport const pipelineStatusFilter = (filters, pipeline) => {\n  if (!filters || !filters.selected || !filters.selected.size) {\n    return true;\n  }\n  const status = pipelineFilterReducer(pipeline);\n  return filters.selected.has(status) || !_.includes(filters.all, status);\n};\n\nexport const pipelineRunStatusFilter = (phases, pipeline) => {\n  if (!phases || !phases.selected || !phases.selected.size) {\n    return true;\n  }\n\n  const status = pipelineRunFilterReducer(pipeline);\n  return phases.selected.has(status) || !_.includes(phases.all, status);\n};\n","import * as _ from 'lodash';\nimport { formatDuration } from '@console/internal/components/utils/datetime';\nimport {\n  ContainerStatus,\n  K8sResourceKind,\n  k8sUpdate,\n  k8sGet,\n  SecretKind,\n  K8sResourceCommon,\n} from '@console/internal/module/k8s';\nimport {\n  LOG_SOURCE_RESTARTING,\n  LOG_SOURCE_WAITING,\n  LOG_SOURCE_RUNNING,\n  LOG_SOURCE_TERMINATED,\n} from '@console/internal/components/utils';\nimport { ServiceAccountModel } from '@console/internal/models';\nimport { errorModal } from '@console/internal/components/modals/error-modal';\nimport { PIPELINE_SERVICE_ACCOUNT, SecretAnnotationId } from '../components/pipelines/const';\nimport {\n  getLatestRun,\n  Pipeline,\n  PipelineRun,\n  runStatus,\n  PipelineParam,\n  PipelineRunParam,\n  PipelineTaskRef,\n  PipelineWorkspace,\n  PipelineRunWorkspace,\n} from './pipeline-augment';\nimport { pipelineFilterReducer, pipelineRunStatus } from './pipeline-filter-reducer';\n\ninterface Resources {\n  inputs?: Resource[];\n  outputs?: Resource[];\n}\n\ninterface Resource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport type ServiceAccountType = {\n  secrets: { [name: string]: string }[];\n} & K8sResourceCommon;\n\nexport interface PipelineVisualizationTaskItem {\n  name: string;\n  resources?: Resources;\n  params?: object;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n}\n\nexport const TaskStatusClassNameMap = {\n  'In Progress': 'is-running',\n  Succeeded: 'is-done',\n  Failed: 'is-error',\n  Idle: 'is-idle',\n};\n\nexport const conditions = {\n  hasFromDependency: (task: PipelineVisualizationTaskItem): boolean =>\n    task.resources &&\n    task.resources.inputs &&\n    task.resources.inputs.length > 0 &&\n    !!task.resources.inputs[0].from,\n  hasRunAfterDependency: (task: PipelineVisualizationTaskItem): boolean =>\n    task.runAfter && task.runAfter.length > 0,\n};\n\nexport enum ListFilterId {\n  Running = 'Running',\n  Failed = 'Failed',\n  Succeeded = 'Succeeded',\n  Cancelled = 'Cancelled',\n  Other = '-',\n}\n\nexport const ListFilterLabels = {\n  [ListFilterId.Running]: 'Running',\n  [ListFilterId.Failed]: 'Failed',\n  [ListFilterId.Succeeded]: 'Complete',\n  [ListFilterId.Cancelled]: 'Cancelled',\n  [ListFilterId.Other]: 'Other',\n};\n\n// to be used by both Pipeline and Pipelinerun visualisation\nconst sortTasksByRunAfterAndFrom = (\n  tasks: PipelineVisualizationTaskItem[],\n): PipelineVisualizationTaskItem[] => {\n  // check and sort tasks by 'runAfter' and 'from' dependency\n  const output = tasks;\n  for (let i = 0; i < output.length; i++) {\n    let flag = -1;\n    if (conditions.hasRunAfterDependency(output[i])) {\n      for (let j = 0; j < output.length; j++) {\n        if (i < j && output[j].taskRef.name === output[i].runAfter[output[i].runAfter.length - 1]) {\n          flag = j;\n        }\n      }\n    } else if (conditions.hasFromDependency(output[i])) {\n      for (let j = i + 1; j < output.length; j++) {\n        if (output[j].taskRef.name === output[i].resources.inputs[0].from[0]) {\n          flag = j;\n        }\n      }\n    }\n    if (flag > -1) {\n      // swap with last matching task\n      const temp = output[flag];\n      output[flag] = output[i];\n      output[i] = temp;\n    }\n  }\n  return output;\n};\n\n/**\n * Appends the pipeline run status to each tasks in the pipeline.\n * @param pipeline\n * @param pipelineRun\n */\nconst appendPipelineRunStatus = (pipeline, pipelineRun) => {\n  return _.map(pipeline.spec.tasks, (task) => {\n    if (!pipelineRun.status) {\n      return task;\n    }\n    if (pipelineRun.status && !pipelineRun.status.taskRuns && !pipelineRun.status.runs) {\n      return _.merge(task, { status: { reason: runStatus.Failed } });\n    }\n    const mTask = _.merge(task, {\n      status: _.get(_.find(pipelineRun.status.taskRuns, { pipelineTaskName: task.name }) || _.find(pipelineRun.status.runs, { pipelineTaskName: task.name }), 'status'),\n    });\n    // append task duration\n    if (mTask.status && mTask.status.completionTime && mTask.status.startTime) {\n      const date =\n        new Date(mTask.status.completionTime).getTime() -\n        new Date(mTask.status.startTime).getTime();\n      mTask.status.duration = formatDuration(date);\n    }\n    // append task status\n    if (!mTask.status) {\n      mTask.status = { reason: runStatus.Idle };\n    } else if (mTask.status && mTask.status.conditions) {\n      mTask.status.reason = pipelineRunStatus(mTask) || runStatus.Idle;\n    }\n    return mTask;\n  });\n};\n\nexport const getPipelineTasks = (\n  pipeline: K8sResourceKind,\n  pipelineRun: K8sResourceKind = {\n    apiVersion: '',\n    metadata: {},\n    kind: 'PipelineRun',\n  },\n): PipelineVisualizationTaskItem[][] => {\n  // Each unit in 'out' array is termed as stage | out = [stage1 = [task1], stage2 = [task2,task3], stage3 = [task4]]\n  const out = [];\n  if (!pipeline.spec || !pipeline.spec.tasks) {\n    return out;\n  }\n  const taskList = appendPipelineRunStatus(pipeline, pipelineRun);\n  // Step 1: Sort Tasks to get in correct order\n  const tasks = sortTasksByRunAfterAndFrom(taskList);\n\n  // Step 2: Push all nodes without any dependencies in different stages\n  tasks.forEach((task) => {\n    if (!conditions.hasFromDependency(task) && !conditions.hasRunAfterDependency(task)) {\n      if (out.length === 0) {\n        out.push([]);\n      }\n      out[0].push(task);\n    }\n  });\n\n  // Step 3: Push nodes with 'from' dependency and stack similar tasks in a stage\n  tasks.forEach((task) => {\n    if (!conditions.hasRunAfterDependency(task) && conditions.hasFromDependency(task)) {\n      let flag = out.length - 1;\n      for (let i = 0; i < out.length; i++) {\n        for (const t of out[i]) {\n          if (\n            t.taskRef.name === task.resources.inputs[0].from[0] ||\n            t.name === task.resources.inputs[0].from[0]\n          ) {\n            flag = i;\n          }\n        }\n      }\n      const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n      if (\n        nextToFlag &&\n        nextToFlag[0] &&\n        nextToFlag[0].resources &&\n        nextToFlag[0].resources.inputs &&\n        nextToFlag[0].resources.inputs[0] &&\n        nextToFlag[0].resources.inputs[0].from &&\n        nextToFlag[0].resources.inputs[0].from[0] &&\n        nextToFlag[0].resources.inputs[0].from[0] === task.resources.inputs[0].from[0]\n      ) {\n        nextToFlag.push(task);\n      } else {\n        out.splice(flag + 1, 0, [task]);\n      }\n    }\n  });\n\n  // Step 4: Push nodes with 'runAfter' dependencies and stack similar tasks in a stage\n  tasks.forEach((task) => {\n    if (conditions.hasRunAfterDependency(task)) {\n      let flag = out.length - 1;\n      for (let i = 0; i < out.length; i++) {\n        for (const t of out[i]) {\n          if (t.taskRef.name === task.runAfter[0] || t.name === task.runAfter[0]) {\n            flag = i;\n          }\n        }\n      }\n      const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n      if (\n        nextToFlag &&\n        nextToFlag[0].runAfter &&\n        nextToFlag[0].runAfter[0] &&\n        nextToFlag[0].runAfter[0] === task.runAfter[0]\n      ) {\n        nextToFlag.push(task);\n      } else {\n        out.splice(flag + 1, 0, [task]);\n      }\n    }\n  });\n  return out;\n};\n\nexport const containerToLogSourceStatus = (container: ContainerStatus): string => {\n  if (!container) {\n    return LOG_SOURCE_WAITING;\n  }\n  const { state, lastState } = container;\n  if (state.waiting && !_.isEmpty(lastState)) {\n    return LOG_SOURCE_RESTARTING;\n  }\n  if (state.waiting) {\n    return LOG_SOURCE_WAITING;\n  }\n  if (state.terminated) {\n    return LOG_SOURCE_TERMINATED;\n  }\n  return LOG_SOURCE_RUNNING;\n};\n\ntype CurrentPipelineStatus = {\n  currentPipeline: Pipeline;\n  status: string;\n};\n\n/**\n * Takes a pipeline and a series of matching pipeline runs and produces a current pipeline state.\n */\nexport const constructCurrentPipeline = (\n  pipeline: Pipeline,\n  pipelineRuns: PipelineRun[],\n): CurrentPipelineStatus => {\n  if (!pipeline || !pipelineRuns || pipelineRuns.length === 0) {\n    // Not enough data to build the current state\n    return null;\n  }\n\n  const latestRun = getLatestRun({ data: pipelineRuns }, 'creationTimestamp');\n\n  if (!latestRun) {\n    // Without the latestRun we will not have progress to show\n    return null;\n  }\n\n  const currentPipeline: Pipeline = {\n    ...pipeline,\n    latestRun,\n  };\n\n  let status: string = pipelineFilterReducer(currentPipeline);\n  if (status === '-') {\n    status = runStatus.Pending;\n  }\n\n  return {\n    currentPipeline,\n    status,\n  };\n};\n\nexport const getPipelineRunParams = (pipelineParams: PipelineParam[]): PipelineRunParam[] => {\n  return (\n    pipelineParams &&\n    pipelineParams.map((param) => ({\n      name: param.name,\n      value: param.default,\n    }))\n  );\n};\n\nexport const getPipelineRunWorkspaces = (\n  pipelineWorkspaces: PipelineWorkspace[],\n): PipelineRunWorkspace[] => {\n  return (\n    pipelineWorkspaces &&\n    pipelineWorkspaces.map((workspace) => ({\n      name: workspace.name,\n      ...workspace.data,\n    }))\n  );\n};\n\nexport const calculateRelativeTime = (startTime: string, completionTime?: string) => {\n  const start = new Date(startTime).getTime();\n  const end = completionTime ? new Date(completionTime).getTime() : new Date().getTime();\n  const secondsAgo = (end - start) / 1000;\n  const minutesAgo = secondsAgo / 60;\n  const hoursAgo = minutesAgo / 60;\n\n  if (minutesAgo > 90) {\n    const count = Math.round(hoursAgo);\n    return `about ${count} hours`;\n  }\n  if (minutesAgo > 45) {\n    return 'about an hour';\n  }\n  if (secondsAgo > 90) {\n    const count = Math.round(minutesAgo);\n    return `about ${count} minutes`;\n  }\n  if (secondsAgo > 45) {\n    return 'about a minute';\n  }\n  return 'a few seconds';\n};\n\nexport const pipelineRunDuration = (run: PipelineRun): string => {\n  const startTime = _.get(run, ['status', 'startTime'], null);\n  const completionTime = _.get(run, ['status', 'completionTime'], null);\n\n  // Duration cannot be computed if start time is missing or a completed/failed pipeline has no end time\n  if (!startTime || (!completionTime && pipelineRunStatus(run) !== 'Running')) {\n    return '-';\n  }\n  return calculateRelativeTime(startTime, completionTime);\n};\n\nexport const updateServiceAccount = (\n  secretName: string,\n  originalServiceAccount: ServiceAccountType,\n): Promise<ServiceAccountType> => {\n  const updatedServiceAccount = _.cloneDeep(originalServiceAccount);\n  updatedServiceAccount.secrets = [...updatedServiceAccount.secrets, { name: secretName }];\n  return k8sUpdate(ServiceAccountModel, updatedServiceAccount);\n};\n\nexport const associateServiceAccountToSecret = (secret: SecretKind, namespace: string) => {\n  k8sGet(ServiceAccountModel, PIPELINE_SERVICE_ACCOUNT, namespace)\n    .then((serviceAccount) => {\n      if (_.find(serviceAccount.secrets, (s) => s.name === secret.metadata.name) === undefined) {\n        updateServiceAccount(secret.metadata.name, serviceAccount);\n      }\n    })\n    .catch((err) => {\n      errorModal({ error: err.message });\n    });\n};\n\ntype KeyValuePair = {\n  key: string;\n  value: string;\n};\nexport const getSecretAnnotations = (annotation: KeyValuePair) => {\n  const annotations = {};\n  const annotationPrefix = 'tekton.dev';\n  if (annotation?.key === SecretAnnotationId.Git) {\n    annotations[`${annotationPrefix}/${SecretAnnotationId.Git}-0`] = annotation?.value;\n  } else if (annotation?.key === SecretAnnotationId.Image) {\n    annotations[`${annotationPrefix}/${SecretAnnotationId.Image}-0`] = annotation?.value;\n  }\n  return annotations;\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAOA;AAgPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAIA;AACA;AAEA;;;;;;;;;;;;;AC9bA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;AC/CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AAMA;AACA;AACA;AACA;AAWA;AAwBA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}