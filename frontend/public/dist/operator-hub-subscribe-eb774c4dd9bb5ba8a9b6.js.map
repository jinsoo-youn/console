{"version":3,"file":"operator-hub-subscribe-eb774c4dd9bb5ba8a9b6.js","sources":["webpack:///./packages/operator-lifecycle-manager/src/components/operator-hub/operator-hub-subscribe.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport { Helmet } from 'react-helmet';\nimport { match } from 'react-router';\nimport { ActionGroup, Alert, Button, Checkbox, Tooltip } from '@patternfly/react-core';\nimport {\n  Dropdown,\n  ExternalLink,\n  Firehose,\n  history,\n  NsDropdown,\n  openshiftHelpBase,\n  BreadCrumbs,\n  MsgBox,\n  StatusBox,\n  ResourceIcon,\n  ResourceName,\n  resourceListPathFromModel,\n} from '@console/internal/components/utils';\nimport {\n  K8sResourceCommon,\n  apiVersionForModel,\n  apiVersionForReference,\n  k8sCreate,\n  k8sGet,\n  k8sListPartialMetadata,\n  kindForReference,\n  referenceForModel,\n} from '@console/internal/module/k8s';\nimport { RadioGroup, RadioInput } from '@console/internal/components/radio';\nimport { fromRequirements } from '@console/internal/module/k8s/selector';\nimport {\n  SubscriptionModel,\n  OperatorGroupModel,\n  PackageManifestModel,\n  ClusterServiceVersionModel,\n} from '../../models';\nimport { NamespaceModel, RoleBindingModel, RoleModel } from '@console/internal/models';\nimport {\n  OperatorGroupKind,\n  PackageManifestKind,\n  SubscriptionKind,\n  InstallPlanApproval,\n  InstallModeType,\n} from '../../types';\nimport {\n  defaultChannelFor,\n  supportedInstallModesFor,\n  ClusterServiceVersionLogo,\n  providedAPIsForChannel,\n  referenceForProvidedAPI,\n  iconFor,\n} from '../index';\nimport { installedFor, supports, providedAPIsFor, isGlobal } from '../operator-group';\nimport { CRDCard } from '../clusterserviceversion';\nimport { getInternalObjects, isInternalObject } from '../../utils';\n\nexport const OperatorHubSubscribeForm: React.FC<OperatorHubSubscribeFormProps> = (props) => {\n  const [targetNamespace, setTargetNamespace] = React.useState(null);\n  const [installMode, setInstallMode] = React.useState(null);\n  const [updateChannel, setUpdateChannel] = React.useState(null);\n  const [approval, setApproval] = React.useState(InstallPlanApproval.Automatic);\n  const [cannotResolve, setCannotResolve] = React.useState(false);\n  const [suggestedNamespaceExists, setSuggestedNamespaceExists] = React.useState(false);\n  const [\n    useSuggestedNSForSingleInstallMode,\n    setUseSuggestedNSForSingleInstallMode,\n  ] = React.useState(true);\n  const [enableMonitoring, setEnableMonitoring] = React.useState(false);\n  const [error, setError] = React.useState('');\n\n  const { name: pkgName } = props.packageManifest.data[0].metadata;\n  const {\n    provider,\n    channels = [],\n    packageName,\n    catalogSource,\n    catalogSourceNamespace,\n  } = props.packageManifest.data[0].status;\n\n  const selectedUpdateChannel = updateChannel || defaultChannelFor(props.packageManifest.data[0]);\n  const selectedInstallMode =\n    installMode ||\n    supportedInstallModesFor(props.packageManifest.data[0])(selectedUpdateChannel).reduce(\n      (preferredInstallMode, mode) =>\n        mode.type === InstallModeType.InstallModeTypeAllNamespaces\n          ? InstallModeType.InstallModeTypeAllNamespaces\n          : preferredInstallMode,\n      InstallModeType.InstallModeTypeOwnNamespace,\n    );\n\n  const { currentCSVDesc } = channels.find((ch) => ch.name === selectedUpdateChannel);\n  const { installModes = [] } = currentCSVDesc;\n  const suggestedNamespace =\n    currentCSVDesc.annotations?.['operatorframework.io/suggested-namespace'];\n  const operatorRequestsMonitoring =\n    currentCSVDesc.annotations?.['operatorframework.io/cluster-monitoring'] === 'true';\n  const internalObjects = getInternalObjects(currentCSVDesc, 'annotations');\n\n  const globalNS =\n    (props.operatorGroup?.data || ([] as OperatorGroupKind[])).find(\n      (og) => og.metadata.name === 'global-operators',\n    )?.metadata?.namespace || 'openshift-operators';\n  const items = {\n    [globalNS]: <ResourceName kind=\"Project\" name={globalNS} />,\n  };\n\n  let selectedTargetNamespace = targetNamespace || props.targetNamespace;\n  if (selectedInstallMode === InstallModeType.InstallModeTypeAllNamespaces) {\n    if (suggestedNamespace) {\n      items[suggestedNamespace] = (\n        <ResourceName kind=\"Project\" name={`${suggestedNamespace} (Operator recommended)`} />\n      );\n      selectedTargetNamespace = targetNamespace || suggestedNamespace;\n    } else {\n      selectedTargetNamespace = globalNS;\n    }\n  }\n  const isSuggestedNamespaceSelected =\n    suggestedNamespace && suggestedNamespace === selectedTargetNamespace;\n  const selectedApproval = approval || InstallPlanApproval.Automatic;\n\n  React.useEffect(() => {\n    if (!suggestedNamespace) {\n      return;\n    }\n    setTargetNamespace(suggestedNamespace);\n    k8sGet(NamespaceModel, suggestedNamespace)\n      .then(() => setSuggestedNamespaceExists(true))\n      .catch(() => setSuggestedNamespaceExists(false));\n  }, [suggestedNamespace]);\n\n  React.useEffect(() => {\n    k8sListPartialMetadata(PackageManifestModel, {\n      ns: selectedTargetNamespace,\n      fieldSelector: `metadata.name=${pkgName}`,\n      labelSelector: fromRequirements([\n        { key: 'catalog', operator: 'Equals', values: [catalogSource] },\n        { key: 'catalog-namespace', operator: 'Equals', values: [catalogSourceNamespace] },\n      ]),\n    })\n      .then((list) => setCannotResolve(_.isEmpty(list)))\n      .catch(() => setCannotResolve(true));\n  }, [\n    catalogSource,\n    catalogSourceNamespace,\n    pkgName,\n    props.packageManifest.data,\n    selectedTargetNamespace,\n  ]);\n\n  const singleInstallMode = installModes.find(\n    (m) => m.type === InstallModeType.InstallModeTypeOwnNamespace,\n  );\n  const supportsSingle = singleInstallMode && singleInstallMode.supported;\n  const globalInstallMode = installModes.find(\n    (m) => m.type === InstallModeType.InstallModeTypeAllNamespaces,\n  );\n  const supportsGlobal = globalInstallMode && globalInstallMode.supported;\n\n  if (!supportsSingle && !supportsGlobal) {\n    return (\n      <MsgBox\n        title={`${_.get(channels, '[0].currentCSVDesc.displayName')} can't be installed`}\n        detail=\"The operator does not support single namespace or global installation modes.\"\n      />\n    );\n  }\n\n  const descFor = (mode: InstallModeType) => {\n    if (mode === InstallModeType.InstallModeTypeAllNamespaces && supportsGlobal) {\n      return 'Operator will be available in all namespaces.';\n    }\n    if (mode === InstallModeType.InstallModeTypeOwnNamespace && supportsSingle) {\n      return 'Operator will be available in a single namespace only.';\n    }\n    return 'This mode is not supported by this Operator';\n  };\n  const subscriptionExists = (ns: string) =>\n    installedFor(props.subscription.data)(props.operatorGroup.data)(\n      props.packageManifest.data[0].status.packageName,\n    )(ns);\n  const namespaceSupports = (ns: string) => (mode: InstallModeType) => {\n    const operatorGroup = props.operatorGroup.data.find((og) => og.metadata.namespace === ns);\n    if (!operatorGroup || !ns) {\n      return true;\n    }\n    return supports([{ type: mode, supported: true }])(operatorGroup);\n  };\n  const conflictingProvidedAPIs = (ns: string) => {\n    const operatorGroups = props.operatorGroup.data.filter(\n      (og) => og.status.namespaces.includes(ns) || isGlobal(og),\n    );\n    if (_.isEmpty(operatorGroups)) {\n      return [];\n    }\n    const existingAPIs = _.flatMap(operatorGroups, providedAPIsFor);\n    const providedAPIs = providedAPIsForChannel(props.packageManifest.data[0])(\n      selectedUpdateChannel,\n    ).map((desc) => referenceForProvidedAPI(desc));\n\n    return _.intersection(existingAPIs, providedAPIs);\n  };\n\n  const submit = async () => {\n    // Clear any previous errors.\n    setError('');\n\n    const ns: K8sResourceCommon = {\n      metadata: {\n        name: selectedTargetNamespace,\n        labels:\n          operatorRequestsMonitoring && enableMonitoring\n            ? {\n                'openshift.io/cluster-monitoring': 'true',\n              }\n            : {},\n      },\n    };\n\n    const rbacName = `${selectedTargetNamespace}-prometheus`;\n    const prometheusRole = {\n      kind: RoleModel.kind,\n      apiVersion: `${RoleModel.apiGroup}/${RoleModel.apiVersion}`,\n      metadata: {\n        name: rbacName,\n        namespace: selectedTargetNamespace,\n      },\n      rules: [\n        {\n          apiGroups: [''],\n          resources: ['services', 'endpoints', 'pods'],\n          verbs: ['get', 'list', 'watch'],\n        },\n      ],\n    };\n\n    const prometheusRoleBinding = {\n      kind: RoleBindingModel.kind,\n      apiVersion: `${RoleBindingModel.apiGroup}/${RoleBindingModel.apiVersion}`,\n      metadata: {\n        name: rbacName,\n        namespace: selectedTargetNamespace,\n      },\n      roleRef: {\n        kind: 'Role',\n        name: rbacName,\n        apiGroup: RoleBindingModel.apiGroup,\n      },\n      subjects: [\n        {\n          kind: 'ServiceAccount',\n          name: 'prometheus-operator',\n          namespace: 'openshift-monitoring',\n        },\n      ],\n    };\n\n    const operatorGroup: OperatorGroupKind = {\n      apiVersion: apiVersionForModel(OperatorGroupModel) as OperatorGroupKind['apiVersion'],\n      kind: 'OperatorGroup',\n      metadata: {\n        generateName: `${selectedTargetNamespace}-`,\n        namespace: selectedTargetNamespace,\n      },\n      ...(selectedInstallMode === InstallModeType.InstallModeTypeAllNamespaces\n        ? {}\n        : {\n            spec: {\n              targetNamespaces: [selectedTargetNamespace],\n            },\n          }),\n    };\n\n    const subscription: SubscriptionKind = {\n      apiVersion: apiVersionForModel(SubscriptionModel) as SubscriptionKind['apiVersion'],\n      kind: 'Subscription',\n      metadata: {\n        name: packageName,\n        namespace: selectedTargetNamespace,\n      },\n      spec: {\n        source: catalogSource,\n        sourceNamespace: catalogSourceNamespace,\n        name: packageName,\n        startingCSV: channels.find((ch) => ch.name === selectedUpdateChannel).currentCSV,\n        channel: selectedUpdateChannel,\n        installPlanApproval: selectedApproval,\n      },\n    };\n\n    try {\n      if (isSuggestedNamespaceSelected && !suggestedNamespaceExists) {\n        await k8sCreate(NamespaceModel, ns);\n        if (operatorRequestsMonitoring && enableMonitoring) {\n          await k8sCreate(RoleModel, prometheusRole);\n          await k8sCreate(RoleBindingModel, prometheusRoleBinding);\n        }\n      }\n      if (\n        !props.operatorGroup.data.some(\n          (group) => group.metadata.namespace === selectedTargetNamespace,\n        )\n      ) {\n        await k8sCreate(OperatorGroupModel, operatorGroup);\n      }\n      await k8sCreate(SubscriptionModel, subscription);\n      history.push(\n        resourceListPathFromModel(\n          ClusterServiceVersionModel,\n          targetNamespace || props.targetNamespace || selectedTargetNamespace,\n        ),\n      );\n    } catch (err) {\n      setError(err.message || 'Could not create operator subscription.');\n    }\n  };\n\n  const formValid = () =>\n    [selectedUpdateChannel, selectedInstallMode, selectedTargetNamespace, selectedApproval].some(\n      (v) => _.isNil(v) || _.isEmpty(v),\n    ) ||\n    subscriptionExists(selectedTargetNamespace) ||\n    !namespaceSupports(selectedTargetNamespace)(selectedInstallMode) ||\n    (selectedTargetNamespace && cannotResolve) ||\n    !_.isEmpty(conflictingProvidedAPIs(selectedTargetNamespace));\n\n  const formError = () => {\n    return (\n      (error && (\n        <Alert\n          isInline\n          className=\"co-alert co-alert--scrollable\"\n          variant=\"danger\"\n          title=\"An error occurred\"\n        >\n          <div className=\"co-pre-line\">{error}</div>\n        </Alert>\n      )) ||\n      (!namespaceSupports(selectedTargetNamespace)(selectedInstallMode) && (\n        <Alert\n          isInline\n          className=\"co-alert\"\n          variant=\"danger\"\n          title=\"Namespace does not support installation mode\"\n        >\n          The operator group in the {selectedTargetNamespace} namespace does not support the\n          {selectedInstallMode === InstallModeType.InstallModeTypeAllNamespaces\n            ? ' global '\n            : ' single namespace '}\n          installation mode.\n        </Alert>\n      )) ||\n      (subscriptionExists(selectedTargetNamespace) && (\n        <Alert\n          isInline\n          className=\"co-alert\"\n          variant=\"danger\"\n          title={`Operator subscription for namespace '${selectedTargetNamespace}' already exists`}\n        />\n      )) ||\n      (!_.isEmpty(conflictingProvidedAPIs(selectedTargetNamespace)) && (\n        <Alert isInline className=\"co-alert\" variant=\"danger\" title=\"Operator conflicts exist\">\n          Installing Operator in selected namespace would cause conflicts with another Operator\n          providing these APIs:\n          <ul>\n            {conflictingProvidedAPIs(selectedTargetNamespace).map((gvk) => (\n              <li key={gvk}>\n                <strong>{kindForReference(gvk)}</strong> <i>({apiVersionForReference(gvk)})</i>\n              </li>\n            ))}\n          </ul>\n        </Alert>\n      )) ||\n      (selectedTargetNamespace && cannotResolve && (\n        <Alert\n          isInline\n          className=\"co-alert\"\n          variant=\"danger\"\n          title=\"Operator not available for selected namespaces\"\n        />\n      ))\n    );\n  };\n\n  const showMonitoringCheckbox =\n    operatorRequestsMonitoring && _.startsWith(selectedTargetNamespace, 'openshift-');\n\n  const suggestedNamespaceDetails = isSuggestedNamespaceSelected && (\n    <>\n      <Alert\n        isInline\n        className=\"co-alert co-alert--scrollable\"\n        variant={suggestedNamespaceExists ? 'warning' : 'info'}\n        title={suggestedNamespaceExists ? 'Namespace already exists' : 'Namespace creation'}\n      >\n        {suggestedNamespaceExists ? (\n          <>\n            Namespace <b>{suggestedNamespace}</b> already exists and will be used. Other users can\n            already have access to this namespace.\n          </>\n        ) : (\n          <>\n            Namespace <b>{suggestedNamespace}</b> does not exist and will be created.\n          </>\n        )}\n      </Alert>\n      {showMonitoringCheckbox && !suggestedNamespaceExists && (\n        <div className=\"co-form-subsection\">\n          <Checkbox\n            id=\"enable-monitoring-checkbox\"\n            label=\"Enable operator recommended cluster monitoring on this namespace\"\n            onChange={setEnableMonitoring}\n            isChecked={enableMonitoring}\n          />\n          {props.packageManifest.data[0].metadata.labels['opsrc-provider'] !== 'redhat' && (\n            <Alert\n              isInline\n              className=\"co-alert pf-c-alert--top-margin\"\n              variant=\"warning\"\n              title=\"Namespace monitoring\"\n            >\n              Please note that installing non Red Hat operators into openshift namespaces and\n              enabling monitoring voids user support. Enabling cluster monitoring for non Red Hat\n              operators can lead to malicious metrics data overriding existing cluster metrics. For\n              more information, see the{' '}\n              <ExternalLink\n                href={`${openshiftHelpBase}monitoring/cluster_monitoring/configuring-the-monitoring-stack.html#maintenance-and-support_configuring-monitoring`}\n                text=\"cluster monitoring documentation\"\n              />{' '}\n              .\n            </Alert>\n          )}\n        </div>\n      )}\n    </>\n  );\n\n  const globalNamespaceInstallMode = (\n    <>\n      <div className=\"form-group\">\n        <Dropdown\n          id=\"dropdown-selectbox\"\n          dropDownClassName=\"dropdown--full-width\"\n          menuClassName=\"dropdown-menu--text-wrap\"\n          items={items}\n          title={\n            <ResourceName\n              kind=\"Project\"\n              name={\n                isSuggestedNamespaceSelected\n                  ? `${selectedTargetNamespace} (Operator recommended)`\n                  : selectedTargetNamespace\n              }\n            />\n          }\n          disabled={_.size(items) === 1}\n          selectedKey={selectedTargetNamespace}\n          onChange={(ns: string) => {\n            setTargetNamespace(ns);\n            setCannotResolve(false);\n          }}\n        />\n      </div>\n      {suggestedNamespaceDetails}\n    </>\n  );\n\n  const singleNamespaceInstallMode = !suggestedNamespace ? (\n    <NsDropdown\n      id=\"dropdown-selectbox\"\n      selectedKey={selectedTargetNamespace}\n      onChange={setTargetNamespace}\n    />\n  ) : (\n    <div className=\"form-group\">\n      <RadioInput\n        onChange={() => {\n          setUseSuggestedNSForSingleInstallMode(true);\n          setTargetNamespace(suggestedNamespace);\n        }}\n        value={suggestedNamespace}\n        checked={useSuggestedNSForSingleInstallMode}\n        title=\"Operator recommended namespace:\"\n      >\n        {' '}\n        <ResourceIcon kind=\"Project\" />\n        <b>{suggestedNamespace}</b>\n      </RadioInput>\n      {useSuggestedNSForSingleInstallMode && suggestedNamespaceDetails}\n      <RadioInput\n        onChange={() => {\n          setUseSuggestedNSForSingleInstallMode(false);\n          setTargetNamespace(null);\n        }}\n        value={suggestedNamespace}\n        checked={!useSuggestedNSForSingleInstallMode}\n        title=\"Pick an existing namespace\"\n      />\n      {!useSuggestedNSForSingleInstallMode && (\n        <NsDropdown\n          id=\"dropdown-selectbox\"\n          selectedKey={selectedTargetNamespace}\n          onChange={setTargetNamespace}\n        />\n      )}\n    </div>\n  );\n\n  const providedAPIs = providedAPIsForChannel(props.packageManifest.data[0])(\n    selectedUpdateChannel,\n  ).filter((item) => !isInternalObject(internalObjects, item.name));\n\n  return (\n    <div className=\"row\">\n      <div className=\"col-xs-6\">\n        <>\n          <div className=\"form-group\">\n            <Tooltip content=\"The channel to track and receive the updates from.\">\n              <h5 className=\"co-required\">Update Channel</h5>\n            </Tooltip>\n            <RadioGroup\n              currentValue={selectedUpdateChannel}\n              items={channels.map((ch) => ({ value: ch.name, title: ch.name }))}\n              onChange={(e) => {\n                setUpdateChannel(e.currentTarget.value);\n                setInstallMode(null);\n              }}\n            />\n          </div>\n          <div className=\"form-group\">\n            <h5 className=\"co-required\">Installation Mode</h5>\n            <div>\n              <RadioInput\n                onChange={(e) => {\n                  setInstallMode(e.target.value);\n                  setTargetNamespace(null);\n                  setCannotResolve(false);\n                }}\n                value={InstallModeType.InstallModeTypeAllNamespaces}\n                checked={selectedInstallMode === InstallModeType.InstallModeTypeAllNamespaces}\n                disabled={!supportsGlobal}\n                title=\"All namespaces on the cluster\"\n                subTitle=\"(default)\"\n              >\n                <div className=\"co-m-radio-desc\">\n                  <p className=\"text-muted\">\n                    {descFor(InstallModeType.InstallModeTypeAllNamespaces)}\n                  </p>\n                </div>\n              </RadioInput>\n            </div>\n            <div>\n              <RadioInput\n                onChange={(e) => {\n                  setInstallMode(e.target.value);\n                  setTargetNamespace(\n                    useSuggestedNSForSingleInstallMode ? suggestedNamespace : null,\n                  );\n                  setCannotResolve(false);\n                }}\n                value={InstallModeType.InstallModeTypeOwnNamespace}\n                checked={selectedInstallMode === InstallModeType.InstallModeTypeOwnNamespace}\n                disabled={!supportsSingle}\n                title=\"A specific namespace on the cluster\"\n              >\n                <div className=\"co-m-radio-desc\">\n                  <p className=\"text-muted\">\n                    {descFor(InstallModeType.InstallModeTypeOwnNamespace)}\n                  </p>\n                </div>\n              </RadioInput>\n            </div>\n          </div>\n          <div className=\"form-group\">\n            <h5 className=\"co-required\">Installed Namespace</h5>\n            {selectedInstallMode === InstallModeType.InstallModeTypeAllNamespaces &&\n              globalNamespaceInstallMode}\n            {selectedInstallMode === InstallModeType.InstallModeTypeOwnNamespace &&\n              singleNamespaceInstallMode}\n          </div>\n          <div className=\"form-group\">\n            <Tooltip content=\"The strategy to determine either manual or automatic updates.\">\n              <h5 className=\"co-required\">Approval Strategy</h5>\n            </Tooltip>\n            <RadioGroup\n              currentValue={selectedApproval}\n              items={[\n                { value: InstallPlanApproval.Automatic, title: 'Automatic' },\n                { value: InstallPlanApproval.Manual, title: 'Manual' },\n              ]}\n              onChange={(e) => setApproval(e.currentTarget.value)}\n            />\n          </div>\n        </>\n        <div className=\"co-form-section__separator\" />\n        {formError()}\n        <ActionGroup className=\"pf-c-form\">\n          <Button onClick={() => submit()} isDisabled={formValid()} variant=\"primary\">\n            Install\n          </Button>\n          <Button variant=\"secondary\" onClick={() => history.push('/operatorhub')}>\n            Cancel\n          </Button>\n        </ActionGroup>\n      </div>\n      <div className=\"col-xs-6\">\n        <ClusterServiceVersionLogo\n          displayName={_.get(channels, '[0].currentCSVDesc.displayName')}\n          icon={iconFor(props.packageManifest.data[0])}\n          provider={provider}\n        />\n        <h4>Provided APIs</h4>\n        <div className=\"co-crd-card-row\">\n          {!providedAPIs.length ? (\n            <span className=\"text-muted\">No Kubernetes APIs are provided by this Operator.</span>\n          ) : (\n            providedAPIs.map((api) => (\n              <CRDCard key={referenceForProvidedAPI(api)} canCreate={false} crd={api} csv={null} />\n            ))\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\nconst OperatorHubSubscribe: React.FC<OperatorHubSubscribeFormProps> = (props) => (\n  <StatusBox data={props.packageManifest.data[0]} loaded={props.loaded} loadError={props.loadError}>\n    <OperatorHubSubscribeForm {...props} />\n  </StatusBox>\n);\n\nexport const OperatorHubSubscribePage: React.SFC<OperatorHubSubscribePageProps> = (props) => {\n  const search = new URLSearchParams({\n    'details-item': `${new URLSearchParams(window.location.search).get(\n      'pkg',\n    )}-${new URLSearchParams(window.location.search).get('catalogNamespace')}`,\n  });\n\n  return (\n    <>\n      <Helmet>\n        <title>Operator Installation</title>\n      </Helmet>\n      <div className=\"co-m-nav-title co-m-nav-title--breadcrumbs\">\n        <BreadCrumbs\n          breadcrumbs={[\n            { name: 'OperatorHub', path: `/operatorhub?${search.toString()}` },\n            { name: 'Operator Installation', path: props.match.url },\n          ]}\n        />\n        <h1 className=\"co-m-pane__heading\">Install Operator</h1>\n        <p className=\"co-help-text\">\n          Install your Operator by subscribing to one of the update channels to keep the Operator up\n          to date. The strategy determines either manual or automatic updates.\n        </p>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <Firehose\n          resources={[\n            {\n              isList: true,\n              kind: referenceForModel(OperatorGroupModel),\n              prop: 'operatorGroup',\n            },\n            {\n              isList: true,\n              kind: referenceForModel(PackageManifestModel),\n              namespace: new URLSearchParams(window.location.search).get('catalogNamespace'),\n              fieldSelector: `metadata.name=${new URLSearchParams(window.location.search).get(\n                'pkg',\n              )}`,\n              selector: {\n                matchLabels: {\n                  catalog: new URLSearchParams(window.location.search).get('catalog'),\n                },\n              },\n              prop: 'packageManifest',\n            },\n            {\n              isList: true,\n              kind: referenceForModel(SubscriptionModel),\n              prop: 'subscription',\n            },\n          ]}\n        >\n          {/* FIXME(alecmerdler): Hack because `Firehose` injects props without TypeScript knowing about it */}\n          <OperatorHubSubscribe\n            {...(props as any)}\n            targetNamespace={\n              new URLSearchParams(window.location.search).get('targetNamespace') || null\n            }\n          />\n        </Firehose>\n      </div>\n    </>\n  );\n};\n\nexport type OperatorHubSubscribeFormProps = {\n  loaded: boolean;\n  loadError?: any;\n  namespace: string;\n  targetNamespace?: string;\n  operatorGroup: { loaded: boolean; data: OperatorGroupKind[] };\n  packageManifest: { loaded: boolean; data: PackageManifestKind[] };\n  subscription: { loaded: boolean; data: SubscriptionKind[] };\n};\n\nexport type OperatorHubSubscribePageProps = {\n  match: match;\n};\n\nOperatorHubSubscribe.displayName = 'OperatorHubSubscribe';\nOperatorHubSubscribeForm.displayName = 'OperatorHubSubscribeForm';\nOperatorHubSubscribePage.displayName = 'OperatorHubSubscribePage';\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AAEA;AACA;AAcA;AAUA;AACA;AACA;AAMA;AACA;AAOA;AAQA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAQA;AACA;AAEA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AAEA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAGA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAQA;AAGA;;AAOA;;AACA;AACA;AACA;AAEA;AAEA;AAQA;;AAIA;AAGA;;AAAA;;AAAA;AAAA;AAMA;AASA;AAEA;AAGA;AAEA;;AAQA;AAEA;;AAGA;AACA;AAGA;AAEA;AAMA;;AAUA;AACA;AAGA;AAEA;AAOA;AAEA;AACA;AAUA;AACA;AAOA;AACA;AACA;AAGA;AAIA;AAQA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AAUA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAOA;AACA;AAMA;AACA;AAEA;AACA;AAGA;AACA;AAMA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAKA;AACA;AACA;AACA;AAGA;AAKA;AACA;AAKA;AACA;AAYA;AAEA;AAEA;AAIA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAUA;AAgBA;AACA;AACA;;;;;A","sourceRoot":""}