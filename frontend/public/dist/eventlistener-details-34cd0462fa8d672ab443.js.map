{"version":3,"file":"eventlistener-details-34cd0462fa8d672ab443.js","sources":["webpack:///./packages/dev-console/src/components/pipelines/EventListenerPage.tsx","webpack:///./packages/dev-console/src/components/pipelines/detail-page-tabs/EventListenerDetails.tsx","webpack:///./packages/dev-console/src/components/pipelines/resource-overview/DynamicResourceLinkList.scss?7299","webpack:///./packages/dev-console/src/components/pipelines/resource-overview/DynamicResourceLinkList.tsx","webpack:///./packages/dev-console/src/components/pipelines/resource-overview/TriggerTemplateResourceLink.scss?915d","webpack:///./packages/dev-console/src/components/pipelines/resource-overview/TriggerTemplateResourceLink.tsx","webpack:///./packages/dev-console/src/components/pipelines/utils/triggers.ts","webpack:///./packages/dev-console/src/utils/pipeline-augment.ts","webpack:///./public/components/utils/k8s-get-hook.ts"],"sourcesContent":["import * as React from 'react';\nimport { DetailsPage, DetailsPageProps } from '@console/internal/components/factory';\nimport { Kebab, navFactory, viewYamlComponent } from '@console/internal/components/utils';\nimport EventListenerDetails from './detail-page-tabs/EventListenerDetails';\n\nconst EventListenerPage: React.FC<DetailsPageProps> = (props) => (\n  <DetailsPage\n    {...props}\n    menuActions={Kebab.factory.common}\n    pages={[navFactory.details(EventListenerDetails), navFactory.editYaml(viewYamlComponent)]}\n  />\n);\n\nexport default EventListenerPage;\n","import * as React from 'react';\nimport { SectionHeading, ResourceSummary } from '@console/internal/components/utils';\nimport { TriggerBindingModel, TriggerTemplateModel } from '../../../models';\nimport { EventListenerKind } from '../resource-types';\nimport DynamicResourceLinkList, {\n  ResourceModelLink,\n} from '../resource-overview/DynamicResourceLinkList';\nimport TriggerTemplateResourceLink from '../resource-overview/TriggerTemplateResourceLink';\nimport {\n  RouteTemplate,\n  useEventListenerTriggerTemplateNames,\n  getEventListenerTriggerBindingNames,\n} from '../utils/triggers';\n\nexport interface EventListenerDetailsProps {\n  obj: EventListenerKind;\n}\n\nconst EventListenerDetails: React.FC<EventListenerDetailsProps> = ({ obj: eventListener }) => {\n  const routeTemplates: RouteTemplate[] = useEventListenerTriggerTemplateNames(eventListener) || [];\n  const bindings: ResourceModelLink[] = getEventListenerTriggerBindingNames(eventListener);\n  return (\n    <div className=\"co-m-pane__body\">\n      <SectionHeading text=\"Event Listener Details\" />\n      <div className=\"row\">\n        <div className=\"col-sm-6\">\n          <ResourceSummary resource={eventListener} />\n        </div>\n        <div className=\"col-sm-6\">\n          <TriggerTemplateResourceLink\n            namespace={eventListener.metadata.namespace}\n            model={TriggerTemplateModel}\n            links={routeTemplates}\n          />\n          <DynamicResourceLinkList\n            links={bindings}\n            namespace={eventListener.metadata.namespace}\n            title={TriggerBindingModel.labelPlural}\n          />\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport default EventListenerDetails;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { ResourceLink } from '@console/internal/components/utils';\nimport { K8sKind, referenceForModel } from '@console/internal/module/k8s';\n\nimport './DynamicResourceLinkList.scss';\n\nexport type ResourceModelLink = {\n  model: K8sKind;\n  name: string;\n  displayName?: string;\n};\n\ntype DynamicResourceLinkListProps = {\n  links: ResourceModelLink[];\n  namespace: string;\n  title: string;\n};\n\nconst DynamicResourceLinkList: React.FC<DynamicResourceLinkListProps> = ({\n  links = [],\n  namespace,\n  title,\n}) => {\n  if (links.length === 0) {\n    return null;\n  }\n  return (\n    <div className=\"odc-dynamic-resource-link-list\">\n      <dl>\n        <dt>{title}</dt>\n        <dd>\n          {links.map(({ name, model, displayName = '' }) => {\n            const kind = referenceForModel(model);\n            let linkName = name;\n            if (displayName.length > 0 && name !== displayName) {\n              linkName += ` (${displayName})`;\n            }\n            return (\n              <div key={`${kind}/${name}`}>\n                <ResourceLink\n                  kind={kind}\n                  name={name}\n                  displayName={linkName}\n                  namespace={namespace}\n                  title={name}\n                  inline\n                />\n              </div>\n            );\n          })}\n        </dd>\n      </dl>\n    </div>\n  );\n};\n\nexport default DynamicResourceLinkList;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { ResourceLink, ExternalLink } from '@console/internal/components/utils';\nimport { K8sKind, referenceForModel } from '@console/internal/module/k8s';\nimport { RouteTemplate } from '../utils/triggers';\nimport './TriggerTemplateResourceLink.scss';\n\ntype TriggerTemplateResourceLinkProps = {\n  namespace: string;\n  model: K8sKind;\n  links: RouteTemplate[];\n};\nconst TriggerTemplateResourceLink: React.FC<TriggerTemplateResourceLinkProps> = ({\n  links = [],\n  namespace,\n  model,\n}) => {\n  const title = model.labelPlural;\n  const kind = referenceForModel(model);\n\n  if (links.length === 0) {\n    return null;\n  }\n  return (\n    <div className=\"odc-trigger-template-list\">\n      <dl>\n        <dt>{title}</dt>\n        {links.map(({ routeURL, triggerTemplateName }) => {\n          return (\n            <dd key={triggerTemplateName}>\n              <ResourceLink\n                kind={kind}\n                name={triggerTemplateName}\n                namespace={namespace}\n                title={triggerTemplateName}\n                inline\n              />\n              {routeURL && (\n                <div className=\"odc-trigger-template-list__url\">\n                  <ExternalLink href={routeURL} text={routeURL} />\n                </div>\n              )}\n            </dd>\n          );\n        })}\n      </dl>\n    </div>\n  );\n};\n\nexport default TriggerTemplateResourceLink;\n","import * as React from 'react';\nimport { flatten, mapValues } from 'lodash';\nimport { RouteModel } from '@console/internal/models';\nimport { getRouteWebURL } from '@console/internal/components/routes';\nimport { K8sResourceCommon, referenceForModel, RouteKind } from '@console/internal/module/k8s';\nimport { useK8sGet } from '@console/internal/components/utils/k8s-get-hook';\nimport {\n  useK8sWatchResource,\n  useK8sWatchResources,\n  WatchK8sResource,\n  WatchK8sResources,\n  WatchK8sResults,\n  WatchK8sResultsObject,\n} from '@console/internal/components/utils/k8s-watch-hook';\nimport { EventListenerModel, PipelineRunModel, TriggerTemplateModel } from '../../../models';\nimport { getResourceModelFromBindingKind, PipelineRun } from '../../../utils/pipeline-augment';\nimport {\n  EventListenerKind,\n  EventListenerKindTrigger,\n  TriggerBindingKind,\n  TriggerTemplateKind,\n} from '../resource-types';\nimport { ResourceModelLink } from '../resource-overview/DynamicResourceLinkList';\n\ntype RouteMap = { [generatedName: string]: RouteKind };\ntype TriggerTemplateMapping = { [key: string]: TriggerTemplateKind };\n\nconst getResourceName = (resource: K8sResourceCommon): string => resource.metadata.name;\nconst getEventListenerTemplateNames = (el: EventListenerKind): string[] =>\n  el.spec.triggers.map((elTrigger: EventListenerKindTrigger) => elTrigger.template.name);\nconst getEventListenerGeneratedName = (eventListener: EventListenerKind) =>\n  eventListener.status?.configuration.generatedName;\n\nconst useEventListenerRoutes = (\n  namespace: string,\n  eventListenerResources: EventListenerKind[],\n): RouteMap => {\n  const memoResources: WatchK8sResources<RouteMap> = React.useMemo(() => {\n    return (eventListenerResources || []).map(getEventListenerGeneratedName).reduce(\n      (acc, generatedName) => ({\n        ...acc,\n        [generatedName]: {\n          kind: RouteModel.kind,\n          name: generatedName,\n          namespace,\n          optional: true,\n        } as WatchK8sResource,\n      }),\n      {},\n    );\n  }, [namespace, eventListenerResources]);\n\n  const results: WatchK8sResults<RouteMap> = useK8sWatchResources<RouteMap>(memoResources);\n\n  return mapValues(results, (result: WatchK8sResultsObject<RouteKind>) => result.data);\n};\n\nconst useAllEventListeners = (namespace: string) => {\n  const eventListenerResource: WatchK8sResource = React.useMemo(\n    () => ({\n      kind: referenceForModel(EventListenerModel),\n      isList: true,\n      namespace,\n    }),\n    [namespace],\n  );\n  const [resources, eventListenerLoaded] = useK8sWatchResource<EventListenerKind[]>(\n    eventListenerResource,\n  );\n\n  return eventListenerLoaded ? resources : null;\n};\n\nexport type RouteTemplate = {\n  routeURL: string | null;\n  triggerTemplateName: string;\n};\n\nexport const usePipelineTriggerTemplateNames = (\n  pipelineName: string,\n  namespace: string,\n): RouteTemplate[] | null => {\n  const eventListenerResources = useAllEventListeners(namespace);\n  const triggerTemplateResources: WatchK8sResources<TriggerTemplateMapping> = React.useMemo(() => {\n    if (!eventListenerResources) {\n      return {};\n    }\n    return flatten(eventListenerResources.map(getEventListenerTemplateNames)).reduce(\n      (resourceMap, triggerTemplateName: string) => ({\n        ...resourceMap,\n        [triggerTemplateName]: {\n          kind: referenceForModel(TriggerTemplateModel),\n          name: triggerTemplateName,\n          namespace,\n          optional: true,\n        },\n      }),\n      {},\n    );\n  }, [namespace, eventListenerResources]);\n  const triggerTemplates: WatchK8sResults<TriggerTemplateMapping> = useK8sWatchResources(\n    triggerTemplateResources,\n  );\n  const routes: RouteMap = useEventListenerRoutes(namespace, eventListenerResources);\n\n  const triggerTemplateResults: WatchK8sResultsObject<TriggerTemplateKind>[] = Object.values(\n    triggerTemplates,\n  );\n  const countExpected = Object.keys(triggerTemplateResources).length;\n  const countLoaded = triggerTemplateResults.filter(({ loaded }) => loaded).length;\n  const countErrored = triggerTemplateResults.filter(({ loadError }) => !!loadError).length;\n  if (countLoaded === 0 || countLoaded !== countExpected - countErrored) {\n    return null;\n  }\n  const matchingTriggerTemplateNames: string[] = triggerTemplateResults\n    .filter((resourceWatch) => resourceWatch.loaded)\n    .map((resourceWatch) => resourceWatch.data)\n    .filter((triggerTemplate: TriggerTemplateKind) => {\n      const plr: PipelineRun = triggerTemplate?.spec?.resourcetemplates?.find(\n        ({ kind }) => kind === PipelineRunModel.kind,\n      );\n      return plr?.spec?.pipelineRef?.name === pipelineName;\n    })\n    .map(getResourceName);\n\n  return (eventListenerResources || []).reduce((acc, ev: EventListenerKind) => {\n    const eventListenerTemplateNames = getEventListenerTemplateNames(ev);\n    const generatedRouteName = getEventListenerGeneratedName(ev);\n\n    const triggerTemplateName = matchingTriggerTemplateNames.find((name) =>\n      eventListenerTemplateNames.includes(name),\n    );\n    const route: RouteKind = routes[generatedRouteName];\n\n    if (!triggerTemplateName) {\n      return acc;\n    }\n\n    let routeURL = null;\n    try {\n      if (route) {\n        routeURL = getRouteWebURL(route);\n      }\n    } catch (e) {\n      // swallow errors, we don't care if we can't create a good route right now\n    }\n\n    return [...acc, { routeURL, triggerTemplateName }];\n  }, []);\n};\n\nexport const useEventListenerTriggerTemplateNames = (\n  eventListener: EventListenerKind,\n): RouteTemplate[] | null => {\n  const {\n    metadata: { namespace },\n  } = eventListener;\n\n  const [route, routeLoaded] = useK8sGet<RouteKind>(\n    RouteModel,\n    getEventListenerGeneratedName(eventListener),\n    namespace,\n  );\n  return eventListener.spec.triggers.reduce(\n    (acc, trigger) => [\n      ...acc,\n      {\n        routeURL: route && route?.status?.ingress && routeLoaded ? getRouteWebURL(route) : null,\n        triggerTemplateName: trigger.template.name,\n      },\n    ],\n    [],\n  );\n};\n\nexport const getEventListenerTriggerBindingNames = (\n  eventListener: EventListenerKind,\n): ResourceModelLink[] => {\n  return eventListener.spec.triggers.reduce(\n    (acc, trigger) => [\n      ...acc,\n      ...trigger.bindings.map((binding) => ({\n        model: getResourceModelFromBindingKind(binding.kind),\n        name: binding.name,\n      })),\n    ],\n    [] as ResourceModelLink[],\n  );\n};\n\nexport const getTriggerTemplatePipelineName = (triggerTemplate: TriggerTemplateKind): string => {\n  return (\n    triggerTemplate.spec.resourcetemplates.find(({ kind }) => kind === PipelineRunModel.kind)?.spec\n      .pipelineRef.name || ''\n  );\n};\n\nexport const useTriggerTemplateEventListenerNames = (triggerTemplate: TriggerTemplateKind) => {\n  const eventListenerResources = useAllEventListeners(triggerTemplate.metadata.namespace) || [];\n\n  return eventListenerResources\n    .filter((eventListener: EventListenerKind) =>\n      eventListener.spec.triggers.find(\n        ({ template: { name } }) => name === getResourceName(triggerTemplate),\n      ),\n    )\n    .map(getResourceName);\n};\n\nexport const useTriggerBindingEventListenerNames = (triggerBinding: TriggerBindingKind) => {\n  const eventListenerResources = useAllEventListeners(triggerBinding.metadata.namespace) || [];\n  return eventListenerResources\n    .filter((eventListener: EventListenerKind) =>\n      eventListener.spec.triggers.find(({ bindings }) =>\n        bindings.find(\n          ({ kind, name }) =>\n            getResourceName(triggerBinding) === name &&\n            getResourceModelFromBindingKind(kind).kind === triggerBinding.kind,\n        ),\n      ),\n    )\n    .map(getResourceName);\n};\n","import {\n  chart_color_green_400 as successColor,\n  chart_color_blue_300 as runningColor,\n  global_danger_color_100 as failureColor,\n  chart_color_blue_100 as pendingColor,\n  chart_color_black_400 as skippedColor,\n  chart_color_black_500 as cancelledColor,\n} from '@patternfly/react-tokens';\nimport { K8sKind, K8sResourceKind, referenceForModel } from '@console/internal/module/k8s';\nimport {\n  ClusterTaskModel,\n  ClusterTriggerBindingModel,\n  PipelineRunModel,\n  TaskModel,\n  TriggerBindingModel,\n} from '../models';\nimport { pipelineRunFilterReducer } from './pipeline-filter-reducer';\n\ninterface Metadata {\n  name: string;\n  namespace?: string;\n}\n\nexport interface PropPipelineData {\n  metadata: Metadata;\n  latestRun?: PipelineRun;\n}\n\ninterface StatusMessage {\n  message: string;\n  pftoken: { name: string; value: string; var: string };\n}\n\nexport interface TaskStatus {\n  PipelineNotStarted: number;\n  Pending: number;\n  Running: number;\n  Succeeded: number;\n  Cancelled: number;\n  Failed: number;\n}\n\nexport interface PipelineTaskRef {\n  kind?: string;\n  name: string;\n}\n\nexport interface PipelineTaskParam {\n  name: string;\n  value: any;\n}\nexport interface PipelineTaskResources {\n  inputs?: PipelineTaskResource[];\n  outputs?: PipelineTaskResource[];\n}\nexport interface PipelineTaskResource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport interface PipelineTask {\n  name: string;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n}\n\nexport interface Resource {\n  propsReferenceForRuns: string[];\n  resources: FirehoseResource[];\n}\n\nexport interface PipelineResource {\n  name: string;\n  type: string;\n}\n\ntype PipelineRunResourceCommonProperties = {\n  name: string;\n};\nexport type PipelineRunInlineResourceParam = { name: string; value: string };\nexport type PipelineRunInlineResource = PipelineRunResourceCommonProperties & {\n  resourceSpec: {\n    params: PipelineRunInlineResourceParam[];\n    type: string;\n  };\n};\nexport type PipelineRunReferenceResource = PipelineRunResourceCommonProperties & {\n  resourceRef: {\n    name: string;\n  };\n};\nexport type PipelineRunResource = PipelineRunReferenceResource | PipelineRunInlineResource;\n\nexport interface Runs {\n  data?: PipelineRun[];\n}\n\nexport type KeyedRuns = { [key: string]: Runs };\n\nexport interface Pipeline extends K8sResourceKind {\n  latestRun?: PipelineRun;\n  spec: {\n    params?: PipelineParam[];\n    resources?: PipelineResource[];\n    workspaces?: PipelineWorkspace[];\n    tasks: PipelineTask[];\n    serviceAccountName?: string;\n  };\n}\n\nexport type TaskRunKind = { pipelineTaskName?: string } & K8sResourceKind;\n\nexport interface TaskRuns {\n  [key: string]: TaskRunKind;\n}\n\nexport interface PipelineSpecTaskRef {\n  kind?: string;\n  name?: string;\n  apiVersion?: string;\n}\n\nexport interface PipelineSpecTaskSpec {\n  metadata?: {};\n  steps?: {\n    // TODO: Figure out required fields\n    env?: PipelineTaskParam[];\n    image?: string;\n    name?: string;\n    resources?: {};\n    script?: string;\n    securityContext?: {\n      privileged: boolean;\n      [key: string]: any;\n    }\n    imagePullPolicy?: string;\n    workingDir?: string;\n  }[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpecTask {\n  name: string;\n  runAfter?: string[];\n  taskRef?: PipelineSpecTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n  taskSpec?: PipelineSpecTaskSpec;\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpec extends K8sResourceKind {\n  tasks: PipelineSpecTask[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineRun extends K8sResourceKind {\n  spec?: {\n    pipelineRef?: { name: string };\n    params?: PipelineRunParam[];\n    workspaces?: PipelineRunWorkspace[];\n    resources?: PipelineRunResource[];\n    serviceAccountName?: string;\n    // Odd status value that only appears in a single case - cancelling a pipeline\n    status?: 'PipelineRunCancelled';\n    timeout?: string;\n    pipelineSpec?: PipelineSpec;\n  };\n  status?: {\n    succeededCondition?: string;\n    creationTimestamp?: string;\n    conditions?: Condition[];\n    startTime?: string;\n    completionTime?: string;\n    taskRuns?: TaskRuns;\n    runs?: TaskRuns; \n    phase?: string;\n    nodes?: any;\n  };\n}\n\nexport type PipelineResourceKind = K8sResourceKind & {\n  spec: {\n    params: { name: string; value: string }[];\n    type: string;\n  };\n};\n\nexport interface PipelineResourceTaskParam extends PipelineParam {\n  type: string;\n}\nexport interface PipelineResourceTaskResource {\n  name: string;\n  type: string;\n  optional?: boolean;\n}\nexport interface PipelineResourceTask extends K8sResourceKind {\n  spec: {\n    params?: PipelineResourceTaskParam[];\n    resources?: {\n      inputs?: PipelineResourceTaskResource[];\n      outputs?: PipelineResourceTaskResource[];\n    };\n\n    steps: {\n      // TODO: Figure out required fields\n      args?: string[];\n      command?: string[];\n      image?: string;\n      resources?: {}[];\n    }[];\n  };\n}\n\nexport interface Condition {\n  type: string;\n  status: string;\n  reason?: string;\n  message?: string;\n  lastTransitionTime?: string;\n}\n\nexport interface Param {\n  name: string;\n}\n\nexport interface PipelineParam extends Param {\n  default?: string | string[];\n  description?: string;\n}\n\nexport interface PipelineRunParam extends Param {\n  value: string | string[];\n  input?: string;\n  output?: string;\n  resource?: object;\n}\n\nexport interface PipelineWorkspace extends Param {\n  type: string;\n  data?: {\n    [key: string]: string;\n  };\n}\n\nexport interface PipelineRunWorkspace extends Param {\n  [key: string]: string;\n}\n\ninterface FirehoseResource {\n  kind: string;\n  namespace?: string;\n  isList?: boolean;\n  selector?: object;\n}\n\nexport const getResources = (data: PropPipelineData[]): Resource => {\n  const resources = [];\n  const propsReferenceForRuns = [];\n  if (data && data.length > 0) {\n    data.forEach((pipeline, i) => {\n      if (pipeline.metadata && pipeline.metadata.namespace && pipeline.metadata.name) {\n        propsReferenceForRuns.push(`PipelineRun_${i}`);\n        resources.push({\n          kind: referenceForModel(PipelineRunModel),\n          namespace: pipeline.metadata.namespace,\n          isList: true,\n          prop: `PipelineRun_${i}`,\n          selector: {\n            'tekton.dev/pipeline': pipeline.metadata.name,\n          },\n        });\n      }\n    });\n    return { propsReferenceForRuns, resources };\n  }\n  return { propsReferenceForRuns: null, resources: null };\n};\n\nexport const getLatestRun = (runs: Runs, field: string): PipelineRun => {\n  if (!runs || !runs.data || !(runs.data.length > 0) || !field) {\n    return null;\n  }\n  let latestRun = runs.data[0];\n  if (field === 'creationTimestamp') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].metadata &&\n        runs.data[i].metadata[field] &&\n        new Date(runs.data[i].metadata[field]) > new Date(latestRun.metadata[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else if (field === 'startTime' || field === 'completionTime') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].status &&\n        runs.data[i].status[field] &&\n        new Date(runs.data[i].status[field]) > new Date(latestRun.status[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else {\n    latestRun = runs.data[runs.data.length - 1];\n  }\n  if (!latestRun.status) {\n    latestRun = { ...latestRun, status: {} };\n  }\n  if (!latestRun.status.succeededCondition) {\n    latestRun.status = { ...latestRun.status, succeededCondition: '' };\n  }\n  latestRun.status.succeededCondition = pipelineRunFilterReducer(latestRun);\n  return latestRun;\n};\n\nexport const augmentRunsToData = (\n  data: PropPipelineData[],\n  propsReferenceForRuns: string[],\n  runs: { [key: string]: Runs },\n): PropPipelineData[] => {\n  if (propsReferenceForRuns) {\n    const newData: PropPipelineData[] = [];\n    propsReferenceForRuns.forEach((reference, i) => {\n      const latestRun = getLatestRun(runs[reference], 'creationTimestamp');\n      if (latestRun !== data[i].latestRun) {\n        // ensure we create a new data object if the latestRun has changed so that shallow compare fails\n        newData.push({ ...data[i], latestRun });\n      } else {\n        newData.push(data[i]);\n      }\n    });\n    return newData;\n  }\n  return data;\n};\n\nexport enum runStatus {\n  Succeeded = 'Succeeded',\n  Failed = 'Failed',\n  Running = 'Running',\n  'In Progress' = 'In Progress',\n  FailedToStart = 'FailedToStart',\n  PipelineNotStarted = 'PipelineNotStarted',\n  Skipped = 'Skipped',\n  Cancelled = 'Cancelled',\n  Pending = 'Pending',\n  Idle = 'Idle',\n}\n\nexport const getRunStatusColor = (status: string): StatusMessage => {\n  switch (status) {\n    case runStatus.Succeeded:\n      return { message: 'Succeeded', pftoken: successColor };\n    case runStatus.Failed:\n      return { message: 'Failed', pftoken: failureColor };\n    case runStatus.FailedToStart:\n      return {\n        message: 'PipelineRun failed to start',\n        pftoken: failureColor,\n      };\n    case runStatus.Running:\n      return { message: 'Running', pftoken: runningColor };\n    case runStatus['In Progress']:\n      return { message: 'Running', pftoken: runningColor };\n\n    case runStatus.Skipped:\n      return { message: 'Skipped', pftoken: skippedColor };\n    case runStatus.Cancelled:\n      return { message: 'Cancelled', pftoken: cancelledColor };\n    case runStatus.Idle:\n    case runStatus.Pending:\n      return { message: 'Pending', pftoken: pendingColor };\n    default:\n      return { message: 'PipelineRun not started yet', pftoken: pendingColor };\n  }\n};\n\nexport const truncateName = (name: string, length: number): string =>\n  name.length < length ? name : `${name.slice(0, length - 1)}...`;\n\nexport const getTaskStatus = (pipelinerun: PipelineRun, pipeline: Pipeline): TaskStatus => {\n  const totalTasks =\n    pipeline && pipeline.spec && pipeline.spec.tasks ? pipeline.spec.tasks.length : 0;\n  const plrTasks =\n    pipelinerun && pipelinerun.status && pipelinerun.status.taskRuns\n      ? pipelinerun.status.runs ? Object.keys(pipelinerun.status.runs).concat(Object.keys(pipelinerun.status.taskRuns))\n        : Object.keys(pipelinerun.status.taskRuns)\n      : [];\n  const plrTaskLength = plrTasks.length;\n  const taskStatus: TaskStatus = {\n    PipelineNotStarted: 0,\n    Pending: 0,\n    Running: 0,\n    Succeeded: 0,\n    Failed: 0,\n    Cancelled: 0,\n  };\n  if (plrTasks) {\n    plrTasks.forEach((taskRun) => {\n      const status = pipelineRunFilterReducer(pipelinerun.status.taskRuns[taskRun] ?? pipelinerun.status.runs[taskRun]);\n      if (status === 'Succeeded' || status === 'Completed' || status === 'Complete') {\n        taskStatus[runStatus.Succeeded]++;\n      } else if (status === 'Running') {\n        taskStatus[runStatus.Running]++;\n      } else if (status === 'Failed') {\n        taskStatus[runStatus.Failed]++;\n      } else if (status === 'Cancelled') {\n        taskStatus[runStatus.Cancelled]++;\n      } else {\n        taskStatus[runStatus.Pending]++;\n      }\n    });\n    taskStatus[runStatus.Failed] > 0 || taskStatus[runStatus.Cancelled] > 0\n      ? (taskStatus[runStatus.Cancelled] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks)\n      : (taskStatus[runStatus.Pending] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks);\n  } else if (\n    pipelinerun &&\n    pipelinerun.status &&\n    pipelinerun.status.conditions &&\n    pipelinerun.status.conditions[0].status === 'False'\n  ) {\n    taskStatus[runStatus.Cancelled] = totalTasks;\n  } else {\n    taskStatus[runStatus.PipelineNotStarted]++;\n  }\n  return taskStatus;\n};\n\nexport const getResourceModelFromTaskKind = (kind: string): K8sKind =>\n  kind === ClusterTaskModel.kind ? ClusterTaskModel : TaskModel;\n\nexport const getResourceModelFromBindingKind = (kind: string): K8sKind =>\n  kind === ClusterTriggerBindingModel.kind ? ClusterTriggerBindingModel : TriggerBindingModel;\n\nexport const getResourceModelFromTask = (task: PipelineTask): K8sKind => {\n  const {\n    taskRef: { kind },\n  } = task;\n\n  return getResourceModelFromTaskKind(kind);\n};\n\nexport const pipelineRefExists = (pipelineRun: PipelineRun): boolean =>\n  !!pipelineRun.spec.pipelineRef?.name;\n","import * as React from 'react';\nimport { k8sGet, K8sKind, K8sResourceCommon } from '../../module/k8s';\n\nexport const useK8sGet = <R extends K8sResourceCommon = K8sResourceCommon>(\n  kind: K8sKind,\n  name?: string,\n  namespace?: string,\n  opts?: { [k: string]: string },\n): [R, boolean, any] => {\n  const [data, setData] = React.useState<R>();\n  const [loaded, setLoaded] = React.useState(false);\n  const [loadError, setLoadError] = React.useState();\n\n  React.useEffect(() => {\n    const fetch = async () => {\n      try {\n        setLoadError(null);\n        setLoaded(false);\n        setData(null);\n        const resource = await k8sGet(kind, name, namespace, opts);\n        setData(resource);\n      } catch (error) {\n        setLoadError(error);\n      } finally {\n        setLoaded(true);\n      }\n    };\n    fetch();\n  }, [kind, name, namespace, opts]);\n\n  return [data, loaded, loadError];\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAQA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAGA;AACA;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AASA;AAEA;;;;;;;;;;;;AC7CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAcA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AAKA;AAEA;;;;;;;;;;;;ACxDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAOA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AAKA;AAIA;AAEA;;;;;;;;;;;;;ACjDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAYA;AACA;AAEA;AAGA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAIA;AACA;AAOA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAIA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;AACA;AAIA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAIA;AACA;;;;;;;;;;;;;AC9NA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAQA;AACA;AAOA;AAkPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAGA;AACA;AAIA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;AChcA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;A","sourceRoot":""}