{"version":3,"file":"create-operand-c197c4a9c064a183fddb.js","sources":["webpack:///./packages/operator-lifecycle-manager/src/components/operand/DEPRECATED_operand-form.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/operand/create-operand.tsx"],"sourcesContent":["// THIS COMPONENT IS DEPRECATED AND WILL BE REMOVED IN v4.6.\n\nimport * as _ from 'lodash';\nimport * as classNames from 'classnames';\nimport * as Immutable from 'immutable';\nimport * as React from 'react';\nimport { JSONSchema6, JSONSchema6TypeName } from 'json-schema';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport {\n  Alert,\n  ActionGroup,\n  Button,\n  Switch,\n  Accordion,\n  Checkbox,\n  AccordionItem,\n  AccordionToggle,\n  AccordionContent,\n} from '@patternfly/react-core';\nimport { ConfigureUpdateStrategy } from '@console/internal/components/modals/configure-update-strategy-modal';\nimport { ExpandCollapse } from '@console/internal/components/utils/expand-collapse';\nimport { RadioGroup } from '@console/internal/components/radio';\nimport {\n  GroupVersionKind,\n  ImagePullPolicy,\n  k8sCreate,\n  K8sResourceKind,\n  kindForReference,\n  modelFor,\n  NodeAffinity as NodeAffinityType,\n} from '@console/internal/module/k8s';\nimport {\n  NumberSpinner,\n  history,\n  SelectorInput,\n  ListDropdown,\n  useScrollToTopOnMount,\n  Dropdown,\n} from '@console/internal/components/utils';\nimport { ClusterServiceVersionLogo } from '../index';\nimport { ResourceRequirements } from '../descriptors/spec/resource-requirements';\nimport { Descriptor, SpecCapability, StatusCapability } from '../descriptors/types';\nimport {\n  NodeAffinity,\n  PodAffinity,\n  DEFAULT_NODE_AFFINITY,\n  DEFAULT_POD_AFFINITY,\n} from '../descriptors/spec/affinity';\nimport { OperandFormProps } from './operand-form';\nimport { ProvidedAPI } from '../../types';\n\n/*\n * Matches a path that contains an array index. Use Sting.match against an OperandField 'path'\n * property to determine if it contains an array index. It will parse the path into three parts,\n * [match, pathBeforeIndex, index, pathAfterIndex]. For example:\n *\n *   const [match, pathBeforeIndex, index, pathAfterIndex] =\n *     'path.before[0].path.after'.match(ARRAY_INDEX_PATTERN);\n *\n *   console.log(match);\n *   > 'path.before[0].path.after'\n *\n *   console.log(pathBeforeIndex);\n *   > 'path.before'\n *\n *   console.log(index)\n *   > '0'\n *\n *   console.log(pathAfterIndex)\n *   > 'path.after'\n *\n */\nconst ARRAY_INDEX_PATTERN = /^(.*)\\[(\\d+)\\]\\.?(.*)$/;\n\n// Regex for SpecCapability.arrayFieldGroup and SpecCapability.fieldGroup\nconst ARRAY_FIELD_GROUP_PATTERN = _.escapeRegExp(SpecCapability.arrayFieldGroup);\nconst FIELD_GROUP_PATTERN = _.escapeRegExp(SpecCapability.fieldGroup);\n\n/*\n * Matches either field group or array field group SpecCapabilty. Use String.match against an\n * OperandField.capability element to determine if it is a group descriptor and parse group type\n * and name. For example:\n *\n *   const [match, groupType, name] = 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:groupName';\n *\n *   console.log(match);\n *   > 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:groupName'\n *\n *   console.log(groupType);\n *   > 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:'\n *\n *   console.log(name);\n *   > 'groupName'\n */\nconst GROUP_PATTERN = new RegExp(`^(${FIELD_GROUP_PATTERN}|${ARRAY_FIELD_GROUP_PATTERN})(.*)$`);\n\n// Default max nesting depth the form should display\nconst MAX_DEPTH = 1;\n\nenum Validations {\n  maximum = 'maximum',\n  minimum = 'minimum',\n  maxLength = 'maxLength',\n  minLength = 'minLength',\n  pattern = 'pattern',\n}\n\nconst idFromPath = (path) => `root_${path.split('.').join('_')}`;\n\n/*\n * Determines if a field contains a descriptor in it's capabilities. If only prefix is\n * provided, this will return true if the field has ANY capability that starts with the prefix. If\n * both prefix and suffix are provided, this will return true only if the field has a capability\n * that matches the concatenation of prefix + suffix.\n */\nconst hasDescriptor = (field: OperandField, prefix: string, suffix: string = null): boolean => {\n  return suffix\n    ? _.includes(field.capabilities, `${prefix}${suffix}`)\n    : _.some(field.capabilities, (capability) => capability.startsWith(prefix));\n};\n\n/*\n * Accepts an OperandField and returns a name and group type if that field is either a\n * a field group or array field group. Returned as object to allow destructuring of needed values\n * only.\n */\nconst parseGroupDescriptor = (\n  field: OperandField,\n): { groupName?: string; groupType?: string; regexMatch?: string } => {\n  const groupDescriptor = _.find(\n    field.capabilities,\n    (descriptor) =>\n      descriptor.startsWith(SpecCapability.fieldGroup) ||\n      descriptor.startsWith(SpecCapability.arrayFieldGroup),\n  );\n  const [regexMatch, groupType, groupName] = groupDescriptor.match(GROUP_PATTERN) || [];\n  return { regexMatch, groupName, groupType };\n};\n\n/*\n * Splits a path string into path before the array index, the array index itself, and the path after\n * the index. Returns as object to allow destructuring of needed values only.\n */\nconst parseArrayPath = (\n  path: string,\n): { index?: number; regexMatch?: string; pathBeforeIndex?: string; pathAfterIndex?: string } => {\n  const [regexMatch, pathBeforeIndex, index, pathAfterIndex] =\n    path.match(ARRAY_INDEX_PATTERN) || [];\n  return regexMatch\n    ? { index: _.parseInt(index), regexMatch, pathBeforeIndex, pathAfterIndex }\n    : { regexMatch };\n};\n\n/*\n * If the path contains an array index, this function will return the path with the 'operation'\n * callback return value in place of the existing array index. If no array index is in the path,\n * the original path is returned.\n */\nconst modifyArrayFieldPathIndex = (\n  path: string,\n  operation: (index?: number) => string | number,\n): string => {\n  const { regexMatch, index, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n  return !regexMatch\n    ? path\n    : `${pathBeforeIndex}[${operation(index)}]${pathAfterIndex && `.${pathAfterIndex}`}`;\n};\n\n// Accepts a SpecCapbability[] array and returns an appropriate default value for that field\nconst defaultValueFor = (capabilities: Capability[]): any => {\n  // String fields\n  if (\n    _.intersection(capabilities, [\n      SpecCapability.podCount,\n      SpecCapability.password,\n      SpecCapability.text,\n      SpecCapability.number,\n      SpecCapability.select,\n    ]).length > 0\n  ) {\n    return '';\n  }\n\n  if (capabilities.includes(SpecCapability.imagePullPolicy)) {\n    return ImagePullPolicy.IfNotPresent;\n  }\n\n  // Resource requirement fields\n  if (capabilities.includes(SpecCapability.resourceRequirements)) {\n    return Immutable.fromJS({\n      limits: {\n        cpu: '',\n        memory: '',\n        'ephemeral-storage': '',\n      },\n      requirements: {\n        cpu: '',\n        memory: '',\n        'ephemeral-storage': '',\n      },\n    });\n  }\n\n  // Update strategy\n  if (capabilities.includes(SpecCapability.updateStrategy)) {\n    return Immutable.fromJS({\n      type: 'RollingUpdate',\n      rollingUpdate: {\n        maxUnavailable: '',\n        maxSurge: '',\n      },\n    });\n  }\n\n  // Node and pod affinities\n  if (capabilities.includes(SpecCapability.nodeAffinity)) {\n    return Immutable.fromJS(DEFAULT_NODE_AFFINITY).setIn(\n      ['preferredDuringSchedulingIgnoredDuringExecution', 'weight'],\n      '',\n    );\n  }\n\n  if (\n    capabilities.includes(SpecCapability.podAffinity) ||\n    capabilities.includes(SpecCapability.podAntiAffinity)\n  ) {\n    return Immutable.fromJS(DEFAULT_POD_AFFINITY).setIn(\n      ['preferredDuringSchedulingIgnoredDuringExecution', 'weight'],\n      '',\n    );\n  }\n\n  // If none of these capabilities are present in the array, return null.\n  return null;\n};\n\n// Accepts an OpenAPI spec property and returns a corresponding SpecCapability[] array.\nconst capabilitiesFor = (property: JSONSchema6): SpecCapability[] => {\n  if (property.enum) {\n    return _.map(\n      property.enum || [],\n      (option: string) => `${SpecCapability.select}${option}` as SpecCapability,\n    );\n  }\n  switch (property.type) {\n    case 'integer':\n      return [SpecCapability.number];\n    case 'boolean':\n      return [SpecCapability.booleanSwitch];\n    default:\n      return [SpecCapability.text];\n  }\n};\n\n/*\n * Recursively traverses OpenAPI spec properties and flattens all nested properties into an\n * OperandField[] array.\n * If a resource instance is provided in the 'obj' argument, then array-type spec properties\n * will be expanded into the appropriate number of fields.\n * If a matching providedAPI descriptor exists, it will take precedence over the openAPI spec,\n * except that the providedAPI x-descriptors will be unioned with OpenAPI capabilities.\n */\nconst flattenNestedProperties = (\n  property: JSONSchema6,\n  name: string,\n  providedAPI: ProvidedAPI,\n  obj: K8sResourceKind,\n  {\n    currentCapabilities = [],\n    currentPath = [],\n    fields = [],\n    required = false,\n  }: FlattenNestedPropertiesAccumulator,\n): OperandField[] => {\n  // Null check\n  if (!property) {\n    return fields;\n  }\n\n  const handleObjectProperty = (): OperandField[] =>\n    _.flatMap(property.properties, (nestedProperty, nestedPropertyName) =>\n      flattenNestedProperties(nestedProperty as JSONSchema6, nestedPropertyName, providedAPI, obj, {\n        currentCapabilities: [\n          ...currentCapabilities,\n          `${SpecCapability.fieldGroup}${name}` as SpecCapability,\n        ],\n        currentPath: [...currentPath, name],\n        fields,\n        required: (property?.required || []).includes(nestedPropertyName),\n      }),\n    );\n\n  const handleArrayProperty = (): OperandField[] => {\n    // Find the number of array elements that are already defined in the provided object\n    const n = _.get(obj, `spec.${currentPath.join('.')}${name}`, []).length || 1;\n\n    // Since _.times will return a multidimensional array of OperandFields (OperandField[][]), we\n    // need to flatten one level deeper than _.flatMap provides.\n    return _.flatMapDepth(\n      (property.items as JSONSchema6)?.properties ?? {},\n      (nestedProperty, nestedPropertyName) =>\n        // Repeat recursion (n) times so that the correct number of fields are created for\n        // existing values in obj. This ensures that further nested fields also get created.\n        _.times(n, (index) =>\n          flattenNestedProperties(\n            nestedProperty as JSONSchema6,\n            nestedPropertyName,\n            providedAPI,\n            obj,\n            {\n              currentCapabilities: [\n                ...currentCapabilities,\n                `${SpecCapability.arrayFieldGroup}${name}` as SpecCapability,\n              ],\n              currentPath: [...currentPath, `${name}[${index}]`], // Array field paths must include an index\n              fields,\n              required: (property?.required || []).includes(nestedPropertyName),\n            },\n          ),\n        ),\n      2,\n    );\n  };\n\n  const handleAtomicProperty = (): OperandField[] => {\n    const path = [...currentPath, name].join('.');\n\n    // ProvidedAPI should only have a single descriptor for each array field. Regardless of the\n    // index of this field, use the providedAPI.specDescriptor at index 0.\n    const providedAPIField = _.find(providedAPI?.specDescriptors, {\n      path: modifyArrayFieldPathIndex(path, () => 0),\n    });\n    return [\n      ...fields,\n      {\n        capabilities: _.union(\n          providedAPIField?.['x-descriptors'] || [],\n          currentCapabilities,\n          capabilitiesFor(property as JSONSchema6),\n        ),\n        description: providedAPIField?.description || property.description,\n        displayName: providedAPIField?.displayName || _.startCase(name),\n        path: `spec.${path}`,\n        required,\n        type: property.type,\n        validation: _.pick(property, Object.keys(Validations)),\n      } as OperandField,\n    ];\n  };\n\n  switch (property.type) {\n    // If this property is of 'object' type, return a flat map of its properties\n    case 'object':\n      return handleObjectProperty();\n\n    // If this property of is of 'array' type, return a flat map of its item's properties.\n    case 'array':\n      return handleArrayProperty();\n\n    // This property is not an array or object, so it can be mapped to a specific descriptor\n    default:\n      return handleAtomicProperty();\n  }\n};\n\n// Returns traversal depth of an OpenAPI spec property.\nconst getPropertyDepth = (property: JSONSchema6, depth: number = 0): number => {\n  // If this property is not an array or object, we have reached the maximum depth\n  if (!property || !['object', 'array'].includes(property.type as string)) {\n    return depth;\n  }\n\n  // Return the maximum depth of the nested properties\n  return Math.max(\n    0,\n    ..._.map(\n      property?.properties || (property?.items as JSONSchema6)?.properties,\n      (nestedProperty) => getPropertyDepth(nestedProperty as JSONSchema6, depth + 1),\n    ),\n  );\n};\n\n/*\n * Maps openAPI spec properties to OperandField[] array. This will return all fields with a traversal\n * depth less than the 'depth' argument, and will combine matching providedAPI descriptors with the\n * corresponding OpenAPI spec property in a way that providedAPI data will take precedence over\n * openAPI spec properties.\n */\nconst fieldsForOpenAPI = (\n  schema: JSONSchema6,\n  providedAPI: ProvidedAPI,\n  obj: K8sResourceKind,\n  depth: number = MAX_DEPTH,\n): OperandField[] => {\n  return _.reduce(\n    schema?.properties || {},\n    (openAPIFieldsAccumulator: OperandField[], property: JSONSchema6, propertyName: string) => {\n      if (!property?.type || getPropertyDepth(property) > depth) {\n        return openAPIFieldsAccumulator;\n      }\n      return [\n        ...openAPIFieldsAccumulator,\n        ...flattenNestedProperties(property, propertyName, providedAPI, obj, {\n          required: (schema?.required || []).includes(propertyName),\n        }),\n      ];\n    },\n    [],\n  );\n};\n\n/*\n * Convert a CRD specDescriptor to appropriate OperandField type. Expands obj array properties\n * to the appropriate number of fields.\n */\nconst specDescriptorToFields = (\n  { description, displayName, path, 'x-descriptors': capabilities = [] }: Descriptor,\n  obj: K8sResourceKind,\n): OperandField[] => {\n  // Use regex to check path for an array index, and parse out the parts of the path before\n  // and after the array index.\n  const { regexMatch, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n\n  // If match exists, the field represents an element in an array field group, which means we\n  // need to create 'n' duplicates of this field, where 'n' is the number of\n  // elements in the corresponding array property of 'obj'. If n = 0, we only create one field.\n  if (regexMatch) {\n    const n = _.get(obj, _.toPath(`spec.${pathBeforeIndex}`), []).length || 1;\n    return _.flatten(\n      _.times(n, (index) => ({\n        path: `spec.${pathBeforeIndex}[${index}]${pathAfterIndex && `.${pathAfterIndex}`}`,\n        displayName,\n        description,\n        capabilities,\n        type: null,\n        required: null,\n        validation: null,\n      })),\n    );\n  }\n  return [\n    {\n      path: `spec.${path}`,\n      displayName,\n      description,\n      type: null,\n      required: null,\n      validation: null,\n      capabilities,\n    },\n  ];\n};\n\nconst pathToArray = (path: string): (string | number)[] =>\n  _.map(_.toPath(path), (subPath) => {\n    return /^\\d+$/.test(subPath) ? _.parseInt(subPath) : subPath;\n  });\n\nconst FieldGroup: React.FC<FieldGroupProps> = ({ children, isExpanded = false, id, label }) => {\n  const [expanded, setExpanded] = React.useState<boolean>(isExpanded);\n\n  const onToggle = (event) => {\n    event.preventDefault();\n    setExpanded((current) => !current);\n  };\n\n  return (\n    <div id={`${id}_field-group`} className=\"co-dynamic-form__field-group\">\n      <AccordionItem>\n        <AccordionToggle id={`${id}_accordion-toggle`} onClick={onToggle} isExpanded={expanded}>\n          <label htmlFor={`${id}_accordion-content`}>{label}</label>\n        </AccordionToggle>\n        <AccordionContent id={`${id}_accordion-content`} isHidden={!expanded}>\n          {children}\n        </AccordionContent>\n      </AccordionItem>\n    </div>\n  );\n};\n\n// Wrapper for individual operand form inputs\nconst OperandFormInputGroup: React.FC<OperandFormInputGroupProps> = ({ error, field, input }) => {\n  const { description, displayName, path, required } = field;\n  const id = idFromPath(path);\n  return input ? (\n    <div className=\"form-group co-dynamic-form__form-group\" data-test-selector={path}>\n      <label className={classNames('form-label', { 'co-required': required })} htmlFor={id}>\n        {displayName}\n      </label>\n      {input}\n      {description && (\n        <span id={`${id}__description`} className=\"help-block\">\n          {description}\n        </span>\n      )}\n      {error && <span className=\"co-error\">{error}</span>}\n    </div>\n  ) : null;\n};\n\n// eslint-disable-next-line @typescript-eslint/camelcase\nexport const DEPRECATED_CreateOperandForm: React.FC<OperandFormProps> = ({\n  formData,\n  csv,\n  schema,\n  model,\n  onChange,\n  providedAPI,\n  match,\n  next,\n}) => {\n  const immutableFormData = Immutable.fromJS(formData);\n  const handleFormDataUpdate = (path: string, value: any): void => {\n    const { regexMatch, index, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n\n    // Immutable will not initialize a deep path as a List if it includes an integer, so we need to manually\n    // initialize non-existent array properties to a List instance before updating state at that path.\n    if (regexMatch && index === 0) {\n      const existing = immutableFormData.getIn([...pathToArray(pathBeforeIndex), 0]);\n      const item = Immutable.Map(existing || {}).setIn(pathToArray(pathAfterIndex), value);\n      const list = Immutable.List([item]);\n      onChange(immutableFormData.setIn(pathToArray(pathBeforeIndex), list).toJS());\n    }\n    onChange(immutableFormData.setIn(pathToArray(path), value).toJS());\n  };\n\n  const handleFormDataDelete = (path) => {\n    onChange(immutableFormData.deleteIn(pathToArray(path)).toJS());\n  };\n\n  // Map providedAPI spec descriptors and openAPI spec properties to OperandField[] array\n  const [fields, setFields] = React.useState<OperandField[]>(() => {\n    // Get fields from openAPI\n    const schemaFields = fieldsForOpenAPI(\n      schema?.properties?.spec as JSONSchema6,\n      providedAPI,\n      formData,\n    );\n\n    // Get fields from providedAPI that do not exist in the OpenAPI spec.\n    const descriptorFields = _.reduce(\n      providedAPI?.specDescriptors ?? [],\n      (providedAPIFieldsAccumulator, specDescriptor) => {\n        // If this field was already created, ignore it.\n        if (_.find(schemaFields, { path: `spec.${specDescriptor.path}` })) {\n          return providedAPIFieldsAccumulator;\n        }\n\n        // Add the field if it doesn't exist\n        return [\n          ...providedAPIFieldsAccumulator,\n          ...specDescriptorToFields(specDescriptor, formData),\n        ];\n      },\n      [],\n    );\n\n    // Concatenate all fields and return\n    return [...schemaFields, ...descriptorFields];\n  });\n\n  const labelTags = React.useMemo(() => {\n    const formValue = immutableFormData.getIn(['metadata', 'labels']);\n    return SelectorInput.arrayify(_.isFunction(formValue?.toJS) ? formValue.toJS() : {});\n  }, [immutableFormData]);\n\n  const [error, setError] = React.useState<string>();\n  const [formErrors, setFormErrors] = React.useState<FieldErrors>({});\n\n  // Group fields into advanced, arrayFieldGroup, fieldGroup, and normal fields for rendering.\n  // Note that arrayFieldGroup and fieldGroup fields are still flat after this. The memoized\n  // 'arrayFieldGroups' and 'fieldGroups' (below) further organizes these by their respective\n  // group descriptors to simplify rendering and state management.\n  const [\n    advancedFields = [],\n    arrayFields = [],\n    groupFields = [],\n    normalFields = [],\n  ]: OperandField[][] = React.useMemo(\n    (): OperandField[][] =>\n      _.reduce(\n        fields,\n        (\n          [\n            advancedFieldsAccumulator = [],\n            arrayFieldsAccumulator = [],\n            groupFieldsAccumulator = [],\n            normalFieldsAccumulator = [],\n          ],\n          field,\n        ) => {\n          if (hasDescriptor(field, SpecCapability.arrayFieldGroup)) {\n            return [\n              advancedFieldsAccumulator,\n              [...arrayFieldsAccumulator, field],\n              groupFieldsAccumulator,\n              normalFieldsAccumulator,\n            ];\n          }\n          if (hasDescriptor(field, SpecCapability.fieldGroup)) {\n            return [\n              advancedFieldsAccumulator,\n              arrayFieldsAccumulator,\n              [...groupFieldsAccumulator, field],\n              normalFieldsAccumulator,\n            ];\n          }\n          if (hasDescriptor(field, SpecCapability.advanced)) {\n            return [\n              [...advancedFieldsAccumulator, field],\n              arrayFieldsAccumulator,\n              groupFieldsAccumulator,\n              normalFieldsAccumulator,\n            ];\n          }\n          return [\n            advancedFieldsAccumulator,\n            arrayFieldsAccumulator,\n            groupFieldsAccumulator,\n            [...normalFieldsAccumulator, field],\n          ];\n        },\n        [],\n      ),\n    [fields],\n  );\n\n  // Create memoized arrayFieldGroups. Organizes arrayFields into a structure that is easy to map\n  // and render.\n  const arrayFieldGroups = React.useMemo(() => {\n    // Group all fields by group name\n    const groupedByName = _.groupBy(arrayFields, (field) => {\n      const { groupName } = parseGroupDescriptor(field);\n      return groupName;\n    });\n\n    // Map {groupName: string, fieldLists: OperandField[][]}, where OperandField is a nested array\n    // of the appropriate fields, grouped by index.\n    return _.map(groupedByName, (fieldsInGroup, groupName: string) => ({\n      groupName,\n      fieldLists: _.reduce(\n        fieldsInGroup,\n        (fieldListsAccumulator, field) => {\n          const { index, regexMatch } = parseArrayPath(field.path);\n          if (regexMatch) {\n            fieldListsAccumulator[index] = [...(fieldListsAccumulator[index] || []), field];\n          }\n          return fieldListsAccumulator;\n        },\n        [],\n      ),\n    }));\n  }, [arrayFields]);\n\n  // Create memoized fieldGroups. Map to array of fields grouped by fieldGroup name so that sorting\n  // is easy.\n  const fieldGroups = React.useMemo(() => {\n    const groupedByName = _.groupBy(groupFields, (field) => {\n      const { groupName } = parseGroupDescriptor(field);\n      return groupName;\n    });\n\n    return _.map(groupedByName, (fieldList, groupName) => ({\n      groupName,\n      fieldList,\n    }));\n  }, [groupFields]);\n\n  const getFormData = (path): any => immutableFormData.getIn(pathToArray(path));\n\n  // Validate form and submit API request if no validation failures\n  const submit = (event) => {\n    event.preventDefault();\n    const errors = fields\n      .filter((f) => !_.isNil(f.validation) || !_.isEmpty(f.validation))\n      .filter((f) => f.required || !_.isEqual(getFormData(f.path), defaultValueFor(f.capabilities)))\n      .reduce<FieldErrors>((allErrors, field) => {\n        // NOTE: Use server-side validation in Kubernetes 1.16 (https://github.com/kubernetes/kubernetes/issues/80718#issuecomment-521081640)\n        const fieldErrors = _.map(field.validation, (val, rule: Validations) => {\n          const formVal = getFormData(field.path);\n          switch (rule) {\n            case Validations.minimum:\n              return formVal >= val ? null : `Must be greater than ${val}.`;\n            case Validations.maximum:\n              return formVal <= val ? null : `Must be less than ${val}.`;\n            case Validations.minLength:\n              return formVal.length >= val ? null : `Must be at least ${val} characters.`;\n            case Validations.maxLength:\n              return formVal.length <= val ? null : `Must be greater than ${val} characters.`;\n            case Validations.pattern:\n              return new RegExp(val as string).test(formVal)\n                ? null\n                : `Does not match required pattern ${val}`;\n            default:\n              return null;\n          }\n        });\n        // Just use first error\n        return { ...allErrors, [field.path]: fieldErrors.find((e) => !_.isNil(e)) };\n      }, {});\n    setFormErrors(errors);\n\n    if (_.isEmpty(_.compact(_.values(errors)))) {\n      k8sCreate(\n        model,\n        model.namespaced\n          ? immutableFormData.setIn(['metadata', 'namespace'], match.params.ns).toJS()\n          : immutableFormData.toJS(),\n      )\n        .then(() => history.push(next))\n        .catch((err: Error) => setError(err.message || 'Unknown error.'));\n    }\n  };\n\n  // TODO(alecmerdler): Move this into a single `<SpecDescriptorInput>` entry component in the `descriptors/` directory\n  const inputFor = ({ capabilities, displayName, path, required, validation }: OperandField) => {\n    const id = idFromPath(path);\n    const formDataValue = getFormData(path);\n    const currentValue = _.isNil(formDataValue) ? defaultValueFor(capabilities) : formDataValue;\n    if (capabilities.find((c) => c.startsWith(SpecCapability.fieldDependency))) {\n      const controlFieldInfoList = capabilities.filter((c) =>\n        c.startsWith(SpecCapability.fieldDependency),\n      );\n      const controlFieldPathList = _.uniq(\n        controlFieldInfoList\n          .map((c) => c.split(SpecCapability.fieldDependency)[1])\n          .reduce((infoList, info) => [info.split(':')[0], ...infoList], []),\n      );\n      const controlFieldPath =\n        _.isArray(controlFieldPathList) && controlFieldPathList.length === 1\n          ? controlFieldPathList[0]\n          : null;\n      const currentControlFieldValue = !_.isNil(getFormData(`spec.${controlFieldPath}`))\n        ? getFormData(`spec.${controlFieldPath}`).toString()\n        : null;\n      const expectedControlFieldValueList = controlFieldInfoList\n        .map((c) => c.split(SpecCapability.fieldDependency)[1])\n        .reduce((infoList, info) => [info.split(':')[1], ...infoList], []);\n\n      if (!expectedControlFieldValueList.includes(currentControlFieldValue)) {\n        return null;\n      }\n    }\n    if (capabilities.includes(SpecCapability.podCount)) {\n      return (\n        <NumberSpinner\n          id={id}\n          className=\"pf-c-form-control\"\n          value={currentValue}\n          onChange={({ currentTarget: { value } }) =>\n            handleFormDataUpdate(path, _.toInteger(value))\n          }\n          changeValueBy={(operation) =>\n            handleFormDataUpdate(path, _.toInteger(currentValue) + operation)\n          }\n          autoFocus\n          required\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.resourceRequirements)) {\n      const cpuLimitsPath = `limits.cpu`;\n      const memoryLimitsPath = `limits.memory`;\n      const storageLimitsPath = 'limits.ephemeral-storage';\n      const cpuRequestsPath = `requests.cpu`;\n      const memoryRequestsPath = `requests.memory`;\n      const storageRequestsPath = 'requests.ephemeral-storage';\n      return (\n        <dl style={{ marginLeft: '15px' }}>\n          <dt>Limits</dt>\n          <dd>\n            <ResourceRequirements\n              cpu={currentValue.getIn(_.toPath(cpuLimitsPath))}\n              memory={currentValue.getIn(_.toPath(memoryLimitsPath))}\n              storage={currentValue.getIn(_.toPath(storageLimitsPath))}\n              onChangeCPU={(value) => handleFormDataUpdate(`${path}.${cpuLimitsPath}`, value)}\n              onChangeMemory={(value) => handleFormDataUpdate(`${path}.${memoryLimitsPath}`, value)}\n              onChangeStorage={(value) =>\n                handleFormDataUpdate(`${path}.${storageLimitsPath}`, value)\n              }\n              path={`${id}.limits`}\n            />\n          </dd>\n          <dt>Requests</dt>\n          <dd>\n            <ResourceRequirements\n              cpu={currentValue.getIn(_.toPath(cpuRequestsPath))}\n              memory={currentValue.getIn(_.toPath(memoryRequestsPath))}\n              storage={currentValue.getIn(_.toPath(storageRequestsPath))}\n              onChangeCPU={(value) => handleFormDataUpdate(`${path}.${cpuRequestsPath}`, value)}\n              onChangeMemory={(value) =>\n                handleFormDataUpdate(`${path}.${memoryRequestsPath}`, value)\n              }\n              onChangeStorage={(value) =>\n                handleFormDataUpdate(`${path}.${storageRequestsPath}`, value)\n              }\n              path={`${id}.requests`}\n            />\n          </dd>\n        </dl>\n      );\n    }\n    if (capabilities.includes(SpecCapability.password)) {\n      return (\n        <div>\n          <input\n            className=\"pf-c-form-control\"\n            id={id}\n            type=\"password\"\n            {...validation}\n            onChange={({ currentTarget: { value } }) => handleFormDataUpdate(path, value)}\n            value={currentValue}\n          />\n        </div>\n      );\n    }\n    if (capabilities.some((c) => c.startsWith(SpecCapability.k8sResourcePrefix))) {\n      const groupVersionKind: GroupVersionKind = capabilities\n        .find((c) => c.startsWith(SpecCapability.k8sResourcePrefix))\n        .split(SpecCapability.k8sResourcePrefix)[1]\n        .replace('core~v1~', '');\n      const k8sModel = modelFor(groupVersionKind);\n      if (!k8sModel) {\n        // eslint-disable-next-line no-console\n        console.warn('[Legacy CreateOperandForm] Cluster does not have resource', groupVersionKind);\n      }\n      return k8sModel ? (\n        <ListDropdown\n          id={id}\n          resources={[\n            {\n              kind: groupVersionKind,\n              namespace: k8sModel.namespaced ? match?.params?.ns : null,\n            },\n          ]}\n          desc={displayName}\n          placeholder={`Select ${kindForReference(groupVersionKind)}`}\n          onChange={(value) => handleFormDataUpdate(path, value)}\n          selectedKey={currentValue ? `${currentValue}-${k8sModel?.kind}` : null}\n        />\n      ) : null;\n    }\n    if (capabilities.includes(SpecCapability.checkbox)) {\n      return (\n        <Checkbox\n          id={id}\n          style={{ marginLeft: '10px' }}\n          isChecked={(_.isNil(currentValue) ? false : currentValue) as boolean}\n          label={displayName}\n          required={required}\n          onChange={(value) => handleFormDataUpdate(path, value)}\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.booleanSwitch)) {\n      return (\n        <Switch\n          key={id}\n          id={id}\n          isChecked={(_.isNil(currentValue) ? false : currentValue) as boolean}\n          onChange={(value) => handleFormDataUpdate(path, value)}\n          label=\"True\"\n          labelOff=\"False\"\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.imagePullPolicy)) {\n      return (\n        <RadioGroup\n          id={id}\n          currentValue={currentValue}\n          items={_.values(ImagePullPolicy).map((policy) => ({\n            value: policy,\n            title: policy,\n          }))}\n          onChange={({ currentTarget: { value } }) => handleFormDataUpdate(path, value)}\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.updateStrategy)) {\n      const maxUnavailablePath = `rollingUpdate.maxUnavailable`;\n      const maxSurgePath = `rollingUpdate.maxSurge`;\n      return (\n        <ConfigureUpdateStrategy\n          strategyType={currentValue.get('type')}\n          maxUnavailable={currentValue.getIn(_.toPath(maxUnavailablePath))}\n          maxSurge={currentValue.getIn(_.toPath(maxSurgePath))}\n          onChangeStrategyType={(value) => handleFormDataUpdate(`${path}.type`, value)}\n          onChangeMaxUnavailable={(value) =>\n            handleFormDataUpdate(`${path}.${maxUnavailablePath}`, value)\n          }\n          onChangeMaxSurge={(value) => handleFormDataUpdate(`${path}.${maxSurgePath}`, value)}\n          replicas={1}\n          uid={id}\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.text)) {\n      return (\n        <div>\n          <input\n            key={id}\n            className=\"pf-c-form-control\"\n            id={id}\n            type=\"text\"\n            onChange={({ currentTarget: { value } }) => handleFormDataUpdate(path, value)}\n            value={currentValue}\n          />\n        </div>\n      );\n    }\n    if (capabilities.includes(SpecCapability.number)) {\n      return (\n        <div>\n          <input\n            key={path}\n            className=\"pf-c-form-control\"\n            id={id}\n            type=\"number\"\n            onChange={({ currentTarget: { value } }) =>\n              handleFormDataUpdate(path, value !== '' ? _.toNumber(value) : '')\n            }\n            value={currentValue !== '' ? _.toNumber(currentValue) : ''}\n          />\n        </div>\n      );\n    }\n    if (capabilities.includes(SpecCapability.nodeAffinity)) {\n      return (\n        <div style={{ marginLeft: '15px' }}>\n          <NodeAffinity\n            affinity={currentValue.toJS() as NodeAffinityType}\n            onChange={(value) => handleFormDataUpdate(path, Immutable.fromJS(value))}\n            uid={id}\n          />\n        </div>\n      );\n    }\n    if (\n      capabilities.includes(SpecCapability.podAffinity) ||\n      capabilities.includes(SpecCapability.podAntiAffinity)\n    ) {\n      return (\n        <div style={{ marginLeft: '15px' }}>\n          <PodAffinity\n            affinity={currentValue.toJS()}\n            onChange={(value) => handleFormDataUpdate(path, Immutable.fromJS(value))}\n            uid={id}\n          />\n        </div>\n      );\n    }\n    if (capabilities.some((c) => c.startsWith(SpecCapability.select))) {\n      return (\n        <div>\n          <Dropdown\n            id={id}\n            title={`Select ${displayName}`}\n            selectedKey={currentValue}\n            items={capabilities\n              .filter((c) => c.startsWith(SpecCapability.select))\n              .map((c) => c.split(SpecCapability.select)[1])\n              .reduce((all, option) => ({ [option]: option, ...all }), {})}\n            onChange={(value) => handleFormDataUpdate(path, value)}\n          />\n        </div>\n      );\n    }\n    return null;\n  };\n\n  /* Inserts an arrayFieldGroup at nextIndex. The fieldList argument is an array of fields\n   * representing a single element in an arrayFieldGroup. To add an arrayFieldGroup, we duplicate\n   * each field in this fieldList, replacing the array index in field.path with the nextIndex\n   * argument\n   */\n  const addArrayFieldGroup = (fieldLists: OperandField[][]) => {\n    // Duplicate each field in fieldList, creating the corresponding field and formValue at\n    // arrayFieldGroup[nextIndex]\n    const addedFields = _.reduce(\n      _.last(fieldLists),\n      (fieldAccumulator, field) => {\n        // Replace index of field with nextIndex\n        const path = modifyArrayFieldPathIndex(field.path, () => fieldLists.length);\n        return [...fieldAccumulator, { ...field, path }];\n      },\n      [],\n    );\n\n    setFields((currentFields) => [...currentFields, ...addedFields]);\n  };\n\n  // Removes fields corresponding to an  arrayFieldGroup index from the form\n  const removeArrayFieldGroup = (fieldLists: OperandField[][], indexToRemove: number) => {\n    // Flat array of fields in this arrayFieldGroup at index > removed.\n    const fieldsToLeftShift = _.flatten(\n      _.filter(fieldLists, (_unused, index) => index > indexToRemove),\n    );\n\n    // List of paths to be removed from fields list. Fields and values in fieldsToLeftShift\n    // will be replaced with left-shifted equivalents\n    const fieldPathsToRemove = _.map([...fieldLists[indexToRemove], ...fieldsToLeftShift], 'path');\n    const [regexMatch, formDataPathToRemove] =\n      (fieldPathsToRemove?.[0] || '').match(/^(.*\\[\\d+\\]).*$/) || [];\n\n    const leftShiftedFields = _.reduce(\n      fieldsToLeftShift,\n      (fieldAccumulator, field) => {\n        const path = modifyArrayFieldPathIndex(field.path, (index) => index - 1);\n        return [...fieldAccumulator, { ...field, path }];\n      },\n      [],\n    );\n\n    // Remove arrayFieldGroup from fields and replace subsequent arrayFieldGroup fields with\n    // left-shifted ones.\n    setFields((currentFields) => {\n      return [\n        // Filter out all removed fields and fields that need to be left-shifted\n        ..._.filter(currentFields, (field) => !_.includes(fieldPathsToRemove, field.path)),\n        // Add new left-shifted fields\n        ...leftShiftedFields,\n      ];\n    });\n    regexMatch && handleFormDataDelete(formDataPathToRemove);\n  };\n\n  const renderArrayFieldGroups = () =>\n    _.map(_.sortBy(arrayFieldGroups, 'groupName'), ({ fieldLists, groupName }) => {\n      // If there is no name for this fieldGroup, or no fields associated with the group name, don't\n      // render anything\n      if (_.isEmpty(groupName) || _.isEmpty(fieldLists)) {\n        return null;\n      }\n\n      const groupDisplayName = _.startCase(groupName);\n      const singularGroupDisplayName = groupDisplayName.replace(/s$/, '');\n      const id = `root_spec_${groupName}`;\n      const isExpanded = !_.some(fieldLists, (fieldList) =>\n        _.some(fieldList, (f) => hasDescriptor(f, SpecCapability.advanced) && !f.required),\n      );\n\n      return (\n        <FieldGroup id={id} isExpanded={isExpanded} key={id} label={groupDisplayName}>\n          {_.map(fieldLists, (fieldList, index) => (\n            <React.Fragment key={`${groupName}-${index}`}>\n              {index > 0 && <hr />}\n              {fieldLists.length > 1 && (\n                <div className=\"row co-array-field-group__remove\">\n                  <Button\n                    type=\"button\"\n                    className=\"co-array-field-group__remove-btn\"\n                    onClick={() => removeArrayFieldGroup(fieldLists, index)}\n                    variant=\"link\"\n                  >\n                    <MinusCircleIcon className=\"co-icon-space-r\" />\n                    Remove {singularGroupDisplayName}\n                  </Button>\n                </div>\n              )}\n              {_.map(fieldList, (field) => (\n                <OperandFormInputGroup\n                  key={field.path}\n                  error={formErrors?.[field.path]}\n                  field={field}\n                  input={inputFor(field)}\n                />\n              ))}\n            </React.Fragment>\n          ))}\n          <div className=\"row\">\n            <Button type=\"button\" onClick={() => addArrayFieldGroup(fieldLists)} variant=\"link\">\n              <PlusCircleIcon className=\"co-icon-space-r\" />\n              Add {singularGroupDisplayName}\n            </Button>\n          </div>\n        </FieldGroup>\n      );\n    });\n\n  const renderFieldGroups = () =>\n    _.map(_.sortBy(fieldGroups, 'groupName'), ({ fieldList, groupName }) => {\n      if (_.isEmpty(groupName) || _.isEmpty(fieldList)) {\n        return null;\n      }\n      const id = `root_spec_${groupName}`;\n      const isExpanded = !_.some(\n        fieldList,\n        (f) => f.capabilities.includes(SpecCapability.advanced) && !f.required,\n      );\n      return (\n        <FieldGroup key={id} id={id} isExpanded={isExpanded} label={_.startCase(groupName)}>\n          {_.map(fieldList, (field) => (\n            <OperandFormInputGroup\n              key={field.path}\n              error={formErrors?.[field.path]}\n              field={field}\n              input={inputFor(field)}\n            />\n          ))}\n        </FieldGroup>\n      );\n    });\n\n  const renderNormalFields = () =>\n    _.map(normalFields, (field) => (\n      <OperandFormInputGroup\n        key={field.path}\n        field={field}\n        input={inputFor(field)}\n        error={formErrors?.[field.path]}\n      />\n    ));\n\n  const renderAdvancedFields = () =>\n    advancedFields.length > 0 && (\n      <div>\n        <ExpandCollapse\n          textExpanded=\"Advanced Configuration\"\n          textCollapsed=\"Advanced Configuration\"\n        >\n          {_.map(advancedFields, (field) => (\n            <OperandFormInputGroup\n              key={field.path}\n              field={field}\n              input={inputFor(field)}\n              error={formErrors?.[field.path]}\n            />\n          ))}\n        </ExpandCollapse>\n      </div>\n    );\n  useScrollToTopOnMount();\n\n  return (\n    <div className=\"co-m-pane__body\">\n      <div className=\"row\">\n        <div className=\"col-md-8 col-lg-7\">\n          <Alert\n            isInline\n            className=\"co-alert co-break-word\"\n            variant=\"info\"\n            title={\n              'Note: Some fields may not be represented in this form. Please select \"YAML View\" for full control of object creation.'\n            }\n          />\n          <form className=\"co-dynamic-form\" onSubmit={submit}>\n            <Accordion asDefinitionList={false} className=\"co-dynamic-form__accordion\">\n              <div key={'metadata.name'} className=\"form-group\">\n                <label className=\"control-label co-required\" htmlFor=\"name\">\n                  Name\n                </label>\n                <input\n                  className=\"pf-c-form-control\"\n                  type=\"text\"\n                  onChange={({ target: { value } }) => handleFormDataUpdate('metadata.name', value)}\n                  value={immutableFormData.getIn(['metadata', 'name']) || 'example'}\n                  id=\"root_metadata_name\"\n                  required\n                />\n              </div>\n              <div key={'root_metadata_labels'} className=\"form-group\">\n                <label className=\"control-label\" htmlFor=\"tags-input\">\n                  Labels\n                </label>\n                <SelectorInput\n                  onChange={(value) =>\n                    handleFormDataUpdate(\n                      'metadata.labels',\n                      Immutable.fromJS(SelectorInput.objectify(value)),\n                    )\n                  }\n                  tags={labelTags}\n                />\n              </div>\n              {renderArrayFieldGroups()}\n              {renderFieldGroups()}\n              {renderNormalFields()}\n              {renderAdvancedFields()}\n            </Accordion>\n            {(!_.isEmpty(error) || !_.isEmpty(_.compact(_.values(formErrors)))) && (\n              <Alert\n                isInline\n                className=\"co-alert co-break-word co-alert--scrollable\"\n                variant=\"danger\"\n                title=\"Error\"\n              >\n                {error || 'Fix above errors'}\n              </Alert>\n            )}\n            <div style={{ paddingBottom: '30px' }}>\n              <ActionGroup className=\"pf-c-form\">\n                <Button onClick={submit} type=\"submit\" variant=\"primary\">\n                  Create\n                </Button>\n                <Button onClick={history.goBack} variant=\"secondary\">\n                  Cancel\n                </Button>\n              </ActionGroup>\n            </div>\n          </form>\n        </div>\n        <div className=\"col-md-4 col-lg-5\">\n          {csv && providedAPI && (\n            <div style={{ marginBottom: '30px' }}>\n              <ClusterServiceVersionLogo\n                displayName={providedAPI.displayName}\n                icon={_.get(csv, 'spec.icon[0]')}\n                provider={_.get(csv, 'spec.provider')}\n              />\n              {providedAPI.description}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\ntype Capability = SpecCapability | StatusCapability;\n\n/**\n * Combines OLM descriptor with JSONSchema.\n */\ntype OperandField = {\n  path: string;\n  displayName: string;\n  description?: string;\n  type: JSONSchema6TypeName;\n  required: boolean;\n  validation: {\n    [Validations.maximum]?: number;\n    [Validations.minimum]?: number;\n    [Validations.maxLength]?: number;\n    [Validations.pattern]?: string;\n    [Validations.minLength]?: number;\n  };\n  capabilities: Capability[];\n};\n\ntype FlattenNestedPropertiesAccumulator = {\n  currentCapabilities?: Capability[];\n  currentPath?: string[];\n  fields?: OperandField[];\n  required: boolean;\n};\n\ntype FieldErrors = {\n  [path: string]: string;\n};\n\ntype OperandFormInputGroupProps = {\n  field: OperandField;\n  input: JSX.Element;\n  error: string;\n};\n\ntype FieldGroupProps = {\n  isExpanded?: boolean;\n  id: string;\n  label: string;\n};\n","import * as _ from 'lodash';\nimport * as React from 'react';\nimport { JSONSchema6 } from 'json-schema';\nimport {\n  K8sKind,\n  K8sResourceKind,\n  K8sResourceKindReference,\n  kindForReference,\n  referenceForModel,\n  nameForModel,\n  CustomResourceDefinitionKind,\n  definitionFor,\n} from '@console/internal/module/k8s';\nimport { CustomResourceDefinitionModel } from '@console/internal/models';\nimport { Firehose } from '@console/internal/components/utils/firehose';\nimport {\n  StatusBox,\n  FirehoseResult,\n  BreadCrumbs,\n  resourcePathFromModel,\n} from '@console/internal/components/utils';\nimport { RootState } from '@console/internal/redux';\nimport { SyncedEditor } from '@console/shared/src/components/synced-editor';\nimport { getActivePerspective } from '@console/internal/reducers/ui';\nimport { EditorType } from '@console/shared/src/components/synced-editor/editor-toggle';\nimport { connect } from 'react-redux';\nimport { Helmet } from 'react-helmet';\nimport { match as RouterMatch } from 'react-router';\nimport { ClusterServiceVersionModel } from '../../models';\nimport { ClusterServiceVersionKind, ProvidedAPI } from '../../types';\nimport { OperandForm } from './operand-form';\nimport { OperandYAML } from './operand-yaml';\nimport { exampleForModel, providedAPIForModel } from '..';\nimport { FORM_HELP_TEXT, YAML_HELP_TEXT, DEFAULT_K8S_SCHEMA } from './const';\nimport { getSchemaErrors, prune } from '@console/shared/src/components/dynamic-form/utils';\nimport { hasNoFields } from './utils';\n// eslint-disable-next-line @typescript-eslint/camelcase\nimport { DEPRECATED_CreateOperandForm } from './DEPRECATED_operand-form';\n\nexport const CreateOperand: React.FC<CreateOperandProps> = ({\n  clusterServiceVersion,\n  customResourceDefinition,\n  initialEditorType,\n  loaded,\n  loadError,\n  match,\n  model,\n  activePerspective,\n}) => {\n  const { data: csv } = clusterServiceVersion;\n  const { data: crd } = customResourceDefinition;\n  const [helpText, setHelpText] = React.useState(FORM_HELP_TEXT);\n  const next =\n    activePerspective === 'dev'\n      ? '/topology'\n      : `${resourcePathFromModel(\n          ClusterServiceVersionModel,\n          match.params.appName,\n          match.params.ns,\n        )}/${match.params.plural}`;\n\n  const providedAPI = React.useMemo<ProvidedAPI>(() => providedAPIForModel(csv, model), [\n    csv,\n    model,\n  ]);\n\n  // TODO This logic should be removed in 4.6 and we should only be using\n  // the OperandForm component. We are providing a temporary fallback\n  // to the old form component to ease the transition to structural schemas\n  // over descriptors. In 4.6, structural schemas will be required, and\n  // the fallback will no longer be necessary/provided. If no structural schema\n  // is provided in 4.6, a form will not be generated.\n  const [schema, FormComponent] = React.useMemo(() => {\n    const baseSchema =\n      crd?.spec?.validation?.openAPIV3Schema ?? (definitionFor(model) as JSONSchema6);\n    const useFallback =\n      getSchemaErrors(baseSchema).length ||\n      hasNoFields((baseSchema?.properties?.spec ?? {}) as JSONSchema6);\n    return useFallback\n      ? // eslint-disable-next-line @typescript-eslint/camelcase\n        [baseSchema, DEPRECATED_CreateOperandForm]\n      : [\n          _.defaultsDeep({}, DEFAULT_K8S_SCHEMA, _.omit(baseSchema, 'properties.status')),\n          OperandForm,\n        ];\n  }, [crd, model]);\n\n  const sample = React.useMemo<K8sResourceKind>(() => exampleForModel(csv, model), [csv, model]);\n\n  const pruneFunc = React.useCallback((data) => prune(data, sample), [sample]);\n\n  const onChangeEditorType = React.useCallback((newMethod) => {\n    setHelpText(newMethod === EditorType.Form ? FORM_HELP_TEXT : YAML_HELP_TEXT);\n  }, []);\n\n  return (\n    <StatusBox loaded={loaded} loadError={loadError} data={clusterServiceVersion}>\n      {loaded ? (\n        <>\n          <div className=\"co-create-operand__header\">\n            <div className=\"co-create-operand__header-buttons\">\n              <BreadCrumbs\n                breadcrumbs={[\n                  {\n                    name: csv.spec.displayName,\n                    path: resourcePathFromModel(\n                      ClusterServiceVersionModel,\n                      csv.metadata.name,\n                      csv.metadata.namespace,\n                    ),\n                  },\n                  { name: `Create ${model.label}`, path: window.location.pathname },\n                ]}\n              />\n            </div>\n            <h1 className=\"co-create-operand__header-text\">{`Create ${model.label}`}</h1>\n            <p className=\"help-block\">{helpText}</p>\n          </div>\n          <SyncedEditor\n            context={{\n              formContext: { csv, match, model, next, schema, providedAPI },\n              yamlContext: { next, match },\n            }}\n            FormEditor={FormComponent}\n            initialData={sample}\n            initialType={initialEditorType}\n            onChangeEditorType={onChangeEditorType}\n            prune={pruneFunc}\n            YAMLEditor={OperandYAML}\n          />\n        </>\n      ) : null}\n    </StatusBox>\n  );\n};\n\nconst stateToProps = (state: RootState, props: Omit<CreateOperandPageProps, 'model'>) => ({\n  model: state.k8s.getIn(['RESOURCES', 'models', props.match.params.plural]) as K8sKind,\n  activePerspective: getActivePerspective(state),\n});\n\nexport const CreateOperandPage = connect(stateToProps)((props: CreateOperandPageProps) => (\n  <>\n    <Helmet>\n      <title>{`Create ${kindForReference(props.match.params.plural)}`}</title>\n    </Helmet>\n    {props.model && (\n      <Firehose\n        resources={[\n          {\n            kind: referenceForModel(ClusterServiceVersionModel),\n            name: props.match.params.appName,\n            namespace: props.match.params.ns,\n            isList: false,\n            prop: 'clusterServiceVersion',\n          },\n          {\n            kind: CustomResourceDefinitionModel.kind,\n            isList: false,\n            name: nameForModel(props.model),\n            prop: 'customResourceDefinition',\n            optional: true,\n          },\n        ]}\n      >\n        {/* FIXME(alecmerdler): Hack because `Firehose` injects props without TypeScript knowing about it */}\n        <CreateOperand\n          {...(props as any)}\n          model={props.model}\n          match={props.match}\n          initialEditorType={EditorType.Form}\n        />\n      </Firehose>\n    )}\n  </>\n));\n\nexport type CreateOperandProps = {\n  activePerspective: string;\n  clusterServiceVersion: FirehoseResult<ClusterServiceVersionKind>;\n  customResourceDefinition?: FirehoseResult<CustomResourceDefinitionKind>;\n  initialEditorType: EditorType;\n  loaded: boolean;\n  loadError?: any;\n  match: RouterMatch<{ appName: string; ns: string; plural: K8sResourceKindReference }>;\n  model: K8sKind;\n};\n\nexport type CreateOperandPageProps = {\n  match: RouterMatch<{ appName: string; ns: string; plural: K8sResourceKindReference }>;\n  model: K8sKind;\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAWA;AACA;AACA;AACA;AASA;AAQA;AACA;AACA;AACA;AASA;;;;;;;;;;;;;;;;;;;;AAoBA;AACA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;;;AAeA;AACA;AAEA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAGA;AAIA;AAEA;AACA;AACA;AAEA;;;AAGA;AACA;AAGA;AAEA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AAYA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAEA;;;;;AAKA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAKA;AAGA;AAEA;AACA;AAUA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAMA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAkBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAYA;AACA;AACA;AAgBA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAUA;AACA;AACA;AAUA;AACA;AACA;AAKA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAcA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAEA;AAYA;AACA;AACA;AAEA;AAOA;AACA;AAEA;AAEA;AAEA;AAOA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAKA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AAMA;;AACA;AAIA;AAUA;AACA;AACA;;AACA;AAKA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAYA;AAEA;AAUA;AAGA;AAeA;AAEA;AAEA;AACA;AACA;AAQA;AACA;AACA;AACA;AAGA;AASA;AACA;AAGA;AAUA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAGA;AAOA;AAGA;AAKA;AAOA;;;;;;;;;;;;;ACjsCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAUA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AAYA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;;;;;A","sourceRoot":""}