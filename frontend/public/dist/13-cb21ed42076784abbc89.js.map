{"version":3,"file":"13-cb21ed42076784abbc89.js","sources":["webpack:///./packages/console-shared/src/components/dynamic-form/const.ts","webpack:///./packages/console-shared/src/components/dynamic-form/fields.tsx","webpack:///./packages/console-shared/src/components/dynamic-form/index.tsx","webpack:///./packages/console-shared/src/components/dynamic-form/styles.scss?0b37","webpack:///./packages/console-shared/src/components/dynamic-form/templates.tsx","webpack:///./packages/console-shared/src/components/dynamic-form/types.ts","webpack:///./packages/console-shared/src/components/dynamic-form/utils.ts","webpack:///./packages/console-shared/src/components/dynamic-form/widgets.tsx","webpack:///./packages/console-shared/src/components/synced-editor/editor-toggle.tsx","webpack:///./packages/console-shared/src/components/synced-editor/index.tsx","webpack:///./packages/console-shared/src/components/synced-editor/styles.scss?d7a0","webpack:///./packages/console-shared/src/utils/yaml.ts","webpack:///./packages/operator-lifecycle-manager/src/components/descriptors/spec/additional-properties.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/descriptors/spec/affinity.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/descriptors/spec/match-expressions.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/descriptors/spec/spec-descriptor-input.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/operand/const.ts","webpack:///./packages/operator-lifecycle-manager/src/components/operand/operand-form.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/operand/operand-yaml.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/operand/utils.ts","webpack:///./public/components/create-yaml.tsx"],"sourcesContent":["export const K8S_UI_SCHEMA = {\n  apiVersion: {\n    'ui:widget': 'hidden',\n    'ui:options': {\n      label: false,\n    },\n  },\n  kind: {\n    'ui:widget': 'hidden',\n    'ui:options': {\n      label: false,\n    },\n  },\n  spec: {\n    'ui:options': {\n      label: false,\n    },\n  },\n  status: {\n    'ui:widget': 'hidden',\n    'ui:options': {\n      label: false,\n    },\n  },\n  'ui:order': ['metadata', 'spec', '*'],\n};\n\nexport const JSON_SCHEMA_GROUP_TYPES: string[] = ['object', 'array'];\nexport const JSON_SCHEMA_NUMBER_TYPES: string[] = ['number', 'integer'];\n","import * as _ from 'lodash';\nimport * as classnames from 'classnames';\nimport * as React from 'react';\nimport { JSONSchema6 } from 'json-schema';\nimport { getUiOptions } from 'react-jsonschema-form/lib/utils';\nimport { FieldProps, UiSchema } from 'react-jsonschema-form';\nimport SchemaField, { SchemaFieldProps } from 'react-jsonschema-form/lib/components/fields/SchemaField';\nimport { LinkifyExternal, SelectorInput, Dropdown } from '@console/internal/components/utils';\nimport { AccordionContent, AccordionItem, AccordionToggle, Switch } from '@patternfly/react-core';\nimport { MatchExpressions } from '@console/operator-lifecycle-manager/src/components/descriptors/spec/match-expressions';\nimport { ResourceRequirements } from '@console/operator-lifecycle-manager/src/components/descriptors/spec/resource-requirements';\nimport { AdditionalPropertyFields } from '@console/operator-lifecycle-manager/src/components/descriptors/spec/additional-properties';\nimport { ConfigureUpdateStrategy, UPDATE_STRATEGY_DESCRIPTION } from '@console/internal/components/modals/configure-update-strategy-modal';\nimport { NodeAffinity, PodAffinity } from '@console/operator-lifecycle-manager/src/components/descriptors/spec/affinity';\nimport { getSchemaErrors, useSchemaDescription, useSchemaLabel } from './utils';\n// import { useTranslation } from 'react-i18next';\nconst Description = ({ id, description }) =>\n  description ? (\n    <span id={id} className=\"help-block\">\n      <LinkifyExternal>\n        <div className=\"co-pre-line\">{description}</div>\n      </LinkifyExternal>\n    </span>\n  ) : null;\n\nexport const DescriptionField: React.FC<FieldProps> = ({ id, description }) => {\n  // const { t } = useTranslation();\n  // return <Description id={id} description={t(`COMMON:${description}`)} />;\n  return <Description id={id} description={description} />;\n};\n\nexport const FormField: React.FC<FormFieldProps> = ({ children, id, defaultLabel, required, schema, uiSchema }) => {\n  const [showLabel, label] = useSchemaLabel(schema, uiSchema, defaultLabel || 'Value');\n  return (\n    <div id={`${id}_field`} className=\"form-group\">\n      {showLabel && label && (\n        <label className={classnames('form-label', { 'co-required': required })} htmlFor={id}>\n          {label}\n        </label>\n      )}\n      {children}\n    </div>\n  );\n};\n\nexport const FieldSet: React.FC<FieldSetProps> = ({ children, defaultLabel, idSchema, required = false, schema, uiSchema }) => {\n  const [expanded, setExpanded] = React.useState(false);\n  const [showLabel, label] = useSchemaLabel(schema, uiSchema, defaultLabel);\n  const description = useSchemaDescription(schema, uiSchema);\n  const onToggle = e => {\n    e.preventDefault();\n    setExpanded(current => !current);\n  };\n  return showLabel && label ? (\n    <div id={`${idSchema.$id}_field-group`} className=\"form-group co-dynamic-form__field-group\">\n      <AccordionItem>\n        <AccordionToggle id={`${idSchema.$id}_accordion-toggle`} onClick={onToggle} isExpanded={expanded}>\n          <label className={classnames({ 'co-required': required })} htmlFor={`${idSchema.$id}_accordion-content`}>\n            {_.startCase(label)}\n          </label>\n        </AccordionToggle>\n        {description && <Description id={`${idSchema.$id}_description`} description={description} />}\n        <AccordionContent id={`${idSchema.$id}_accordion-content`} isHidden={!expanded}>\n          {children}\n        </AccordionContent>\n      </AccordionItem>\n    </div>\n  ) : (\n    <>{children}</>\n  );\n};\n\nexport const UpdateStrategyField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => {\n  const description = useSchemaDescription(schema, uiSchema, UPDATE_STRATEGY_DESCRIPTION);\n  return (\n    <FormField defaultLabel={name || 'Update Strategy'} id={idSchema.$id} required={required} schema={schema} uiSchema={uiSchema}>\n      <Description description={description} id={idSchema.$id} />\n      <ConfigureUpdateStrategy\n        showDescription={false}\n        strategyType={formData?.type || 'RollingUpdate'}\n        maxUnavailable={formData?.rollingUpdate?.maxUnavailable || ''}\n        maxSurge={formData?.rollingUpdate?.maxSurge || ''}\n        onChangeStrategyType={type => onChange(_.set(_.cloneDeep(formData), 'type', type))}\n        onChangeMaxUnavailable={maxUnavailable => onChange(_.set(_.cloneDeep(formData), 'rollingUpdate.maxUnavailable', maxUnavailable))}\n        onChangeMaxSurge={maxSurge => onChange(_.set(_.cloneDeep(formData), 'rollingUpdate.maxSurge', maxSurge))}\n        replicas={1}\n        uid={idSchema.$id}\n      />\n    </FormField>\n  );\n};\n\nexport const NodeAffinityField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => (\n  <FieldSet defaultLabel={name || 'Node Affinity'} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n    <NodeAffinity affinity={formData} onChange={affinity => onChange(affinity)} uid={idSchema.$id} />\n  </FieldSet>\n);\n\nexport const PodAffinityField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => (\n  <FieldSet defaultLabel={name || 'Pod Affinity'} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n    <PodAffinity affinity={formData} onChange={affinity => onChange(affinity)} uid={idSchema.$id} />\n  </FieldSet>\n);\n\nexport const MatchExpressionsField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => (\n  <FieldSet defaultLabel={name || 'Match Expressions'} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n    <MatchExpressions matchExpressions={formData} onChange={v => onChange(v)} uid={idSchema.$id} />\n  </FieldSet>\n);\n\nexport const BooleanField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, uiSchema }) => {\n  const { labelOn = 'true', labelOff = 'false' } = getUiOptions(uiSchema);\n  return (\n    <div>\n      <Switch id={idSchema?.$id || name} key={idSchema?.$id || name} isChecked={_.isNil(formData) ? false : formData} onChange={v => onChange(v)} label={labelOn as string} labelOff={labelOff as string} />\n    </div>\n  );\n};\n\nexport const LabelsField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => (\n  <FormField defaultLabel={name} id={idSchema.$id} required={required} schema={schema} uiSchema={uiSchema}>\n    <SelectorInput inputProps={{ id: idSchema.$id }} onChange={newValue => onChange(SelectorInput.objectify(newValue))} tags={SelectorInput.arrayify(formData)} />\n  </FormField>\n);\n\nexport const ResourceRequirementsField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => (\n  <FieldSet defaultLabel={name || 'Resource Requirements'} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n    <dl id={idSchema.$id}>\n      <dt>Limits</dt>\n      <dd>\n        <ResourceRequirements cpu={formData?.limits?.cpu || ''} memory={formData?.limits?.memory || ''} storage={formData?.limits?.['ephemeral-storage'] || ''} onChangeCPU={cpu => onChange(_.set(_.cloneDeep(formData), 'limits.cpu', cpu))} onChangeMemory={mem => onChange(_.set(_.cloneDeep(formData), 'limits.memory', mem))} onChangeStorage={sto => onChange(_.set(_.cloneDeep(formData), 'limits.ephemeral-storage', sto))} path={`${idSchema.$id}.limits`} />\n      </dd>\n      <dt>Requests</dt>\n      <dd>\n        <ResourceRequirements cpu={formData?.requests?.cpu || ''} memory={formData?.requests?.memory || ''} storage={formData?.requests?.['ephemeral-storage'] || ''} onChangeCPU={cpu => onChange(_.set(_.cloneDeep(formData), 'requests.cpu', cpu))} onChangeMemory={mem => onChange(_.set(_.cloneDeep(formData), 'requests.memory', mem))} onChangeStorage={sto => onChange(_.set(_.cloneDeep(formData), 'requests.ephemeral-storage', sto))} path={`${idSchema.$id}.requests`} />\n      </dd>\n    </dl>\n  </FieldSet>\n);\nexport const AdditionalPropertyField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, required, schema, uiSchema }) => (\n  <FieldSet defaultLabel={name || 'Resource Requirements'} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n    <AdditionalPropertyFields data={formData} onChange={onChange} path={`${idSchema.$id}`}></AdditionalPropertyFields>\n  </FieldSet>\n);\n\nexport const DropdownField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, schema, uiSchema = {} }) => {\n  const { items, title } = getUiOptions(uiSchema);\n  return <Dropdown id={idSchema.$id} key={idSchema.$id} title={`Select ${title || schema?.title || name}`} selectedKey={formData} items={items ?? {}} onChange={val => onChange(val)} />;\n};\n\nexport const TextField: React.FC<FieldProps> = ({ formData, idSchema, name, onChange, onBlur, schema, uiSchema = {}, disabled = false, required = false, readonly = false }) => {\n  return <input className=\"pf-c-form-control\" disabled={disabled} id={idSchema.$id} key={idSchema.$id} onBlur={onBlur && (event => onBlur(idSchema.$id, event.target.value))} onChange={({ currentTarget }) => onChange(currentTarget.value)} readOnly={readonly} required={required} type=\"text\" value={formData} />;\n};\n\nexport const CustomSchemaField: React.FC<SchemaFieldProps> = props => {\n  const errors = getSchemaErrors(props.schema ?? {});\n  if (errors.length) {\n    // eslint-disable-next-line no-console\n    console.warn('DynamicForm component does not support the provided JSON schema: ', errors);\n    return null;\n  }\n\n  return <SchemaField {...props} />;\n};\n\nexport const NullField = () => null;\n\nexport default {\n  TextField,\n  AdditionalPropertyField,\n  BooleanField,\n  DescriptionField,\n  DropdownField,\n  LabelsField,\n  MatchExpressionsField,\n  NodeAffinityField,\n  NullField,\n  PodAffinityField,\n  ResourceRequirementsField,\n  SchemaField: CustomSchemaField,\n  UpdateStrategyField,\n};\n\ntype FormFieldProps = {\n  id: string;\n  defaultLabel?: string;\n  required: boolean;\n  schema: JSONSchema6;\n  uiSchema: UiSchema;\n};\n\ntype FieldSetProps = Pick<FieldProps, 'idSchema' | 'required' | 'schema' | 'uiSchema'> & {\n  defaultLabel?: string;\n};\n","import * as _ from 'lodash';\nimport * as React from 'react';\nimport Form, { FormProps } from 'react-jsonschema-form';\nimport { Accordion, ActionGroup, Button, Alert } from '@patternfly/react-core';\nimport { history } from '@console/internal/components/utils';\nimport defaultWidgets from './widgets';\nimport defaultFields from './fields';\nimport { FieldTemplate as DefaultFieldTemplate, ObjectFieldTemplate as DefaultObjectFieldTemplate, ArrayFieldTemplate as DefaultArrayFieldTemplate, ErrorTemplate as DefaultErrorTemplate } from './templates';\nimport { K8S_UI_SCHEMA } from './const';\nimport { getSchemaErrors } from './utils';\nimport './styles.scss';\n\nexport const DynamicForm: React.FC<DynamicFormProps> = ({ ArrayFieldTemplate = DefaultArrayFieldTemplate, errors = [], ErrorTemplate = DefaultErrorTemplate, fields = {}, FieldTemplate = DefaultFieldTemplate, formContext, formData = {}, noValidate = false, ObjectFieldTemplate = DefaultObjectFieldTemplate, onChange = _.noop, onError = _.noop, onSubmit = _.noop, schema, uiSchema = {}, widgets = {} }) => {\n  const schemaErrors = getSchemaErrors(schema);\n  // IF the top level schema is unsupported, don't render a form at all.\n  if (schemaErrors.length) {\n    // eslint-disable-next-line no-console\n    console.warn('A form could not be generated for this resource.', schemaErrors);\n    return <Alert isInline className=\"co-alert co-break-word\" variant=\"info\" title={'A form is not available for this resource. Please use the YAML View.'} />;\n  }\n  return (\n    <>\n      <Alert isInline className=\"co-alert co-break-word\" variant=\"info\" title={'Note: Some fields may not be represented in this form. Please select \"YAML View\" for full control of object creation.'} />\n      <Accordion asDefinitionList={false} className=\"co-dynamic-form__accordion\">\n        <Form\n          className=\"co-dynamic-form\"\n          // liveValidate={true}\n          noValidate\n          ArrayFieldTemplate={ArrayFieldTemplate}\n          fields={{ ...defaultFields, ...fields }}\n          FieldTemplate={FieldTemplate}\n          formContext={{ ...formContext, formData }}\n          formData={formData}\n          noHtml5Validate\n          ObjectFieldTemplate={ObjectFieldTemplate}\n          onChange={next => onChange(next.formData)}\n          onError={newErrors => onError(_.map(newErrors, error => error.stack))}\n          onSubmit={onSubmit}\n          schema={schema}\n          // Don't show the react-jsonschema-form error list at top\n          showErrorList={false}\n          uiSchema={_.defaultsDeep({}, K8S_UI_SCHEMA, uiSchema)}\n          widgets={{ ...defaultWidgets, ...widgets }}\n        >\n          {errors.length > 0 && <ErrorTemplate errors={errors} />}\n          <div style={{ paddingBottom: '30px' }}>\n            <ActionGroup className=\"pf-c-form\">\n              <Button type=\"submit\" variant=\"primary\">\n                Create\n              </Button>\n              <Button onClick={history.goBack} variant=\"secondary\">\n                Cancel\n              </Button>\n            </ActionGroup>\n          </div>\n        </Form>\n      </Accordion>\n    </>\n  );\n};\n\ntype DynamicFormProps = FormProps<any> & {\n  errors?: string[];\n  ErrorTemplate?: React.FC<{ errors: string[] }>;\n};\n\nexport * from './types';\nexport * from './const';\n","// extracted by mini-css-extract-plugin","import * as _ from 'lodash';\nimport * as React from 'react';\nimport { ArrayFieldTemplateProps, FieldTemplateProps, ObjectFieldTemplateProps } from 'react-jsonschema-form';\nimport { Button, Alert, FormHelperText } from '@patternfly/react-core';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport { JSON_SCHEMA_GROUP_TYPES } from './const';\nimport { getUiOptions, getSchemaType } from 'react-jsonschema-form/lib/utils';\nimport { ExpandCollapse } from '@console/internal/components/utils';\nimport { AdditionalPropertyFields } from '@console/operator-lifecycle-manager/src/components/descriptors/spec/additional-properties';\nimport { FieldSet, FormField } from './fields';\nimport { useSchemaLabel } from './utils';\n\nexport const AtomicFieldTemplate: React.FC<FieldTemplateProps> = ({ children, id, label, rawErrors, description, required, schema, uiSchema }) => {\n  return (\n    <FormField id={id} defaultLabel={label} required={required} schema={schema} uiSchema={uiSchema}>\n      {children}\n      {description}\n      {!_.isEmpty(rawErrors) && (\n        <>\n          {_.map(rawErrors, error => (\n            <FormHelperText key={error} isHidden={false} isError>\n              {_.capitalize(error)}\n            </FormHelperText>\n          ))}\n        </>\n      )}\n    </FormField>\n  );\n};\n\nconst AdvancedProperties: React.FC<Pick<ObjectFieldTemplateProps, 'properties'>> = ({ properties }) => (\n  <ExpandCollapse textCollapsed=\"Advanced Configuration\" textExpanded=\"Advanced Configuration\">\n    {_.map(properties, property => property.content)}\n  </ExpandCollapse>\n);\n\nexport const FieldTemplate: React.FC<FieldTemplateProps> = props => {\n  const { hidden, schema = {}, children, uiSchema = {}, formContext = {} } = props;\n  const type = getSchemaType(schema);\n  const [dependencyMet, setDependencyMet] = React.useState(true);\n  React.useEffect(() => {\n    const { dependency } = getUiOptions(uiSchema ?? {}) as DependencyUIOption; // Type defs for this function are awful\n    if (dependency) {\n      setDependencyMet(dependency.value === _.get(formContext.formData ?? {}, ['spec', ...(dependency.path ?? [])], '').toString());\n    }\n  }, [uiSchema, formContext]);\n\n  if (hidden || !dependencyMet) {\n    return null;\n  }\n  const isGroup = JSON_SCHEMA_GROUP_TYPES.includes(type);\n  return isGroup ? children : <AtomicFieldTemplate {...props} />;\n};\n\nexport const ObjectFieldTemplate: React.FC<ObjectFieldTemplateProps> = ({ idSchema, properties, required, schema, title, uiSchema }) => {\n  const { advanced } = getUiOptions(uiSchema ?? {});\n  const { normalProperties, advancedProperties } = _.groupBy(properties ?? [], ({ name }) => (_.includes(advanced as string[], name) ? 'advancedProperties' : 'normalProperties'));\n  return properties?.length ? (\n    <FieldSet defaultLabel={title} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n      <div className=\"co-dynamic-form__field-group-content\">\n        {normalProperties?.length > 0 && _.map(normalProperties, p => p.content)}\n        {advancedProperties?.length > 0 && <AdvancedProperties properties={advancedProperties} />}\n      </div>\n    </FieldSet>\n  ) : null;\n};\n\nexport const ArrayFieldTemplate: React.FC<ArrayFieldTemplateProps> = ({ idSchema, items, onAddClick, required, schema, title, uiSchema }) => {\n  const [, label] = useSchemaLabel(schema, uiSchema, title ?? 'Items');\n  let singularLabel = label;\n  if (label.match('ss$')) {\n  } else if (label.match('ies$')) {\n    singularLabel = singularLabel.replace(/ies$/, 'y');\n  } else if (label.match('es$')) {\n    if (label.match('oes$') || label.match('ses$') || label.match('xes$') || label.match('ches$') || label.match('shes$')) {\n      singularLabel = singularLabel.replace(/es$/, '');\n    } else {\n      singularLabel = singularLabel.replace(/s$/, '');\n    }\n  } else if (label.match('s$')) {\n    singularLabel = singularLabel.replace(/s$/, '');\n  }\n  return (\n    <FieldSet defaultLabel={label} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n      {_.map(items ?? [], item => {\n        return (\n          <div className=\"co-dynamic-form__array-field-group-item\" key={item.key}>\n            {item.index > 0 && <hr />}\n            {item.hasRemove && (\n              <div className=\"row co-dynamic-form__array-field-group-remove\">\n                <Button id={`${item.key}_remove-btn`} type=\"button\" onClick={item.onDropIndexClick(item.index)} variant=\"link\">\n                  <MinusCircleIcon className=\"co-icon-space-r\" />\n                  Remove {singularLabel}\n                </Button>\n              </div>\n            )}\n            {item.children}\n          </div>\n        );\n      })}\n      <div className=\"row\">\n        <Button id={`${idSchema.$id}_add-btn`} type=\"button\" onClick={onAddClick} variant=\"link\">\n          <PlusCircleIcon className=\"co-icon-space-r\" />\n          Add {singularLabel}\n        </Button>\n      </div>\n    </FieldSet>\n  );\n};\n\nexport const AdditionalFieldTemplate: React.FC<ArrayFieldTemplateProps> = ({ idSchema, items, onAddClick, required, schema, title, uiSchema }) => {\n  const [, label] = useSchemaLabel(schema, uiSchema, title ?? 'Items');\n\n  return (\n    <FieldSet defaultLabel={label} idSchema={idSchema} required={required} schema={schema} uiSchema={uiSchema}>\n      {_.map(items ?? [], item => {\n        return (\n          <div className=\"co-dynamic-form__array-field-group-item\" key={item.key}>\n            {item.index > 0 && <hr />}\n            {item.hasRemove && (\n              <div className=\"row co-dynamic-form__array-field-group-remove\">\n                <Button id={`${item.key}_remove-btn`} type=\"button\" onClick={item.onDropIndexClick(item.index)} variant=\"link\">\n                  <MinusCircleIcon className=\"co-icon-space-r\" />\n                  Remove {label}\n                </Button>\n              </div>\n            )}\n            <AdditionalPropertyFields data={item} onChange={item.onDropIndexClick} path={`${idSchema.$id}`}>\n              {' '}\n            </AdditionalPropertyFields>\n          </div>\n        );\n      })}\n      <div className=\"row\">\n        <Button id={`${idSchema.$id}_add-btn`} type=\"button\" onClick={onAddClick} variant=\"link\">\n          <PlusCircleIcon className=\"co-icon-space-r\" />\n          Add {label}\n        </Button>\n      </div>\n    </FieldSet>\n  );\n};\n\nexport const ErrorTemplate: React.FC<{ errors: string[] }> = ({ errors }) => (\n  <Alert isInline className=\"co-alert co-break-word co-alert--scrollable\" variant=\"danger\" title=\"Error\">\n    Fix the above errors:\n    <ul>\n      {_.map(errors, error => (\n        <li key={error}>{error}</li>\n      ))}\n    </ul>\n  </Alert>\n);\n\ntype DependencyUIOption = {\n  dependency?: {\n    path: string;\n    value: string;\n  };\n};\n","export enum SchemaType {\n  string = 'string',\n  number = 'number',\n  integer = 'integer',\n  boolean = 'boolean',\n  null = 'null',\n  array = 'array',\n  object = 'object',\n}\n","import * as _ from 'lodash';\nimport { JSONSchema6 } from 'json-schema';\nimport { UiSchema } from 'react-jsonschema-form';\nimport { getUiOptions } from 'react-jsonschema-form/lib/utils';\n\nconst UNSUPPORTED_SCHEMA_PROPERTIES = []; // Openshift에서는 oneOf, allOf, anyOf에 대한 schema 무시하도록 해놈. 이거 일단 이유를 모르겠어서 없애놈. 나중에 문제 생기면 다시 봐야할듯.\n\nexport const useSchemaLabel = (schema: JSONSchema6, uiSchema: UiSchema, defaultLabel?: string) => {\n  const options = getUiOptions(uiSchema ?? {});\n  const showLabel = options?.label ?? true;\n  const label = (options?.title || schema?.title || defaultLabel) as string;\n  return [showLabel, label] as [boolean, string];\n};\n\nexport const useSchemaDescription = (schema: JSONSchema6, uiSchema: UiSchema, defaultDescription?: string) => (getUiOptions(uiSchema ?? {})?.description || schema?.description || defaultDescription) as string;\n\nexport const getSchemaErrors = (schema: JSONSchema6): SchemaError[] => {\n  return [\n    ...(_.isEmpty(schema)\n      ? [\n          {\n            title: 'Empty Schema',\n            message: 'Schema is empty.',\n          },\n        ]\n      : []),\n    ..._.map(_.intersection(_.keys(schema), UNSUPPORTED_SCHEMA_PROPERTIES), unsupportedProperty => ({\n      title: 'Unsupported Property',\n      message: `Cannot generate form fields for JSON schema with ${unsupportedProperty} property.`,\n    })),\n  ];\n};\n\n// Returns true if a value is not nil and is empty\nconst definedAndEmpty = value => !_.isNil(value) && _.isEmpty(value);\n\n// Helper function for prune\n// TODO (jon) Make this pure\nconst pruneRecursive = (current: any, sample: any): any => {\n  const valueIsEmpty = (value, key) => _.isNil(value) || _.isNaN(value) || (_.isString(value) && _.isEmpty(value)) || (_.isObject(value) && _.isEmpty(pruneRecursive(value, sample?.[key])));\n\n  // Value should be pruned if it is empty and the correspondeing sample is not explicitly\n  // defined as an empty value.\n  const shouldPrune = (value, key) => valueIsEmpty(value, key) && !definedAndEmpty(sample?.[key]);\n\n  // Prune each property of current value that meets the pruning criteria\n  _.forOwn(current, (value, key) => {\n    if (shouldPrune(value, key)) {\n      delete current[key];\n    }\n  });\n\n  // remove any leftover undefined values from the delete operation on an array\n  if (_.isArray(current)) {\n    _.pull(current, undefined);\n  }\n\n  return current;\n};\n\n// Deeply remove all empty, NaN, null, or undefined values from an object or array. If a value meets\n// the above criteria, but the corresponding sample is explicitly defined as an empty vaolue, it\n// will not be pruned.\n// Based on https://stackoverflow.com/a/26202058/8895304\nexport const prune = (obj: any, sample?: any): any => {\n  return pruneRecursive(_.cloneDeep(obj), sample);\n};\n\ntype SchemaError = {\n  title: string;\n  message: string;\n};\n","import * as _ from 'lodash';\nimport * as React from 'react';\nimport { Checkbox } from '@patternfly/react-core';\nimport { WidgetProps } from 'react-jsonschema-form';\nimport { NumberSpinner, ListDropdown, Dropdown } from '@console/internal/components/utils';\nimport { K8sKind, GroupVersionKind, ImagePullPolicy } from '@console/internal/module/k8s';\nimport { RadioGroup } from '@console/internal/components/radio';\nimport { JSON_SCHEMA_NUMBER_TYPES } from './const';\nimport { getSchemaType } from 'react-jsonschema-form/lib/utils';\n\nexport const TextWidget: React.FC<WidgetProps> = props => {\n  const { disabled = false, id, onBlur, onChange, onFocus, readonly = false, required = false, schema = {}, value = '' } = props;\n  const schemaType = getSchemaType(schema);\n  return JSON_SCHEMA_NUMBER_TYPES.includes(schemaType) ? <NumberWidget {...props} /> : <input className=\"pf-c-form-control\" disabled={disabled} id={id} key={id} onBlur={onBlur && (event => onBlur(id, event.target.value))} onChange={({ currentTarget }) => onChange(currentTarget.value)} onFocus={onFocus && (event => onFocus(id, event.target.value))} readOnly={readonly} required={required} type=\"text\" value={value} />;\n};\n\nexport const NumberWidget: React.FC<WidgetProps> = ({ value, id, onChange }) => {\n  const numberValue = _.toNumber(value);\n  return <input className=\"pf-c-form-control\" id={id} key={id} onChange={({ currentTarget }) => onChange(currentTarget.value !== '' ? _.toNumber(currentTarget.value) : '')} type=\"number\" value={_.isFinite(numberValue) ? numberValue : ''} />;\n};\n\nexport const PasswordWidget: React.FC<WidgetProps> = ({ value = '', id, onChange }) => {\n  return <input className=\"pf-c-form-control\" key={id} id={id} type=\"password\" onChange={({ currentTarget }) => onChange(currentTarget.value)} value={value} />;\n};\n\nexport const CheckboxWidget: React.FC<WidgetProps> = ({ value = false, id, label, onChange, required }) => {\n  return <Checkbox id={id} key={id} isChecked={value} label={label} required={required} onChange={checked => onChange(checked)} />;\n};\n\nexport const PodCountWidget: React.FC<WidgetProps> = ({ value, id, onChange }) => {\n  return <NumberSpinner id={id} className=\"pf-c-form-control\" value={value} onChange={({ currentTarget }) => onChange(_.toInteger(currentTarget.value))} changeValueBy={operation => onChange(_.toInteger(value) + operation)} autoFocus required />;\n};\n\nexport const K8sResourceWidget: React.FC<K8sResourceWidgetProps> = ({ value, id, label, options, formContext, onChange }) => {\n  const { model, groupVersionKind } = options;\n  const { namespace } = formContext;\n  const selectedKey = value ? `${value}-${model.kind}` : null;\n\n  return <div>{!_.isUndefined(model) ? <ListDropdown key={id} id={id} resources={[{ kind: groupVersionKind, namespace: model.namespaced ? namespace : null }]} desc={label} placeholder={`Select ${model.label}`} onChange={next => onChange(next)} selectedKey={selectedKey} /> : <span>Cluster does not have resource {groupVersionKind}</span>}</div>;\n};\n\nexport const ImagePullPolicyWidget: React.FC<WidgetProps> = ({ id, value, onChange }) => {\n  return (\n    <RadioGroup\n      id={id}\n      currentValue={value}\n      items={_.values(ImagePullPolicy).map(policy => ({\n        value: policy,\n        title: policy,\n      }))}\n      onChange={({ currentTarget }) => onChange(currentTarget.value)}\n    />\n  );\n};\n\nexport const SelectWidget: React.FC<WidgetProps> = ({ id, label, onChange, options, schema, value }) => {\n  const { enumOptions = [], title } = options;\n  const items = _.reduce(\n    enumOptions as OptionsList,\n    (itemAccumulator, option) => {\n      return {\n        ...itemAccumulator,\n        [option.label]: option.value,\n      };\n    },\n    {},\n  );\n  return <Dropdown id={id} key={id} title={`Select ${title || schema?.title || label}`} selectedKey={value} items={items} onChange={val => onChange(val)} />;\n};\n\ntype OptionsList = {\n  label: string;\n  value: string;\n}[];\n\ntype K8sResourceWidgetProps = WidgetProps & {\n  options: {\n    model: K8sKind;\n    groupVersionKind: GroupVersionKind;\n  };\n};\n\nexport default {\n  BaseInput: TextWidget,\n  CheckboxWidget,\n  ImagePullPolicyWidget,\n  K8sResourceWidget,\n  NumberWidget,\n  PasswordWidget,\n  PodCountWidget,\n  SelectWidget,\n  TextWidget,\n  int32: NumberWidget,\n  int64: NumberWidget,\n};\n","import * as React from 'react';\nimport { RadioGroup } from '@console/internal/components/radio';\nimport './styles.scss';\n\nexport enum EditorType {\n  Form = 'form',\n  YAML = 'yaml',\n}\n\nexport const EditorToggle: React.FC<EditorToggleProps> = ({ value, onChange }) => {\n  return (\n    <div className=\"co-synced-editor__editor-toggle\">\n      <RadioGroup\n        label=\"Configure via:\"\n        currentValue={value}\n        inline\n        items={[\n          {\n            value: EditorType.Form,\n            title: 'Form View',\n          },\n          {\n            value: EditorType.YAML,\n            title: 'YAML View',\n          },\n        ]}\n        onChange={({ currentTarget }) => onChange(currentTarget.value as EditorType)}\n      />\n    </div>\n  );\n};\n\ntype EditorToggleProps = {\n  value: EditorType;\n  onChange?: (newValue: EditorType) => void;\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { EditorType, EditorToggle } from './editor-toggle';\nimport { safeJSToYAML, asyncYAMLToJS } from '../../utils/yaml';\nimport { Alert, Button } from '@patternfly/react-core';\n\nconst YAML_KEY_ORDER = ['apiVerion', 'kind', 'metadata', 'spec', 'status'];\nexport const YAML_TO_JS_OPTIONS = {\n  skipInvalid: true,\n  sortKeys: (a, b) => _.indexOf(YAML_KEY_ORDER, a) - _.indexOf(YAML_KEY_ORDER, b),\n};\n\n// Provides toggling and syncing between a form and yaml editor. The formData state is the source\n// of truth. Both the form editor and the yaml editor update the formData state. Here's the basic logic of this component:\n// In the form view:\n//   - formData is both rendered and updated by the form component\n//   - on toggle to YAML editor, yaml is parsed from current formData state.\n// In the YAML view:\n//   - on each yaml change, attempt to parse yaml to js:\n//       - If it fails, nothing happens. formData remains unchanged.\n//       - If successful, formData is updated to resulting js\n//   - on toggle to form view, no action needs to be taken to sync because formData has remained up to date with each yaml change\n//\n//  This means that when switching from YAML to Form, you can lose changes if the YAML editor contains unparsable YAML\n//  TODO Add an extra step when switching from yaml to form to warn user if they are about to lose changes.\nexport const SyncedEditor: React.FC<SyncedEditorProps> = ({\n  context = {},\n  FormEditor,\n  initialType = EditorType.Form,\n  initialData = {},\n  onChangeEditorType = _.noop,\n  onChange = _.noop,\n  prune,\n  YAMLEditor,\n}) => {\n  const { formContext, yamlContext } = context;\n  const [formData, setFormData] = React.useState<K8sResourceKind>(initialData);\n  const [yaml, setYAML] = React.useState(safeJSToYAML(initialData));\n  const [type, setType] = React.useState<EditorType>(initialType);\n  const [safeToSwitch, setSafeToSwitch] = React.useState<boolean>(true);\n  const [yamlWarning, setYAMLWarning] = React.useState<boolean>(false);\n\n  const handleFormDataChange = (newFormData: K8sResourceKind = {}) => {\n    if (!_.isEqual(newFormData, formData)) {\n      setFormData(newFormData);\n      onChange(newFormData);\n    }\n  };\n\n  const handleYAMLChange = (newYAML: string = '') => {\n    asyncYAMLToJS(newYAML)\n      .then((js) => {\n        setSafeToSwitch(true);\n        handleFormDataChange(js);\n      })\n      .catch(() => setSafeToSwitch(false));\n  };\n\n  const changeEditorType = (newType: EditorType): void => {\n    setType(newType);\n    onChangeEditorType(newType);\n  };\n\n  const handleToggleToForm = () => {\n    if (safeToSwitch) {\n      changeEditorType(EditorType.Form);\n    } else {\n      setYAMLWarning(true);\n    }\n  };\n\n  const handleToggleToYAML = () => {\n    setYAML(safeJSToYAML(prune?.(formData) ?? formData, yaml, YAML_TO_JS_OPTIONS));\n    changeEditorType(EditorType.YAML);\n  };\n\n  const onClickYAMLWarningConfirm = () => {\n    setSafeToSwitch(true);\n    setYAMLWarning(false);\n    changeEditorType(EditorType.Form);\n  };\n\n  const onClickYAMLWarningCancel = () => {\n    setYAMLWarning(false);\n  };\n\n  const onChangeType = (newType) => {\n    switch (newType) {\n      case EditorType.YAML:\n        handleToggleToYAML();\n        break;\n      case EditorType.Form:\n        handleToggleToForm();\n        break;\n      default:\n        break;\n    }\n  };\n\n  return (\n    <>\n      <EditorToggle value={type} onChange={onChangeType} />\n      {yamlWarning && (\n        <Alert\n          className=\"co-synced-editor__yaml-warning\"\n          variant=\"danger\"\n          isInline\n          title=\"Invalid YAML cannot be persisted\"\n        >\n          <p>Switching to Form View will delete any invalid YAML.</p>\n          <Button variant=\"danger\" onClick={onClickYAMLWarningConfirm}>\n            Switch and Delete\n          </Button>\n          &nbsp;\n          <Button variant=\"secondary\" onClick={onClickYAMLWarningCancel}>\n            Cancel\n          </Button>\n        </Alert>\n      )}\n      {type === EditorType.Form ? (\n        <FormEditor\n          formData={formData}\n          onChange={handleFormDataChange}\n          prune={prune}\n          {...formContext}\n        />\n      ) : (\n        <YAMLEditor initialYAML={yaml} onChange={handleYAMLChange} {...yamlContext} />\n      )}\n    </>\n  );\n};\n\ntype SyncedEditorProps = {\n  context: {\n    formContext: { [key: string]: any };\n    yamlContext: { [key: string]: any };\n  };\n  FormEditor: React.FC<any>;\n  initialType?: EditorType;\n  initialData?: K8sResourceKind;\n  onChangeEditorType?: (newType: EditorType) => void;\n  onChange?: (data: K8sResourceKind) => void;\n  prune?: (data: any) => any;\n  YAMLEditor: React.FC<any>;\n};\n","// extracted by mini-css-extract-plugin","import { safeDump, safeLoad } from 'js-yaml';\n\n// Safely parse js obj to yaml. Returns fallback (emtpy string by default) on exception.\nexport const safeJSToYAML = (js: any, fallback: string = '', options: any = {}): string => {\n  try {\n    return safeDump(js, options);\n  } catch {\n    return fallback;\n  }\n};\n\n// Safely parse yaml to js object. Returns fallback (empty object by default) on exception.\nexport const safeYAMLToJS = (yaml: string, fallback: any = {}, options: any = {}): any => {\n  try {\n    return safeLoad(yaml, options);\n  } catch {\n    return fallback;\n  }\n};\n\nexport const asyncJSToYAML = (js: any, options: any = {}): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const yaml = safeDump(js, options);\n      resolve(yaml);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\n\nexport const asyncYAMLToJS = (yaml: string, options: any = {}): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const js = safeLoad(yaml, options);\n      resolve(js);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport { Button } from '@patternfly/react-core';\n\nexport const AdditionalPropertyFields: React.FC<AdditionalPropertyProps> = props => {\n  let { data, onChange } = props;\n\n  const obj = data;\n  const [items, setItems] = React.useState(_.keys(obj).map(cur => ({ [cur]: obj[cur] })));\n\n  const onAddProperty = () => {\n    setItems(prev => items.concat({ '': '' }));\n  };\n  const onRemoveProperty = idx => {\n    setItems(items.filter((cur, index) => idx !== index));\n  };\n\n  return (\n    <>\n      <Button id={`add-btn`} type=\"button\" onClick={onAddProperty} variant=\"link\">\n        <PlusCircleIcon className=\"co-icon-space-r\" />\n        Add Property\n      </Button>\n      {items.length > 0 && (\n        <div className=\"row\" style={{ marginTop: '10px' }}>\n          <div className=\"col-xs-4\">Key</div>\n          <div className=\"col-xs-4\">Value</div>\n        </div>\n      )}\n      {items.length > 0 && items.map((cur, idx) => <AdditionalPropertyItem key={idx} id={`property-${idx}`} index={idx} items={items} data={cur} onChange={onChange} onRemove={onRemoveProperty} />)}\n    </>\n  );\n};\n\nconst AdditionalPropertyItem = props => {\n  const { index, items, data, onChange, onRemove } = props;\n  const [additionalKey, setKey] = React.useState(Object.keys(data)[0]);\n  const [additionalValue, setValue] = React.useState(Object.values(data)[0] || ' ');\n  React.useEffect(() => {\n    setKey(Object.keys(data)[0]);\n    setValue(Object.values(data)[0]);\n  }, [data]);\n  React.useEffect(() => {\n    const result = {};\n    items.forEach(cur => {\n      result[Object.keys(cur)[0]] = Object.values(cur)[0];\n    });\n    return onChange(result);\n  }, [additionalKey, additionalValue]);\n  return (\n    <div className=\"row co-m-form-row\">\n      <div className=\"col-xs-4\">\n        <input\n          value={additionalKey}\n          onChange={e => {\n            const value = e.target.value;\n            setKey(value);\n            console.log(value);\n            items.splice(index, 1, { [value]: additionalValue });\n          }}\n          id={additionalKey}\n          name={additionalKey}\n          type=\"text\"\n          className=\"pf-c-form-control\"\n          key={`key-${index}`}\n        />\n      </div>\n      <div className=\"col-xs-4\">\n        <input\n          value={additionalValue as string}\n          onChange={e => {\n            const value = e.target.value;\n            setValue(value);\n            console.log(value);\n            items.splice(index, 1, { [additionalKey]: value });\n          }}\n          id={'value' + additionalValue}\n          type=\"text\"\n          className=\"pf-c-form-control\"\n          key={`value-${index}`}\n        />\n      </div>\n      <Button id={`btn-property-remove-${index}`} type=\"button\" onClick={() => onRemove(index)} variant=\"link\">\n        <MinusCircleIcon className=\"co-icon-space-r\" />\n        Remove Property\n      </Button>\n    </div>\n  );\n};\n\ntype AdditionalPropertyProps = {\n  data: any;\n  path: string;\n  onChange: any;\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport { Button, Tooltip } from '@patternfly/react-core';\nimport {\n  NodeAffinity as NodeAffinityType,\n  MatchExpression,\n  PodAffinity as PodAffinityType,\n  PodAffinityTerm,\n  Selector,\n} from '@console/internal/module/k8s';\nimport { MatchExpressions } from './match-expressions';\n\nenum AffinityRuleType {\n  Preferred = 'Preferred',\n  Required = 'Required',\n}\n\nconst REQUIRED_TOOLTIP = 'Required rules must be met before a pod can be scheduled on a node.';\nconst PREFERRED_TOOLTIP =\n  'Preferred rules specify that, if the rule is met, the scheduler tries to enforce the rules, but does not guarantee enforcement.';\nconst ALLOWED_MATCH_EXPRESSION_OPERATORS: MatchExpression['operator'][] = [\n  'In',\n  'NotIn',\n  'Exists',\n  'DoesNotExist',\n];\nconst DEFAULT_MATCH_EXPRESSION: MatchExpression = {\n  key: '',\n  operator: 'Exists',\n};\n\nexport const DEFAULT_NODE_AFFINITY: NodeAffinityType = {\n  requiredDuringSchedulingIgnoredDuringExecution: {\n    nodeSelectorTerms: [{ matchExpressions: [_.cloneDeep(DEFAULT_MATCH_EXPRESSION)] }],\n  },\n  preferredDuringSchedulingIgnoredDuringExecution: [\n    {\n      weight: 1,\n      preference: { matchExpressions: [_.cloneDeep(DEFAULT_MATCH_EXPRESSION)] },\n    },\n  ],\n};\n\nexport const DEFAULT_POD_AFFINITY: PodAffinityType = {\n  requiredDuringSchedulingIgnoredDuringExecution: [\n    {\n      topologyKey: 'failure-domain.beta.kubernetes.io/zone',\n      labelSelector: { matchExpressions: [_.cloneDeep(DEFAULT_MATCH_EXPRESSION)] },\n    },\n  ],\n  preferredDuringSchedulingIgnoredDuringExecution: [\n    {\n      weight: 1,\n      podAffinityTerm: {\n        topologyKey: 'failure-domain.beta.kubernetes.io/zone',\n        labelSelector: { matchExpressions: [_.cloneDeep(DEFAULT_MATCH_EXPRESSION)] },\n      },\n    },\n  ],\n};\n\nconst NodeAffinityRule: React.FC<NodeAffinityRuleProps> = ({\n  key,\n  type,\n  showRemoveButton = false,\n  onClickRemove,\n  onChange = () => {},\n  rule,\n}) => {\n  const { weight, selector } = rule;\n  const onChangeMatchExpressions = (matchExpressions: MatchExpression[]): void =>\n    onChange({\n      ...rule,\n      selector: {\n        ...selector,\n        matchExpressions,\n      },\n    });\n\n  const onChangeWeight = (e: React.ChangeEvent<HTMLInputElement>): void => {\n    const parsedValue = _.parseInt(e?.target?.value);\n    onChange({\n      ...rule,\n      weight: _.isFinite(parsedValue) ? parsedValue : undefined,\n    });\n  };\n\n  return (\n    <div className=\"co-affinity-term\">\n      {showRemoveButton && (\n        <Button\n          type=\"button\"\n          className=\"co-affinity-term__remove\"\n          onClick={onClickRemove}\n          variant=\"link\"\n        >\n          <MinusCircleIcon className=\"co-icon-space-r\" />\n          Remove {type}\n        </Button>\n      )}\n      {type === AffinityRuleType.Preferred && (\n        <div className=\"co-affinity-term__weight-input\">\n          <label className=\"control-label co-required\" htmlFor={`preference-${key}`}>\n            Weight\n          </label>\n          <input\n            className=\"pf-c-form-control\"\n            type=\"number\"\n            value={weight}\n            onChange={onChangeWeight}\n            required\n          />\n        </div>\n      )}\n      <MatchExpressions\n        matchExpressions={selector?.matchExpressions}\n        onChange={onChangeMatchExpressions}\n        allowedOperators={ALLOWED_MATCH_EXPRESSION_OPERATORS}\n        uid={key}\n      />\n    </div>\n  );\n};\n\nexport const NodeAffinity: React.FC<NodeAffinityProps> = ({ affinity, onChange, uid = '' }) => {\n  const requiredRules =\n    affinity?.requiredDuringSchedulingIgnoredDuringExecution?.nodeSelectorTerms || [];\n  const preferredRules = affinity?.preferredDuringSchedulingIgnoredDuringExecution || [];\n  const addRequiredRule = () =>\n    onChange?.({\n      ...affinity,\n      requiredDuringSchedulingIgnoredDuringExecution: {\n        nodeSelectorTerms: [...requiredRules, { matchExpressions: [] }],\n      },\n    });\n\n  const removeRequiredRule = (atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      requiredDuringSchedulingIgnoredDuringExecution: {\n        nodeSelectorTerms: requiredRules.filter((_v, index) => index !== atIndex),\n      },\n    });\n\n  const updateRequiredRules = ({ selector }: NodeAffinityRule, atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      requiredDuringSchedulingIgnoredDuringExecution: {\n        nodeSelectorTerms: requiredRules.map((current, index) =>\n          index === atIndex ? selector : current,\n        ),\n      },\n    });\n\n  const addPreferredRule = () =>\n    onChange?.({\n      ...affinity,\n      preferredDuringSchedulingIgnoredDuringExecution: [\n        ...preferredRules,\n        { weight: 1, preference: { matchExpressions: [] } },\n      ],\n    });\n\n  const removePreferredRule = (atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      preferredDuringSchedulingIgnoredDuringExecution: preferredRules.filter(\n        (_v, index) => index !== atIndex,\n      ),\n    });\n\n  const updatePreferredRules = (\n    { selector: preference, weight }: NodeAffinityRule,\n    atIndex: number,\n  ) =>\n    onChange?.({\n      ...affinity,\n      preferredDuringSchedulingIgnoredDuringExecution: preferredRules.map((current, index) =>\n        index === atIndex ? { preference, weight } : current,\n      ),\n    });\n\n  return (\n    <dl>\n      <Tooltip content={REQUIRED_TOOLTIP}>\n        <dt>Required During Scheduling Ignored During Execution</dt>\n      </Tooltip>\n      <dd>\n        {requiredRules.map((selector, requiredIndex) => (\n          <NodeAffinityRule\n            // Have to use array index in the key bc any other unique id whould have to use editable fields.\n            // eslint-disable-next-line react/no-array-index-key\n            key={`${uid}-node-affinity-required-${requiredIndex}`}\n            onChange={(rule) => updateRequiredRules(rule, requiredIndex)}\n            onClickRemove={() => removeRequiredRule(requiredIndex)}\n            rule={{ selector }}\n            showRemoveButton\n            type={AffinityRuleType.Required}\n          />\n        ))}\n        <div className=\"row\">\n          <Button type=\"button\" onClick={addRequiredRule} variant=\"link\">\n            <PlusCircleIcon className=\"co-icon-space-r\" />\n            Add Required\n          </Button>\n        </div>\n      </dd>\n      <Tooltip content={PREFERRED_TOOLTIP}>\n        <dt>Preferred During Scheduling Ignored During Execution</dt>\n      </Tooltip>\n      <dd>\n        {preferredRules.map(({ preference: selector, weight }, preferredIndex) => (\n          <NodeAffinityRule\n            // Have to use array index in the key bc any other unique id whould have to use editable fields.\n            // eslint-disable-next-line react/no-array-index-key\n            key={`${uid}-node-affinity-preferred-${preferredIndex}`}\n            onChange={(rule) => updatePreferredRules(rule, preferredIndex)}\n            onClickRemove={() => removePreferredRule(preferredIndex)}\n            rule={{ selector, weight }}\n            showRemoveButton\n            type={AffinityRuleType.Preferred}\n          />\n        ))}\n        <div className=\"row\">\n          <Button type=\"button\" onClick={addPreferredRule} variant=\"link\">\n            <PlusCircleIcon className=\"co-icon-space-r\" />\n            Add Preferred\n          </Button>\n        </div>\n      </dd>\n    </dl>\n  );\n};\n\nconst PodAffinityRule: React.FC<PodAffinityRuleProps> = ({\n  key,\n  onChange = () => {},\n  onClickRemove = () => {},\n  showRemoveButton = false,\n  rule,\n  type,\n}) => {\n  const { podAffinityTerm, weight } = rule;\n  const selector = podAffinityTerm?.labelSelector || {};\n  const topologyKey = podAffinityTerm?.topologyKey;\n  const onChangeWeight = (e: React.ChangeEvent<HTMLInputElement>): void => {\n    const parsed = _.parseInt(e?.target?.value);\n    onChange({\n      ...rule,\n      weight: _.isFinite(parsed) ? parsed : undefined,\n    });\n  };\n\n  const onChangeTopologyKey = (e: React.ChangeEvent<HTMLInputElement>): void =>\n    onChange({\n      ...rule,\n      podAffinityTerm: {\n        ...podAffinityTerm,\n        topologyKey: e?.target?.value,\n      },\n    });\n  const onChangeMatchExpressions = (matchExpressions: MatchExpression[]): void =>\n    onChange({\n      ...rule,\n      podAffinityTerm: {\n        ...podAffinityTerm,\n        labelSelector: {\n          ...selector,\n          matchExpressions,\n        },\n      },\n    });\n\n  return podAffinityTerm ? (\n    <div className=\"co-affinity-term\">\n      {showRemoveButton && (\n        <Button\n          type=\"button\"\n          className=\"co-affinity-term__remove\"\n          onClick={onClickRemove}\n          variant=\"link\"\n        >\n          <MinusCircleIcon className=\"co-icon-space-r\" />\n          Remove {type}\n        </Button>\n      )}\n      <div className=\"co-affinity-term__topology\">\n        {type === AffinityRuleType.Preferred && (\n          <div className=\"co-affinity-term__weight-input\">\n            <label className=\"control-label co-required\" htmlFor={`preference-${key}`}>\n              Weight\n            </label>\n            <input\n              className=\"pf-c-form-control\"\n              type=\"number\"\n              value={weight}\n              onChange={onChangeWeight}\n              required\n            />\n          </div>\n        )}\n        <div className=\"co-affinity-term__topology-input\">\n          <label className=\"control-label co-required\" htmlFor={`topology-${key}`}>\n            Topology Key\n          </label>\n          <input\n            id={`topology-${key}`}\n            className=\"pf-c-form-control\"\n            type=\"text\"\n            value={topologyKey}\n            onChange={onChangeTopologyKey}\n            required\n          />\n        </div>\n      </div>\n      <MatchExpressions\n        matchExpressions={selector?.matchExpressions}\n        onChange={onChangeMatchExpressions}\n        allowedOperators={ALLOWED_MATCH_EXPRESSION_OPERATORS}\n        uid={key}\n      />\n    </div>\n  ) : null;\n};\n\nexport const PodAffinity: React.FC<PodAffinityProps> = ({ affinity, onChange, uid = '' }) => {\n  const {\n    requiredDuringSchedulingIgnoredDuringExecution: requiredRules = [],\n    preferredDuringSchedulingIgnoredDuringExecution: preferredRules = [],\n  } = affinity || {};\n\n  const addRequiredRule = () =>\n    onChange?.({\n      ...affinity,\n      requiredDuringSchedulingIgnoredDuringExecution: [\n        ...requiredRules,\n        { topologyKey: '', labelSelector: { matchExpressions: [] } },\n      ],\n    });\n\n  const removeRequiredRule = (atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      requiredDuringSchedulingIgnoredDuringExecution: requiredRules.filter(\n        (_v, index) => atIndex !== index,\n      ),\n    });\n\n  const updateRequiredRules = ({ podAffinityTerm: next }: PodAffinityRule, atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      requiredDuringSchedulingIgnoredDuringExecution: requiredRules.map((current, index) =>\n        index === atIndex ? next : current,\n      ),\n    });\n\n  const addPreferredRule = () =>\n    onChange?.({\n      ...affinity,\n      preferredDuringSchedulingIgnoredDuringExecution: [\n        ...preferredRules,\n        {\n          weight: 1,\n          podAffinityTerm: { topologyKey: '', labelSelector: { matchExpressions: [] } },\n        },\n      ],\n    });\n\n  const removePreferredRule = (atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      preferredDuringSchedulingIgnoredDuringExecution: preferredRules.filter(\n        (_v, index) => atIndex !== index,\n      ),\n    });\n\n  const updatePreferredRules = (next: PodAffinityRule, atIndex: number) =>\n    onChange?.({\n      ...affinity,\n      preferredDuringSchedulingIgnoredDuringExecution: preferredRules.map((current, index) =>\n        index === atIndex ? next : current,\n      ),\n    });\n\n  return (\n    <dl>\n      <Tooltip content={REQUIRED_TOOLTIP}>\n        <dt>Required During Scheduling Ignored During Execution</dt>\n      </Tooltip>\n      <dd>\n        {_.map(requiredRules, (podAffinityTerm, ruleIndex) => (\n          // Have to use array index in the key bc any other unique id whould have to use editable fields.\n          // eslint-disable-next-line react/no-array-index-key\n          <PodAffinityRule\n            key={`${uid}-pod-affinity-required-${ruleIndex}`}\n            rule={{ podAffinityTerm }}\n            onChange={(rule) => updateRequiredRules(rule, ruleIndex)}\n            onClickRemove={() => removeRequiredRule(ruleIndex)}\n            showRemoveButton\n            type={AffinityRuleType.Required}\n          />\n        ))}\n        <div className=\"row\">\n          <Button type=\"button\" onClick={addRequiredRule} variant=\"link\">\n            <PlusCircleIcon className=\"co-icon-space-r\" />\n            Add Required\n          </Button>\n        </div>\n      </dd>\n      <Tooltip content={PREFERRED_TOOLTIP}>\n        <dt>Preferred During Scheduling Ignored During Execution</dt>\n      </Tooltip>\n      <dd>\n        {preferredRules.map((preferredRule, ruleIndex) => {\n          // Have to use array index in the key bc any other unique id whould have to use editable fields.\n          return (\n            <PodAffinityRule\n              // eslint-disable-next-line react/no-array-index-key\n              key={`${uid}-pod-affinity-preferred-${ruleIndex}`}\n              onChange={(rule) => updatePreferredRules(rule, ruleIndex)}\n              onClickRemove={() => removePreferredRule(ruleIndex)}\n              showRemoveButton\n              rule={preferredRule}\n              type={AffinityRuleType.Preferred}\n            />\n          );\n        })}\n\n        <div className=\"row\">\n          <Button type=\"button\" onClick={addPreferredRule} variant=\"link\">\n            <PlusCircleIcon className=\"co-icon-space-r\" />\n            Add Preferred\n          </Button>\n        </div>\n      </dd>\n    </dl>\n  );\n};\n\ntype NodeAffinityRule = {\n  selector: Selector;\n  weight?: number;\n};\n\nexport type NodeAffinityRuleProps = {\n  key: string;\n  onChange?: (rule: NodeAffinityRule) => void;\n  onClickRemove?: () => void;\n  rule: NodeAffinityRule;\n  showRemoveButton?: boolean;\n  type: AffinityRuleType;\n};\n\nexport type NodeAffinityProps = {\n  uid?: string;\n  affinity: NodeAffinityType;\n  onChange: (affinity: NodeAffinityType) => void;\n};\n\ntype PodAffinityRule = {\n  podAffinityTerm: PodAffinityTerm;\n  weight?: number;\n};\n\nexport type PodAffinityRuleProps = {\n  key: string;\n  rule: PodAffinityRule;\n  onChange?: (rule: PodAffinityRule) => void;\n  onClickRemove?: () => void;\n  showRemoveButton?: boolean;\n  type: AffinityRuleType;\n};\n\nexport type PodAffinityProps = {\n  uid?: string;\n  affinity: PodAffinityType;\n  onChange: (affinity: PodAffinityType) => void;\n};\n\nNodeAffinity.displayName = 'NodeAffinity';\nPodAffinity.displayName = 'PodAffinity';\n","import * as React from 'react';\nimport { Button } from '@patternfly/react-core';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport { MatchExpression } from '@console/internal/module/k8s';\nimport { Dropdown } from '@console/internal/components/utils';\n\nconst ALL_OPERATORS: MatchExpression['operator'][] = [\n  'DoesNotExist',\n  'Equals',\n  'Exists',\n  'In',\n  'NotEqual',\n  'NotIn',\n];\n\nconst MatchExpression: React.FC<MatchExpressionProps> = ({\n  expression,\n  onChange = () => {},\n  allowedOperators = ALL_OPERATORS,\n  onClickRemove = () => {},\n}) => (\n  <div className=\"row key-operator-value__row\">\n    <div className=\"col-md-4 col-xs-5 key-operator-value__name-field\">\n      <div className=\"key-operator-value__heading hidden-md hidden-lg text-secondary text-uppercase\">\n        Key\n      </div>\n      <input\n        type=\"text\"\n        className=\"pf-c-form-control\"\n        value={expression.key}\n        onChange={(e) => onChange({ ...expression, key: e.target.value })}\n      />\n    </div>\n    <div className=\"col-md-3 col-xs-5 key-operator-value__operator-field\">\n      <div className=\"key-operator-value__heading hidden-md hidden-lg text-secondary text-uppercase\">\n        Operator\n      </div>\n      <Dropdown\n        dropDownClassName=\"dropdown--full-width\"\n        items={allowedOperators.reduce((acc, o) => ({ ...acc, [o]: o }), {})}\n        onChange={(operator: MatchExpression['operator']) => onChange({ ...expression, operator })}\n        selectedKey={expression.operator}\n        title={expression.operator}\n      />\n    </div>\n    <div className=\"col-md-3 col-xs-5 key-operator-value__value-field key-operator-value__value-field--stacked\">\n      <div className=\"key-operator-value__heading hidden-md hidden-lg text-secondary text-uppercase\">\n        Value\n      </div>\n      <input\n        className=\"pf-c-form-control\"\n        type=\"text\"\n        value={expression?.value}\n        onChange={(e) => onChange({ ...expression, value: e?.target?.value })}\n        readOnly={['Exists', 'DoesNotExist'].includes(expression.operator)}\n      />\n    </div>\n    <div className=\"col-xs-1 key-operator-value__action key-operator-value__action--stacked\">\n      <div className=\"key-operator-value__heading key-operator-value__heading-button hidden-md hidden-lg\" />\n      <Button\n        type=\"button\"\n        onClick={onClickRemove}\n        aria-label=\"Delete\"\n        className=\"key-operator-value__delete-button\"\n        variant=\"plain\"\n      >\n        <MinusCircleIcon />\n      </Button>\n    </div>\n  </div>\n);\n\nexport const MatchExpressions: React.FC<MatchExpressionsProps> = ({\n  matchExpressions = [],\n  onChange = () => {}, // Default to noop\n  allowedOperators = ALL_OPERATORS,\n  uid = '',\n}) => {\n  const updateExpression = (index: number, newExpression: MatchExpression): void =>\n    onChange(matchExpressions.map((exp, i) => (i === index ? newExpression : exp)));\n\n  const removeExpression = (index: number): void =>\n    onChange(matchExpressions.filter((_exp, i) => i !== index));\n\n  const addExpression = (): void =>\n    onChange([...matchExpressions, { key: '', operator: 'Exists' }]);\n\n  return (\n    <>\n      <div className=\"row key-operator-value__heading hidden-sm hidden-xs\">\n        <div className=\"col-md-4 text-secondary text-uppercase\">Key</div>\n        <div className=\"col-md-3 text-secondary text-uppercase\">Operator</div>\n        <div className=\"col-md-3 text-secondary text-uppercase\">Value</div>\n      </div>\n      {matchExpressions.map((expression, index) => (\n        // Have to use array index in the key bc any other unique id whould have to use editable fields.\n        <MatchExpression\n          // eslint-disable-next-line react/no-array-index-key\n          key={`${uid}-match-expression-${index}`}\n          expression={expression}\n          allowedOperators={allowedOperators}\n          onClickRemove={() => removeExpression(index)}\n          onChange={(newExpression) => updateExpression(index, newExpression)}\n        />\n      ))}\n      <div className=\"row\">\n        <Button type=\"button\" onClick={addExpression} variant=\"link\">\n          <PlusCircleIcon className=\"co-icon-space-r\" />\n          Add More\n        </Button>\n      </div>\n    </>\n  );\n};\n\nexport type MatchExpressionsProps = {\n  matchExpressions: MatchExpression[];\n  onChange?: (matchExpressions: MatchExpression[]) => void;\n  allowedOperators?: MatchExpression['operator'][];\n  uid?: string;\n};\n\nexport type MatchExpressionProps = {\n  expression: MatchExpression;\n  onChange?: (expression: MatchExpression) => void;\n  onClickRemove?: () => void;\n  allowedOperators?: MatchExpression['operator'][];\n};\n\nMatchExpressions.displayName = 'MatchExpressions';\n","import * as Immutable from 'immutable';\nimport { SpecCapability } from '../types';\nimport {\n  NodeAffinityField,\n  PodAffinityField,\n  ResourceRequirementsField,\n  UpdateStrategyField,\n  BooleanField,\n} from '@console/shared/src/components/dynamic-form/fields';\nimport {\n  CheckboxWidget,\n  ImagePullPolicyWidget,\n  NumberWidget,\n  PasswordWidget,\n  TextWidget,\n  PodCountWidget,\n  SelectWidget,\n} from '@console/shared/src/components/dynamic-form/widgets';\n\nexport const capabilityFieldMap = Immutable.Map({\n  [SpecCapability.nodeAffinity]: NodeAffinityField,\n  [SpecCapability.podAffinity]: PodAffinityField,\n  [SpecCapability.podAntiAffinity]: PodAffinityField,\n  [SpecCapability.resourceRequirements]: ResourceRequirementsField,\n  [SpecCapability.updateStrategy]: UpdateStrategyField,\n  [SpecCapability.booleanSwitch]: BooleanField,\n});\n\nexport const capabilityWidgetMap = Immutable.Map({\n  [SpecCapability.hidden]: 'hidden',\n  [SpecCapability.imagePullPolicy]: ImagePullPolicyWidget,\n  [SpecCapability.checkbox]: CheckboxWidget,\n  [SpecCapability.number]: NumberWidget,\n  [SpecCapability.password]: PasswordWidget,\n  [SpecCapability.podCount]: PodCountWidget,\n  [SpecCapability.text]: TextWidget,\n  [SpecCapability.select]: SelectWidget,\n});\n","import * as _ from 'lodash';\nimport { JSONSchema6 } from 'json-schema';\nimport { SpecCapability } from '../descriptors/types';\nimport { SchemaType } from '@console/shared/src/components/dynamic-form';\n\nexport const YAML_HELP_TEXT =\n  'Create by manually entering YAML or JSON definitions, or by dragging and dropping a file into the editor.';\nexport const FORM_HELP_TEXT =\n  'Create by completing the form. Default values may be provided by the Operator authors.';\nexport const DEFAULT_K8S_SCHEMA: JSONSchema6 = {\n  type: SchemaType.object,\n  properties: {\n    metadata: {\n      type: SchemaType.object,\n      properties: {\n        namespace: { type: SchemaType.string },\n        name: {\n          type: SchemaType.string,\n          default: 'example',\n        },\n        labels: {\n          type: SchemaType.object,\n          properties: {},\n          additionalProperties: { type: SchemaType.string },\n        },\n      },\n      required: ['name'],\n    },\n    spec: { type: SchemaType.object },\n    apiVersion: { type: SchemaType.string },\n    kind: { type: SchemaType.string },\n  },\n};\n\nexport const REGEXP_K8S_RESOURCE_CAPABILITY = _.escapeRegExp(SpecCapability.k8sResourcePrefix);\nexport const REGEXP_FIELD_DEPENDENCY_CAPABILITY = _.escapeRegExp(SpecCapability.fieldDependency);\nexport const REGEXP_SELECT_CAPABILITY = _.escapeRegExp(SpecCapability.select);\n\nexport const REGEXP_K8S_RESOURCE_SUFFIX = new RegExp(\n  `^${REGEXP_K8S_RESOURCE_CAPABILITY}(?:core~v1~)?(.*)$`,\n);\nexport const REGEXP_SELECT_OPTION = new RegExp(`${REGEXP_SELECT_CAPABILITY}(.*)$`);\nexport const REGEXP_FIELD_DEPENDENCY_PATH_VALUE = new RegExp(\n  `^${REGEXP_FIELD_DEPENDENCY_CAPABILITY}([^:]*):(.*)$`,\n);\nexport const HIDDEN_UI_SCHEMA = {\n  'ui:widget': 'hidden',\n  'ui:options': { label: false },\n};\n\nconst SORT_WEIGHT_BASE = 10;\nexport const SORT_WEIGHT_SCALE_1 = SORT_WEIGHT_BASE ** 1;\nexport const SORT_WEIGHT_SCALE_2 = SORT_WEIGHT_BASE ** 2;\nexport const SORT_WEIGHT_SCALE_3 = SORT_WEIGHT_BASE ** 3;\n","import { JSONSchema6 } from 'json-schema';\nimport { k8sCreate, K8sKind, K8sResourceKind } from '@console/internal/module/k8s';\nimport { history, useScrollToTopOnMount } from '@console/internal/components/utils';\nimport * as _ from 'lodash';\nimport * as React from 'react';\nimport { ClusterServiceVersionKind, CRDDescription, APIServiceDefinition } from '../../types';\nimport { ClusterServiceVersionLogo } from '../index';\nimport { DynamicForm } from '@console/shared/src/components/dynamic-form';\nimport { getUISchema } from './utils';\n\nexport const OperandForm: React.FC<OperandFormProps> = ({ csv, formData, match, model, next, onChange, providedAPI, prune, schema }) => {\n  const [errors, setErrors] = React.useState<string[]>([]);\n  // const [formData, setFormData] = React.useState(initialData);\n\n  const processFormData = ({ metadata, ...rest }) => {\n    const data = {\n      metadata: {\n        ...metadata,\n        ...(match?.params?.ns && model.namespaced && { namespace: match.params.ns }),\n      },\n      ...rest,\n    };\n    return prune?.(data) ?? data;\n  };\n\n  const handleSubmit = ({ formData: submitFormData }) => {\n    k8sCreate(model, processFormData(submitFormData))\n      .then(() => {\n        if (next) {\n          next += `/${submitFormData.metadata.name}`;\n          history.push(next);\n        }\n      })\n      .catch(e => setErrors([e.message]));\n  };\n\n  const uiSchema = React.useMemo(() => getUISchema(schema, providedAPI), [schema, providedAPI]);\n\n  useScrollToTopOnMount();\n\n  return (\n    <div className=\"co-m-pane__body\">\n      <div className=\"row\">\n        <div className=\"col-md-0 col-md-push-12 col-lg-1 col-lg-push-11\">\n          {csv && providedAPI && (\n            <div style={{ marginBottom: '30px' }}>\n              <ClusterServiceVersionLogo displayName={providedAPI.displayName} icon={_.get(csv, 'spec.icon[0]')} provider={_.get(csv, 'spec.provider')} />\n              {providedAPI.description}\n            </div>\n          )}\n        </div>\n        <div className=\"col-md-12 col-md-pull-0 col-lg-11 col-lg-pull-1\">\n          <DynamicForm noValidate errors={errors} formContext={{ namespace: match.params.ns }} uiSchema={uiSchema} formData={formData} onChange={onChange} onError={setErrors} onSubmit={handleSubmit} schema={schema} />\n        </div>\n      </div>\n    </div>\n  );\n};\n\ntype ProvidedAPI = CRDDescription | APIServiceDefinition;\n\nexport type OperandFormProps = {\n  formData?: K8sResourceKind;\n  onChange?: (formData?: any) => void;\n  match: { params: { ns: string } };\n  next?: string;\n  csv: ClusterServiceVersionKind;\n  model: K8sKind;\n  providedAPI: ProvidedAPI;\n  prune?: (data: any) => any;\n  schema: JSONSchema6;\n};\n","import * as React from 'react';\nimport { match as RouterMatch } from 'react-router-dom';\nimport { K8sResourceKindReference } from '@console/internal/module/k8s';\nimport { CreateYAML } from '@console/internal/components/create-yaml';\n\n/**\n * Component which wraps the YAML editor to ensure the templates are added from the `ClusterServiceVersion` annotations.\n */\nexport const OperandYAML: React.FC<OperandYAMLProps> = ({\n  match,\n  onChange,\n  next,\n  initialYAML = '',\n}) => {\n  return (\n    <CreateYAML\n      hideHeader\n      match={match}\n      onChange={onChange}\n      template={initialYAML}\n      {...(next && { resourceObjPath: () => next })}\n    />\n  );\n};\n\nexport type OperandYAMLProps = {\n  initialYAML?: string;\n  onChange?: (yaml: string) => void;\n  match: RouterMatch<{ appName: string; ns: string; plural: K8sResourceKindReference }>;\n  next?: string;\n};\n","import * as _ from 'lodash';\nimport * as Immutable from 'immutable';\nimport { JSONSchema6 } from 'json-schema';\nimport { SpecCapability, Descriptor } from '../descriptors/types';\nimport { modelFor } from '@console/internal/module/k8s';\nimport { capabilityFieldMap, capabilityWidgetMap } from '../descriptors/spec/spec-descriptor-input';\nimport { HIDDEN_UI_SCHEMA, REGEXP_K8S_RESOURCE_SUFFIX, REGEXP_SELECT_OPTION, REGEXP_FIELD_DEPENDENCY_PATH_VALUE, SORT_WEIGHT_SCALE_1, SORT_WEIGHT_SCALE_2, SORT_WEIGHT_SCALE_3 } from './const';\nimport { UiSchema } from 'react-jsonschema-form';\nimport { SchemaType } from '@console/shared/src/components/dynamic-form';\nimport { getSchemaType } from 'react-jsonschema-form/lib/utils';\nimport { getSchemaErrors } from '@console/shared/src/components/dynamic-form/utils';\nimport { isArray } from 'lodash';\n\n// Transform a path string from a descriptor to a JSON schema path array\nexport const descriptorPathToUISchemaPath = (path: string): string[] =>\n  (_.toPath(path) ?? []).map(subPath => {\n    return /^\\d+$/.test(subPath) ? 'items' : subPath;\n  });\n\n// Determine if a given path is defined on a JSONSchema\nexport const jsonSchemaHas = (jsonSchema: JSONSchema6, schemaPath: string[]): boolean => {\n  const [next, ...rest] = schemaPath;\n  const nextSchema = jsonSchema?.[next] ?? jsonSchema?.properties?.[next];\n  if (rest.length && !!nextSchema) {\n    return jsonSchemaHas(nextSchema, rest);\n  }\n  return !!nextSchema;\n};\n\n// Applies a hidden widget and label configuration to every property of the given schema.\n// This is useful for whitelisting only a few schema properties when all properties are not known.\nexport const hideAllExistingProperties = (schema: JSONSchema6) => {\n  return _.reduce(\n    schema?.properties,\n    (acc, _unused, propertyName) => ({\n      ...acc,\n      [propertyName]: HIDDEN_UI_SCHEMA,\n    }),\n    {},\n  );\n};\n\n// Determine if a schema will produce an empty form field.\nexport const hasNoFields = (jsonSchema: JSONSchema6 = {}): boolean => {\n  // If schema is empty or has unsupported properties, it will not render any fields on the form\n  if (getSchemaErrors(jsonSchema).length > 0) {\n    return true;\n  }\n\n  const type = getSchemaType(jsonSchema) ?? '';\n  const handleArray = () => {\n    return hasNoFields(jsonSchema.items as JSONSchema6);\n  };\n  const handleObject = () => {\n    return _.every(jsonSchema?.properties, hasNoFields) && !jsonSchema?.additionalProperties;\n    //  && hasNoFields(jsonSchema?.additionalProperties as JSONSchema6);\n  };\n\n  switch (type) {\n    case SchemaType.array:\n      return handleArray();\n    case SchemaType.object:\n      return handleObject();\n    // case '':\n    //   return true; // type이 없는 parameter에 경우 form editor 안그리는 로직 있던 거 제거\n    default:\n      return false;\n  }\n};\n\n// Map json schema to default ui schema\nexport const getDefaultUISchema = (jsonSchema: JSONSchema6, jsonSchemaName: string): UiSchema => {\n  const type = getSchemaType(jsonSchema ?? {});\n  if (hasNoFields(jsonSchema)) {\n    return HIDDEN_UI_SCHEMA;\n  }\n  if (!!jsonSchema?.additionalProperties) {\n    if (jsonSchemaName.toLowerCase().indexOf('label') >= 0 || jsonSchemaName.toLowerCase().indexOf('annotation') >= 0 || jsonSchemaName.toLowerCase().indexOf('selector') >= 0) {\n      return {\n        'ui:field': 'LabelsField',\n      };\n    }\n    return {\n      'ui:field': 'AdditionalPropertyField',\n    };\n  } else if (jsonSchema?.['x-kubernetes-int-or-string'] || jsonSchema?.['anyOf']) {\n    if (\n      isArray(jsonSchema.anyOf) &&\n      jsonSchema.anyOf.every(cur => {\n        if (isArray(cur?.['type'])) {\n          return cur['type'][0] === 'string' || cur['type'][0] === 'number' || cur['type'][0] === 'null' || cur['type'][0] === 'integer';\n        } else if (cur?.['type']){\n          return cur['type'] === 'string' || cur['type'] === 'number' || cur['type'] === 'null' || cur['type'] === 'integer';\n        }\n      })\n    ) {\n      delete jsonSchema?.anyOf;\n      jsonSchema.type = 'string';\n    }\n    delete jsonSchema?.anyOf;\n  } else if (jsonSchema?.['oneOf']) {\n    if (\n      isArray(jsonSchema.oneOf) &&\n      jsonSchema.oneOf.every(cur => {\n        if (isArray(cur?.['type'])) {\n          return cur['type'][0] === 'string' || cur['type'][0] === 'number' || cur['type'][0] === 'null' || cur['type'][0] === 'integer';\n        } else if (cur?.['type']){\n          return cur['type'] === 'string' || cur['type'] === 'number' || cur['type'] === 'null' || cur['type'] === 'integer';\n        }\n      })\n    ) {\n      delete jsonSchema?.oneOf;\n      jsonSchema.type = 'string';\n    }\n    delete jsonSchema?.oneOf;\n  } else if (jsonSchema?.['allOf']) {\n    if (\n      isArray(jsonSchema.allOf) &&\n      jsonSchema.allOf.every(cur => {\n        if (isArray(cur?.['type'])) {\n          return cur['type'][0] === 'string' || cur['type'][0] === 'number' || cur['type'][0] === 'null' || cur['type'][0] === 'integer';\n        } else if (cur?.['type']){\n          return cur['type'] === 'string' || cur['type'] === 'number' || cur['type'] === 'null' || cur['type'] === 'integer';\n        }\n      })\n    ) {\n      delete jsonSchema?.allOf;\n      jsonSchema.type = 'string';\n    }\n    delete jsonSchema?.allOf;\n  }\n\n  const handleArray = () => {\n    const itemsUISchema = getDefaultUISchema(jsonSchema.items as JSONSchema6, '');\n    return !_.isEmpty(itemsUISchema) ? { items: itemsUISchema } : {};\n  };\n\n  const handleObject = () => {\n    return _.reduce(\n      jsonSchema.properties,\n      (uiSchemaAccumulator: UiSchema, property: JSONSchema6, name: string) => {\n        const propertyUISchema = getDefaultUISchema(property, name);\n        return _.isEmpty(propertyUISchema)\n          ? uiSchemaAccumulator\n          : {\n              ...(uiSchemaAccumulator ?? {}),\n              [name]: propertyUISchema,\n            };\n      },\n      {},\n    );\n  };\n  switch (type) {\n    case SchemaType.array:\n      return handleArray();\n    case SchemaType.object:\n      return handleObject();\n    default:\n      return {};\n  }\n};\n\nconst k8sResourceCapabilityToUISchema = (capability: SpecCapability): UiSchema => {\n  const [, groupVersionKind] = capability.match(REGEXP_K8S_RESOURCE_SUFFIX) ?? [];\n  const model = groupVersionKind && modelFor(groupVersionKind);\n  if (model) {\n    return {\n      'ui:widget': 'K8sResourceWidget',\n      'ui:options': { model, groupVersionKind },\n    };\n  }\n  return {};\n};\n\nconst fieldDependencyCapabilityToUISchema = (capability: SpecCapability): UiSchema => {\n  const [, path, value] = capability.match(REGEXP_FIELD_DEPENDENCY_PATH_VALUE) ?? [];\n  if (!!path && !!value) {\n    return { 'ui:dependency': { path: descriptorPathToUISchemaPath(path), value } };\n  }\n  return {};\n};\n\nconst selectCapabilitiesToUISchema = (capabilities: SpecCapability[]): UiSchema => {\n  const items = capabilities.reduce((optionAccumulator, capability) => {\n    const [, option] = capability.match(REGEXP_SELECT_OPTION) ?? [];\n    return {\n      ...optionAccumulator,\n      ...(option && { [option]: option }),\n    };\n  }, {});\n\n  if (!_.isEmpty(items)) {\n    return {\n      'ui:field': 'DropdownField',\n      'ui:items': items,\n    };\n  }\n\n  return {};\n};\n\n// Given an array of SpecCapabilities, return the appropriate corresponding UISchema\nexport const capabilitiesToUISchema = (capabilities: SpecCapability[] = []) => {\n  if (!capabilities?.length) {\n    return {};\n  }\n\n  const k8sResourceCapability = _.find(capabilities, capability => capability.startsWith(SpecCapability.k8sResourcePrefix));\n  if (k8sResourceCapability) {\n    return k8sResourceCapabilityToUISchema(k8sResourceCapability);\n  }\n\n  const fieldDependencyCapability = _.find(capabilities, capability => capability.startsWith(SpecCapability.fieldDependency));\n  if (fieldDependencyCapability) {\n    return fieldDependencyCapabilityToUISchema(fieldDependencyCapability);\n  }\n\n  const hasSelectOptions = _.some(capabilities, capability => capability.startsWith(SpecCapability.select));\n  if (hasSelectOptions) {\n    return selectCapabilitiesToUISchema(capabilities);\n  }\n\n  const field = _.reduce(\n    capabilities,\n    (fieldAccumulator, capability) => {\n      return fieldAccumulator ?? capabilityFieldMap.get(capability);\n    },\n    undefined,\n  );\n\n  const widget = _.reduce(\n    capabilities,\n    (widgetAccumulator, capability) => {\n      return widgetAccumulator ?? capabilityWidgetMap.get(capability);\n    },\n    undefined,\n  );\n\n  return {\n    ...(field && { 'ui:field': field }),\n    ...(widget && { 'ui:widget': widget }),\n  };\n};\n\n// Given a JSONSchema and associated uiSchema, create the appropriat ui schema order property for the jsonSchema.\n// Orders properties according to the following rules:\n//  - required properties with an associated ui schema come first,\n//  - required properties without an associated ui schema next,\n//  - optional fields with an associated ui schema next,\n//  - all other properties\nexport const getJSONSchemaOrder = (jsonSchema, uiSchema) => {\n  const type = getSchemaType(jsonSchema ?? {});\n  const handleArray = () => {\n    const descendantOrder = getJSONSchemaOrder(jsonSchema?.items as JSONSchema6, uiSchema?.items);\n    return !_.isEmpty(descendantOrder) ? { items: descendantOrder } : {};\n  };\n\n  const handleObject = () => {\n    const propertyNames = _.keys(jsonSchema?.properties ?? {});\n    if (_.isEmpty(propertyNames)) {\n      return {};\n    }\n\n    // Map control fields to an array so that  an index can be used to apply a modifier to sort weigths of dependent fields\n    const controlProperties = _.reduce(\n      uiSchema,\n      (controlPropertyAccumulator, { 'ui:dependency': dependency }) => {\n        const control = _.last(dependency?.path ?? []);\n        return !control ? controlPropertyAccumulator : [...controlPropertyAccumulator, control];\n      },\n      [],\n    );\n\n    /**\n     * Give a property name a sort wieght based on whether it has a descriptor (uiSchema has property), is required, or is a control\n     * field for a property with a field dependency. A lower weight means higher sort order. Fields are weighted according to the following criteria:\n     *  - Required fields with descriptor - 0 to 999\n     *  - Required fields without descriptor 1000 to 1999\n     *  - Optional fields with descriptor 2000 to 2999\n     *  - Control fields that don't fit any above - 3000 to 3999\n     *  - All other fields - Infinity\n     *\n     * Within each of the above criteria, fields are further weighted based on field dependency:\n     *   - Fields without dependency - base weight\n     *   - Control field - base weight  + (nth control field) * 100\n     *   - Dependent field - corresponding control field weight + 10\n     *\n     * These weight numbers are arbitrary, but spaced far enough apart to leave room for multiple levels of sorting.\n     */\n    const getSortWeight = (property: string): number => {\n      // This property's control field, if it exists\n      const control = _.last<string>(uiSchema?.[property]?.['ui:dependency']?.path ?? []);\n\n      // A small offset that is added to the base weight so that control fields get sorted last within\n      // their appropriate group\n      const controlOffset = (controlProperties.indexOf(property) + 1) * SORT_WEIGHT_SCALE_2;\n\n      // If this property is a dependent, it's weight is based on it's control property\n      if (control) {\n        return getSortWeight(control) + controlOffset + SORT_WEIGHT_SCALE_1;\n      }\n\n      const isRequired = (jsonSchema?.required ?? []).includes(property);\n      const hasDescriptor = uiSchema?.[property];\n\n      // Required fields with a desriptor are sorted first (lowest weight).\n      if (isRequired && hasDescriptor) {\n        return SORT_WEIGHT_SCALE_3 + controlOffset;\n      }\n\n      // Fields that are required, but have no descriptors get sorted next\n      if (isRequired) {\n        return SORT_WEIGHT_SCALE_3 * 2 + controlOffset;\n      }\n\n      // Optional fields with descriptors get sorted next\n      if (hasDescriptor) {\n        return SORT_WEIGHT_SCALE_3 * 3 + controlOffset;\n      }\n\n      // Control fields that don't fit into any of the above criteria come next\n      if (controlOffset > 0) {\n        return SORT_WEIGHT_SCALE_3 * 4 + controlOffset;\n      }\n\n      // All other fields are sorted in the order in which they are encountered\n      // in the schema\n      return Infinity;\n    };\n\n    const uiOrder = Immutable.Set(propertyNames)\n      .sortBy(getSortWeight)\n      .toJS();\n\n    return {\n      ...(uiOrder.length > 1 && { 'ui:order': uiOrder }),\n      ..._.reduce(\n        jsonSchema?.properties ?? {},\n        (orderAccumulator, property, propertyName) => {\n          const descendantOrder = getJSONSchemaOrder(property, uiSchema?.[propertyName]);\n          if (_.isEmpty(descendantOrder)) {\n            return orderAccumulator;\n          }\n          return {\n            ...orderAccumulator,\n            [propertyName]: descendantOrder,\n          };\n        },\n        {},\n      ),\n    };\n  };\n\n  switch (type) {\n    case SchemaType.array:\n      return handleArray();\n    case SchemaType.object:\n      return handleObject();\n    default:\n      return {};\n  }\n};\n\n// Map a set of spec descriptors to a ui schema\nexport const descriptorsToUISchema = (descriptors: Descriptor<SpecCapability>[], jsonSchema: JSONSchema6) => {\n  const uiSchemaFromDescriptors = _.reduce(\n    descriptors,\n    (uiSchemaAccumulator, { path, description, displayName, 'x-descriptors': capabilities = [] }) => {\n      const uiSchemaPath = descriptorPathToUISchemaPath(path);\n      if (!jsonSchemaHas(jsonSchema, uiSchemaPath)) {\n        // eslint-disable-next-line no-console\n        console.warn('SpecDescriptor path references a non-existent schema property:', path);\n        return uiSchemaAccumulator;\n      }\n      const isAdvanced = _.includes(capabilities, SpecCapability.advanced);\n      const capabilitiesUISchema = capabilitiesToUISchema(_.without(capabilities, SpecCapability.advanced));\n      return uiSchemaAccumulator.withMutations(mutable => {\n        if (isAdvanced) {\n          const advancedPropertyName = _.last(uiSchemaPath);\n          const pathToAdvanced = [...uiSchemaPath.slice(0, uiSchemaPath.length - 1), 'ui:advanced'];\n          const currentAdvanced = mutable.getIn(pathToAdvanced) ?? Immutable.List();\n          mutable.setIn(pathToAdvanced, currentAdvanced.push(advancedPropertyName));\n        }\n\n        mutable.setIn(\n          uiSchemaPath,\n          Immutable.Map({\n            ...(description && { 'ui:description': description }),\n            ...(displayName && { 'ui:title': displayName }),\n            ...capabilitiesUISchema,\n          }),\n        );\n      });\n    },\n    Immutable.Map(),\n  ).toJS();\n  return _.merge(uiSchemaFromDescriptors, getJSONSchemaOrder(jsonSchema, uiSchemaFromDescriptors)); // schema 우선순위 정렬 로직\n};\n\n// Use jsonSchema, descriptors, and some defaults to generate a uiSchema\nexport const getUISchema = (jsonSchema, providedAPI) => {\n  return _.defaultsDeep(\n    {\n      metadata: {\n        ...hideAllExistingProperties(jsonSchema?.properties?.metadata as JSONSchema6),\n        name: {\n          'ui:title': 'Name',\n          'ui:widget': 'TextWidget',\n        },\n        labels: {\n          'ui:title': 'Labels',\n          'ui:field': 'LabelsField',\n        },\n        'ui:options': {\n          label: false,\n        },\n        'ui:order': ['name', 'labels', '*'],\n      },\n      spec: {\n        ...descriptorsToUISchema(providedAPI?.specDescriptors, jsonSchema?.properties?.spec),\n        'ui:options': {\n          label: false,\n        },\n      },\n      'ui:order': ['metadata', 'spec', '*'],\n    },\n    getDefaultUISchema(jsonSchema, ''),\n  );\n};\n","import * as React from 'react';\nimport { match as RouterMatch } from 'react-router-dom';\nimport { yamlTemplates } from '../models/yaml-templates';\nimport { connectToPlural } from '../kinds';\nimport { AsyncComponent } from './utils/async';\nimport { Firehose, LoadingBox } from './utils';\nimport {\n  K8sKind,\n  apiVersionForModel,\n  referenceForModel,\n  K8sResourceKindReference,\n  K8sResourceKind,\n} from '../module/k8s';\nimport { ErrorPage404 } from './error';\nimport { safeYAMLToJS } from '@console/shared/src/utils/yaml';\n\nexport const CreateYAML = connectToPlural((props: CreateYAMLProps) => {\n  const {\n    match,\n    kindsInFlight,\n    kindObj,\n    hideHeader = false,\n    onChange = () => null,\n    resourceObjPath,\n  } = props;\n  const { params } = match;\n\n  if (!kindObj) {\n    if (kindsInFlight) {\n      return <LoadingBox />;\n    }\n    return <ErrorPage404 />;\n  }\n\n  const namespace = params.ns || 'default';\n  const template =\n    props.template ||\n    yamlTemplates.getIn([referenceForModel(kindObj), 'default']) ||\n    yamlTemplates.getIn(['DEFAULT', 'default']);\n\n  const obj = safeYAMLToJS(template);\n  obj.kind = kindObj.kind;\n  obj.metadata = obj.metadata || {};\n  if (kindObj.namespaced) {\n    obj.metadata.namespace = namespace;\n  }\n  if (kindObj.crd && template === yamlTemplates.getIn(['DEFAULT', 'default'])) {\n    obj.apiVersion = apiVersionForModel(kindObj);\n    obj.spec = obj.spec || {};\n  }\n  const header = `Create ${kindObj.label}`;\n\n  // TODO: if someone edits namespace, we'll redirect to old namespace\n\n  return (\n    <AsyncComponent\n      loader={() => import('./droppable-edit-yaml').then((c) => c.DroppableEditYAML)}\n      obj={obj}\n      create={true}\n      kind={kindObj.kind}\n      header={header}\n      hideHeader={hideHeader}\n      resourceObjPath={resourceObjPath}\n      onChange={onChange}\n    />\n  );\n});\n\nexport const EditYAMLPage: React.SFC<EditYAMLPageProps> = (props) => {\n  const Wrapper = (wrapperProps) => (\n    <AsyncComponent\n      {...wrapperProps}\n      obj={wrapperProps.obj.data}\n      loader={() => import('./edit-yaml').then((c) => c.EditYAML)}\n      create={false}\n    />\n  );\n  return (\n    <Firehose\n      resources={[\n        {\n          kind: props.kind,\n          name: props.match.params.name,\n          namespace: props.match.params.ns,\n          isList: false,\n          prop: 'obj',\n        },\n      ]}\n    >\n      <Wrapper />\n    </Firehose>\n  );\n};\n\nexport type CreateYAMLProps = {\n  match: RouterMatch<{ ns: string; plural: string; appName?: string }>;\n  kindsInFlight: boolean;\n  kindObj: K8sKind;\n  template?: string;\n  download?: boolean;\n  header?: string;\n  hideHeader?: boolean;\n  resourceObjPath?: (obj: K8sResourceKind, kind: K8sResourceKindReference) => string;\n  onChange?: (yaml: string) => any;\n};\n\nexport type EditYAMLPageProps = {\n  match: RouterMatch<{ ns: string; name: string }>;\n  kind: string;\n};\n\nEditYAMLPage.displayName = 'EditYAMLPage';\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAQA;AAEA;;AACA;AACA;AAEA;AACA;AAaA;AAEA;AAEA;AAIA;AAEA;AAIA;AAEA;AAIA;AACA;AACA;AAEA;AAGA;AAEA;AAEA;AAIA;;AAAA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAYA;AACA;AAIA;AACA;AACA;AACA;AAGA;AASA;AAOA;AACA;;;;;;;;;;;;ACnEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAWA;AAEA;AAMA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AAIA;AAGA;AACA;AACA;AACA;;AACA;AAKA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AACA;AAIA;AAKA;AACA;AACA;AACA;;AACA;AAKA;AAEA;;AAGA;;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAGA;AAIA;AAGA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;;;;;;;;;;;;;AC9BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AACA;;AAIA;AAKA;AAYA;;;;;;;;;;;;ACpIA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAQA;AACA;AAGA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAGA;;;;;;;;;;;;;ACzFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAQA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AASA;;AACA;AACA;AAIA;AAEA;AAEA;AAOA;;AACA;AAGA;AAEA;AAGA;AASA;AAQA;AAEA;;AACA;AAEA;AACA;AAIA;AACA;AAGA;AAIA;AACA;AAGA;AAIA;AAGA;AAGA;AAIA;AACA;AACA;AAGA;AAQA;AAWA;AAEA;AACA;AAEA;AACA;AAEA;AACA;;AADA;AACA;AACA;AAQA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;;AADA;AACA;AACA;AAQA;AACA;AACA;AAEA;AAKA;AAEA;AAQA;AACA;AACA;AACA;;AACA;AACA;AAIA;AAEA;;AACA;AAMA;AACA;AAYA;AAEA;AAOA;;AACA;AAGA;AACA;AAEA;AAGA;AASA;AACA;AAGA;AAUA;AAQA;AAEA;AACA;AAKA;AAIA;AACA;AACA;AAGA;AAQA;AAQA;AAIA;AACA;AACA;AACA;AACA;AACA;AAGA;AAQA;AAQA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AAAA;AACA;AAQA;AAEA;AACA;AACA;AAEA;AAKA;AA0CA;AACA;;;;;;;;;;;;;ACjeA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AAGA;AAOA;AACA;AAGA;AAQA;AACA;AAGA;AAQA;AACA;AACA;AAOA;AAMA;AAGA;AAGA;AAGA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AAAA;AACA;AAOA;AACA;AACA;AAEA;AAIA;AAgBA;;;;;;;;;;;;;ACjIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAOA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpDA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAAA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AACA;AAIA;AACA;AAKA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;;AAEA;AACA;AAMA;AASA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAAA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAQA;AAEA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAIA;AAGA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;;AAGA;AACA;AACA;AAIA;;;;;;;;;;;;;;;AAeA;AACA;;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAIA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAGA;AACA;AAEA;AACA;;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AAGA;;;;;;;;;;;;;AC5aA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAYA;AAEA;AACA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAmBA;;;;;A","sourceRoot":""}