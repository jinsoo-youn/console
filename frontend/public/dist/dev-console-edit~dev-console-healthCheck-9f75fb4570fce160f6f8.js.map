{"version":3,"file":"dev-console-edit~dev-console-healthCheck-9f75fb4570fce160f6f8.js","sources":["webpack:///./packages/dev-console/src/components/edit-application/edit-application-utils.ts"],"sourcesContent":["import * as _ from 'lodash';\nimport {\n  K8sResourceKind,\n  referenceFor,\n  referenceForModel,\n  ImagePullPolicy,\n} from '@console/internal/module/k8s';\nimport { BuildStrategyType } from '@console/internal/components/build';\nimport { DeploymentConfigModel, DeploymentModel } from '@console/internal/models';\nimport { ServiceModel } from '@console/knative-plugin';\nimport { UNASSIGNED_KEY } from '../../const';\nimport { Resources, DeploymentData, GitReadableTypes } from '../import/import-types';\nimport { AppResources } from './edit-application-types';\nimport { RegistryType } from '../../utils/imagestream-utils';\nimport { getHealthChecksData } from '../health-checks/create-health-checks-probe-utils';\nimport { detectGitType } from '../import/import-validation-utils';\n\nexport enum CreateApplicationFlow {\n  Git = 'Import from Git',\n  Dockerfile = 'Import from Dockerfile',\n  Container = 'Deploy Image',\n}\n\nexport const getResourcesType = (resource: K8sResourceKind): Resources => {\n  switch (resource.kind) {\n    case DeploymentConfigModel.kind:\n      return Resources.OpenShift;\n    case DeploymentModel.kind:\n      return Resources.Kubernetes;\n    case referenceFor(resource) === referenceForModel(ServiceModel) ? ServiceModel.kind : '':\n      return Resources.KnativeService;\n    default:\n      return null;\n  }\n};\n\nexport const getPageHeading = (buildStrategy: string): string => {\n  switch (buildStrategy) {\n    case BuildStrategyType.Source:\n      return CreateApplicationFlow.Git;\n    case BuildStrategyType.Docker:\n      return CreateApplicationFlow.Dockerfile;\n    default:\n      return CreateApplicationFlow.Container;\n  }\n};\n\nconst checkIfTriggerExists = (\n  triggers: { [key: string]: any }[],\n  type: string,\n  resourceKind?: string,\n) => {\n  return !!_.find(triggers, (trigger) => {\n    if (resourceKind === DeploymentConfigModel.kind && type === 'ImageChange') {\n      return trigger.type === type && trigger.imageChangeParams?.automatic;\n    }\n    return trigger.type === type;\n  });\n};\n\nexport const getGitData = (buildConfig: K8sResourceKind) => {\n  const url = buildConfig?.spec?.source?.git?.uri ?? '';\n  const gitData = {\n    url,\n    type: detectGitType(url),\n    ref: _.get(buildConfig, 'spec.source.git.ref', ''),\n    dir: _.get(buildConfig, 'spec.source.contextDir', ''),\n    showGitType: false,\n    secret: _.get(buildConfig, 'spec.source.sourceSecret.name', ''),\n    isUrlValidating: false,\n  };\n  return gitData;\n};\n\nexport const getRouteData = (route: K8sResourceKind, resource: K8sResourceKind) => {\n  let routeData = {\n    disable: !_.isEmpty(route),\n    create: true,\n    targetPort: _.get(route, 'spec.port.targetPort', ''),\n    unknownTargetPort: '',\n    defaultUnknownPort: 8080,\n    path: _.get(route, 'spec.path', ''),\n    hostname: _.get(route, 'spec.host', ''),\n    secure: _.has(route, 'spec.termination'),\n    tls: {\n      termination: _.get(route, 'spec.termination', ''),\n      insecureEdgeTerminationPolicy: _.get(route, 'spec.insecureEdgeTerminationPolicy', ''),\n      caCertificate: _.get(route, 'spec.caCertificate', ''),\n      certificate: _.get(route, 'spec.certificate', ''),\n      destinationCACertificate: _.get(route, 'spec.destinationCACertificate', ''),\n      privateKey: _.get(route, 'spec.privateKey', ''),\n    },\n  };\n  if (getResourcesType(resource) === Resources.KnativeService) {\n    const containers = _.get(resource, 'spec.template.spec.containers', []);\n    const port = _.get(containers[0], 'ports[0].containerPort', '');\n    routeData = {\n      ...routeData,\n      disable:\n        _.get(resource, 'metadata.labels[\"serving.knative.dev/visibility\"]', '') !==\n        'cluster-local',\n      unknownTargetPort: _.toString(port),\n      targetPort: _.toString(port),\n    };\n  }\n  return routeData;\n};\n\nexport const getBuildData = (buildConfig: K8sResourceKind, gitType: string) => {\n  const buildStrategyType = _.get(buildConfig, 'spec.strategy.type', '');\n  let buildStrategyData;\n  switch (buildStrategyType) {\n    case BuildStrategyType.Source:\n      buildStrategyData = _.get(buildConfig, 'spec.strategy.sourceStrategy');\n      break;\n    case BuildStrategyType.Docker:\n      buildStrategyData = _.get(buildConfig, 'spec.strategy.dockerStrategy');\n      break;\n    default:\n      buildStrategyData = { env: [] };\n  }\n  const triggers = _.get(buildConfig, 'spec.triggers');\n  const buildData = {\n    env: buildStrategyData.env || [],\n    triggers: {\n      webhook: checkIfTriggerExists(triggers, GitReadableTypes[gitType]),\n      image: checkIfTriggerExists(triggers, 'ImageChange'),\n      config: checkIfTriggerExists(triggers, 'ConfigChange'),\n    },\n    strategy: buildStrategyType,\n  };\n  return buildData;\n};\n\nexport const getServerlessData = (resource: K8sResourceKind) => {\n  let serverlessData = {\n    scaling: {\n      minpods: 0,\n      maxpods: '',\n      concurrencytarget: '',\n      concurrencylimit: '',\n    },\n  };\n  if (getResourcesType(resource) === Resources.KnativeService) {\n    const annotations = _.get(resource, 'spec.template.metadata.annotations');\n    serverlessData = {\n      scaling: {\n        minpods: _.get(annotations, 'autoscaling.knative.dev/minScale', 0),\n        maxpods: _.get(annotations, 'autoscaling.knative.dev/maxScale', ''),\n        concurrencytarget: _.get(annotations, 'autoscaling.knative.dev/target', ''),\n        concurrencylimit: _.get(resource, 'spec.template.spec.containerConcurrency', ''),\n      },\n    };\n  }\n  return serverlessData;\n};\n\nexport const getDeploymentData = (resource: K8sResourceKind) => {\n  const deploymentData: DeploymentData = {\n    env: [],\n    replicas: 1,\n    triggers: { image: true, config: true },\n  };\n  const container = resource.spec?.template?.spec?.containers?.[0];\n  const env = container?.env ?? [];\n  switch (getResourcesType(resource)) {\n    case Resources.KnativeService:\n      return {\n        ...deploymentData,\n        env,\n        triggers: {\n          image: container?.imagePullPolicy === ImagePullPolicy.Always,\n        },\n      };\n    case Resources.OpenShift: {\n      const triggers = resource.spec?.triggers;\n      return {\n        env,\n        triggers: {\n          image: checkIfTriggerExists(triggers, 'ImageChange', resource.kind),\n          config: checkIfTriggerExists(triggers, 'ConfigChange'),\n        },\n        replicas: resource.spec?.replicas ?? 1,\n      };\n    }\n    case Resources.Kubernetes: {\n      const imageTrigger = JSON.parse(\n        resource.metadata?.annotations?.['image.openshift.io/triggers'] ?? '[]',\n      )?.[0];\n      return {\n        env,\n        triggers: {\n          image: imageTrigger?.pause === 'false',\n        },\n        replicas: resource.spec?.replicas ?? 1,\n      };\n    }\n    default:\n      return deploymentData;\n  }\n};\n\nexport const getLimitsData = (resource: K8sResourceKind) => {\n  const containers = _.get(resource, 'spec.template.spec.containers', []);\n  const resourcesRegEx = /^[0-9]*|[a-zA-Z]*/g;\n  const cpuLimit = _.get(containers[0], 'resources.limits.cpu', '').match(resourcesRegEx);\n  const memoryLimit = _.get(containers[0], 'resources.limits.memory', '').match(resourcesRegEx);\n  const cpuRequest = _.get(containers[0], 'resources.requests.cpu', '').match(resourcesRegEx);\n  const memoryRequest = _.get(containers[0], 'resources.requests.memory', '').match(resourcesRegEx);\n  const limitsData = {\n    cpu: {\n      request: cpuRequest[0],\n      requestUnit: cpuRequest[1] || '',\n      defaultRequestUnit: cpuRequest[1] || '',\n      limit: cpuLimit[0],\n      limitUnit: cpuLimit[1] || '',\n      defaultLimitUnit: cpuLimit[1] || '',\n    },\n    memory: {\n      request: memoryRequest[0],\n      requestUnit: memoryRequest[1] || 'Mi',\n      defaultRequestUnit: memoryRequest[1] || 'Mi',\n      limit: memoryLimit[0],\n      limitUnit: memoryLimit[1] || 'Mi',\n      defaultLimitUnit: memoryLimit[1] || 'Mi',\n    },\n  };\n  return limitsData;\n};\n\nexport const getUserLabels = (resource: K8sResourceKind) => {\n  const defaultLabels = [\n    'app',\n    'app.kubernetes.io/instance',\n    'app.kubernetes.io/component',\n    'app.kubernetes.io/name',\n    'app.openshift.io/runtime',\n    'app.kubernetes.io/part-of',\n    'app.openshift.io/runtime-version',\n    'app.openshift.io/runtime-namespace',\n  ];\n  const allLabels = _.get(resource, 'metadata.labels', {});\n  const userLabels = _.omit(allLabels, defaultLabels);\n  return userLabels;\n};\n\nexport const getCommonInitialValues = (\n  editAppResource: K8sResourceKind,\n  route: K8sResourceKind,\n  name: string,\n  namespace: string,\n) => {\n  const appGroupName = _.get(editAppResource, 'metadata.labels[\"app.kubernetes.io/part-of\"]');\n  const commonInitialValues = {\n    formType: 'edit',\n    name,\n    application: {\n      name: appGroupName || '',\n      selectedKey: appGroupName || UNASSIGNED_KEY,\n    },\n    project: {\n      name: namespace,\n    },\n    route: getRouteData(route, editAppResource),\n    resources: getResourcesType(editAppResource),\n    serverless: getServerlessData(editAppResource),\n    pipeline: {\n      enabled: false,\n    },\n    deployment: getDeploymentData(editAppResource),\n    labels: getUserLabels(editAppResource),\n    limits: getLimitsData(editAppResource),\n    healthChecks: getHealthChecksData(editAppResource),\n  };\n  return commonInitialValues;\n};\n\nexport const getGitAndDockerfileInitialValues = (\n  buildConfig: K8sResourceKind,\n  route: K8sResourceKind,\n) => {\n  if (_.isEmpty(buildConfig)) {\n    return {};\n  }\n  const currentImage = _.split(\n    _.get(buildConfig, 'spec.strategy.sourceStrategy.from.name', ''),\n    ':',\n  );\n  const git = getGitData(buildConfig);\n  const initialValues = {\n    git,\n    docker: {\n      dockerfilePath: _.get(\n        buildConfig,\n        'spec.strategy.dockerStrategy.dockerfilePath',\n        'Dockerfile',\n      ),\n      containerPort: parseInt(_.split(_.get(route, 'spec.port.targetPort'), '-')[0], 10),\n    },\n    image: {\n      selected: currentImage[0] || '',\n      recommended: '',\n      tag: currentImage[1] || '',\n      tagObj: {},\n      ports: [],\n      isRecommending: false,\n      couldNotRecommend: false,\n    },\n    build: getBuildData(buildConfig, git.type),\n  };\n  return initialValues;\n};\n\nconst deployImageInitialValues = {\n  searchTerm: '',\n  registry: 'external',\n  imageStream: {\n    image: '',\n    tag: '',\n    namespace: '',\n  },\n  isi: {\n    name: '',\n    image: {},\n    tag: '',\n    status: { metadata: {}, status: '' },\n    ports: [],\n  },\n  image: {\n    name: '',\n    image: {},\n    tag: '',\n    status: { metadata: {}, status: '' },\n    ports: [],\n  },\n  build: {\n    env: [],\n    triggers: {},\n    strategy: '',\n  },\n  isSearchingForImage: false,\n};\n\nexport const getExternalImageInitialValues = (appResources: AppResources) => {\n  const imageStreamList = appResources?.imageStream?.data;\n  if (_.isEmpty(imageStreamList)) {\n    return {};\n  }\n  const imageStream = _.orderBy(imageStreamList, ['metadata.resourceVersion'], ['desc']);\n  const name = imageStream.length && imageStream[0]?.spec?.tags?.[0]?.from?.name;\n  return {\n    ...deployImageInitialValues,\n    searchTerm: name,\n    registry: 'external',\n    imageStream: {\n      ...deployImageInitialValues.imageStream,\n      grantAccess: true,\n    },\n  };\n};\n\nexport const getInternalImageInitialValues = (editAppResource: K8sResourceKind) => {\n  const imageStreamNamespace = _.get(\n    editAppResource,\n    'metadata.labels[\"app.openshift.io/runtime-namespace\"]',\n    '',\n  );\n  const imageStreamName = _.get(editAppResource, 'metadata.labels[\"app.openshift.io/runtime\"]', '');\n  const imageStreamTag = _.get(\n    editAppResource,\n    'metadata.labels[\"app.openshift.io/runtime-version\"]',\n    '',\n  );\n  return {\n    ...deployImageInitialValues,\n    registry: RegistryType.Internal,\n    imageStream: {\n      image: imageStreamName,\n      tag: imageStreamTag,\n      namespace: imageStreamNamespace,\n    },\n  };\n};\n\nexport const getExternalImagelValues = (appResource: K8sResourceKind) => {\n  const name = _.get(appResource, 'spec.template.spec.containers[0].image', null);\n  if (_.isEmpty(appResource) || !name) {\n    return {};\n  }\n  return {\n    ...deployImageInitialValues,\n    searchTerm: name,\n    registry: RegistryType.External,\n    imageStream: {\n      ...deployImageInitialValues.imageStream,\n      grantAccess: true,\n    },\n  };\n};\n\nexport const getInitialValues = (\n  appResources: AppResources,\n  appName: string,\n  namespace: string,\n) => {\n  const commonValues = getCommonInitialValues(\n    _.get(appResources, 'editAppResource.data'),\n    _.get(appResources, 'route.data'),\n    appName,\n    namespace,\n  );\n  const gitDockerValues = getGitAndDockerfileInitialValues(\n    _.get(appResources, 'buildConfig.data'),\n    _.get(appResources, 'route.data'),\n  );\n  let externalImageValues = {};\n  let internalImageValues = {};\n\n  if (_.isEmpty(gitDockerValues)) {\n    externalImageValues = getExternalImageInitialValues(appResources);\n    internalImageValues = _.isEmpty(externalImageValues)\n      ? getInternalImageInitialValues(_.get(appResources, 'editAppResource.data'))\n      : {};\n    if (\n      _.isEmpty(externalImageValues) &&\n      !_.get(internalImageValues, 'imageStream.tag') &&\n      !_.get(internalImageValues, 'imageStream.image')\n    ) {\n      const editAppResourceData = _.get(appResources, 'editAppResource.data');\n      if (editAppResourceData?.kind === ServiceModel.kind) {\n        internalImageValues = {};\n        externalImageValues = getExternalImagelValues(_.get(appResources, 'editAppResource.data'));\n      }\n    }\n  }\n\n  return {\n    ...commonValues,\n    ...gitDockerValues,\n    ...externalImageValues,\n    ...internalImageValues,\n  };\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AACA;AAKA;AACA;AAKA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AASA;AAEA;AAKA;AAMA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;;;;;A","sourceRoot":""}