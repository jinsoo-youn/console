{"version":3,"file":"pipeline~pipeline-builder-edit-page~pipeline-builder-page~pipeline-details~pipeline-overview-list~pi~3bd37dc8-28373152389603de9c92.js","sources":["webpack:///./packages/dev-console/src/components/import/section/FormSection.scss?8752","webpack:///./packages/dev-console/src/components/import/section/FormSection.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/ModalStructure.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/MultipleKeySelector.scss?221b","webpack:///./packages/dev-console/src/components/pipelines/modals/common/MultipleKeySelector.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/MultipleResourceKeySelector.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PVCDropdown.scss?84fd","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PVCDropdown.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineParameterSection.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineResourceDropdown.scss?bd49","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineResourceDropdown.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineResourceDropdownField.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineResourceSection.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineSecretSection.scss?8f13","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PipelineSecretSection.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/PiplelineWorkspacesSection.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/SecretAnnotation.scss?e135","webpack:///./packages/dev-console/src/components/pipelines/modals/common/SecretAnnotation.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/SecretForm.scss?6e17","webpack:///./packages/dev-console/src/components/pipelines/modals/common/SecretForm.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/SecretsList.scss?fde6","webpack:///./packages/dev-console/src/components/pipelines/modals/common/SecretsList.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/common/const.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/common/utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/common/validation-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/index.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/start-pipeline/StartPipelineForm.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/start-pipeline/StartPipelineModal.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/start-pipeline/submit-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/AddTriggerForm.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/AddTriggerModal.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/RemoveTriggerForm.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/RemoveTriggerModal.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/TriggerBindingSection.scss?1ba0","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/TriggerBindingSection.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/TriggerBindingSelector.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/TriggerBindingSelectorDropdown.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/TriggerTemplateSelector.scss?6c91","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/TriggerTemplateSelector.tsx","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/const.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/remove-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/resource-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/submit-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/modals/triggers/validation-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/PipelineClusterOptions.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/PipelineGitOptions.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/PipelineImageOptions.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/PipelineResourceParam.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/PipelineStorageOptions.tsx","webpack:///./packages/dev-console/src/components/pipelines/pipeline-resource/pipelineResource-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/utils/triggers.ts","webpack:///./public/components/utils/k8s-get-hook.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport cx from 'classnames';\nimport { FormHelperText } from '@patternfly/react-core';\nimport './FormSection.scss';\n\nexport interface FormSectionProps {\n  title?: React.ReactNode;\n  subTitle?: React.ReactNode;\n  fullWidth?: boolean;\n  children: React.ReactNode;\n  flexLayout?: boolean;\n  extraMargin?: boolean;\n}\n\nconst flexStyle: React.CSSProperties = {\n  display: 'flex',\n  flex: 1,\n  flexDirection: 'column',\n  margin: 'var(--pf-global--spacer--md) 0',\n};\n\nconst FormSection: React.FC<FormSectionProps> = ({\n  title,\n  subTitle,\n  fullWidth,\n  children,\n  flexLayout,\n  extraMargin,\n}) => (\n  <div\n    className={cx('pf-c-form', {\n      'co-m-pane__form': !fullWidth,\n      'odc-form-section--extra-margin': extraMargin,\n    })}\n    style={flexLayout ? flexStyle : {}}\n  >\n    {title && <h2 className=\"odc-form-section__heading\">{title}</h2>}\n    {subTitle && <FormHelperText isHidden={false}>{subTitle}</FormHelperText>}\n    {children}\n  </div>\n);\n\nexport default FormSection;\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { FormikProps, FormikValues } from 'formik';\nimport { Form } from '@patternfly/react-core';\nimport {\n  ModalBody,\n  ModalComponentProps,\n  ModalSubmitFooter,\n  ModalTitle,\n} from '@console/internal/components/factory';\n\ntype ModalStructureProps = {\n  children: React.ReactNode;\n  submitBtnText: string;\n  submitDanger?: boolean;\n  title: string;\n};\n\ntype ModalStructureCombinedProps = FormikProps<FormikValues> &\n  ModalComponentProps &\n  ModalStructureProps;\n\nconst ModalStructure: React.FC<ModalStructureCombinedProps> = (props) => {\n  const {\n    children,\n    close,\n    errors,\n    isSubmitting,\n    handleSubmit,\n    status,\n    submitBtnText,\n    submitDanger,\n    title,\n  } = props;\n\n  return (\n    <Form onSubmit={handleSubmit}>\n      <div className=\"modal-content\">\n        <ModalTitle>{title}</ModalTitle>\n        <ModalBody>\n          <div className=\"pf-c-form\">{children}</div>\n        </ModalBody>\n        <ModalSubmitFooter\n          errorMessage={status?.submitError}\n          inProgress={isSubmitting}\n          submitText={submitBtnText}\n          submitDisabled={!_.isEmpty(errors)}\n          submitDanger={submitDanger}\n          cancel={close}\n        />\n      </div>\n    </Form>\n  );\n};\n\nexport default ModalStructure;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { FieldArray, useFormikContext, FormikValues } from 'formik';\nimport * as _ from 'lodash';\nimport cx from 'classnames';\nimport { PlusCircleIcon, MinusCircleIcon } from '@patternfly/react-icons';\nimport { DropdownField, InputField, getFieldId, useFormikValidationFix } from '@console/shared';\nimport { TextInputTypes, Button, FormGroup } from '@patternfly/react-core';\nimport './MultipleKeySelector.scss';\n\ninterface MultipleKeySelectorProps {\n  name: string;\n  keys: { [key: string]: string };\n}\n\nconst MultipleKeySelector: React.FC<MultipleKeySelectorProps> = ({ name, keys }) => {\n  const { values } = useFormikContext<FormikValues>();\n  const items = _.get(values, name, [{ key: '', path: '' }]);\n  useFormikValidationFix(items);\n  return (\n    <FieldArray\n      name={name}\n      key=\"multiple-key-selector\"\n      render={({ push, remove }) => {\n        return (\n          <FormGroup\n            fieldId={getFieldId(name, 'multiple-key-selector')}\n            label=\"Items\"\n            className=\"odc-multiple-key-selector\"\n          >\n            {items.length > 0 &&\n              items.map((item, index) => {\n                const fieldKey = `${name}.${index}.${item.key}`;\n                return (\n                  <div className=\"form-group odc-multiple-key-selector__item\" key={fieldKey}>\n                    <DropdownField\n                      name={`${name}.${index}.key`}\n                      title=\"Select a key\"\n                      items={keys}\n                      fullWidth\n                    />\n                    <InputField\n                      name={`${name}.${index}.path`}\n                      type={TextInputTypes.text}\n                      placeholder=\"Enter a path\"\n                      isDisabled={!item.key}\n                    />\n                    <div\n                      className={cx('odc-multiple-key-selector__deleteButton', {\n                        '--disabled': items.length <= 1,\n                      })}\n                    >\n                      <MinusCircleIcon aria-hidden=\"true\" onClick={() => remove(index)} />\n                    </div>\n                  </div>\n                );\n              })}\n            <Button\n              variant=\"link\"\n              onClick={() => push({ key: '', path: '' })}\n              icon={<PlusCircleIcon />}\n              isInline\n            >\n              Add items\n            </Button>\n          </FormGroup>\n        );\n      }}\n    />\n  );\n};\n\nexport default MultipleKeySelector;\n","import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { useField, useFormikContext, FormikValues } from 'formik';\nimport cx from 'classnames';\nimport * as fuzzy from 'fuzzysearch';\nimport * as _ from 'lodash';\nimport { RootState } from '@console/internal/redux';\nimport { getActiveNamespace } from '@console/internal/reducers/ui';\nimport { K8sKind, K8sResourceKind } from '@console/internal/module/k8s';\nimport { ResourceDropdown, getFieldId, useFormikValidationFix } from '@console/shared';\nimport { FormGroup } from '@patternfly/react-core';\nimport {\n  useK8sWatchResource,\n  WatchK8sResource,\n} from '@console/internal/components/utils/k8s-watch-hook';\nimport MultipleKeySelector from './MultipleKeySelector';\n\ninterface MultipleResourceKeySelectorProps {\n  label: string;\n  resourceModel: K8sKind;\n  required?: boolean;\n  resourceNameField: string;\n  resourceKeysField: string;\n}\n\ninterface StateProps {\n  namespace: string;\n}\n\nconst MultipleResourceKeySelector: React.FC<StateProps & MultipleResourceKeySelectorProps> = ({\n  label,\n  namespace,\n  resourceModel,\n  required,\n  resourceNameField,\n  resourceKeysField,\n}) => {\n  const { setFieldValue, setFieldTouched } = useFormikContext<FormikValues>();\n  const [field, { touched, error }] = useField(resourceNameField);\n  const isValid = !(touched && error);\n  const fieldId = getFieldId(resourceNameField, 'res-dropdown');\n  const [keys, setKeys] = React.useState({});\n\n  useFormikValidationFix(field.value);\n\n  const resource: WatchK8sResource = React.useMemo(\n    () => ({\n      kind: resourceModel.kind,\n      isList: true,\n      namespace,\n      optional: true,\n    }),\n    [namespace, resourceModel.kind],\n  );\n\n  const [resources, loaded, loadError] = useK8sWatchResource(resource);\n\n  const autocompleteFilter = (strText, item): boolean => fuzzy(strText, item?.props?.name);\n\n  const generateKeys = (resourceName: string) => {\n    const selectedResource: K8sResourceKind = _.find(resources, (res) => {\n      return _.get(res, 'metadata.name') === resourceName;\n    });\n    const keyMap = selectedResource?.data;\n    const itemKeys = Object.keys(keyMap).reduce((acc, key) => ({ ...acc, [key]: key }), {});\n    setKeys(itemKeys);\n  };\n\n  return (\n    <FormGroup\n      fieldId={fieldId}\n      label={label}\n      isValid={isValid}\n      className=\"odc-multiple-key-selector\"\n      isRequired={required}\n    >\n      <ResourceDropdown\n        resources={[\n          { kind: resourceModel.kind, loaded, loadError, data: resources as K8sResourceKind[] },\n        ]}\n        loaded={loaded}\n        loadError={loadError}\n        dataSelector={['metadata', 'name']}\n        selectedKey={field.value}\n        placeholder={`Select a ${resourceModel.label}`}\n        autocompleteFilter={autocompleteFilter}\n        dropDownClassName={cx({ 'dropdown--full-width': true })}\n        onChange={(value: string) => {\n          setFieldValue(resourceKeysField, undefined);\n          setFieldValue(resourceNameField, value);\n          setFieldTouched(resourceNameField, true);\n          generateKeys(value);\n        }}\n        showBadge\n      />\n      {field.value && <MultipleKeySelector name={resourceKeysField} keys={keys} />}\n    </FormGroup>\n  );\n};\n\nconst mapStateToProps = (state: RootState): StateProps => ({\n  namespace: getActiveNamespace(state),\n});\n\nexport default connect<StateProps, null, MultipleResourceKeySelectorProps>(mapStateToProps)(\n  MultipleResourceKeySelector,\n);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as fuzzy from 'fuzzysearch';\nimport { connect } from 'react-redux';\nimport { ResourceDropdownField } from '@console/shared';\nimport { PersistentVolumeClaimModel } from '@console/internal/models';\nimport { getActiveNamespace } from '@console/internal/reducers/ui';\nimport { RootState } from '@console/internal/redux';\nimport './PVCDropdown.scss';\n\ninterface PVCDropdownProps {\n  name: string;\n}\n\ninterface StateProps {\n  namespace: string;\n}\n\nconst PVCDropdown: React.FC<PVCDropdownProps & StateProps> = ({ name, namespace }) => {\n  const autocompleteFilter = (strText, item): boolean => fuzzy(strText, item?.props?.name);\n  const resources = [\n    {\n      isList: true,\n      kind: PersistentVolumeClaimModel.kind,\n      namespace,\n      prop: PersistentVolumeClaimModel.id,\n      optional: true,\n    },\n  ];\n  return (\n    <ResourceDropdownField\n      name={name}\n      className=\"odc-pvc-dropdown\"\n      resources={resources}\n      dataSelector={['metadata', 'name']}\n      placeholder=\"Select a PVC\"\n      autocompleteFilter={autocompleteFilter}\n      fullWidth\n      showBadge\n    />\n  );\n};\n\nconst mapStateToProps = (state: RootState): StateProps => ({\n  namespace: getActiveNamespace(state),\n});\n\nexport default connect<StateProps, null, PVCDropdownProps>(mapStateToProps)(PVCDropdown);\n","import * as React from 'react';\nimport { FieldArray } from 'formik';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField } from '@console/shared';\nimport { PipelineParam } from '../../../../utils/pipeline-augment';\nimport FormSection from '../../../import/section/FormSection';\n\ntype ParametersSectionProps = {\n  parameters: PipelineParam[];\n};\n\nconst PipelineParameterSection: React.FC<ParametersSectionProps> = ({ parameters }) => (\n  <FieldArray\n    name=\"parameters\"\n    key=\"parameters-row\"\n    render={() =>\n      parameters.length > 0 && (\n        <FormSection title=\"Parameters\" fullWidth>\n          {parameters.map((parameter, index) => (\n            <InputField\n              key={parameter.name}\n              name={`parameters.${index}.default`}\n              type={TextInputTypes.text}\n              label={parameter.name}\n              helpText={parameter.description}\n              placeholder=\"Name\"\n              required\n            />\n          ))}\n        </FormSection>\n      )\n    }\n  />\n);\n\nexport default PipelineParameterSection;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { FormikValues, useField, useFormikContext } from 'formik';\nimport { Select, SelectOption } from '@patternfly/react-core';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport {\n  useK8sWatchResource,\n  WatchK8sResource,\n} from '@console/internal/components/utils/k8s-watch-hook';\nimport { LoadingInline } from '@console/internal/components/utils';\nimport { PipelineResourceModel } from '../../../../models';\nimport { PipelineResourceKind } from '../../../../utils/pipeline-augment';\nimport { CREATE_PIPELINE_RESOURCE } from './const';\n\nimport './PipelineResourceDropdown.scss';\n\ntype PipelineResourceDropdownProps = {\n  autoSelect?: boolean;\n  filterType: string;\n  name: string;\n  namespace: string;\n  selectedKey: string;\n};\n\nconst PipelineResourceDropdown: React.FC<PipelineResourceDropdownProps> = (props) => {\n  const { autoSelect, filterType, name, namespace, selectedKey } = props;\n\n  const [isExpanded, setExpanded] = React.useState(false);\n  const { setFieldValue, setFieldTouched } = useFormikContext<FormikValues>();\n  const [, { touched }] = useField(name);\n\n  const resourceDefinition: WatchK8sResource = React.useMemo(\n    () => ({\n      isList: true,\n      namespace,\n      kind: referenceForModel(PipelineResourceModel),\n    }),\n    [namespace],\n  );\n  const [resources, loaded, error] = useK8sWatchResource<PipelineResourceKind[]>(\n    resourceDefinition,\n  );\n\n  const availableResources: PipelineResourceKind[] = resources.filter(\n    (resource) => resource.spec.type === filterType,\n  );\n\n  const canAutoSelect = autoSelect && !touched && loaded && !error;\n  React.useEffect(() => {\n    if (canAutoSelect) {\n      if (availableResources.length === 0) {\n        setFieldValue(name, CREATE_PIPELINE_RESOURCE);\n      } else {\n        setFieldValue(name, availableResources[0].metadata.name);\n      }\n      setFieldTouched(name);\n    }\n  }, [canAutoSelect, name, availableResources, setFieldTouched, setFieldValue]);\n\n  const options = [\n    { label: 'Create Pipeline Resource', value: CREATE_PIPELINE_RESOURCE },\n    ...availableResources.map((resource) => {\n      const resourceName = resource.metadata.name;\n      const url = _.find(resource.spec.params, ['name', 'url'])?.value || '';\n      const label = url.trim().length > 0 ? `${url} (${resourceName})` : resourceName;\n\n      return { label, value: resourceName };\n    }),\n  ];\n\n  return (\n    <Select\n      className=\"odc-pipeline-resource-dropdown\"\n      selections={selectedKey}\n      isExpanded={isExpanded}\n      onToggle={() => setExpanded(!isExpanded)}\n      onSelect={(e, value) => {\n        setFieldValue(name, value);\n        setExpanded(false);\n      }}\n      placeholderText={!loaded ? <LoadingInline /> : 'Select Pipeline Resource'}\n      isDisabled={loaded && availableResources.length === 0}\n    >\n      {options.map(({ label, value }) => (\n        <SelectOption key={value} value={value}>\n          {label}\n        </SelectOption>\n      ))}\n    </Select>\n  );\n};\n\nexport default PipelineResourceDropdown;\n","import * as React from 'react';\nimport { useField, useFormikContext, FormikValues } from 'formik';\nimport { FormGroup } from '@patternfly/react-core';\nimport { DropdownFieldProps, useFormikValidationFix } from '@console/shared';\nimport PipelineResourceParam from '../../pipeline-resource/PipelineResourceParam';\nimport { CREATE_PIPELINE_RESOURCE } from './const';\nimport { PipelineModalFormResource } from './types';\nimport PipelineResourceDropdown from './PipelineResourceDropdown';\n\ntype PipelineResourceDropdownFieldProps = DropdownFieldProps & {\n  filterType?: string;\n};\nconst PipelineResourceDropdownField: React.FC<PipelineResourceDropdownFieldProps> = (props) => {\n  const { filterType, name, label } = props;\n\n  const [field] = useField<PipelineModalFormResource>(name);\n  const { values } = useFormikContext<FormikValues>();\n  const { namespace } = values;\n  const {\n    value: { selection },\n  } = field;\n  const creating = selection === CREATE_PIPELINE_RESOURCE;\n\n  useFormikValidationFix(field.value);\n\n  return (\n    <>\n      <FormGroup fieldId={name} label={label} isRequired>\n        <PipelineResourceDropdown\n          {...props}\n          autoSelect={selection == null}\n          filterType={filterType}\n          namespace={namespace}\n          name={`${name}.selection`}\n          selectedKey={selection}\n        />\n      </FormGroup>\n\n      {creating && <PipelineResourceParam name={`${name}.data`} type={filterType} />}\n    </>\n  );\n};\n\nexport default PipelineResourceDropdownField;\n","import * as React from 'react';\nimport { capitalize } from 'lodash';\nimport { FieldArray, useField } from 'formik';\nimport FormSection from '../../../import/section/FormSection';\nimport PipelineResourceDropdownField from './PipelineResourceDropdownField';\nimport { PipelineModalFormResource } from './types';\n\ntype ResourceSectionType = {\n  formikIndex: number;\n  resource: PipelineModalFormResource;\n};\ntype ResourceSection = {\n  cluster?: ResourceSectionType[];\n  git?: ResourceSectionType[];\n  image?: ResourceSectionType[];\n  storage?: ResourceSectionType[];\n};\n\nconst reduceToSections = (\n  acc: ResourceSection,\n  resource: PipelineModalFormResource,\n  formikIndex: number,\n) => {\n  const resourceType = resource.data.type;\n\n  if (!resourceType) {\n    return acc;\n  }\n\n  return {\n    ...acc,\n    [resourceType]: [...(acc[resourceType] || []), { formikIndex, resource }],\n  };\n};\n\nconst PipelineResourceSection: React.FC = () => {\n  const [{ value: resources }] = useField<PipelineModalFormResource[]>('resources');\n\n  const sections: ResourceSection = resources.reduce(reduceToSections, {} as ResourceSection);\n  const types = Object.keys(sections);\n\n  return (\n    <>\n      {types.map((type) => (\n        <FieldArray\n          name={type}\n          key={type}\n          render={() => {\n            const section = sections[type];\n\n            return (\n              <FormSection title={`${capitalize(type)} Resources`} fullWidth>\n                {section.map((sectionData: ResourceSectionType) => {\n                  const { formikIndex, resource } = sectionData;\n\n                  return (\n                    <PipelineResourceDropdownField\n                      key={resource.name}\n                      name={`resources.${formikIndex}`}\n                      filterType={type}\n                      label={resource.name}\n                    />\n                  );\n                })}\n              </FormSection>\n            );\n          }}\n        />\n      ))}\n    </>\n  );\n};\n\nexport default PipelineResourceSection;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Formik, useField, useFormikContext, FormikValues } from 'formik';\nimport { PlusCircleIcon } from '@patternfly/react-icons';\nimport { Button } from '@patternfly/react-core';\nimport { ExpandCollapse } from '@console/internal/components/utils';\nimport { SecretType } from '@console/internal/components/secrets/create-secret';\nimport { SecretModel } from '@console/internal/models';\nimport { k8sCreate } from '@console/internal/module/k8s';\nimport {\n  associateServiceAccountToSecret,\n  getSecretAnnotations,\n} from '../../../../utils/pipeline-utils';\nimport { SecretAnnotationId } from '../../const';\nimport { advancedSectionValidationSchema } from './validation-utils';\nimport SecretForm from './SecretForm';\nimport SecretsList from './SecretsList';\n\nimport './PipelineSecretSection.scss';\n\nconst initialValues = {\n  secretName: '',\n  annotations: { key: SecretAnnotationId.Image, value: '' },\n  type: SecretType.dockerconfigjson,\n  formData: {},\n};\n\ntype PipelineSecretSectionProps = {\n  namespace: string;\n};\n\nconst PipelineSecretSection: React.FC<PipelineSecretSectionProps> = ({ namespace }) => {\n  const [secretOpenField] = useField<boolean>('secretOpen');\n  const { setFieldValue } = useFormikContext<FormikValues>();\n\n  const handleSubmit = (values, actions) => {\n    actions.setSubmitting(true);\n    const newSecret = {\n      apiVersion: SecretModel.apiVersion,\n      kind: SecretModel.kind,\n      metadata: {\n        name: values.secretName,\n        namespace,\n        annotations: getSecretAnnotations(values.annotations),\n      },\n      type: values.type,\n      stringData: values.formData,\n    };\n    k8sCreate(SecretModel, newSecret)\n      .then((resp) => {\n        actions.setSubmitting(false);\n        setFieldValue(secretOpenField.name, false);\n        associateServiceAccountToSecret(resp, namespace);\n      })\n      .catch((err) => {\n        actions.setSubmitting(false);\n        setFieldValue(secretOpenField.name, false);\n        actions.setStatus({ submitError: err.message });\n      });\n  };\n\n  const handleReset = (values, actions) => {\n    actions.resetForm({ values: initialValues, status: {} });\n    setFieldValue(secretOpenField.name, false);\n  };\n\n  return (\n    <ExpandCollapse textExpanded=\"Hide Credential Options\" textCollapsed=\"Show Credential Options\">\n      <div className=\"odc-pipeline-secret-section\">\n        <p>\n          The following secrets are available for all pipelines in this namespace to authenticate to\n          the specified git server or docker registry:\n        </p>\n        <div className=\"odc-pipeline-secret-section__secrets\">\n          <SecretsList namespace={namespace} />\n          {secretOpenField.value ? (\n            <div className=\"odc-pipeline-secret-section__secret-form\">\n              <Formik\n                initialValues={initialValues}\n                validationSchema={advancedSectionValidationSchema}\n                onSubmit={handleSubmit}\n                onReset={handleReset}\n              >\n                {(props) => <SecretForm {...props} />}\n              </Formik>\n            </div>\n          ) : (\n            <Button\n              variant=\"link\"\n              onClick={() => {\n                setFieldValue(secretOpenField.name, true);\n              }}\n              className=\"odc-pipeline-secret-section__secret-action\"\n              icon={<PlusCircleIcon />}\n            >\n              Add Secret\n            </Button>\n          )}\n        </div>\n      </div>\n    </ExpandCollapse>\n  );\n};\n\nexport default PipelineSecretSection;\n","import * as React from 'react';\nimport { useFormikContext, FormikValues, useField } from 'formik';\nimport { SecretModel, ConfigMapModel } from '@console/internal/models';\nimport { DropdownField } from '@console/shared';\nimport { PipelineWorkspace } from '../../../../utils/pipeline-augment';\nimport FormSection from '../../../import/section/FormSection';\nimport { VolumeTypes } from '../../const';\nimport PVCDropdown from './PVCDropdown';\nimport MultipleResourceKeySelector from './MultipleResourceKeySelector';\n\nconst getVolumeTypeFields = (volumeType: VolumeTypes, index: number) => {\n  switch (VolumeTypes[volumeType]) {\n    case VolumeTypes.Secret: {\n      return (\n        <MultipleResourceKeySelector\n          resourceNameField={`workspaces.${index}.data.secret.secretName`}\n          resourceKeysField={`workspaces.${index}.data.secret.items`}\n          label=\"Secret\"\n          resourceModel={SecretModel}\n          required\n        />\n      );\n    }\n    case VolumeTypes.ConfigMap: {\n      return (\n        <MultipleResourceKeySelector\n          resourceNameField={`workspaces.${index}.data.configMap.name`}\n          resourceKeysField={`workspaces.${index}.data.configMap.items`}\n          label=\"Config Map\"\n          resourceModel={ConfigMapModel}\n          required\n        />\n      );\n    }\n    case VolumeTypes.PVC: {\n      return <PVCDropdown name={`workspaces.${index}.data.persistentVolumeClaim.claimName`} />;\n    }\n    default:\n      return null;\n  }\n};\n\nconst PipelineWorkspacesSection: React.FC = () => {\n  const { setFieldValue } = useFormikContext<FormikValues>();\n  const [{ value: workspaces }] = useField<PipelineWorkspace[]>('workspaces');\n  return (\n    workspaces.length > 0 && (\n      <FormSection title=\"Workspaces\" fullWidth>\n        {workspaces.map((workspace, index) => (\n          <div className=\"form-group\" key={workspace.name}>\n            <DropdownField\n              name={`workspaces.${index}.type`}\n              label={workspace.name}\n              items={VolumeTypes}\n              onChange={() => setFieldValue(`workspaces.${index}.data`, {})}\n              fullWidth\n              required\n            />\n            {getVolumeTypeFields(workspace.type as VolumeTypes, index)}\n          </div>\n        ))}\n      </FormSection>\n    )\n  );\n};\n\nexport default PipelineWorkspacesSection;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField, DropdownField } from '@console/shared';\nimport { SecretAnnotationType } from '../../const';\nimport './SecretAnnotation.scss';\n\ntype SecretAnnotationParam = {\n  fieldName: string;\n  isReadOnly?: boolean;\n};\n\nconst SecretAnnotation: React.FC<SecretAnnotationParam> = (props) => {\n  const { fieldName, isReadOnly = false } = props;\n  return (\n    <div className=\"odc-secret-annotation\">\n      <p className=\"odc-secret-annotation__label\">Designate provider to be authenticated</p>\n      <div className=\"form-group\">\n        <DropdownField\n          name={`${fieldName}.key`}\n          items={SecretAnnotationType}\n          label=\"Access to\"\n          disabled={isReadOnly}\n          fullWidth\n          required\n        />\n      </div>\n      <div className=\"form-group\">\n        <InputField\n          name={`${fieldName}.value`}\n          helpText=\"The base server url (e.g. https://github.com)\"\n          type={TextInputTypes.text}\n          isReadOnly={isReadOnly}\n          label=\"Server URL\"\n          required\n        />\n      </div>\n    </div>\n  );\n};\n\nexport default SecretAnnotation;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { FormikValues, useFormikContext } from 'formik';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { ButtonBar } from '@console/internal/components/utils';\nimport {\n  SecretType,\n  BasicAuthSubform,\n  SSHAuthSubform,\n  CreateConfigSubform,\n} from '@console/internal/components/secrets/create-secret';\nimport { DropdownField, InputField, ActionGroupWithIcons } from '@console/shared';\nimport SecretAnnotation from './SecretAnnotation';\nimport './SecretForm.scss';\n\nconst authTypes = {\n  [SecretType.dockerconfigjson]: 'Image Registry Credentials',\n  [SecretType.basicAuth]: 'Basic Authentication',\n  [SecretType.sshAuth]: 'SSH Key',\n};\n\nconst renderSecretForm = (\n  type: SecretType,\n  stringData: {\n    [key: string]: any;\n  },\n  onDataChanged: (value: string) => void,\n) => {\n  switch (type) {\n    case SecretType.basicAuth:\n      return (\n        <BasicAuthSubform onChange={onDataChanged} stringData={stringData[SecretType.basicAuth]} />\n      );\n    case SecretType.sshAuth:\n      return (\n        <SSHAuthSubform onChange={onDataChanged} stringData={stringData[SecretType.sshAuth]} />\n      );\n    case SecretType.dockerconfigjson:\n      return (\n        <CreateConfigSubform\n          onChange={onDataChanged}\n          stringData={stringData[SecretType.dockerconfigjson]}\n        />\n      );\n    default:\n      return null;\n  }\n};\n\nconst SecretForm: React.FC<FormikValues> = ({\n  handleSubmit,\n  handleReset,\n  status,\n  isSubmitting,\n}) => {\n  const { values, setFieldValue } = useFormikContext<FormikValues>();\n  const [stringData, setStringData] = React.useState({\n    [SecretType.basicAuth]: {},\n    [SecretType.sshAuth]: {},\n    [SecretType.dockerconfigjson]: {},\n  });\n\n  const setValues = (type: SecretType) => {\n    if (type === SecretType.dockerconfigjson) {\n      setFieldValue(\n        'formData',\n        _.mapValues({ '.dockerconfigjson': stringData[type] }, JSON.stringify),\n      );\n    } else {\n      setFieldValue('formData', stringData[type]);\n    }\n  };\n\n  const onDataChanged = (value: string) => {\n    setStringData(_.merge(stringData, { [values.type]: value }));\n    setValues(values.type);\n  };\n\n  return (\n    <div className=\"odc-secret-form\">\n      <h1 className=\"co-section-heading-tertiary odc-secret-form__title\">Create Source Secret</h1>\n      <div className=\"form-group\">\n        <InputField\n          type={TextInputTypes.text}\n          required\n          name=\"secretName\"\n          label=\"Secret Name\"\n          helpText=\"Unique name of the new secret.\"\n        />\n      </div>\n      <div className=\"form-group\">\n        <SecretAnnotation fieldName=\"annotations\" />\n      </div>\n      <div className=\"form-group\">\n        <DropdownField\n          name=\"type\"\n          label=\"Authentication Type\"\n          items={authTypes}\n          title={authTypes[values.type]}\n          onChange={(type: SecretType) => setValues(type)}\n          fullWidth\n          required\n        />\n      </div>\n      {renderSecretForm(values.type, stringData, onDataChanged)}\n      <ButtonBar errorMessage={status?.submitError} inProgress={isSubmitting}>\n        <ActionGroupWithIcons onSubmit={handleSubmit} onClose={handleReset} />\n      </ButtonBar>\n    </div>\n  );\n};\n\nexport default SecretForm;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport {\n  ResourceLink,\n  Firehose,\n  FirehoseResult,\n  FirehoseResource,\n} from '@console/internal/components/utils';\nimport { SecretModel, ServiceAccountModel } from '@console/internal/models';\nimport { SecretType } from '@console/internal/components/secrets/create-secret';\nimport { SecondaryStatus } from '@console/shared';\nimport { SecretKind } from '@console/internal/module/k8s';\nimport { ServiceAccountType } from '../../../../utils/pipeline-utils';\nimport { PIPELINE_SERVICE_ACCOUNT } from '../../const';\nimport './SecretsList.scss';\n\ntype SecretsProps = {\n  secrets?: FirehoseResult<SecretKind[]>;\n  serviceaccounts?: FirehoseResult<ServiceAccountType>;\n};\n\ntype SecretsListProps = {\n  namespace: string;\n};\n\nconst secretTypes = [SecretType.dockerconfigjson, SecretType.basicAuth, SecretType.sshAuth];\n\nconst Secrets: React.FC<SecretsProps> = ({ secrets, serviceaccounts }) => {\n  const serviceAccountSecrets = _.map(serviceaccounts.data.secrets, 'name');\n  const filterData = _.filter(\n    secrets.data,\n    (secret) =>\n      _.includes(secretTypes, secret.type) &&\n      _.includes(serviceAccountSecrets, secret.metadata.name),\n  );\n  const sortedFilterData = _.sortBy(filterData, (data) => data.metadata.name);\n\n  return (\n    <div className=\"odc-secrets-list\">\n      {sortedFilterData.map((secret) => {\n        return (\n          <ResourceLink\n            key={secret.metadata.uid}\n            kind={SecretModel.kind}\n            name={secret.metadata.name}\n            namespace={secret.metadata.namespace}\n            title={secret.metadata.name}\n            linkTo={false}\n          />\n        );\n      })}\n      {_.isEmpty(sortedFilterData) && <SecondaryStatus status=\"No source secrets found\" />}\n    </div>\n  );\n};\n\nconst SecretsList: React.FC<SecretsListProps> = ({ namespace }) => {\n  const resources: FirehoseResource[] = [\n    {\n      isList: true,\n      namespace,\n      kind: SecretModel.kind,\n      prop: SecretModel.plural,\n    },\n    {\n      isList: false,\n      namespace,\n      kind: ServiceAccountModel.kind,\n      prop: ServiceAccountModel.plural,\n      name: PIPELINE_SERVICE_ACCOUNT,\n    },\n  ];\n\n  return (\n    <Firehose resources={resources}>\n      <Secrets />\n    </Firehose>\n  );\n};\n\nexport default SecretsList;\n","import { PipelineResourceType } from '../../const';\n\nexport const CREATE_PIPELINE_RESOURCE = '#CREATE_PIPELINE_RESOURCE#';\n\nexport const initialResourceFormValues = {\n  [PipelineResourceType.git]: {\n    params: {\n      url: '',\n      revision: '',\n    },\n  },\n  [PipelineResourceType.image]: {\n    params: {\n      url: '',\n    },\n  },\n  [PipelineResourceType.storage]: {\n    params: {\n      type: '',\n      location: '',\n      dir: '',\n    },\n  },\n  [PipelineResourceType.cluster]: {\n    params: {\n      name: '',\n      url: '',\n      username: '',\n      password: '',\n      insecure: '',\n    },\n    secrets: {\n      cadata: '',\n      token: '',\n    },\n  },\n};\n","import * as _ from 'lodash';\nimport { getRandomChars } from '@console/shared';\nimport {\n  Pipeline,\n  PipelineResource,\n  PipelineRun,\n  PipelineRunInlineResource,\n  PipelineRunInlineResourceParam,\n  PipelineRunReferenceResource,\n  PipelineRunResource,\n} from '../../../../utils/pipeline-augment';\nimport { PipelineRunModel } from '../../../../models';\nimport { getPipelineRunParams, getPipelineRunWorkspaces } from '../../../../utils/pipeline-utils';\nimport { CREATE_PIPELINE_RESOURCE, initialResourceFormValues } from './const';\nimport { CommonPipelineModalFormikValues, PipelineModalFormResource } from './types';\n\n/**\n * Migrates a PipelineRun from one version to another to support auto-upgrades with old (and invalid) PipelineRuns.\n *\n * Note: Each check within this method should be driven by the apiVersion number if the API is properly up-versioned\n * for these breaking changes. (should be done moving from 0.10.x forward)\n */\nexport const migratePipelineRun = (pipelineRun: PipelineRun): PipelineRun => {\n  let newPipelineRun = pipelineRun;\n\n  const serviceAccountPath = 'spec.serviceAccount';\n  if (_.has(newPipelineRun, serviceAccountPath)) {\n    // .spec.serviceAccount was removed for .spec.serviceAccountName in 0.9.x\n    // Note: apiVersion was not updated for this change and thus we cannot gate this change behind a version number\n    const serviceAccountName = _.get(newPipelineRun, serviceAccountPath);\n    newPipelineRun = _.omit(newPipelineRun, [serviceAccountPath]);\n    newPipelineRun = _.merge(newPipelineRun, {\n      spec: {\n        serviceAccountName,\n      },\n    });\n  }\n\n  return newPipelineRun;\n};\n\nexport const getPipelineRunData = (\n  pipeline: Pipeline = null,\n  latestRun?: PipelineRun,\n): PipelineRun => {\n  if (!pipeline && !latestRun) {\n    // eslint-disable-next-line no-console\n    console.error('Missing parameters, unable to create new PipelineRun');\n    return null;\n  }\n\n  const pipelineName = pipeline ? pipeline.metadata.name : latestRun.spec.pipelineRef.name;\n\n  const resources = latestRun?.spec.resources;\n  const workspaces = latestRun?.spec.workspaces;\n\n  const latestRunParams = latestRun?.spec.params;\n  const pipelineParams = pipeline?.spec.params;\n  const params = latestRunParams || getPipelineRunParams(pipelineParams);\n\n  const newPipelineRun = {\n    apiVersion: pipeline ? pipeline.apiVersion : latestRun.apiVersion,\n    kind: PipelineRunModel.kind,\n    metadata: {\n      name: `${pipelineName}-${getRandomChars(6)}`,\n      namespace: pipeline ? pipeline.metadata.namespace : latestRun.metadata.namespace,\n      labels: _.merge({}, pipeline?.metadata?.labels, latestRun?.metadata?.labels, {\n        'tekton.dev/pipeline': pipelineName,\n      }),\n    },\n    spec: {\n      ...(latestRun?.spec || {}),\n      pipelineRef: {\n        name: pipelineName,\n      },\n      resources,\n      ...(params && { params }),\n      workspaces,\n      status: null,\n    },\n  };\n  return migratePipelineRun(newPipelineRun);\n};\n\nexport const convertPipelineToModalData = (\n  pipeline: Pipeline,\n  alwaysCreateResources: boolean = false,\n): CommonPipelineModalFormikValues => {\n  const {\n    metadata: { namespace },\n    spec: { params, resources },\n  } = pipeline;\n\n  return {\n    namespace,\n    parameters: params || [],\n    resources: (resources || []).map((resource: PipelineResource) => ({\n      name: resource.name,\n      selection: alwaysCreateResources ? CREATE_PIPELINE_RESOURCE : null,\n      data: {\n        ...initialResourceFormValues[resource.type],\n        type: resource.type,\n      },\n    })),\n  };\n};\n\nexport const convertMapToNameValueArray = (map: {\n  [key: string]: any;\n}): PipelineRunInlineResourceParam[] => {\n  return Object.keys(map).map((name) => {\n    const value = map[name];\n    return { name, value };\n  });\n};\n\nconst convertResources = (resource: PipelineModalFormResource): PipelineRunResource => {\n  if (resource.selection === CREATE_PIPELINE_RESOURCE) {\n    return {\n      name: resource.name,\n      resourceSpec: {\n        params: convertMapToNameValueArray(resource.data.params),\n        type: resource.data.type,\n      },\n    } as PipelineRunInlineResource;\n  }\n\n  return {\n    name: resource.name,\n    resourceRef: {\n      name: resource.selection,\n    },\n  } as PipelineRunReferenceResource;\n};\n\nexport const getPipelineRunFromForm = (\n  pipeline: Pipeline,\n  formValues: CommonPipelineModalFormikValues,\n  labels?: { [key: string]: string },\n) => {\n  const { parameters, resources, workspaces } = formValues;\n\n  const pipelineRunData: PipelineRun = {\n    metadata: {\n      labels,\n    },\n    spec: {\n      pipelineRef: {\n        name: pipeline.metadata.name,\n      },\n      params: getPipelineRunParams(parameters),\n      resources: resources.map(convertResources),\n      workspaces: getPipelineRunWorkspaces(workspaces),\n    },\n  };\n  return getPipelineRunData(pipeline, pipelineRunData);\n};\n","import * as yup from 'yup';\nimport { PipelineResourceType, VolumeTypes } from '../../const';\nimport { CREATE_PIPELINE_RESOURCE } from './const';\n\nexport const validateResourceType = yup.object().shape({\n  type: yup.string().required('Required'),\n  params: yup\n    .object()\n    .when('type', {\n      is: PipelineResourceType.git,\n      then: yup.object({\n        url: yup.string().required('Required'),\n        revision: yup.string(),\n      }),\n    })\n    .when('type', {\n      is: PipelineResourceType.image,\n      then: yup.object({\n        url: yup.string().required('Required'),\n      }),\n    })\n    .when('type', {\n      is: PipelineResourceType.storage,\n      then: yup.object({\n        type: yup.string().required('Required'),\n        location: yup.string().required('Required'),\n        dir: yup.string(),\n      }),\n    })\n    .when('type', {\n      is: PipelineResourceType.cluster,\n      then: yup.object({\n        name: yup.string().required('Required'),\n        url: yup.string().required('Required'),\n        username: yup.string().required('Required'),\n        password: yup.string(),\n        insecure: yup.string(),\n      }),\n    }),\n  secrets: yup.object().when('type', {\n    is: PipelineResourceType.cluster,\n    then: yup.object({\n      cadata: yup.string().required('Required'),\n      token: yup.string(),\n    }),\n  }),\n});\n\nexport const formResources = yup.array().of(\n  yup.object().shape({\n    name: yup.string().required('Required'),\n    selection: yup.string().required('Required'),\n    data: yup.object().when('selection', {\n      is: CREATE_PIPELINE_RESOURCE,\n      then: validateResourceType,\n    }),\n  }),\n);\n\nconst volumeTypeSchema = yup\n  .object()\n  .when('type', {\n    is: (type) => VolumeTypes[type] === VolumeTypes.Secret,\n    then: yup.object().shape({\n      secret: yup.object().shape({\n        secretName: yup.string().required('Required'),\n        items: yup.array().of(\n          yup.object().shape({\n            key: yup.string(),\n            path: yup.string().when('key', {\n              is: (key) => !!key,\n              then: yup.string().required('Required'),\n            }),\n          }),\n        ),\n      }),\n    }),\n  })\n  .when('type', {\n    is: (type) => VolumeTypes[type] === VolumeTypes.ConfigMap,\n    then: yup.object().shape({\n      configMap: yup.object().shape({\n        name: yup.string().required('Required'),\n        items: yup.array().of(\n          yup.object().shape({\n            key: yup.string(),\n            path: yup.string().when('key', {\n              is: (key) => !!key,\n              then: yup.string().required('Required'),\n            }),\n          }),\n        ),\n      }),\n    }),\n  })\n  .when('type', {\n    is: (type) => VolumeTypes[type] === VolumeTypes.PVC,\n    then: yup.object().shape({\n      persistentVolumeClaim: yup.object().shape({\n        claimName: yup.string().required('Required'),\n      }),\n    }),\n  });\n\nconst commonPipelineSchema = yup.object().shape({\n  parameters: yup.array().of(\n    yup.object().shape({\n      name: yup.string().required('Required'),\n      description: yup.string(),\n      default: yup.string().required('Required'),\n    }),\n  ),\n  resources: formResources,\n});\n\nexport const startPipelineSchema = commonPipelineSchema.shape({\n  workspaces: yup.array().of(\n    yup.object().shape({\n      type: yup.string().required('Required'),\n      data: volumeTypeSchema,\n    }),\n  ),\n  secretOpen: yup.boolean().equals([false]),\n});\n\nexport const addTriggerSchema = commonPipelineSchema.shape({\n  triggerBinding: yup.object().shape({\n    name: yup.string().required('Required'),\n    resource: yup\n      .object()\n      .shape({\n        metadata: yup.object().shape({\n          name: yup.string().required('Required'),\n        }),\n      })\n      .required('Required'),\n  }),\n});\n\nexport const advancedSectionValidationSchema = yup.object().shape({\n  secretName: yup.string().required('Required'),\n  type: yup.string().required('Required'),\n  annotations: yup.object().shape({\n    key: yup.string().required('Required'),\n    value: yup.string().required('Required'),\n  }),\n});\n","export { default as removeTriggerModal } from './triggers/RemoveTriggerModal';\nexport { default as startPipelineModal } from './start-pipeline/StartPipelineModal';\nexport { default as addTriggerModal } from './triggers/AddTriggerModal';\n","import * as React from 'react';\nimport { FormikValues } from 'formik';\nimport FormSection from '../../../import/section/FormSection';\nimport PipelineParameterSection from '../common/PipelineParameterSection';\nimport PipelineResourceSection from '../common/PipelineResourceSection';\nimport PipelineWorkspacesSection from '../common/PiplelineWorkspacesSection';\nimport PipelineSecretSection from '../common/PipelineSecretSection';\n\nconst StartPipelineForm: React.FC<FormikValues> = ({ values }) => {\n  return (\n    <>\n      <PipelineParameterSection parameters={values.parameters} />\n      <PipelineResourceSection />\n      <PipelineWorkspacesSection />\n      <FormSection title=\"Advanced Options\" fullWidth>\n        <PipelineSecretSection namespace={values.namespace} />\n      </FormSection>\n    </>\n  );\n};\n\nexport default StartPipelineForm;\n","import * as React from 'react';\nimport { Formik } from 'formik';\nimport {\n  createModalLauncher,\n  ModalComponentProps,\n} from '@console/internal/components/factory/modal';\nimport { errorModal } from '@console/internal/components/modals';\nimport { Pipeline, PipelineRun, PipelineWorkspace } from '../../../../utils/pipeline-augment';\n//import { useUserLabelForManualStart } from '../../../pipelineruns/triggered-by';\nimport ModalStructure from '../common/ModalStructure';\nimport { convertPipelineToModalData } from '../common/utils';\nimport { startPipelineSchema } from '../common/validation-utils';\nimport StartPipelineForm from './StartPipelineForm';\nimport { submitStartPipeline } from './submit-utils';\nimport { StartPipelineFormValues } from './types';\n\nexport interface StartPipelineModalProps {\n  pipeline: Pipeline;\n  onSubmit?: (pipelineRun: PipelineRun) => void;\n}\nconst StartPipelineModal: React.FC<StartPipelineModalProps & ModalComponentProps> = ({\n  pipeline,\n  close,\n  onSubmit,\n}) => {\n  //const userStartedLabel = useUserLabelForManualStart();\n\n  const initialValues: StartPipelineFormValues = {\n    ...convertPipelineToModalData(pipeline),\n    workspaces: (pipeline.spec.workspaces || []).map((workspace: PipelineWorkspace) => ({\n      ...workspace,\n      type: 'EmptyDirectory',\n    })),\n    secretOpen: false,\n  };\n\n  const handleSubmit = (values: StartPipelineFormValues, actions): void => {\n    actions.setSubmitting(true);\n\n    submitStartPipeline(values, pipeline, /*userStartedLabel*/)\n      .then((res) => {\n        actions.setSubmitting(false);\n        onSubmit && onSubmit(res);\n        close();\n      })\n      .catch((err) => {\n        actions.setSubmitting(false);\n        actions.setStatus({ submitError: err.message });\n        errorModal({ error: err.message });\n        close();\n      });\n  };\n\n  return (\n    <Formik\n      initialValues={initialValues}\n      onSubmit={handleSubmit}\n      validationSchema={startPipelineSchema}\n    >\n      {(props) => (\n        <ModalStructure submitBtnText=\"Start\" title=\"Start Pipeline\" close={close} {...props}>\n          <StartPipelineForm {...props} />\n        </ModalStructure>\n      )}\n    </Formik>\n  );\n};\n\nexport default createModalLauncher(StartPipelineModal);\n","import { k8sCreate, K8sResourceCommon } from '@console/internal/module/k8s';\nimport { PipelineRunModel } from '../../../../models';\nimport { Pipeline, PipelineRun } from '../../../../utils/pipeline-augment';\nimport {\n  createPipelineResource,\n  createSecretResource,\n} from '../../pipeline-resource/pipelineResource-utils';\nimport { CREATE_PIPELINE_RESOURCE } from '../common/const';\nimport { PipelineModalFormResource } from '../common/types';\nimport { getPipelineRunFromForm } from '../common/utils';\nimport { StartPipelineFormValues } from './types';\n\nexport const resourceSubmit = async (\n  resourceValues: PipelineModalFormResource,\n  namespace: string,\n): Promise<K8sResourceCommon> => {\n  const {\n    data: { params, secrets, type },\n  } = resourceValues;\n\n  return secrets\n    ? createSecretResource(secrets, type, namespace).then((secretResp) => {\n        return createPipelineResource(params, type, namespace, secretResp);\n      })\n    : createPipelineResource(params, type, namespace);\n};\n\nexport const submitStartPipeline = async (\n  values: StartPipelineFormValues,\n  pipeline: Pipeline,\n  labels?: { [key: string]: string },\n): Promise<PipelineRun> => {\n  const { namespace, resources } = values;\n\n  const toCreateResources: { [index: string]: PipelineModalFormResource } = resources.reduce(\n    (acc, resource, index) => {\n      return resource.selection === CREATE_PIPELINE_RESOURCE ? { ...acc, [index]: resource } : acc;\n    },\n    {},\n  );\n  const createdResources = await Promise.all(\n    Object.values(toCreateResources).map((resource) => resourceSubmit(resource, namespace)),\n  );\n\n  let formValues = values;\n  if (createdResources.length > 0) {\n    const indexLookup = Object.keys(toCreateResources);\n    formValues = {\n      ...formValues,\n      resources: formValues.resources.map(\n        (resource, index): PipelineModalFormResource => {\n          if (toCreateResources[index]) {\n            const creationIndex = indexLookup.indexOf(index.toString());\n            return {\n              ...resource,\n              selection: createdResources[creationIndex].metadata.name,\n            };\n          }\n          return resource;\n        },\n      ),\n    };\n  }\n\n  const pipelineRunResource: PipelineRun = await k8sCreate(\n    PipelineRunModel,\n    getPipelineRunFromForm(pipeline, formValues, labels),\n  );\n\n  return Promise.resolve(pipelineRunResource);\n};\n","import * as React from 'react';\nimport { FormikProps } from 'formik';\nimport PipelineResourceSection from '../common/PipelineResourceSection';\nimport PipelineParameterSection from '../common/PipelineParameterSection';\nimport TriggerBindingSection from './TriggerBindingSection';\nimport { AddTriggerFormValues } from './types';\n\ntype AddTriggerFormProps = FormikProps<AddTriggerFormValues>;\n\nconst AddTriggerForm: React.FC<AddTriggerFormProps> = (props) => {\n  const { values } = props;\n\n  return (\n    <>\n      <TriggerBindingSection />\n      <PipelineParameterSection parameters={values.parameters} />\n      <PipelineResourceSection />\n    </>\n  );\n};\n\nexport default AddTriggerForm;\n","import * as React from 'react';\nimport { Formik } from 'formik';\nimport {\n  createModalLauncher,\n  ModalComponentProps,\n} from '@console/internal/components/factory/modal';\nimport { Pipeline } from '../../../../utils/pipeline-augment';\nimport ModalStructure from '../common/ModalStructure';\nimport { convertPipelineToModalData } from '../common/utils';\nimport { addTriggerSchema } from '../common/validation-utils';\nimport AddTriggerForm from './AddTriggerForm';\nimport { TRIGGER_BINDING_EMPTY } from './const';\nimport { submitTrigger } from './submit-utils';\nimport { AddTriggerFormValues } from './types';\n\ntype AddTriggerModalProps = ModalComponentProps & {\n  pipeline: Pipeline;\n};\n\nconst AddTriggerModal: React.FC<AddTriggerModalProps> = ({ pipeline, close }) => {\n  const initialValues: AddTriggerFormValues = {\n    ...convertPipelineToModalData(pipeline, true),\n    triggerBinding: {\n      name: TRIGGER_BINDING_EMPTY,\n      resource: null,\n    },\n  };\n\n  const handleSubmit = (values: AddTriggerFormValues, actions) => {\n    actions.setSubmitting(true);\n\n    submitTrigger(pipeline, values)\n      .then(() => {\n        actions.setSubmitting(false);\n        close();\n      })\n      .catch((error) => {\n        actions.setStatus({ submitError: error?.message || 'There was an unknown error' });\n      });\n  };\n\n  return (\n    <Formik\n      initialValues={initialValues}\n      onSubmit={handleSubmit}\n      validationSchema={addTriggerSchema}\n    >\n      {(props) => (\n        <ModalStructure submitBtnText=\"Add\" title=\"Add Trigger\" close={close} {...props}>\n          <AddTriggerForm {...props} />\n        </ModalStructure>\n      )}\n    </Formik>\n  );\n};\n\nexport default createModalLauncher(AddTriggerModal);\n","import * as React from 'react';\nimport { Split, SplitItem } from '@patternfly/react-core';\nimport { global_warning_color_100 as warningColor } from '@patternfly/react-tokens';\nimport { ExclamationTriangleIcon } from '@patternfly/react-icons';\nimport { Pipeline } from '../../../../utils/pipeline-augment';\nimport TriggerTemplateSelector from './TriggerTemplateSelector';\n\ntype RemoveTriggerFormProps = {\n  pipeline: Pipeline;\n};\n\nconst RemoveTriggerForm: React.FC<RemoveTriggerFormProps> = (props) => {\n  const { pipeline } = props;\n\n  return (\n    <Split className=\"odc-modal-content\" gutter=\"md\">\n      <SplitItem>\n        <ExclamationTriangleIcon size=\"md\" color={warningColor.value} />\n      </SplitItem>\n      <SplitItem isFilled>\n        <p className=\"co-break-word\">\n          Select the trigger to remove from pipeline <b>{pipeline.metadata.name}</b>.\n        </p>\n        <TriggerTemplateSelector\n          name=\"selectedTrigger\"\n          placeholder=\"Select Trigger Template\"\n          pipeline={pipeline}\n        />\n      </SplitItem>\n    </Split>\n  );\n};\n\nexport default RemoveTriggerForm;\n","import * as React from 'react';\nimport { Formik, FormikHelpers } from 'formik';\nimport { createModalLauncher, ModalComponentProps } from '@console/internal/components/factory';\nimport { Pipeline } from '../../../../utils/pipeline-augment';\nimport ModalStructure from '../common/ModalStructure';\nimport RemoveTriggerForm from './RemoveTriggerForm';\nimport { removeTrigger } from './remove-utils';\nimport { RemoveTriggerFormValues } from './types';\nimport { removeTriggerSchema } from './validation-utils';\n\ntype RemoveTriggerModalProps = ModalComponentProps & {\n  pipeline: Pipeline;\n};\n\nconst RemoveTriggerModal: React.FC<RemoveTriggerModalProps> = ({ pipeline, close }) => {\n  const initialValues: RemoveTriggerFormValues = {\n    selectedTrigger: null,\n  };\n\n  const handleSubmit = (\n    values: RemoveTriggerFormValues,\n    actions: FormikHelpers<RemoveTriggerFormValues>,\n  ) => {\n    actions.setSubmitting(true);\n\n    removeTrigger(values, pipeline)\n      .then(() => {\n        actions.setSubmitting(false);\n        close();\n      })\n      .catch((e) => {\n        actions.setSubmitting(false);\n        actions.setStatus({ submitError: e.message });\n      });\n  };\n\n  return (\n    <Formik\n      initialValues={initialValues}\n      onSubmit={handleSubmit}\n      validationSchema={removeTriggerSchema}\n    >\n      {(props) => (\n        <ModalStructure\n          {...props}\n          submitBtnText=\"Remove\"\n          submitDanger\n          title=\"Remove Trigger\"\n          close={close}\n        >\n          <RemoveTriggerForm pipeline={pipeline} />\n        </ModalStructure>\n      )}\n    </Formik>\n  );\n};\n\nexport default createModalLauncher(RemoveTriggerModal);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { useFormikContext } from 'formik';\nimport { Badge, Expandable, FormHelperText } from '@patternfly/react-core';\nimport FormSection from '../../../import/section/FormSection';\nimport { TriggerBindingKind, TriggerBindingParam } from '../../resource-types';\nimport TriggerBindingSelector from './TriggerBindingSelector';\nimport { AddTriggerFormValues } from './types';\n\nimport './TriggerBindingSection.scss';\n\nconst TriggerBindingSection: React.FC = () => {\n  const { setFieldValue } = useFormikContext<AddTriggerFormValues>();\n  const [bindingVars, setBindingVars] = React.useState<TriggerBindingParam[]>(null);\n  const updateTriggerBindingVariables = React.useCallback(\n    (selectedTriggerBinding: TriggerBindingKind) => {\n      setBindingVars(selectedTriggerBinding.spec.params);\n      setFieldValue('triggerBinding.resource', selectedTriggerBinding);\n    },\n    [setFieldValue],\n  );\n\n  return (\n    <div className=\"odc-trigger-binding-section\">\n      <FormSection title=\"Webhook\" fullWidth>\n        <TriggerBindingSelector\n          description=\"Select your git provider type to be associated with the Trigger\"\n          label=\"Git Provider Type\"\n          onChange={updateTriggerBindingVariables}\n        />\n        {bindingVars && (\n          <Expandable toggleTextExpanded=\"Hide Variables\" toggleTextCollapsed=\"Show Variables\">\n            <div className=\"odc-trigger-binding-section__variable-container\">\n              <p className=\"odc-trigger-binding-section__variable-descriptor\">\n                The following variables can be used in the Parameters or when created new Resources.\n              </p>\n              {bindingVars.map(({ name }) => (\n                <Badge key={name} className=\"odc-trigger-binding-section__variable-badge\" isRead>\n                  {name}\n                </Badge>\n              ))}\n            </div>\n            <FormHelperText\n              isHidden={false}\n              className=\"odc-trigger-binding-section__variable-help-text\"\n            >\n              Use this format when referencing variables in this form:{' '}\n              <code>{'$(params.parameter)'}</code>\n            </FormHelperText>\n          </Expandable>\n        )}\n      </FormSection>\n    </div>\n  );\n};\n\nexport default TriggerBindingSection;\n","import * as React from 'react';\nimport { useFormikContext } from 'formik';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { Firehose } from '@console/internal/components/utils';\nimport { ClusterTriggerBindingModel, TriggerBindingModel } from '../../../../models';\nimport { TriggerBindingKind } from '../../resource-types';\nimport TriggerBindingSelectorDropdown from './TriggerBindingSelectorDropdown';\nimport { AddTriggerFormValues } from './types';\n\ntype TriggerBindingSelectorProps = {\n  description?: string;\n  label?: string;\n  onChange: (selectedTriggerBinding: TriggerBindingKind) => void;\n};\n\nconst TriggerBindingSelector: React.FC<TriggerBindingSelectorProps> = (props) => {\n  const { description, label = TriggerBindingModel.label, onChange } = props;\n  const { values } = useFormikContext<AddTriggerFormValues>();\n\n  return (\n    <Firehose\n      resources={[\n        {\n          isList: true,\n          namespace: values.namespace,\n          kind: referenceForModel(TriggerBindingModel),\n          prop: 'triggerBindingData',\n          isOptional: true,\n        },\n        {\n          isList: true,\n          kind: referenceForModel(ClusterTriggerBindingModel),\n          prop: 'clusterTriggerBindingData',\n          isOptional: true,\n        },\n      ]}\n    >\n      <TriggerBindingSelectorDropdown description={description} label={label} onChange={onChange} />\n    </Firehose>\n  );\n};\n\nexport default TriggerBindingSelector;\n","import * as React from 'react';\nimport { FirehoseResult } from '@console/internal/components/utils';\nimport { DropdownField } from '@console/shared';\nimport { TriggerBindingKind } from '../../resource-types';\n\ntype TriggerBindingSelectorProps = {\n  clusterTriggerBindingData?: FirehoseResult<TriggerBindingKind[]>;\n  description?: string;\n  label: string;\n  onChange: (selectedTriggerBinding: TriggerBindingKind) => void;\n  triggerBindingData?: FirehoseResult<TriggerBindingKind[]>;\n};\n\nconst TriggerBindingSelectorDropdown: React.FC<TriggerBindingSelectorProps> = (props) => {\n  const { clusterTriggerBindingData, description, label, onChange, triggerBindingData } = props;\n  const triggerBindings = triggerBindingData?.data || [];\n  const clusterTriggerBindings = clusterTriggerBindingData?.data || [];\n  const bindings = [...triggerBindings, ...clusterTriggerBindings];\n  const dropdownItems = bindings.reduce(\n    (acc, triggerBinding) => ({\n      ...acc,\n      [triggerBinding.metadata.name]: triggerBinding.metadata.name,\n    }),\n    {},\n  );\n\n  return (\n    <DropdownField\n      fullWidth\n      helpText={description}\n      items={dropdownItems}\n      disabled={Object.keys(dropdownItems).length === 0}\n      label={label}\n      name=\"triggerBinding.name\"\n      onChange={(name: string) => {\n        onChange(bindings.find((triggerBinding) => triggerBinding.metadata.name === name));\n      }}\n      title={`Select ${label}`}\n    />\n  );\n};\n\nexport default TriggerBindingSelectorDropdown;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { useField } from 'formik';\nimport { DropdownField } from '@console/shared/src';\nimport { Pipeline } from '../../../../utils/pipeline-augment';\nimport { RouteTemplate, usePipelineTriggerTemplateNames } from '../../utils/triggers';\n\nimport './TriggerTemplateSelector.scss';\n\ntype TriggerTemplateSelectorProps = {\n  name: string;\n  pipeline: Pipeline;\n  placeholder: string;\n};\n\nconst TriggerTemplateSelector: React.FC<TriggerTemplateSelectorProps> = (props) => {\n  const { name, pipeline, placeholder } = props;\n  const {\n    metadata: { name: pipelineName, namespace },\n  } = pipeline;\n\n  const [field] = useField(name);\n  const selection = field.value;\n\n  const templateNames: RouteTemplate[] =\n    usePipelineTriggerTemplateNames(pipelineName, namespace) || [];\n  const items = templateNames.reduce(\n    (acc, { triggerTemplateName }) => ({ ...acc, [triggerTemplateName]: triggerTemplateName }),\n    {},\n  );\n\n  return (\n    <div className=\"odc-trigger-template-selector\">\n      <DropdownField\n        fullWidth\n        disabled={templateNames.length === 0}\n        items={items}\n        name={name}\n        title={placeholder}\n      />\n      {selection ? (\n        <div className=\"co-break-word odc-trigger-template-selector__confirmationMessage\">\n          Are you sure you want to remove <b>{selection}</b> from <b>{pipeline.metadata.name}</b>?\n        </div>\n      ) : (\n        <div className=\"odc-trigger-template-selector__pfModalHack\" />\n      )}\n    </div>\n  );\n};\n\nexport default TriggerTemplateSelector;\n","export const TRIGGER_BINDING_EMPTY = '#empty-trigger-binding#';\n","import { k8sKill, k8sList, k8sPatch } from '@console/internal/module/k8s';\nimport { EventListenerModel, TriggerTemplateModel } from '../../../../models';\nimport { Pipeline } from '../../../../utils/pipeline-augment';\nimport { EventListenerKind } from '../../resource-types';\nimport { RemoveTriggerFormValues } from './types';\n\nexport const removeTrigger = async (values: RemoveTriggerFormValues, pipeline: Pipeline) => {\n  const ns = pipeline.metadata.namespace;\n  const selectedTriggerTemplate = values.selectedTrigger;\n\n  // Remove the selected TriggerTemplate\n  await k8sKill(TriggerTemplateModel, {\n    metadata: { name: selectedTriggerTemplate, namespace: ns },\n  });\n\n  const triggerMatchesTriggerTemplate = ({ template: { name } }) =>\n    name === selectedTriggerTemplate;\n\n  // Get all the event listeners so we can update their references\n  const eventListeners: EventListenerKind[] = await k8sList(EventListenerModel, { ns });\n  const matchingEventListeners = eventListeners.filter(({ spec: { triggers } }) =>\n    triggers.find(triggerMatchesTriggerTemplate),\n  );\n\n  const singleTriggers = ({ spec: { triggers } }) => triggers.length === 1;\n\n  // Delete all EventListeners that only had the one trigger\n  const deletableEventListeners: EventListenerKind[] = matchingEventListeners.filter(\n    singleTriggers,\n  );\n  await Promise.all(\n    deletableEventListeners.map((eventListener) => k8sKill(EventListenerModel, eventListener)),\n  );\n\n  // Update all EventListeners that had more than one trigger\n  const updatableEventListeners: EventListenerKind[] = matchingEventListeners.filter(\n    (eventListener) => !singleTriggers(eventListener),\n  );\n  await Promise.all(\n    updatableEventListeners.map((eventListener) =>\n      k8sPatch(EventListenerModel, eventListener, [\n        {\n          opt: 'replace',\n          path: '/spec/triggers',\n          value: eventListener.spec.triggers.filter(triggerMatchesTriggerTemplate),\n        },\n      ]),\n    ),\n  );\n\n  return Promise.resolve();\n};\n","import { getRandomChars } from '@console/shared';\nimport { apiVersionForModel, RouteKind } from '@console/internal/module/k8s';\nimport { RouteModel } from '@console/internal/models';\nimport { EventListenerModel, TriggerTemplateModel } from '../../../../models';\nimport { PipelineRun } from '../../../../utils/pipeline-augment';\nimport { PIPELINE_SERVICE_ACCOUNT } from '../../const';\nimport {\n  TriggerBindingKind,\n  EventListenerKind,\n  TriggerTemplateKind,\n  TriggerTemplateKindParam,\n} from '../../resource-types';\n\nexport const createTriggerTemplate = (\n  pipelineRun: PipelineRun,\n  params: TriggerTemplateKindParam[],\n): TriggerTemplateKind => {\n  return {\n    apiVersion: apiVersionForModel(TriggerTemplateModel),\n    kind: TriggerTemplateModel.kind,\n    metadata: {\n      name: `trigger-template-${pipelineRun.metadata.name}`,\n    },\n    spec: {\n      params,\n      resourcetemplates: [pipelineRun],\n    },\n  };\n};\n\nexport const createEventListener = (\n  triggerBindings: TriggerBindingKind[],\n  triggerTemplate: TriggerTemplateKind,\n): EventListenerKind => {\n  return {\n    apiVersion: apiVersionForModel(EventListenerModel),\n    kind: EventListenerModel.kind,\n    metadata: {\n      name: `event-listener-${getRandomChars()}`,\n    },\n    spec: {\n      serviceAccountName: PIPELINE_SERVICE_ACCOUNT,\n      triggers: [\n        {\n          bindings: triggerBindings.map(({ kind, metadata: { name } }) => ({ kind, name })),\n          template: { name: triggerTemplate.metadata.name },\n        },\n      ],\n    },\n  };\n};\n\nexport const createEventListenerRoute = (\n  eventListener: EventListenerKind,\n  generatedName?: string,\n  targetPort: number = 8080,\n): RouteKind => {\n  const eventListenerName = eventListener.metadata.name;\n  // Not ideal, but if all else fails, we can do our best guess\n  const referenceName = generatedName || `el-${eventListenerName}`;\n\n  return {\n    apiVersion: apiVersionForModel(RouteModel),\n    kind: RouteModel.kind,\n    metadata: {\n      name: referenceName,\n      labels: {\n        'app.kubernetes.io/managed-by': EventListenerModel.kind,\n        'app.kubernetes.io/part-of': 'Triggers',\n        eventlistener: eventListenerName,\n      },\n    },\n    spec: {\n      port: {\n        targetPort,\n      },\n      to: {\n        kind: 'Service',\n        name: referenceName,\n        weight: 100,\n      },\n    },\n  };\n};\n","import { RouteModel, ServiceModel } from '@console/internal/models';\nimport { errorModal } from '@console/internal/components/modals';\nimport { k8sCreate, k8sGet, K8sResourceKind, RouteKind } from '@console/internal/module/k8s';\nimport { EventListenerModel, TriggerTemplateModel } from '../../../../models';\nimport { Pipeline, PipelineRun } from '../../../../utils/pipeline-augment';\nimport {\n  EventListenerKind,\n  TriggerTemplateKind,\n  TriggerTemplateKindParam,\n} from '../../resource-types';\nimport { getPipelineRunFromForm } from '../common/utils';\nimport {\n  createEventListener,\n  createEventListenerRoute,\n  createTriggerTemplate,\n} from './resource-utils';\nimport { AddTriggerFormValues } from './types';\n\nconst exposeRoute = async (elName: string, ns: string, iteration = 0) => {\n  const elResource: EventListenerKind = await k8sGet(EventListenerModel, elName, ns);\n  const serviceGeneratedName = elResource?.status?.configuration.generatedName;\n\n  try {\n    if (!serviceGeneratedName) {\n      if (iteration < 3) {\n        setTimeout(() => exposeRoute(elName, ns, iteration + 1), 500);\n      } else {\n        // Unable to deterministically create the route; create a default one\n        await k8sCreate(RouteModel, createEventListenerRoute(elResource), { ns });\n      }\n      return;\n    }\n\n    // Get the service, find out what port we are exposed on\n    const serviceResource = await k8sGet(ServiceModel, serviceGeneratedName, ns);\n    const servicePort = serviceResource.spec?.ports?.[0]?.targetPort;\n\n    // Build the exposed route on the correct port\n    const route: RouteKind = createEventListenerRoute(\n      elResource,\n      serviceGeneratedName,\n      servicePort,\n    );\n    await k8sCreate(RouteModel, route, { ns });\n  } catch (e) {\n    errorModal({\n      title: 'Error Exposing Route',\n      error: e.message || 'Unknown error exposing the Webhook route',\n    });\n  }\n};\n\nexport const submitTrigger = async (\n  pipeline: Pipeline,\n  formValues: AddTriggerFormValues,\n): Promise<K8sResourceKind[]> => {\n  const { triggerBinding } = formValues;\n  const thisNamespace = pipeline.metadata.namespace;\n\n  const pipelineRun: PipelineRun = getPipelineRunFromForm(pipeline, formValues);\n  const triggerTemplateParams: TriggerTemplateKindParam[] = triggerBinding.resource.spec.params.map(\n    ({ name }) => ({ name } as TriggerTemplateKindParam),\n  );\n  const triggerTemplate: TriggerTemplateKind = createTriggerTemplate(\n    pipelineRun,\n    triggerTemplateParams,\n  );\n  const eventListener: EventListenerKind = createEventListener(\n    [triggerBinding.resource],\n    triggerTemplate,\n  );\n\n  const metadata = { ns: thisNamespace };\n  let resources: K8sResourceKind[];\n  try {\n    // Validates the modal contents, should be done first\n    const ttResource = await k8sCreate(TriggerTemplateModel, triggerTemplate, metadata);\n\n    // Creates the linkages and will provide the link to non-trigger resources created\n    const elResource = await k8sCreate(EventListenerModel, eventListener, metadata);\n\n    // Capture all related resources\n    resources = [ttResource, elResource];\n  } catch (e) {\n    return Promise.reject(e);\n  }\n\n  exposeRoute(eventListener.metadata.name, thisNamespace);\n\n  return Promise.resolve(resources);\n};\n","import * as yup from 'yup';\n\nexport const removeTriggerSchema = yup.object().shape({\n  selectedTrigger: yup.string().required('Required'),\n});\n","import * as React from 'react';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField, DroppableFileInputField } from '@console/shared';\n\ntype PipelineClusterOptionsProps = { prefixName: string };\n\nconst PipelineClusterOptions: React.FC<PipelineClusterOptionsProps> = ({ prefixName }) => (\n  <>\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.name`}\n      label=\"Name\"\n      helpText=\"Name of the cluster.\"\n      required\n    />\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.url`}\n      label=\"URL\"\n      helpText=\"Host URL of the master node.\"\n      required\n    />\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.username`}\n      label=\"Username\"\n      helpText=\"The user with access to the cluster.\"\n      required\n    />\n    <InputField\n      type={TextInputTypes.password}\n      name={`${prefixName}.params.password`}\n      label=\"Password\"\n      helpText=\"Please provide Password.\"\n    />\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.insecure`}\n      label=\"Insecure\"\n      helpText=\"Indicate server should be accessed without verifying the TLS certificate.\"\n    />\n    <DroppableFileInputField\n      name={`${prefixName}.secrets.cadata`}\n      label=\"Cadata\"\n      helpText=\"The PEM format certificate. Upload file by dragging &amp; dropping, selecting it, or pasting from the clipboard.\"\n      required\n    />\n    <DroppableFileInputField\n      name={`${prefixName}.secrets.token`}\n      label=\"Token\"\n      helpText=\"Upload file by dragging &amp; dropping, selecting it, or pasting from the clipboard.\"\n      required\n    />\n  </>\n);\n\nexport default PipelineClusterOptions;\n","import * as React from 'react';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField } from '@console/shared';\n\ntype PipelineGitOptionsProps = { prefixName: string };\n\nconst PipelineGitOptions: React.FC<PipelineGitOptionsProps> = ({ prefixName }) => (\n  <>\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.url`}\n      label=\"URL\"\n      helpText=\"Please provide git URL.\"\n      required\n    />\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.revision`}\n      label=\"Revision\"\n      helpText=\"Please provide Revisions. i.e master\"\n    />\n  </>\n);\n\nexport default PipelineGitOptions;\n","import * as React from 'react';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField } from '@console/shared';\n\ntype PipelineImageOptionsProps = { prefixName: string };\n\nconst PipelineImageOptions: React.FC<PipelineImageOptionsProps> = ({ prefixName }) => (\n  <InputField\n    type={TextInputTypes.text}\n    name={`${prefixName}.params.url`}\n    label=\"URL\"\n    helpText=\"Please provide Image URL.\"\n    required\n  />\n);\n\nexport default PipelineImageOptions;\n","import * as React from 'react';\nimport FormSection from '../../import/section/FormSection';\nimport PipelineGitOptions from './PipelineGitOptions';\nimport PipelineImageOptions from './PipelineImageOptions';\nimport PipelineClusterOptions from './PipelineClusterOptions';\nimport PipelineStorageOptions from './PipelineStorageOptions';\n\nexport interface PipelineResourceParamProps {\n  name: string;\n  type: string;\n}\n\nconst PipelineResourceParam: React.FC<PipelineResourceParamProps> = (props) => {\n  const { name, type } = props;\n\n  const renderTypeFields = () => {\n    switch (type) {\n      case 'git':\n        return <PipelineGitOptions prefixName={name} />;\n      case 'image':\n        return <PipelineImageOptions prefixName={name} />;\n      case 'cluster':\n        return <PipelineClusterOptions prefixName={name} />;\n      case 'storage':\n        return <PipelineStorageOptions prefixName={name} />;\n      default:\n        return null;\n    }\n  };\n\n  return <FormSection fullWidth>{renderTypeFields()}</FormSection>;\n};\n\nexport default PipelineResourceParam;\n","import * as React from 'react';\nimport { TextInputTypes } from '@patternfly/react-core';\nimport { InputField } from '@console/shared';\n\ntype PipelineStorageOptionsProps = { prefixName: string };\n\nconst PipelineStorageOptions: React.FC<PipelineStorageOptionsProps> = ({ prefixName }) => (\n  <>\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.type`}\n      label=\"Type\"\n      helpText=\"Represents the type of blob storage i.e gcs\"\n      required\n    />\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.location`}\n      label=\"Location\"\n      helpText=\"Represents the location of the blob storage i.e gs://some-private-bucket\"\n      required\n    />\n    <InputField\n      type={TextInputTypes.text}\n      name={`${prefixName}.params.dir`}\n      label=\"Directory\"\n      helpText=\"Represents whether the blob storage is a directory or not\"\n    />\n  </>\n);\n\nexport default PipelineStorageOptions;\n","import * as _ from 'lodash';\nimport { k8sCreate, K8sResourceKind } from '@console/internal/module/k8s';\nimport { SecretModel } from '@console/internal/models';\nimport { getRandomChars } from '@console/shared/src/utils/utils';\nimport { PipelineResourceModel } from '../../../models';\nimport { convertMapToNameValueArray } from '../modals/common/utils';\n\nexport interface ParamData {\n  [key: string]: any;\n}\n\nexport const getDefinedObj = (objData: ParamData): ParamData => {\n  return _.omitBy(objData, (v) => _.isUndefined(v) || _.isNull(v) || v === '');\n};\n\nexport const createPipelineResource = (\n  params: ParamData,\n  type: string,\n  namespace: string,\n  secretResp?: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  const resourceName = `${type}-${getRandomChars(6)}`;\n  const pipelineResource: K8sResourceKind = {\n    apiVersion: 'tekton.dev/v1alpha1',\n    kind: PipelineResourceModel.kind,\n    metadata: {\n      name: resourceName,\n      namespace,\n    },\n    spec: {\n      type,\n      params: convertMapToNameValueArray(getDefinedObj(params)),\n      ...(secretResp && {\n        secrets: _.map(secretResp.data, (value, name) => {\n          return {\n            fieldName: name,\n            secretKey: name,\n            secretName: secretResp.metadata.name,\n          };\n        }),\n      }),\n    },\n  };\n\n  return k8sCreate(PipelineResourceModel, pipelineResource);\n};\n\nexport const createSecretResource = (\n  secret: ParamData,\n  type: string,\n  namespace: string,\n): Promise<K8sResourceKind> => {\n  const resourceName = `${type}-secret-${getRandomChars(6)}`;\n  const secretResource = {\n    apiVersion: 'v1',\n    kind: 'Secret',\n    metadata: {\n      name: resourceName,\n      namespace,\n    },\n    stringData: getDefinedObj(secret),\n  };\n  return k8sCreate(SecretModel, secretResource);\n};\n","import * as React from 'react';\nimport { flatten, mapValues } from 'lodash';\nimport { RouteModel } from '@console/internal/models';\nimport { getRouteWebURL } from '@console/internal/components/routes';\nimport { K8sResourceCommon, referenceForModel, RouteKind } from '@console/internal/module/k8s';\nimport { useK8sGet } from '@console/internal/components/utils/k8s-get-hook';\nimport {\n  useK8sWatchResource,\n  useK8sWatchResources,\n  WatchK8sResource,\n  WatchK8sResources,\n  WatchK8sResults,\n  WatchK8sResultsObject,\n} from '@console/internal/components/utils/k8s-watch-hook';\nimport { EventListenerModel, PipelineRunModel, TriggerTemplateModel } from '../../../models';\nimport { getResourceModelFromBindingKind, PipelineRun } from '../../../utils/pipeline-augment';\nimport {\n  EventListenerKind,\n  EventListenerKindTrigger,\n  TriggerBindingKind,\n  TriggerTemplateKind,\n} from '../resource-types';\nimport { ResourceModelLink } from '../resource-overview/DynamicResourceLinkList';\n\ntype RouteMap = { [generatedName: string]: RouteKind };\ntype TriggerTemplateMapping = { [key: string]: TriggerTemplateKind };\n\nconst getResourceName = (resource: K8sResourceCommon): string => resource.metadata.name;\nconst getEventListenerTemplateNames = (el: EventListenerKind): string[] =>\n  el.spec.triggers.map((elTrigger: EventListenerKindTrigger) => elTrigger.template.name);\nconst getEventListenerGeneratedName = (eventListener: EventListenerKind) =>\n  eventListener.status?.configuration.generatedName;\n\nconst useEventListenerRoutes = (\n  namespace: string,\n  eventListenerResources: EventListenerKind[],\n): RouteMap => {\n  const memoResources: WatchK8sResources<RouteMap> = React.useMemo(() => {\n    return (eventListenerResources || []).map(getEventListenerGeneratedName).reduce(\n      (acc, generatedName) => ({\n        ...acc,\n        [generatedName]: {\n          kind: RouteModel.kind,\n          name: generatedName,\n          namespace,\n          optional: true,\n        } as WatchK8sResource,\n      }),\n      {},\n    );\n  }, [namespace, eventListenerResources]);\n\n  const results: WatchK8sResults<RouteMap> = useK8sWatchResources<RouteMap>(memoResources);\n\n  return mapValues(results, (result: WatchK8sResultsObject<RouteKind>) => result.data);\n};\n\nconst useAllEventListeners = (namespace: string) => {\n  const eventListenerResource: WatchK8sResource = React.useMemo(\n    () => ({\n      kind: referenceForModel(EventListenerModel),\n      isList: true,\n      namespace,\n    }),\n    [namespace],\n  );\n  const [resources, eventListenerLoaded] = useK8sWatchResource<EventListenerKind[]>(\n    eventListenerResource,\n  );\n\n  return eventListenerLoaded ? resources : null;\n};\n\nexport type RouteTemplate = {\n  routeURL: string | null;\n  triggerTemplateName: string;\n};\n\nexport const usePipelineTriggerTemplateNames = (\n  pipelineName: string,\n  namespace: string,\n): RouteTemplate[] | null => {\n  const eventListenerResources = useAllEventListeners(namespace);\n  const triggerTemplateResources: WatchK8sResources<TriggerTemplateMapping> = React.useMemo(() => {\n    if (!eventListenerResources) {\n      return {};\n    }\n    return flatten(eventListenerResources.map(getEventListenerTemplateNames)).reduce(\n      (resourceMap, triggerTemplateName: string) => ({\n        ...resourceMap,\n        [triggerTemplateName]: {\n          kind: referenceForModel(TriggerTemplateModel),\n          name: triggerTemplateName,\n          namespace,\n          optional: true,\n        },\n      }),\n      {},\n    );\n  }, [namespace, eventListenerResources]);\n  const triggerTemplates: WatchK8sResults<TriggerTemplateMapping> = useK8sWatchResources(\n    triggerTemplateResources,\n  );\n  const routes: RouteMap = useEventListenerRoutes(namespace, eventListenerResources);\n\n  const triggerTemplateResults: WatchK8sResultsObject<TriggerTemplateKind>[] = Object.values(\n    triggerTemplates,\n  );\n  const countExpected = Object.keys(triggerTemplateResources).length;\n  const countLoaded = triggerTemplateResults.filter(({ loaded }) => loaded).length;\n  const countErrored = triggerTemplateResults.filter(({ loadError }) => !!loadError).length;\n  if (countLoaded === 0 || countLoaded !== countExpected - countErrored) {\n    return null;\n  }\n  const matchingTriggerTemplateNames: string[] = triggerTemplateResults\n    .filter((resourceWatch) => resourceWatch.loaded)\n    .map((resourceWatch) => resourceWatch.data)\n    .filter((triggerTemplate: TriggerTemplateKind) => {\n      const plr: PipelineRun = triggerTemplate?.spec?.resourcetemplates?.find(\n        ({ kind }) => kind === PipelineRunModel.kind,\n      );\n      return plr?.spec?.pipelineRef?.name === pipelineName;\n    })\n    .map(getResourceName);\n\n  return (eventListenerResources || []).reduce((acc, ev: EventListenerKind) => {\n    const eventListenerTemplateNames = getEventListenerTemplateNames(ev);\n    const generatedRouteName = getEventListenerGeneratedName(ev);\n\n    const triggerTemplateName = matchingTriggerTemplateNames.find((name) =>\n      eventListenerTemplateNames.includes(name),\n    );\n    const route: RouteKind = routes[generatedRouteName];\n\n    if (!triggerTemplateName) {\n      return acc;\n    }\n\n    let routeURL = null;\n    try {\n      if (route) {\n        routeURL = getRouteWebURL(route);\n      }\n    } catch (e) {\n      // swallow errors, we don't care if we can't create a good route right now\n    }\n\n    return [...acc, { routeURL, triggerTemplateName }];\n  }, []);\n};\n\nexport const useEventListenerTriggerTemplateNames = (\n  eventListener: EventListenerKind,\n): RouteTemplate[] | null => {\n  const {\n    metadata: { namespace },\n  } = eventListener;\n\n  const [route, routeLoaded] = useK8sGet<RouteKind>(\n    RouteModel,\n    getEventListenerGeneratedName(eventListener),\n    namespace,\n  );\n  return eventListener.spec.triggers.reduce(\n    (acc, trigger) => [\n      ...acc,\n      {\n        routeURL: route && route?.status?.ingress && routeLoaded ? getRouteWebURL(route) : null,\n        triggerTemplateName: trigger.template.name,\n      },\n    ],\n    [],\n  );\n};\n\nexport const getEventListenerTriggerBindingNames = (\n  eventListener: EventListenerKind,\n): ResourceModelLink[] => {\n  return eventListener.spec.triggers.reduce(\n    (acc, trigger) => [\n      ...acc,\n      ...trigger.bindings.map((binding) => ({\n        model: getResourceModelFromBindingKind(binding.kind),\n        name: binding.name,\n      })),\n    ],\n    [] as ResourceModelLink[],\n  );\n};\n\nexport const getTriggerTemplatePipelineName = (triggerTemplate: TriggerTemplateKind): string => {\n  return (\n    triggerTemplate.spec.resourcetemplates.find(({ kind }) => kind === PipelineRunModel.kind)?.spec\n      .pipelineRef.name || ''\n  );\n};\n\nexport const useTriggerTemplateEventListenerNames = (triggerTemplate: TriggerTemplateKind) => {\n  const eventListenerResources = useAllEventListeners(triggerTemplate.metadata.namespace) || [];\n\n  return eventListenerResources\n    .filter((eventListener: EventListenerKind) =>\n      eventListener.spec.triggers.find(\n        ({ template: { name } }) => name === getResourceName(triggerTemplate),\n      ),\n    )\n    .map(getResourceName);\n};\n\nexport const useTriggerBindingEventListenerNames = (triggerBinding: TriggerBindingKind) => {\n  const eventListenerResources = useAllEventListeners(triggerBinding.metadata.namespace) || [];\n  return eventListenerResources\n    .filter((eventListener: EventListenerKind) =>\n      eventListener.spec.triggers.find(({ bindings }) =>\n        bindings.find(\n          ({ kind, name }) =>\n            getResourceName(triggerBinding) === name &&\n            getResourceModelFromBindingKind(kind).kind === triggerBinding.kind,\n        ),\n      ),\n    )\n    .map(getResourceName);\n};\n","import * as React from 'react';\nimport { k8sGet, K8sKind, K8sResourceCommon } from '../../module/k8s';\n\nexport const useK8sGet = <R extends K8sResourceCommon = K8sResourceCommon>(\n  kind: K8sKind,\n  name?: string,\n  namespace?: string,\n  opts?: { [k: string]: string },\n): [R, boolean, any] => {\n  const [data, setData] = React.useState<R>();\n  const [loaded, setLoaded] = React.useState(false);\n  const [loadError, setLoadError] = React.useState();\n\n  React.useEffect(() => {\n    const fetch = async () => {\n      try {\n        setLoadError(null);\n        setLoaded(false);\n        setData(null);\n        const resource = await k8sGet(kind, name, namespace, opts);\n        setData(resource);\n      } catch (error) {\n        setLoadError(error);\n      } finally {\n        setLoaded(true);\n      }\n    };\n    fetch();\n  }, [kind, name, namespace, opts]);\n\n  return [data, loaded, loadError];\n};\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AAGA;AACA;AACA;AAIA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAkBA;AACA;AAYA;AAEA;AACA;AACA;AACA;AAEA;AAWA;AAEA;;;;;;;;;;;;ACvDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAKA;AAMA;AACA;AACA;AACA;AAEA;AAMA;AAMA;AAEA;AACA;AAEA;AAIA;AACA;AAUA;AAGA;AAEA;;;;;;;;;;;;;ACvEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AAcA;AAQA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;ACxGA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAYA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;AC9CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAMA;AAwBA;;;;;;;;;;;;ACnCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAUA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAGA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAOA;AACA;AACA;AAWA;AAEA;;;;;;;;;;;;;AC5FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AAEA;AACA;AAUA;AAGA;AAEA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAcA;AAKA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AAEA;AACA;AAEA;AAOA;AAEA;AAGA;AAEA;AAQA;AAGA;AAKA;AAEA;;;;;;;;;;;;ACzEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AAaA;AACA;AAWA;AAEA;;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AASA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAQA;AAMA;AAEA;;;;;;;;;;;;AClEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AASA;AACA;AAWA;AAEA;;;;;;;;;;;;ACxCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AAGA;AACA;AAGA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAQA;AACA;AAEA;AACA;AAUA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;AChHA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAGA;AACA;AAWA;AAEA;AACA;AACA;AAIA;AAEA;AAEA;AAEA;AACA;AAUA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAUA;AACA;AACA;AAGA;;;;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAMA;AACA;AACA;AAEA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC5JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA,sDACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA,mEACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA,4DACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAOA;AAKA;AAEA;AASA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAKA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpEA;AACA;AAEA;AAIA;AAEA;AAGA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAEA;AACA;AAGA;AAIA;AACA;AACA;AACA;AAIA;AACA;AACA;AAIA;AACA;AACA;AAGA;AAEA;AAKA;AACA;;;;;;;;;;;;;ACtEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AAEA;;;;;;;;;;;;;ACrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAGA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AAKA;AAEA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AAQA;AAEA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAcA;AAKA;AAEA;;;;;;;;;;;;ACzDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AAKA;AAEA;AACA;AAGA;AAMA;;AAIA;AACA;AAOA;AAEA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;;;;;;;;;;;;AC1CA;AAAA;AAAA;AAAA;AAAA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AAQA;AASA;AACA;AAIA;AAEA;;;;;;;;;;;;AC1CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAQA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AAKA;AAEA;AAOA;;AAEA;;AAAA;AACA;AAMA;AAEA;;;;;;;;;;;;;AClDA;AAAA;AAAA;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAIA;AAEA;AACA;AAGA;AAIA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;ACnDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAQA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnFA;AACA;AACA;AACA;AAOA;AACA;AAOA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AAGA;AAIA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;AC1FA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAEA;AAOA;AAOA;AAOA;AAMA;AAMA;AAMA;AASA;;;;;;;;;;;;;ACxDA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAEA;AAOA;AASA;;;;;;;;;;;;;ACxBA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAUA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;ACjCA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AAEA;AAOA;AAOA;AASA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC/DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AACA;AAYA;AACA;AAEA;AAGA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAIA;AACA;AAOA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAIA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;AACA;AAIA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AAKA;AAIA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9NA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;A","sourceRoot":""}