{"version":3,"file":"create-subscription-yaml-f3938074756ac77f1db2.js","sources":["webpack:///./packages/console-shared/src/utils/yaml.ts","webpack:///./packages/operator-lifecycle-manager/src/components/catalog-source.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/modals/delete-catalog-source-modal.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/modals/disable-default-source-modal.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/operator-group.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/package-manifest.tsx","webpack:///./public/components/create-yaml.tsx"],"sourcesContent":["import { safeDump, safeLoad } from 'js-yaml';\n\n// Safely parse js obj to yaml. Returns fallback (emtpy string by default) on exception.\nexport const safeJSToYAML = (js: any, fallback: string = '', options: any = {}): string => {\n  try {\n    return safeDump(js, options);\n  } catch {\n    return fallback;\n  }\n};\n\n// Safely parse yaml to js object. Returns fallback (empty object by default) on exception.\nexport const safeYAMLToJS = (yaml: string, fallback: any = {}, options: any = {}): any => {\n  try {\n    return safeLoad(yaml, options);\n  } catch {\n    return fallback;\n  }\n};\n\nexport const asyncJSToYAML = (js: any, options: any = {}): Promise<string> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const yaml = safeDump(js, options);\n      resolve(yaml);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\n\nexport const asyncYAMLToJS = (yaml: string, options: any = {}): Promise<any> => {\n  return new Promise((resolve, reject) => {\n    try {\n      const js = safeLoad(yaml, options);\n      resolve(js);\n    } catch (e) {\n      reject(e);\n    }\n  });\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport * as classNames from 'classnames';\nimport { match } from 'react-router-dom';\nimport { CreateYAML } from '@console/internal/components/create-yaml';\nimport { ListPageProps } from '@console/internal/components/monitoring';\nimport { sortable } from '@patternfly/react-table';\nimport { Button } from '@patternfly/react-core';\nimport { withFallback } from '@console/shared/src/components/error/error-boundary';\nimport {\n  K8sResourceKind,\n  referenceForModel,\n  K8sKind,\n  k8sPatch,\n} from '@console/internal/module/k8s';\nimport {\n  Firehose,\n  Kebab,\n  LoadingBox,\n  MsgBox,\n  navFactory,\n  ResourceKebab,\n  ResourceLink,\n  SectionHeading,\n  asAccessReview,\n  KebabOption,\n} from '@console/internal/components/utils';\nimport {\n  DetailsPage,\n  Table,\n  TableRow,\n  TableData,\n  TableProps,\n  MultiListPage,\n  RowFunction,\n} from '@console/internal/components/factory';\nimport { ConfigMapModel } from '@console/internal/models';\nimport { PopoverStatus } from '@console/shared';\nimport {\n  SubscriptionModel,\n  CatalogSourceModel,\n  PackageManifestModel,\n  OperatorGroupModel,\n  OperatorHubModel,\n} from '../models';\nimport {\n  CatalogSourceKind,\n  SubscriptionKind,\n  PackageManifestKind,\n  OperatorGroupKind,\n} from '../types';\nimport { requireOperatorGroup } from './operator-group';\nimport { PackageManifestList } from './package-manifest';\nimport { deleteCatalogSourceModal } from './modals/delete-catalog-source-modal';\nimport { disableDefaultSourceModal } from './modals/disable-default-source-modal';\nimport { OperatorHubKind } from './operator-hub';\n\nconst DEFAULT_SOURCE_NAMESPACE = 'openshift-marketplace';\nconst catalogSourceModelReference = referenceForModel(CatalogSourceModel);\n\nconst deleteModal = (kind: K8sKind, catalogSource: CatalogSourceKind): KebabOption => ({\n  ...Kebab.factory.Delete(kind, catalogSource),\n  callback: () => deleteCatalogSourceModal({ kind, resource: catalogSource }),\n});\n\nconst disableSourceModal = (\n  kind: K8sKind,\n  operatorHub: OperatorHubKind,\n  sourceName: string,\n): KebabOption => ({\n  label: 'Disable',\n  callback: () => disableDefaultSourceModal({ kind, operatorHub, sourceName }),\n  accessReview: asAccessReview(kind, operatorHub, 'patch'),\n});\n\nconst enableSource = (\n  kind: K8sKind,\n  operatorHub: OperatorHubKind,\n  sourceName: string,\n): KebabOption => ({\n  label: 'Enable',\n  callback: () => {\n    const currentSources = _.get(operatorHub, 'spec.sources', []);\n    const patch = [\n      {\n        op: 'add',\n        path: '/spec/sources',\n        value: _.filter(currentSources, (source) => source.name !== sourceName),\n      },\n    ];\n    return k8sPatch(kind, operatorHub, patch);\n  },\n  accessReview: asAccessReview(kind, operatorHub, 'patch'),\n});\n\nconst DefaultSourceKebab: React.FC<DefaultSourceKebabProps> = ({\n  kind,\n  operatorHub,\n  sourceName,\n  sourceDisabled,\n}) => {\n  const options = sourceDisabled\n    ? [enableSource(kind, operatorHub, sourceName)]\n    : [disableSourceModal(kind, operatorHub, sourceName)];\n  return <Kebab options={options} />;\n};\n\nexport const CatalogSourceDetails: React.SFC<CatalogSourceDetailsProps> = ({\n  obj,\n  packageManifests,\n  subscriptions,\n  operatorGroups,\n}) => {\n  const toData = <T extends K8sResourceKind>(data: T[]) => ({ loaded: true, data });\n\n  return !_.isEmpty(obj) ? (\n    <div className=\"co-catalog-details co-m-pane\">\n      <div className=\"co-m-pane__body\">\n        <div className=\"col-xs-4\">\n          <dl className=\"co-m-pane__details\">\n            <dt>Name</dt>\n            <dd>{obj.spec.displayName}</dd>\n          </dl>\n        </div>\n        <div className=\"col-xs-4\">\n          <dl className=\"co-m-pane__details\">\n            <dt>Publisher</dt>\n            <dd>{obj.spec.publisher}</dd>\n          </dl>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text=\"Packages\" />\n        <PackageManifestList\n          loaded\n          data={packageManifests}\n          operatorGroup={toData(operatorGroups)}\n          subscription={toData(subscriptions)}\n        />\n      </div>\n    </div>\n  ) : (\n    <div />\n  );\n};\n\nexport const CatalogSourceDetailsPage: React.SFC<CatalogSourceDetailsPageProps> = (props) => (\n  <DetailsPage\n    {...props}\n    namespace={props.match.params.ns}\n    kind={referenceForModel(CatalogSourceModel)}\n    name={props.match.params.name}\n    pages={[navFactory.details(CatalogSourceDetails), navFactory.editYaml()]}\n    menuActions={Kebab.factory.common}\n    resources={[\n      {\n        kind: referenceForModel(PackageManifestModel),\n        isList: true,\n        namespace: props.match.params.ns,\n        selector: { matchLabels: { catalog: props.match.params.name } },\n        prop: 'packageManifests',\n      },\n      {\n        kind: referenceForModel(SubscriptionModel),\n        isList: true,\n        namespace: props.match.params.ns,\n        prop: 'subscriptions',\n      },\n      {\n        kind: referenceForModel(OperatorGroupModel),\n        isList: true,\n        namespace: props.match.params.ns,\n        prop: 'operatorGroups',\n      },\n    ]}\n  />\n);\n\nexport const CreateSubscriptionYAML: React.SFC<CreateSubscriptionYAMLProps> = (props) => {\n  type CreateProps = {\n    packageManifest: { loaded: boolean; data?: PackageManifestKind };\n    operatorGroup: { loaded: boolean; data?: OperatorGroupKind[] };\n  };\n  const Create = requireOperatorGroup(\n    withFallback<CreateProps>(\n      (createProps) => {\n        if (createProps.packageManifest.loaded && createProps.packageManifest.data) {\n          const pkg = createProps.packageManifest.data;\n          const channel = pkg.status.defaultChannel\n            ? pkg.status.channels.find(({ name }) => name === pkg.status.defaultChannel)\n            : pkg.status.channels[0];\n\n          const template = `\n          apiVersion: ${SubscriptionModel.apiGroup}/${SubscriptionModel.apiVersion}\n          kind: ${SubscriptionModel.kind},\n          metadata:\n            generateName: ${pkg.metadata.name}-\n            namespace: default\n          spec:\n            source: ${new URLSearchParams(props.location.search).get('catalog')}\n            sourceNamespace: ${new URLSearchParams(props.location.search).get('catalogNamespace')}\n            name: ${pkg.metadata.name}\n            startingCSV: ${channel.currentCSV}\n            channel: ${channel.name}\n        `;\n          return (\n            <CreateYAML {...(props as any)} plural={SubscriptionModel.plural} template={template} />\n          );\n        }\n        return <LoadingBox />;\n      },\n      () => (\n        <MsgBox\n          title=\"Package Not Found\"\n          detail=\"Cannot create a Subscription to a non-existent package.\"\n        />\n      ),\n    ),\n  );\n\n  return (\n    <Firehose\n      resources={[\n        {\n          kind: referenceForModel(PackageManifestModel),\n          isList: false,\n          name: new URLSearchParams(props.location.search).get('pkg'),\n          namespace: new URLSearchParams(props.location.search).get('catalogNamespace'),\n          prop: 'packageManifest',\n        },\n        {\n          kind: referenceForModel(OperatorGroupModel),\n          isList: true,\n          namespace: props.match.params.ns,\n          prop: 'operatorGroup',\n        },\n      ]}\n    >\n      {/* FIXME(alecmerdler): Hack because `Firehose` injects props without TypeScript knowing about it */}\n      <Create {...(props as any)} />\n    </Firehose>\n  );\n};\n\nconst tableColumnClasses = [\n  classNames('col-lg-3', 'col-md-3', 'col-sm-4', 'col-xs-6'),\n  classNames('col-lg-2', 'col-md-3', 'col-sm-4', 'col-xs-6'),\n  classNames('col-lg-2', 'col-md-3', 'col-sm-4', 'hidden-xs'),\n  classNames('col-lg-3', 'col-md-3', 'hidden-sm', 'hidden-xs'),\n  classNames('col-lg-2', 'hidden-md', 'hidden-sm', 'hidden-xs'),\n  Kebab.columnClass,\n];\n\nconst CatalogSourceHeader = () => {\n  return [\n    {\n      title: 'Name',\n      sortField: 'name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: 'Publisher',\n      sortField: 'publisher',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: 'Availability',\n      sortField: 'availabilitySort',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: 'Endpoint',\n      sortField: 'endpoint',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: '# of Operators',\n      sortField: 'operatorCount',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[4] },\n    },\n    {\n      title: '',\n      props: { className: tableColumnClasses[5] },\n    },\n  ];\n};\n\nconst getEndpoint = (catalogSource: CatalogSourceKind): React.ReactNode => {\n  if (catalogSource.spec.configmap) {\n    return (\n      <ResourceLink\n        kind={referenceForModel(ConfigMapModel)}\n        name={catalogSource.spec.configmap}\n        namespace={catalogSource.metadata.namespace}\n      />\n    );\n  }\n  return catalogSource.spec.image || catalogSource.spec.address;\n};\n\nconst getOperatorCount = (\n  catalogSource: CatalogSourceKind,\n  packageManifests: PackageManifestKind[],\n): number =>\n  _.filter(packageManifests, {\n    status: {\n      catalogSource: catalogSource.metadata.name,\n      catalogSourceNamespace: catalogSource.metadata.namespace,\n    },\n  } as any).length; // Type inferred to prevent Lodash TypeScript error.\n\nconst CatalogSourceTableRow: RowFunction<CatalogSourceTableRowObj> = ({\n  obj: {\n    availability = '-',\n    disabled = false,\n    endpoint = '-',\n    isDefault = false,\n    name,\n    operatorCount = 0,\n    operatorHub,\n    publisher = '-',\n    source,\n  },\n  index,\n  key,\n  style,\n}) => (\n  <TableRow\n    className={disabled && 'catalog-source__table-row--disabled'}\n    id={source ? source.metadata.uid : index}\n    index={index}\n    style={style}\n    trKey={key}\n  >\n    <TableData className={tableColumnClasses[0]}>\n      {source ? (\n        <ResourceLink\n          kind={catalogSourceModelReference}\n          name={source.metadata.name}\n          namespace={source.metadata.namespace}\n          title={source.metadata.name}\n        />\n      ) : (\n        name\n      )}\n    </TableData>\n    <TableData className={tableColumnClasses[1]}>{publisher}</TableData>\n    <TableData className={tableColumnClasses[2]}>{availability}</TableData>\n    <TableData className={tableColumnClasses[3]}>{endpoint}</TableData>\n    <TableData className={tableColumnClasses[4]}>{operatorCount || '-'}</TableData>\n    <TableData className={tableColumnClasses[5]}>\n      {isDefault ? (\n        <DefaultSourceKebab\n          kind={OperatorHubModel}\n          operatorHub={operatorHub}\n          sourceName={name}\n          sourceDisabled={disabled}\n        />\n      ) : (\n        <ResourceKebab\n          actions={[Kebab.factory.Edit, deleteModal]}\n          kind={catalogSourceModelReference}\n          resource={source}\n        />\n      )}\n    </TableData>\n  </TableRow>\n);\n\nconst CatalogSourceList: React.FC<TableProps> = (props) => (\n  <Table\n    {...props}\n    aria-label=\"Catalog Sources\"\n    Header={CatalogSourceHeader}\n    Row={CatalogSourceTableRow}\n  />\n);\n\nconst DisabledPopover: React.FC<DisabledPopoverProps> = ({ operatorHub, sourceName }) => {\n  const [visible, setVisible] = React.useState<boolean>(null);\n  const close = React.useCallback(() => {\n    setVisible(false);\n  }, []);\n  const onClickEnable = React.useCallback(\n    () =>\n      enableSource(OperatorHubModel, operatorHub, sourceName)\n        .callback()\n        .then(close),\n    [close, operatorHub, sourceName],\n  );\n  return (\n    <PopoverStatus title=\"Disabled\" isVisible={visible} shouldClose={close}>\n      <p>\n        Operators provided by this source will not appear in OperatorHub and any operators installed\n        from this source will not receive updates unitl this source is re-enabled.\n      </p>\n      <Button isInline variant=\"link\" onClick={onClickEnable}>\n        Enable source\n      </Button>\n    </PopoverStatus>\n  );\n};\n\nconst flatten = ({\n  catalogSources,\n  operatorHub,\n  packageManifests,\n}: FlattenArgType): CatalogSourceTableRowObj[] => {\n  const defaultSources: CatalogSourceTableRowObj[] = _.map(\n    operatorHub.status.sources,\n    (defaultSource) => {\n      const catalogSource = _.find(catalogSources.data, {\n        metadata: { name: defaultSource.name, namespace: DEFAULT_SOURCE_NAMESPACE },\n      });\n      const catalogSourceExists = !_.isEmpty(catalogSource);\n      return {\n        availability: catalogSourceExists ? (\n          'Cluster wide'\n        ) : (\n          <DisabledPopover operatorHub={operatorHub} sourceName={defaultSource.name} />\n        ),\n        // Add a string value for sorting by availability since React elements can't be sorted.\n        availabilitySort: catalogSourceExists ? 'Cluster wide' : 'Disabled',\n        disabled: !catalogSourceExists,\n        isDefault: true,\n        name: defaultSource.name,\n        namespace: DEFAULT_SOURCE_NAMESPACE,\n        operatorHub,\n        ...(catalogSourceExists && {\n          source: catalogSource,\n          endpoint: getEndpoint(catalogSource),\n          operatorCount: getOperatorCount(catalogSource, packageManifests.data),\n          publisher: catalogSource.spec.publisher,\n        }),\n      };\n    },\n  );\n\n  const customSources: CatalogSourceTableRowObj[] = _.map(catalogSources.data, (source) => ({\n    availability:\n      source.metadata.namespace === DEFAULT_SOURCE_NAMESPACE\n        ? 'Cluster wide'\n        : source.metadata.namespace,\n    endpoint: getEndpoint(source),\n    name: source.metadata.name,\n    namespace: source.metadata.namespace,\n    operatorCount: getOperatorCount(source, packageManifests.data),\n    operatorHub,\n    publisher: source.spec.publisher,\n    source,\n  }));\n\n  return _.unionWith(\n    defaultSources,\n    customSources,\n    (a, b) => a.name === b.name && a.namespace === b.namespace,\n  );\n};\n\nexport const CatalogSourceListPage: React.FC<CatalogSourceListPageProps> = (props) => (\n  <MultiListPage\n    {...props}\n    canCreate\n    createAccessReview={{ model: CatalogSourceModel }}\n    createButtonText=\"Create Catalog Source\"\n    createProps={{ to: `/k8s/cluster/${referenceForModel(CatalogSourceModel)}/~new` }}\n    flatten={(data) => flatten({ operatorHub: props.obj, ...data })}\n    ListComponent={CatalogSourceList}\n    textFilter=\"catalog-source-name\"\n    hideLabelFilter\n    resources={[\n      {\n        isList: true,\n        kind: referenceForModel(PackageManifestModel),\n        prop: 'packageManifests',\n      },\n      {\n        isList: true,\n        kind: catalogSourceModelReference,\n        prop: 'catalogSources',\n      },\n    ]}\n  />\n);\n\ntype CatalogSourceTableRowObj = {\n  availability: React.ReactNode;\n  disabled?: boolean;\n  endpoint?: React.ReactNode;\n  isDefault?: boolean;\n  name: string;\n  namespace: string;\n  publisher?: string;\n  operatorCount?: number;\n  operatorHub: OperatorHubKind;\n  source?: CatalogSourceKind;\n};\n\ntype DefaultSourceKebabProps = {\n  kind: K8sKind;\n  operatorHub: OperatorHubKind;\n  sourceName: string;\n  sourceDisabled: boolean;\n};\n\ntype DisabledPopoverProps = {\n  operatorHub: OperatorHubKind;\n  sourceName: string;\n};\n\ntype FlattenArgType = {\n  catalogSources: { data: CatalogSourceKind[] };\n  packageManifests: { data: PackageManifestKind[] };\n  operatorHub: OperatorHubKind;\n};\n\nexport type CatalogSourceDetailsProps = {\n  obj: CatalogSourceKind;\n  subscriptions: SubscriptionKind[];\n  packageManifests: PackageManifestKind[];\n  operatorGroups: OperatorGroupKind[];\n};\n\nexport type CatalogSourceDetailsPageProps = {\n  match: match<{ ns?: string; name: string }>;\n};\n\nexport type CatalogSourceListPageProps = {\n  obj: K8sResourceKind;\n} & ListPageProps;\n\nexport type CreateSubscriptionYAMLProps = {\n  match: match<{ ns: string; pkgName: string }>;\n  location: Location;\n};\n\nCatalogSourceDetails.displayName = 'CatalogSourceDetails';\nCatalogSourceDetailsPage.displayName = 'CatalogSourceDetailPage';\nCreateSubscriptionYAML.displayName = 'CreateSubscriptionYAML';\n","import * as React from 'react';\nimport { k8sKill, K8sKind, K8sResourceKind } from '@console/internal/module/k8s';\nimport {\n  createModalLauncher,\n  ModalTitle,\n  ModalBody,\n  ModalSubmitFooter,\n  ModalComponentProps,\n} from '@console/internal/components/factory/modal';\nimport { YellowExclamationTriangleIcon } from '@console/shared';\nimport { withHandlePromise, HandlePromiseProps } from '@console/internal/components/utils';\n\nconst DeleteCatalogSourceModal: React.FC<DeleteCatalogSourceModalProps> = ({\n  kind,\n  resource,\n  close,\n  cancel,\n  inProgress,\n  errorMessage,\n  handlePromise,\n}) => {\n  const [confirmed, setConfirmed] = React.useState<boolean>(false);\n  const isConfirmed = (e: React.KeyboardEvent<HTMLInputElement>) => {\n    setConfirmed(e.currentTarget.value === resource.metadata.name);\n  };\n\n  const submit = React.useCallback(\n    (event: React.FormEvent<EventTarget>) => {\n      event.preventDefault();\n      return handlePromise(k8sKill(kind, resource)).then(close);\n    },\n    [close, handlePromise, kind, resource],\n  );\n\n  return (\n    <form onSubmit={submit} name=\"form\" className=\"modal-content \">\n      <ModalTitle>\n        <YellowExclamationTriangleIcon className=\"co-icon-space-r\" /> Delete {kind.label}?\n      </ModalTitle>\n      <ModalBody>\n        <p>\n          By deleting a catlog source, any operator that has been installed from this source will no\n          longer receive updates.\n        </p>\n        <p>\n          Confirm deletion by typing &nbsp;\n          <strong className=\"co-break-word\">{resource.metadata.name}</strong>\n          &nbsp; below:\n        </p>\n        <input\n          type=\"text\"\n          className=\"pf-c-form-control\"\n          onKeyUp={isConfirmed}\n          placeholder=\"Enter name\"\n        />\n      </ModalBody>\n      <ModalSubmitFooter\n        submitText=\"Delete\"\n        submitDisabled={!confirmed}\n        cancel={cancel}\n        errorMessage={errorMessage}\n        inProgress={inProgress}\n        submitDanger\n      />\n    </form>\n  );\n};\n\ntype DeleteCatalogSourceModalProps = {\n  kind: K8sKind;\n  resource: K8sResourceKind;\n} & ModalComponentProps &\n  HandlePromiseProps;\n\nexport const deleteCatalogSourceModal = createModalLauncher(\n  withHandlePromise(DeleteCatalogSourceModal),\n);\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { k8sPatch, K8sKind } from '@console/internal/module/k8s';\nimport {\n  createModalLauncher,\n  ModalTitle,\n  ModalBody,\n  ModalSubmitFooter,\n  ModalComponentProps,\n} from '@console/internal/components/factory/modal';\nimport { YellowExclamationTriangleIcon } from '@console/shared';\nimport { withHandlePromise, HandlePromiseProps } from '@console/internal/components/utils';\nimport { OperatorHubKind } from '../operator-hub';\n\nconst DisableDefaultSourceModal: React.FC<DisableSourceModalProps> = ({\n  kind,\n  operatorHub,\n  sourceName,\n  close,\n  cancel,\n  inProgress,\n  errorMessage,\n  handlePromise,\n}) => {\n  const submit = React.useCallback(\n    (event: React.FormEvent<EventTarget>): Promise<any> => {\n      event.preventDefault();\n      const currentSources = _.get(operatorHub, 'spec.sources', []);\n      const patch = [\n        {\n          op: 'add',\n          path: '/spec/sources',\n          value: [\n            ..._.filter(currentSources, (source) => source.name !== sourceName),\n            {\n              name: sourceName,\n              disabled: true,\n            },\n          ],\n        },\n      ];\n      return handlePromise(k8sPatch(kind, operatorHub, patch)).then(close);\n    },\n    [close, handlePromise, kind, operatorHub, sourceName],\n  );\n\n  return (\n    <form onSubmit={submit} name=\"form\" className=\"modal-content \">\n      <ModalTitle>\n        <YellowExclamationTriangleIcon className=\"co-icon-space-r\" /> Disable Catalog Source?\n      </ModalTitle>\n      <ModalBody>\n        By disabling a default source, the operators it provides will no longer appear in\n        OperatorHub and any operator that has been installed from this source will no longer receive\n        updates until the source is re-enabled. Disabling the source will also remove the\n        corresponding OperatorSource and CatalogSource resources from the cluster.\n      </ModalBody>\n      <ModalSubmitFooter\n        submitText=\"Disable\"\n        cancel={cancel}\n        errorMessage={errorMessage}\n        inProgress={inProgress}\n        submitDanger\n      />\n    </form>\n  );\n};\n\ntype DisableSourceModalProps = {\n  kind: K8sKind;\n  operatorHub: OperatorHubKind;\n  sourceName: string;\n} & ModalComponentProps &\n  HandlePromiseProps;\n\nexport const disableDefaultSourceModal = createModalLauncher(\n  withHandlePromise(DisableDefaultSourceModal),\n);\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { Link } from 'react-router-dom';\nimport { MsgBox } from '@console/internal/components/utils/status-box';\nimport {\n  K8sResourceKind,\n  GroupVersionKind,\n  referenceForModel,\n  referenceForGroupVersionKind,\n} from '@console/internal/module/k8s';\nimport { AsyncComponent } from '@console/internal/components/utils/async';\nimport { getActiveNamespace } from '@console/internal/actions/ui';\nimport { OperatorGroupModel } from '../models';\nimport { OperatorGroupKind, SubscriptionKind, InstallModeType } from '../types';\n\nexport const targetNamespacesFor = (obj: K8sResourceKind) =>\n  _.get(obj, ['metadata', 'annotations', 'olm.targetNamespaces']);\nexport const operatorNamespaceFor = (obj: K8sResourceKind) =>\n  _.get(obj, ['metadata', 'annotations', 'olm.operatorNamespace']);\nexport const operatorGroupFor = (obj: K8sResourceKind) =>\n  _.get(obj, ['metadata', 'annotations', 'olm.operatorGroup']);\n\nexport const NoOperatorGroupMsg: React.SFC = () => (\n  <MsgBox\n    title=\"Namespace Not Enabled\"\n    detail={\n      <p>\n        The Operator Lifecycle Manager will not watch this namespace because it is not configured\n        with an OperatorGroup.{' '}\n        <Link to={`/ns/${getActiveNamespace()}/${referenceForModel(OperatorGroupModel)}/~new`}>\n          Create one here.\n        </Link>\n      </p>\n    }\n  />\n);\n\ntype RequireOperatorGroupProps = {\n  operatorGroup: { loaded: boolean; data?: OperatorGroupKind[] };\n};\n\nexport const OperatorGroupSelector: React.SFC<OperatorGroupSelectorProps> = (props) => (\n  <AsyncComponent\n    loader={() =>\n      import('@console/internal/components/utils/list-dropdown').then((m) => m.ListDropdown)\n    }\n    onChange={\n      props.onChange ||\n      function() {\n        return null;\n      }\n    }\n    desc=\"Operator Groups\"\n    placeholder=\"Select Operator Group\"\n    selectedKeyKind={referenceForModel(OperatorGroupModel)}\n    dataFilter={props.dataFilter}\n    resources={[\n      {\n        kind: referenceForModel(OperatorGroupModel),\n        fieldSelector: `metadata.name!=${props.excludeName}`,\n      },\n    ]}\n  />\n);\n\nexport const requireOperatorGroup = <P extends RequireOperatorGroupProps>(\n  Component: React.ComponentType<P>,\n) => {\n  return class RequireOperatorGroup extends React.Component<P> {\n    static WrappedComponent = Component;\n\n    render() {\n      const namespaceEnabled =\n        !_.get(this.props.operatorGroup, 'loaded') || !_.isEmpty(this.props.operatorGroup.data);\n\n      return namespaceEnabled ? <Component {...this.props} /> : <NoOperatorGroupMsg />;\n    }\n  } as React.ComponentClass<P> & { WrappedComponent: React.ComponentType<P> };\n};\n\nexport type InstallModeSet = { type: InstallModeType; supported: boolean }[];\n\n/**\n * Logic consistent with https://github.com/operator-framework/operator-lifecycle-manager/blob/4ef074e4207f5518d95ddf8c378036dfc4270dda/pkg/api/apis/operators/v1alpha1/clusterserviceversion.go#L165.\n */\nexport const supports = (set: InstallModeSet) => (obj: OperatorGroupKind) => {\n  const namespaces = _.get(obj.status, 'namespaces') || [];\n  const supportedModes = set.filter(({ supported }) => supported).map(({ type }) => type);\n\n  if (namespaces.length === 0) {\n    return false;\n  }\n  if (namespaces.length === 1) {\n    if (namespaces[0] === obj.metadata.namespace) {\n      return supportedModes.includes(InstallModeType.InstallModeTypeOwnNamespace);\n    }\n    if (namespaces[0] === '') {\n      return supportedModes.includes(InstallModeType.InstallModeTypeAllNamespaces);\n    }\n    return supportedModes.includes(InstallModeType.InstallModeTypeSingleNamespace);\n  }\n  if (\n    namespaces.length > 1 &&\n    !supportedModes.includes(InstallModeType.InstallModeTypeMultiNamespace)\n  ) {\n    return false;\n  }\n  if (namespaces.length > 1) {\n    if (\n      namespaces.includes(obj.metadata.namespace) &&\n      !supportedModes.includes(InstallModeType.InstallModeTypeOwnNamespace)\n    ) {\n      return false;\n    }\n    if (namespaces.includes('')) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const isGlobal = (obj: OperatorGroupKind) =>\n  supports([{ type: InstallModeType.InstallModeTypeAllNamespaces, supported: true }])(obj);\nexport const isSingle = (obj: OperatorGroupKind) =>\n  supports([{ type: InstallModeType.InstallModeTypeSingleNamespace, supported: true }])(obj);\n\n/**\n * Determines if a given Operator package has a `Subscription` that makes it available in the given namespace.\n * Finds any `Subscriptions` for the given package, matches them to their `OperatorGroup`, and checks if the `OperatorGroup` is targeting the given namespace or if it is global.\n */\nexport const subscriptionFor = (allSubscriptions: SubscriptionKind[] = []) => (\n  allGroups: OperatorGroupKind[] = [],\n) => (pkgName: string) => (ns = '') => {\n  return allSubscriptions\n    .filter((sub) => sub.spec.name === pkgName)\n    .find((sub) =>\n      allGroups.some(\n        (og) =>\n          og.metadata.namespace === sub.metadata.namespace &&\n          (isGlobal(og) || _.get(og.status, 'namespaces', [] as string[]).includes(ns)),\n      ),\n    );\n};\n\nexport const installedFor = (allSubscriptions: SubscriptionKind[] = []) => (\n  allGroups: OperatorGroupKind[] = [],\n) => (pkgName: string) => (ns = '') => {\n  return !_.isNil(subscriptionFor(allSubscriptions)(allGroups)(pkgName)(ns));\n};\n\nexport const providedAPIsFor = (og: OperatorGroupKind) =>\n  _.get(og.metadata.annotations, 'olm.providedAPIs', '')\n    .split(',')\n    .map((api) => ({\n      group: api\n        .split('.')\n        .slice(2)\n        .join('.'),\n      version: api.split('.')[1],\n      kind: api.split('.')[0],\n    }))\n    .map(({ group, version, kind }) => referenceForGroupVersionKind(group)(version)(kind));\n\nexport type OperatorGroupSelectorProps = {\n  onChange?: (name: string, kind: GroupVersionKind) => void;\n  excludeName?: string;\n  dataFilter?: (obj: OperatorGroupKind) => boolean;\n};\n\nNoOperatorGroupMsg.displayName = 'NoOperatorGroupMsg';\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { Link, match } from 'react-router-dom';\nimport * as classNames from 'classnames';\nimport { Button } from '@patternfly/react-core';\nimport { referenceForModel, K8sResourceKind } from '@console/internal/module/k8s';\nimport { StatusBox, MsgBox } from '@console/internal/components/utils';\nimport {\n  MultiListPage,\n  Table,\n  TableRow,\n  TableData,\n  RowFunctionArgs,\n} from '@console/internal/components/factory';\nimport { getActiveNamespace } from '@console/internal/actions/ui';\nimport { ALL_NAMESPACES_KEY, OPERATOR_HUB_LABEL } from '@console/shared';\nimport {\n  PackageManifestModel,\n  SubscriptionModel,\n  CatalogSourceModel,\n  OperatorGroupModel,\n} from '../models';\nimport { PackageManifestKind, SubscriptionKind, OperatorGroupKind } from '../types';\nimport { requireOperatorGroup, installedFor, supports } from './operator-group';\nimport {\n  ClusterServiceVersionLogo,\n  visibilityLabel,\n  installModesFor,\n  defaultChannelFor,\n} from './index';\n\nconst tableColumnClasses = [\n  classNames('col-lg-4', 'col-md-4', 'col-sm-4', 'col-xs-6'),\n  classNames('col-lg-3', 'col-md-3', 'col-sm-4', 'hidden-xs'),\n  classNames('col-lg-5', 'col-md-5', 'col-sm-4', 'col-xs-6'),\n];\n\nexport const PackageManifestTableHeader = () => [\n  {\n    title: 'Name',\n    props: { className: tableColumnClasses[0] },\n  },\n  {\n    title: 'Latest Version',\n    props: { className: tableColumnClasses[1] },\n  },\n  {\n    title: 'Subscriptions',\n    props: { className: tableColumnClasses[2] },\n  },\n];\n\nexport const PackageManifestTableRow: React.SFC<PackageManifestTableRowProps> = ({\n  obj,\n  index,\n  rowKey,\n  style,\n  catalogSourceName,\n  catalogSourceNamespace,\n  subscription,\n  defaultNS,\n  canSubscribe,\n}) => {\n  const ns = getActiveNamespace();\n  const channel = !_.isEmpty(obj.status.defaultChannel)\n    ? obj.status.channels.find((ch) => ch.name === obj.status.defaultChannel)\n    : obj.status.channels[0];\n  const { displayName, icon = [], version, provider } = channel.currentCSVDesc;\n\n  const subscriptionLink = () =>\n    ns !== ALL_NAMESPACES_KEY ? (\n      <Link to={`/operatormanagement/ns/${ns}?name=${subscription.metadata.name}`}>\n        View<span className=\"visible-lg-inline\"> subscription</span>\n      </Link>\n    ) : (\n      <Link to={`/operatormanagement/all-namespaces?name=${obj.metadata.name}`}>\n        View<span className=\"visible-lg-inline\"> subscriptions</span>\n      </Link>\n    );\n\n  const createSubscriptionLink = () =>\n    `/k8s/ns/${ns === ALL_NAMESPACES_KEY ? defaultNS : ns}/${SubscriptionModel.plural}/~new?pkg=${\n      obj.metadata.name\n    }&catalog=${catalogSourceName}&catalogNamespace=${catalogSourceNamespace}`;\n\n  return (\n    <TableRow id={obj.metadata.uid} index={index} trKey={rowKey} style={style}>\n      <TableData className={tableColumnClasses[0]}>\n        <ClusterServiceVersionLogo\n          displayName={displayName}\n          icon={_.get(icon, '[0]')}\n          provider={provider.name}\n        />\n      </TableData>\n      <TableData className={tableColumnClasses[1]}>\n        {version} ({channel.name})\n      </TableData>\n      <TableData className={tableColumnClasses[2]}>\n        {subscription ? subscriptionLink() : <span className=\"text-muted\">None</span>}\n        {canSubscribe && (\n          <Link to={createSubscriptionLink()}>\n            <Button variant=\"primary\" type=\"button\">\n              Create<span className=\"visible-lg-inline\"> Subscription</span>\n            </Button>\n          </Link>\n        )}\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const PackageManifestList = requireOperatorGroup((props: PackageManifestListProps) => {\n  type CatalogSourceInfo = {\n    displayName: string;\n    name: string;\n    publisher: string;\n    namespace: string;\n  };\n  const catalogs = (props.data || []).reduce(\n    (allCatalogs, { status }) =>\n      allCatalogs.set(status.catalogSource, {\n        displayName: status.catalogSourceDisplayName,\n        name: status.catalogSource,\n        publisher: status.catalogSourcePublisher,\n        namespace: status.catalogSourceNamespace,\n      }),\n    new Map<string, CatalogSourceInfo>(),\n  );\n\n  return (\n    <StatusBox\n      loaded={props.loaded}\n      loadError={props.loadError}\n      label={PackageManifestModel.labelPlural}\n      data={props.data}\n      EmptyMsg={() => (\n        <MsgBox\n          title=\"No Package Manifests Found\"\n          detail=\"Package Manifests are packaged Operators which can be subscribed to for automatic upgrades.\"\n        />\n      )}\n    >\n      {_.sortBy([...catalogs.values()], 'displayName').map((catalog) => (\n        <div key={catalog.name} className=\"co-catalogsource-list__section\">\n          <div className=\"co-catalogsource-list__section__packages\">\n            <div>\n              <h3>{catalog.displayName}</h3>\n              <span className=\"text-muted\">Packaged by {catalog.publisher}</span>\n            </div>\n            {props.showDetailsLink && (\n              <Link\n                to={`/k8s/ns/${catalog.namespace}/${referenceForModel(CatalogSourceModel)}/${\n                  catalog.name\n                }`}\n              >\n                View catalog details\n              </Link>\n            )}\n          </div>\n          <Table\n            aria-label=\"Package Manifests\"\n            loaded\n            data={(props.data || []).filter((pkg) => pkg.status.catalogSource === catalog.name)}\n            filters={props.filters}\n            Header={PackageManifestTableHeader}\n            Row={(rowArgs: RowFunctionArgs<PackageManifestKind>) => (\n              <PackageManifestTableRow\n                obj={rowArgs.obj}\n                index={rowArgs.index}\n                rowKey={rowArgs.key}\n                style={rowArgs.style}\n                catalogSourceName={catalog.name}\n                catalogSourceNamespace={catalog.namespace}\n                subscription={(props.subscription.data || [])\n                  .filter(\n                    (sub) =>\n                      _.isEmpty(props.namespace) || sub.metadata.namespace === props.namespace,\n                  )\n                  .find((sub) => sub.spec.name === rowArgs.obj.metadata.name)}\n                canSubscribe={\n                  props.canSubscribe &&\n                  !installedFor(props.subscription.data)(props.operatorGroup.data)(\n                    rowArgs.obj.status.packageName,\n                  )(getActiveNamespace()) &&\n                  props.operatorGroup.data\n                    .filter(\n                      (og) =>\n                        _.isEmpty(props.namespace) || og.metadata.namespace === props.namespace,\n                    )\n                    .some((og) =>\n                      supports(installModesFor(rowArgs.obj)(defaultChannelFor(rowArgs.obj)))(og),\n                    )\n                }\n                defaultNS={_.get(props.operatorGroup, 'data[0].metadata.namespace')}\n              />\n            )}\n            EmptyMsg={() => (\n              <MsgBox\n                title=\"No PackageManifests Found\"\n                detail=\"The catalog author has not added any packages.\"\n              />\n            )}\n            virtualize\n          />\n        </div>\n      ))}\n    </StatusBox>\n  );\n});\n\nexport const PackageManifestsPage: React.SFC<PackageManifestsPageProps> = (props) => {\n  const namespace = _.get(props.match, 'params.ns');\n  type Flatten = (resources: { [kind: string]: { data: K8sResourceKind[] } }) => K8sResourceKind[];\n  const flatten: Flatten = (resources) => _.get(resources.packageManifest, 'data', []);\n  const helpText = (\n    <p className=\"co-help-text\">\n      Catalogs are groups of Operators you can make available on the cluster. Use{' '}\n      <Link to=\"/operatorhub\">OperatorHub</Link> to subscribe and grant namespaces access to use\n      installed Operators.\n    </p>\n  );\n\n  return (\n    <MultiListPage\n      {...props}\n      namespace={namespace}\n      showTitle={false}\n      helpText={helpText}\n      ListComponent={(listProps: PackageManifestListProps) => (\n        <PackageManifestList {...listProps} showDetailsLink namespace={namespace} />\n      )}\n      textFilter=\"packagemanifest-name\"\n      flatten={flatten}\n      resources={[\n        {\n          kind: referenceForModel(PackageManifestModel),\n          isList: true,\n          namespaced: true,\n          prop: 'packageManifest',\n          selector: {\n            matchExpressions: [\n              { key: visibilityLabel, operator: 'DoesNotExist' },\n              { key: OPERATOR_HUB_LABEL, operator: 'DoesNotExist' },\n            ],\n          },\n        },\n        {\n          kind: referenceForModel(CatalogSourceModel),\n          isList: true,\n          namespaced: true,\n          prop: 'catalogSource',\n        },\n        {\n          kind: referenceForModel(SubscriptionModel),\n          isList: true,\n          namespaced: true,\n          prop: 'subscription',\n        },\n        {\n          kind: referenceForModel(OperatorGroupModel),\n          isList: true,\n          namespaced: true,\n          prop: 'operatorGroup',\n        },\n      ]}\n    />\n  );\n};\n\nexport type PackageManifestsPageProps = {\n  namespace?: string;\n  match?: match<{ ns?: string }>;\n};\n\nexport type PackageManifestListProps = {\n  namespace?: string;\n  data: PackageManifestKind[];\n  filters?: { [name: string]: string };\n  subscription: { loaded: boolean; data?: SubscriptionKind[] };\n  operatorGroup: { loaded: boolean; data?: OperatorGroupKind[] };\n  loaded: boolean;\n  loadError?: string | Record<string, any>;\n  showDetailsLink?: boolean;\n  canSubscribe?: boolean;\n};\n\nexport type PackageManifestTableRowProps = {\n  obj: PackageManifestKind;\n  index: number;\n  rowKey: string;\n  style: object;\n  catalogSourceName: string;\n  catalogSourceNamespace: string;\n  subscription?: SubscriptionKind;\n  defaultNS: string;\n  canSubscribe: boolean;\n};\n\nPackageManifestTableHeader.displayName = 'PackageManifestTableHeader';\nPackageManifestTableRow.displayName = 'PackageManifestTableRow';\nPackageManifestList.displayName = 'PackageManifestList';\n","import * as React from 'react';\nimport { match as RouterMatch } from 'react-router-dom';\nimport { yamlTemplates } from '../models/yaml-templates';\nimport { connectToPlural } from '../kinds';\nimport { AsyncComponent } from './utils/async';\nimport { Firehose, LoadingBox } from './utils';\nimport {\n  K8sKind,\n  apiVersionForModel,\n  referenceForModel,\n  K8sResourceKindReference,\n  K8sResourceKind,\n} from '../module/k8s';\nimport { ErrorPage404 } from './error';\nimport { safeYAMLToJS } from '@console/shared/src/utils/yaml';\n\nexport const CreateYAML = connectToPlural((props: CreateYAMLProps) => {\n  const {\n    match,\n    kindsInFlight,\n    kindObj,\n    hideHeader = false,\n    onChange = () => null,\n    resourceObjPath,\n  } = props;\n  const { params } = match;\n\n  if (!kindObj) {\n    if (kindsInFlight) {\n      return <LoadingBox />;\n    }\n    return <ErrorPage404 />;\n  }\n\n  const namespace = params.ns || 'default';\n  const template =\n    props.template ||\n    yamlTemplates.getIn([referenceForModel(kindObj), 'default']) ||\n    yamlTemplates.getIn(['DEFAULT', 'default']);\n\n  const obj = safeYAMLToJS(template);\n  obj.kind = kindObj.kind;\n  obj.metadata = obj.metadata || {};\n  if (kindObj.namespaced) {\n    obj.metadata.namespace = namespace;\n  }\n  if (kindObj.crd && template === yamlTemplates.getIn(['DEFAULT', 'default'])) {\n    obj.apiVersion = apiVersionForModel(kindObj);\n    obj.spec = obj.spec || {};\n  }\n  const header = `Create ${kindObj.label}`;\n\n  // TODO: if someone edits namespace, we'll redirect to old namespace\n\n  return (\n    <AsyncComponent\n      loader={() => import('./droppable-edit-yaml').then((c) => c.DroppableEditYAML)}\n      obj={obj}\n      create={true}\n      kind={kindObj.kind}\n      header={header}\n      hideHeader={hideHeader}\n      resourceObjPath={resourceObjPath}\n      onChange={onChange}\n    />\n  );\n});\n\nexport const EditYAMLPage: React.SFC<EditYAMLPageProps> = (props) => {\n  const Wrapper = (wrapperProps) => (\n    <AsyncComponent\n      {...wrapperProps}\n      obj={wrapperProps.obj.data}\n      loader={() => import('./edit-yaml').then((c) => c.EditYAML)}\n      create={false}\n    />\n  );\n  return (\n    <Firehose\n      resources={[\n        {\n          kind: props.kind,\n          name: props.match.params.name,\n          namespace: props.match.params.ns,\n          isList: false,\n          prop: 'obj',\n        },\n      ]}\n    >\n      <Wrapper />\n    </Firehose>\n  );\n};\n\nexport type CreateYAMLProps = {\n  match: RouterMatch<{ ns: string; plural: string; appName?: string }>;\n  kindsInFlight: boolean;\n  kindObj: K8sKind;\n  template?: string;\n  download?: boolean;\n  header?: string;\n  hideHeader?: boolean;\n  resourceObjPath?: (obj: K8sResourceKind, kind: K8sResourceKindReference) => string;\n  onChange?: (yaml: string) => any;\n};\n\nexport type EditYAMLPageProps = {\n  match: RouterMatch<{ ns: string; name: string }>;\n  kind: string;\n};\n\nEditYAMLPage.displayName = 'EditYAMLPage';\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAMA;AAYA;AASA;AACA;AACA;AAaA;AACA;AACA;AACA;AAGA;AACA;AAEA;AAKA;AAKA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAIA;AACA;AACA;AAWA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAKA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAUA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAuBA;AAYA;AACA;AACA;AACA;AACA;AAmBA;AASA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAGA;AAEA;AAIA;AAKA;AAEA;AAKA;AAGA;AACA;AACA;AACA;AACA;AAMA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAuDA;AACA;AACA;;;;;;;;;;;;;AC/hBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAOA;AACA;AAEA;AASA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAIA;AAEA;AACA;;AAAA;AACA;AACA;AACA;AAIA;;AAEA;AAEA;AACA;AAOA;AAUA;AAQA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAOA;AACA;AAGA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAMA;AASA;AASA;;;;;;;;;;;;;AC3EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;;AAMA;AACA;AAYA;AAOA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAIA;;AAGA;AAGA;AACA;AAGA;AACA;AACA;AARA;AAQA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;;;AAGA;AACA;AAGA;AACA;AACA;AAIA;AAGA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;AC1KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAOA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAWA;AACA;AACA;AACA;AACA;AAEA;;AAGA;;AAIA;AAIA;AAKA;AAEA;AACA;AAMA;AACA;;AAAA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAOA;AAEA;AAOA;AAGA;AACA;AACA;AACA;AACA;AAIA;AAeA;AACA;AACA;AACA;;AAAA;AAEA;AAUA;AAeA;AAIA;AAGA;AAGA;AACA;AAIA;AAmBA;AAEA;AACA;AAEA;AACA;;AAEA;AACA;AAEA;AAGA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AA+BA;AACA;AACA;;;;;;;;;;;;;AC5SA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAYA;AAEA;AACA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAmBA;;;;;A","sourceRoot":""}