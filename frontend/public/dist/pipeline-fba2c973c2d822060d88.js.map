{"version":3,"file":"pipeline-fba2c973c2d822060d88.js","sources":["webpack:///./public/components/hypercloud/pipeline.tsx","webpack:///./public/components/hypercloud/pipelines/pipeline-row-kebab-actions.tsx","webpack:///./public/components/hypercloud/pipelines/utils/triggers.ts"],"sourcesContent":["import * as _ from 'lodash-es';\nimport * as React from 'react';\nimport * as classNames from 'classnames';\nimport { sortable } from '@patternfly/react-table';\n\nimport { K8sKind } from '../../module/k8s';\nimport { DetailsPage, ListPage, Table, TableRow, TableData, RowFunction } from '../factory';\nimport { Kebab, KebabAction, detailsPage, Timestamp, navFactory, ResourceLink, ResourceSummary, SectionHeading } from '../utils';\nimport { PipelineModel, TaskModel, ClusterTaskModel } from '../../models';\nimport PipelineVisualization from '../../../packages/dev-console/src/components/pipelines/detail-page-tabs/pipeline-details/PipelineVisualization';\nimport DynamicResourceLinkList from '../../../packages/dev-console/src/components/pipelines/resource-overview/DynamicResourceLinkList';\nimport { Pipeline } from './utils/pipeline-augment';\nimport { PipelineForm, PipelineParametersForm, PipelineResourcesForm, parametersValidationSchema, resourcesValidationSchema } from '../../../packages/dev-console/src/components/pipelines/detail-page-tabs';\nimport { addTrigger } from '../../../packages/dev-console/src/utils/pipeline-actions';\nimport { PipelineRunsPage } from './pipeline-run';\nimport PipelineRowKebabActions from './pipelines/pipeline-row-kebab-actions';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { ResourceLabel } from '../../models/hypercloud/resource-plural';\n\nexport const menuActions: KebabAction[] = [addTrigger, ...Kebab.getExtensionsActionsForKind(PipelineModel), ...Kebab.factory.common];\n\nconst kind = PipelineModel.kind;\n\nconst tableColumnClasses = [\n  'col-xs-6 col-sm-4', // name\n  'col-xs-6 col-sm-4', // namespace\n  'col-sm-4 hidden-xs', // created\n  Kebab.columnClass,\n];\n\nconst PipelineTableHeader = (t?: TFunction) => {\n  return [\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_1'),\n      sortField: 'metadata.name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_2'),\n      sortField: 'metadata.namespace',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_12'),\n      sortField: 'metadata.creationTimestamp',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: '',\n      props: { className: tableColumnClasses[3] },\n    },\n  ];\n};\n\nPipelineTableHeader.displayName = 'PipelineTableHeader';\n\nconst PipelineTableRow: RowFunction<Pipeline> = ({ obj: pipeline, index, key, style }) => {\n  return (\n    <TableRow id={pipeline.metadata.uid} index={index} trKey={key} style={style}>\n      <TableData className={tableColumnClasses[0]}>\n        <ResourceLink kind={kind} name={pipeline.metadata?.name} namespace={pipeline.metadata?.namespace} title={pipeline.metadata?.uid} />\n      </TableData>\n      <TableData className={classNames(tableColumnClasses[1], 'co-break-word')}>\n        <ResourceLink kind=\"Namespace\" name={pipeline.metadata?.namespace} title={pipeline.metadata?.namespace} />\n      </TableData>\n      <TableData className={tableColumnClasses[2]}>\n        <Timestamp timestamp={pipeline.metadata.creationTimestamp} />\n      </TableData>\n      <TableData className={tableColumnClasses[3]}>\n        <PipelineRowKebabActions pipeline={pipeline} />\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const getResourceModelFromTaskKind = (kind: string): K8sKind => (kind === ClusterTaskModel.kind ? ClusterTaskModel : TaskModel);\n\nexport const PipelineDetailsList: React.FC<PipelineDetailsListProps> = ({ ds: pipeline }) => {\n  const taskLinks = pipeline.spec.tasks\n    .filter((pipelineTask: PipelineTask) => !!pipelineTask.taskRef)\n    .map(task => ({\n      model: getResourceModelFromTaskKind(task.taskRef.kind),\n      name: task.taskRef.name,\n      displayName: task.name,\n    }));\n\n  return (\n    <dl className=\"co-m-pane__details\">\n      <DynamicResourceLinkList namespace={pipeline.metadata.namespace} links={taskLinks} title=\"Tasks\" />\n    </dl>\n  );\n};\n\n\nconst PipelineDetails: React.FC<PipelineDetailsProps> = ({ obj: pipeline }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', { 0: ResourceLabel(pipeline, t) })} />\n        <PipelineVisualization pipeline={pipeline} />\n        <div className=\"row\">\n          <div className=\"col-lg-6\">\n            <ResourceSummary resource={pipeline} />\n          </div>\n          <div className=\"col-lg-6\">\n            <PipelineDetailsList ds={pipeline} />\n          </div>\n        </div>\n      </div>\n    </>\n  );\n}\n\nconst { details, editYaml } = navFactory;\n\nexport const Pipelines: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Pipelines\" Header={PipelineTableHeader.bind(null, t)} Row={PipelineTableRow} virtualize />\n};\n\nexport const PipelinesPage: React.FC<PipelinesPageProps> = props => {\n  const { t } = useTranslation();\n\n  return <ListPage\n    title={t('COMMON:MSG_LNB_MENU_59')}\n    createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_59') })}\n    canCreate={true}\n    ListComponent={Pipelines}\n    kind={kind}\n    {...props}\n  />;\n}\n\nexport const PipelinesDetailsPage: React.FC<PipelinesDetailsPageProps> = props => (\n  <DetailsPage\n    {...props}\n    kind={kind}\n    menuActions={menuActions}\n    pages={[\n      details(detailsPage(PipelineDetails)),\n      editYaml(),\n      {\n        href: 'runs',\n        name: 'Pipeline Runs',\n        component: pageProps => <PipelineRunsPage showTitle={false} canCreate={false} namespace={pageProps.obj.metadata.namespace} selector={{ 'tekton.dev/pipeline': pageProps.obj.metadata.name, }} />,\n      },\n      {\n        href: 'parameters',\n        name: 'Parameters',\n        component: pageProps => <PipelineForm PipelineFormComponent={PipelineParametersForm} formName=\"parameters\" validationSchema={parametersValidationSchema} obj={pageProps.obj} {...pageProps} />,\n      },\n      {\n        href: 'resources',\n        name: 'Resources',\n        component: pageProps => <PipelineForm PipelineFormComponent={PipelineResourcesForm} formName=\"resources\" validationSchema={resourcesValidationSchema} obj={pageProps.obj} {...pageProps} />,\n      },\n    ]}\n  />\n);\n\ntype PipelineDetailsListProps = {\n  ds: Pipeline;\n};\n\ntype PipelinesPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype PipelineDetailsProps = {\n  obj: Pipeline;\n};\n\ntype PipelinesDetailsPageProps = {\n  match: any;\n};\nexport interface PipelineTaskRef {\n  kind?: string;\n  name: string;\n}\n\nexport interface PipelineTaskParam {\n  name: string;\n  value: any;\n}\nexport interface PipelineTaskResources {\n  inputs?: PipelineTaskResource[];\n  outputs?: PipelineTaskResource[];\n}\nexport interface PipelineTaskResource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport interface PipelineTask {\n  name: string;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n}\n","import * as React from 'react';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { ResourceKebab } from '@console/internal/components/utils';\n//import { ResourceKebabWithUserLabel } from '../pipelineruns/triggered-by';\nimport { getPipelineKebabActions } from '../utils/pipeline-actions';\nimport { Pipeline, PipelineRun } from '../utils/pipeline-augment';\nimport { PipelineModel } from '../../../models';\nimport { usePipelineTriggerTemplateNames } from './utils/triggers';\n\ntype PipelineRowKebabActionsProps = {\n  pipeline: Pipeline;\n  pipelineRun?: PipelineRun;\n};\n\nconst pipelineReference = referenceForModel(PipelineModel);\n\nconst PipelineRowKebabActions: React.FC<PipelineRowKebabActionsProps> = ({ pipeline, pipelineRun }) => {\n  const {\n    metadata: { name, namespace },\n  } = pipeline;\n  const templateNames = usePipelineTriggerTemplateNames(name, namespace) || [];\n\n  return (\n    <ResourceKebab\n      actions={getPipelineKebabActions(pipeline.latestRun ?? pipelineRun, templateNames.length > 0)}\n      kind={pipelineReference}\n      resource={pipeline}\n    />\n  );\n};\n\nexport default PipelineRowKebabActions;\n","import * as React from 'react';\nimport { flatten, mapValues } from 'lodash';\nimport { RouteModel } from '@console/internal/models';\nimport { getRouteWebURL } from '@console/internal/components/routes';\nimport { K8sResourceCommon, referenceForModel, RouteKind } from '@console/internal/module/k8s';\nimport { useK8sGet } from '@console/internal/components/utils/k8s-get-hook';\nimport {\n  useK8sWatchResource,\n  useK8sWatchResources,\n  WatchK8sResource,\n  WatchK8sResources,\n  WatchK8sResults,\n  WatchK8sResultsObject,\n} from '@console/internal/components/utils/k8s-watch-hook';\nimport { EventListenerModel, PipelineRunModel, TriggerTemplateModel } from '../../../../models';\nimport { /*getResourceModelFromBindingKind,*/ PipelineRun } from '../../utils/pipeline-augment';\nimport {\n  EventListenerKind,\n  EventListenerKindTrigger,\n  //TriggerBindingKind,\n  TriggerTemplateKind,\n} from '../resource-types';\n//import { ResourceModelLink } from '../resource-overview/DynamicResourceLinkList';\n\ntype RouteMap = { [generatedName: string]: RouteKind };\ntype TriggerTemplateMapping = { [key: string]: TriggerTemplateKind };\n\nconst getResourceName = (resource: K8sResourceCommon): string => resource.metadata.name;\nconst getEventListenerTemplateNames = (el: EventListenerKind): string[] =>\n  el.spec.triggers.map((elTrigger: EventListenerKindTrigger) => elTrigger.template.name);\nconst getEventListenerGeneratedName = (eventListener: EventListenerKind) =>\n  eventListener.status?.configuration.generatedName;\n\nconst useEventListenerRoutes = (\n  namespace: string,\n  eventListenerResources: EventListenerKind[],\n): RouteMap => {\n  const memoResources: WatchK8sResources<RouteMap> = React.useMemo(() => {\n    return (eventListenerResources || []).map(getEventListenerGeneratedName).reduce(\n      (acc, generatedName) => ({\n        ...acc,\n        [generatedName]: {\n          kind: RouteModel.kind,\n          name: generatedName,\n          namespace,\n          optional: true,\n        } as WatchK8sResource,\n      }),\n      {},\n    );\n  }, [namespace, eventListenerResources]);\n\n  const results: WatchK8sResults<RouteMap> = useK8sWatchResources<RouteMap>(memoResources);\n\n  return mapValues(results, (result: WatchK8sResultsObject<RouteKind>) => result.data);\n};\n\nconst useAllEventListeners = (namespace: string) => {\n  const eventListenerResource: WatchK8sResource = React.useMemo(\n    () => ({\n      kind: referenceForModel(EventListenerModel),\n      isList: true,\n      namespace,\n    }),\n    [namespace],\n  );\n  const [resources, eventListenerLoaded] = useK8sWatchResource<EventListenerKind[]>(\n    eventListenerResource,\n  );\n\n  return eventListenerLoaded ? resources : null;\n};\n\nexport type RouteTemplate = {\n  routeURL: string | null;\n  triggerTemplateName: string;\n};\n\nexport const usePipelineTriggerTemplateNames = (\n  pipelineName: string,\n  namespace: string,\n): RouteTemplate[] | null => {\n  const eventListenerResources = useAllEventListeners(namespace);\n  const triggerTemplateResources: WatchK8sResources<TriggerTemplateMapping> = React.useMemo(() => {\n    if (!eventListenerResources) {\n      return {};\n    }\n    return flatten(eventListenerResources.map(getEventListenerTemplateNames)).reduce(\n      (resourceMap, triggerTemplateName: string) => ({\n        ...resourceMap,\n        [triggerTemplateName]: {\n          kind: referenceForModel(TriggerTemplateModel),\n          name: triggerTemplateName,\n          namespace,\n          optional: true,\n        },\n      }),\n      {},\n    );\n  }, [namespace, eventListenerResources]);\n  const triggerTemplates: WatchK8sResults<TriggerTemplateMapping> = useK8sWatchResources(\n    triggerTemplateResources,\n  );\n  const routes: RouteMap = useEventListenerRoutes(namespace, eventListenerResources);\n\n  const triggerTemplateResults: WatchK8sResultsObject<TriggerTemplateKind>[] = Object.values(\n    triggerTemplates,\n  );\n  const countExpected = Object.keys(triggerTemplateResources).length;\n  const countLoaded = triggerTemplateResults.filter(({ loaded }) => loaded).length;\n  const countErrored = triggerTemplateResults.filter(({ loadError }) => !!loadError).length;\n  if (countLoaded === 0 || countLoaded !== countExpected - countErrored) {\n    return null;\n  }\n  const matchingTriggerTemplateNames: string[] = triggerTemplateResults\n    .filter((resourceWatch) => resourceWatch.loaded)\n    .map((resourceWatch) => resourceWatch.data)\n    .filter((triggerTemplate: TriggerTemplateKind) => {\n      const plr: PipelineRun = triggerTemplate?.spec?.resourcetemplates?.find(\n        ({ kind }) => kind === PipelineRunModel.kind,\n      );\n      return plr?.spec?.pipelineRef?.name === pipelineName;\n    })\n    .map(getResourceName);\n\n  return (eventListenerResources || []).reduce((acc, ev: EventListenerKind) => {\n    const eventListenerTemplateNames = getEventListenerTemplateNames(ev);\n    const generatedRouteName = getEventListenerGeneratedName(ev);\n\n    const triggerTemplateName = matchingTriggerTemplateNames.find((name) =>\n      eventListenerTemplateNames.includes(name),\n    );\n    const route: RouteKind = routes[generatedRouteName];\n\n    if (!triggerTemplateName) {\n      return acc;\n    }\n\n    let routeURL = null;\n    try {\n      if (route) {\n        routeURL = getRouteWebURL(route);\n      }\n    } catch (e) {\n      // swallow errors, we don't care if we can't create a good route right now\n    }\n\n    return [...acc, { routeURL, triggerTemplateName }];\n  }, []);\n};\n\nexport const useEventListenerTriggerTemplateNames = (\n  eventListener: EventListenerKind,\n): RouteTemplate[] | null => {\n  const {\n    metadata: { namespace },\n  } = eventListener;\n\n  const [route, routeLoaded] = useK8sGet<RouteKind>(\n    RouteModel,\n    getEventListenerGeneratedName(eventListener),\n    namespace,\n  );\n  return eventListener.spec.triggers.reduce(\n    (acc, trigger) => [\n      ...acc,\n      {\n        routeURL: route && route?.status?.ingress && routeLoaded ? getRouteWebURL(route) : null,\n        triggerTemplateName: trigger.template.name,\n      },\n    ],\n    [],\n  );\n};\n\n// export const getEventListenerTriggerBindingNames = (\n//   eventListener: EventListenerKind,\n// ): ResourceModelLink[] => {\n//   return eventListener.spec.triggers.reduce(\n//     (acc, trigger) => [\n//       ...acc,\n//       ...trigger.bindings.map((binding) => ({\n//         model: getResourceModelFromBindingKind(binding.kind),\n//         name: binding.name,\n//       })),\n//     ],\n//     [] as ResourceModelLink[],\n//   );\n// };\n\nexport const getTriggerTemplatePipelineName = (triggerTemplate: TriggerTemplateKind): string => {\n  return (\n    triggerTemplate.spec.resourcetemplates.find(({ kind }) => kind === PipelineRunModel.kind)?.spec\n      .pipelineRef.name || ''\n  );\n};\n\nexport const useTriggerTemplateEventListenerNames = (triggerTemplate: TriggerTemplateKind) => {\n  const eventListenerResources = useAllEventListeners(triggerTemplate.metadata.namespace) || [];\n\n  return eventListenerResources\n    .filter((eventListener: EventListenerKind) =>\n      eventListener.spec.triggers.find(\n        ({ template: { name } }) => name === getResourceName(triggerTemplate),\n      ),\n    )\n    .map(getResourceName);\n};\n\n// export const useTriggerBindingEventListenerNames = (triggerBinding: TriggerBindingKind) => {\n//   const eventListenerResources = useAllEventListeners(triggerBinding.metadata.namespace) || [];\n//   return eventListenerResources\n//     .filter((eventListener: EventListenerKind) =>\n//       eventListener.spec.triggers.find(({ bindings }) =>\n//         bindings.find(\n//           ({ kind, name }) =>\n//             getResourceName(triggerBinding) === name &&\n//             getResourceModelFromBindingKind(kind).kind === triggerBinding.kind,\n//         ),\n//       ),\n//     )\n//     .map(getResourceName);\n// };\n"],"mappings":";;;;;;;;;;AACA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAQA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjKA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAEA;;AACA;AAGA;AAEA;AAOA;AAEA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAaA;AACA;AAEA;AAGA;AAIA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AAIA;AACA;AAOA;AAIA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAIA;AACA;AAGA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAIA;AAKA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAIA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}