{"version":3,"file":"delete-revision~dev-console-topology~git-import-form~pipeline~pipeline-builder-edit-page~pipeline-bu~4a2e68d5-27f150ec7666587683b8.js","sources":["webpack:///./packages/dev-console/src/components/charts/HorizontalStackedBars.scss?1886","webpack:///./packages/dev-console/src/components/charts/HorizontalStackedBars.tsx","webpack:///./packages/topology/src/Visualization.ts","webpack:///./packages/topology/src/anchors/AbstractAnchor.ts","webpack:///./packages/topology/src/anchors/CenterAnchor.ts","webpack:///./packages/topology/src/anchors/EllipseAnchor.ts","webpack:///./packages/topology/src/anchors/RectAnchor.ts","webpack:///./packages/topology/src/anchors/SVGAnchor.ts","webpack:///./packages/topology/src/anchors/index.ts","webpack:///./packages/topology/src/behavior/index.ts","webpack:///./packages/topology/src/behavior/useAnchor.tsx","webpack:///./packages/topology/src/behavior/useBendpoint.tsx","webpack:///./packages/topology/src/behavior/useDndDrag.tsx","webpack:///./packages/topology/src/behavior/useDndDrop.tsx","webpack:///./packages/topology/src/behavior/useDndManager.tsx","webpack:///./packages/topology/src/behavior/useDragNode.tsx","webpack:///./packages/topology/src/behavior/usePanZoom.tsx","webpack:///./packages/topology/src/behavior/useReconnect.tsx","webpack:///./packages/topology/src/behavior/useSelection.tsx","webpack:///./packages/topology/src/behavior/useSvgAnchor.tsx","webpack:///./packages/topology/src/behavior/withContextMenu.tsx","webpack:///./packages/topology/src/behavior/withCreateConnector.tsx","webpack:///./packages/topology/src/behavior/withRemoveConnector.tsx","webpack:///./packages/topology/src/components/ConnectorArrow.scss?c60a","webpack:///./packages/topology/src/components/ConnectorArrow.tsx","webpack:///./packages/topology/src/components/DefaultCreateConnector.scss?7f01","webpack:///./packages/topology/src/components/DefaultCreateConnector.tsx","webpack:///./packages/topology/src/components/DefaultRemoveConnector.tsx","webpack:///./packages/topology/src/components/EdgeConnectorArrow.tsx","webpack:///./packages/topology/src/components/ElementWrapper.tsx","webpack:///./packages/topology/src/components/GraphComponent.tsx","webpack:///./packages/topology/src/components/VisualizationSurface.scss?45e2","webpack:///./packages/topology/src/components/VisualizationSurface.tsx","webpack:///./packages/topology/src/components/contextmenu/ContextMenu.scss?12fd","webpack:///./packages/topology/src/components/contextmenu/ContextMenu.tsx","webpack:///./packages/topology/src/components/contextmenu/ContextSubMenuItem.scss?333d","webpack:///./packages/topology/src/components/contextmenu/ContextSubMenuItem.tsx","webpack:///./packages/topology/src/components/contextmenu/index.ts","webpack:///./packages/topology/src/components/defs/SVGDefs.tsx","webpack:///./packages/topology/src/components/defs/SVGDefsContext.ts","webpack:///./packages/topology/src/components/defs/SVGDefsProvider.tsx","webpack:///./packages/topology/src/components/defs/index.ts","webpack:///./packages/topology/src/components/index.ts","webpack:///./packages/topology/src/components/layers/Layer.tsx","webpack:///./packages/topology/src/components/layers/LayerContainer.tsx","webpack:///./packages/topology/src/components/layers/LayersContext.ts","webpack:///./packages/topology/src/components/layers/LayersProvider.tsx","webpack:///./packages/topology/src/components/layers/index.ts","webpack:///./packages/topology/src/const.ts","webpack:///./packages/topology/src/elements/BaseEdge.ts","webpack:///./packages/topology/src/elements/BaseElement.ts","webpack:///./packages/topology/src/elements/BaseGraph.ts","webpack:///./packages/topology/src/elements/BaseNode.ts","webpack:///./packages/topology/src/elements/defaultElementFactory.ts","webpack:///./packages/topology/src/elements/index.ts","webpack:///./packages/topology/src/geom/Dimensions.ts","webpack:///./packages/topology/src/geom/Point.ts","webpack:///./packages/topology/src/geom/Rect.ts","webpack:///./packages/topology/src/geom/index.ts","webpack:///./packages/topology/src/index.ts","webpack:///./packages/topology/src/layouts/BaseLayout.ts","webpack:///./packages/topology/src/layouts/ColaLayout.ts","webpack:///./packages/topology/src/layouts/DagreLayout.ts","webpack:///./packages/topology/src/layouts/ForceLayout.ts","webpack:///./packages/topology/src/layouts/ForceSimulation.ts","webpack:///./packages/topology/src/layouts/index.ts","webpack:///./packages/topology/src/mobx-exports.ts","webpack:///./packages/topology/src/types.ts","webpack:///./packages/topology/src/utils/ControllerContext.ts","webpack:///./packages/topology/src/utils/ElementContext.ts","webpack:///./packages/topology/src/utils/Stateful.ts","webpack:///./packages/topology/src/utils/anchor-utils.ts","webpack:///./packages/topology/src/utils/createAggregateEdges.ts","webpack:///./packages/topology/src/utils/element-utils.ts","webpack:///./packages/topology/src/utils/geom-utils.ts","webpack:///./packages/topology/src/utils/index.ts","webpack:///./packages/topology/src/utils/svg-utils.ts","webpack:///./packages/topology/src/utils/useCallbackRef.ts","webpack:///./packages/topology/src/utils/useCombineRefs.ts","webpack:///./packages/topology/src/utils/useHover.ts","webpack:///./packages/topology/src/utils/useSize.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport classNames from 'classnames';\nimport './HorizontalStackedBars.scss';\n\nexport type StackedValue = {\n  color: string;\n  name: string;\n  size: number;\n};\n\nexport type HorizontalStackedBarsProps = {\n  barGap?: number;\n  height?: number | string;\n  inline?: boolean;\n  values: StackedValue[];\n  width?: number | string;\n};\n\nconst HorizontalStackedBars: React.FC<HorizontalStackedBarsProps> = ({\n  barGap,\n  height,\n  inline,\n  values,\n  width,\n}) => {\n  return (\n    <div\n      className={classNames('odc-horizontal-stacked-bars', { 'is-inline': inline })}\n      style={{ height, width, ['--bar-gap' as any]: barGap && `${barGap}px` }}\n    >\n      <div className=\"odc-horizontal-stacked-bars__bars\">\n        {values.map(({ color, name, size }) => (\n          <div\n            key={name}\n            className=\"odc-horizontal-stacked-bars__data-bar\"\n            style={{\n              background: color,\n              flexGrow: size,\n            }}\n          />\n        ))}\n      </div>\n    </div>\n  );\n};\n\nexport default HorizontalStackedBars;\n","import { ComponentType } from 'react';\nimport { action, observable } from 'mobx';\nimport * as _ from 'lodash';\nimport {\n  Controller,\n  Graph,\n  Edge,\n  Node,\n  ComponentFactory,\n  GraphElement,\n  ElementFactory,\n  ElementModel,\n  isEdge,\n  isNode,\n  Model,\n  EventListener,\n  ModelKind,\n  LayoutFactory,\n  Layout,\n  isGraph,\n} from './types';\nimport defaultElementFactory from './elements/defaultElementFactory';\nimport Stateful from './utils/Stateful';\n\nexport default class Visualization extends Stateful implements Controller {\n  @observable.shallow\n  elements: { [id: string]: GraphElement } = {};\n\n  @observable.ref\n  private graph?: Graph;\n\n  private layoutFactories: LayoutFactory[] = [];\n\n  private componentFactories: ComponentFactory[] = [];\n\n  private elementFactories: ElementFactory[] = [defaultElementFactory];\n\n  private eventListeners: { [type: string]: EventListener[] } = {};\n\n  @observable.shallow\n  private readonly store = {};\n\n  getStore<S = {}>(): S {\n    return this.store as S;\n  }\n\n  @action\n  fromModel(model: Model): void {\n    const oldGraph = this.graph;\n\n    // create elements\n    if (model.graph) {\n      this.graph = this.createElement<Graph>(ModelKind.graph, model.graph);\n    }\n    const validIds: string[] = [];\n\n    const idToElement: { [id: string]: ElementModel } = {};\n\n    model.nodes &&\n      model.nodes.forEach((n) => {\n        idToElement[n.id] = n;\n        this.createElement<Node>(ModelKind.node, n);\n        validIds.push(n.id);\n      });\n\n    model.edges &&\n      model.edges.forEach((e) => {\n        idToElement[e.id] = e;\n        this.createElement<Edge>(ModelKind.edge, e);\n        validIds.push(e.id);\n      });\n\n    // merge data\n    if (model.graph && this.graph) {\n      this.graph.setModel(model.graph);\n    }\n\n    const processed: { [id: string]: boolean } = {};\n\n    // process bottom up\n    const processElement = (element: ElementModel): void => {\n      if (element.children) {\n        element.children.forEach((id) => processElement(idToElement[id]));\n      }\n      if (!processed[element.id]) {\n        processed[element.id] = true;\n        this.elements[element.id].setModel(element);\n      }\n    };\n\n    model.nodes && model.nodes.forEach(processElement);\n    model.edges && model.edges.forEach(processElement);\n\n    // remove all stale elements\n    _.forIn(this.elements, (element) => {\n      if (!isGraph(element) && !validIds.includes(element.getId())) {\n        this.removeElement(element);\n      }\n    });\n\n    if (oldGraph && oldGraph !== this.graph) {\n      this.removeElement(oldGraph);\n    }\n\n    if (this.graph) {\n      this.parentOrphansToGraph(this.graph);\n    }\n  }\n\n  getGraph(): Graph {\n    if (!this.graph) {\n      throw new Error('Graph has not been set.');\n    }\n    return this.graph;\n  }\n\n  @action\n  setGraph(graph: Graph) {\n    if (this.graph !== graph) {\n      if (this.graph) {\n        this.graph.setController(undefined);\n      }\n      this.graph = graph;\n      graph.setController(this);\n      // TODO clean up and populate registries\n    }\n  }\n\n  getElements(): GraphElement[] {\n    return _.values(this.elements);\n  }\n\n  addElement(element: GraphElement): void {\n    if (this.elements[element.getId()]) {\n      throw new Error(`Duplicate element for ID '${element.getId()}`);\n    }\n    element.setController(this);\n    this.elements[element.getId()] = element;\n  }\n\n  removeElement(element: GraphElement): void {\n    if (this.elements[element.getId()]) {\n      element.remove();\n      // unparent all of the element's children such that they can be reparented\n      element\n        .getChildren()\n        .slice()\n        .forEach((child) => child.remove());\n      element.destroy();\n      element.setController(undefined);\n      delete this.elements[element.getId()];\n    }\n  }\n\n  getElementById(id: string): GraphElement | undefined {\n    return this.elements[id];\n  }\n\n  getNodeById(id: string): Node | undefined {\n    const node = this.elements[id];\n    if (node && isNode(node)) {\n      return node;\n    }\n    return undefined;\n  }\n\n  getEdgeById(id: string): Edge | undefined {\n    const edge = this.elements[id];\n    if (edge && isEdge(edge)) {\n      return edge;\n    }\n    return undefined;\n  }\n\n  getComponent(kind: ModelKind, type: string): ComponentType<{ element: GraphElement }> {\n    for (const factory of this.componentFactories) {\n      const component = factory(kind, type);\n      if (component) {\n        return component;\n      }\n    }\n    throw new Error(`Could not find component for: Kind '${kind}', Type '${type}'`);\n  }\n\n  registerLayoutFactory(factory: LayoutFactory) {\n    this.layoutFactories.unshift(factory);\n  }\n\n  getLayout(type: string): Layout | undefined {\n    for (const factory of this.layoutFactories) {\n      const layout = factory(type, this.getGraph());\n      if (layout) {\n        return layout;\n      }\n    }\n    throw new Error(`Could not find layout for type: ${type}`);\n  }\n\n  registerComponentFactory(factory: ComponentFactory) {\n    this.componentFactories.unshift(factory);\n  }\n\n  registerElementFactory(factory: ElementFactory): void {\n    this.elementFactories.unshift(factory);\n  }\n\n  addEventListener<L extends EventListener = EventListener>(type: string, listener: L): Controller {\n    if (!this.eventListeners[type]) {\n      this.eventListeners[type] = [listener];\n    } else {\n      this.eventListeners[type].push(listener);\n    }\n    return this;\n  }\n\n  removeEventListener(type: string, listener: EventListener): Controller {\n    if (!this.eventListeners[type]) {\n      return this;\n    }\n    const listeners = this.eventListeners[type];\n    const l: EventListener[] = [];\n    for (let i = 0, { length } = listeners; i < length; i++) {\n      if (listeners[i] !== listener) {\n        l.push(listeners[i]);\n      }\n    }\n    if (l.length) {\n      this.eventListeners[type] = l;\n    } else {\n      delete this.eventListeners[type];\n    }\n    return this;\n  }\n\n  fireEvent(type: string, ...args: any): void {\n    const listeners = this.eventListeners[type];\n    if (listeners) {\n      for (let i = 0, { length } = listeners; i < length; i++) {\n        listeners[i](...args);\n      }\n    }\n  }\n\n  private createElement<E extends GraphElement>(kind: ModelKind, elementModel: ElementModel): E {\n    const existingElement = this.elements[elementModel.id];\n    if (existingElement) {\n      return existingElement as E;\n    }\n    for (const factory of this.elementFactories) {\n      const element = factory(kind, elementModel.type);\n      if (element) {\n        this.initElement(element, elementModel);\n        // cast to return type\n        return element as E;\n      }\n    }\n    throw new Error(`Could not create element for: ${JSON.stringify(elementModel)}`);\n  }\n\n  private initElement(element: GraphElement, model: ElementModel): void {\n    // set require fields\n    element.setId(model.id);\n    element.setType(model.type);\n    element.setController(this);\n    this.addElement(element);\n  }\n\n  private parentOrphansToGraph(graph: Graph): void {\n    this.getElements().forEach((element: GraphElement) => {\n      if (element !== this.graph && !element.hasParent()) {\n        graph.appendChild(element);\n      }\n    });\n  }\n}\n","import Point from '../geom/Point';\nimport { Anchor, Node } from '../types';\n\nexport default abstract class AbstractAnchor<E extends Node = Node> implements Anchor {\n  protected readonly owner: E;\n\n  // Consumption of the offset depends on the concrete anchor implementation but it is\n  // indended that the reference point is moved by the offset relative to the point location\n  // in the direction of the opposing reference point.\n  protected readonly offset: number;\n\n  constructor(owner: E, offset: number = 0) {\n    this.owner = owner;\n    this.offset = offset;\n  }\n\n  abstract getLocation(reference: Point): Point;\n\n  getReferencePoint(): Point {\n    return this.owner\n      .getBounds()\n      .getCenter()\n      .translate(this.offset, this.offset);\n  }\n}\n","import Point from '../geom/Point';\nimport AbstractAnchor from './AbstractAnchor';\nimport { getEllipseAnchorPoint } from '../utils/anchor-utils';\n\nexport default class CenterAnchor extends AbstractAnchor {\n  getLocation(reference: Point): Point {\n    const bounds = this.owner.getBounds();\n    if (this.offset === 0) {\n      return bounds.getCenter();\n    }\n    const offset2x = this.offset * 2;\n    return getEllipseAnchorPoint(bounds.getCenter(), offset2x, offset2x, reference);\n  }\n}\n","import Point from '../geom/Point';\nimport { getEllipseAnchorPoint } from '../utils/anchor-utils';\nimport AbstractAnchor from './AbstractAnchor';\n\nexport default class EllipseAnchor extends AbstractAnchor {\n  getLocation(reference: Point): Point {\n    const r = this.owner.getBounds();\n    if (r.isEmpty()) {\n      return r.getCenter();\n    }\n\n    const offset2x = this.offset * 2;\n    return getEllipseAnchorPoint(r.getCenter(), r.width + offset2x, r.height + offset2x, reference);\n  }\n}\n","import Point from '../geom/Point';\nimport { getRectAnchorPoint } from '../utils/anchor-utils';\nimport AbstractAnchor from './AbstractAnchor';\n\nexport default class RectAnchor extends AbstractAnchor {\n  getLocation(reference: Point): Point {\n    const r = this.owner.getBounds();\n    const center = r.getCenter();\n    if (r.isEmpty()) {\n      return center;\n    }\n\n    const offset2x = this.offset * 2;\n    return getRectAnchorPoint(center, r.width + offset2x, r.height + offset2x, reference);\n  }\n}\n","import { observable } from 'mobx';\nimport Point from '../geom/Point';\nimport {\n  getEllipseAnchorPoint,\n  getPathAnchorPoint,\n  getPolygonAnchorPoint,\n  getRectAnchorPoint,\n} from '../utils/anchor-utils';\nimport AbstractAnchor from './AbstractAnchor';\n\nexport default class SVGAnchor extends AbstractAnchor {\n  @observable.ref\n  private svgElement?: SVGElement;\n\n  setSVGElement(svgElement: SVGElement) {\n    this.svgElement = svgElement;\n  }\n\n  private getCircleLocation(circle: SVGCircleElement, reference: Point): Point {\n    const center: Point = new Point(circle.cx.baseVal.value, circle.cy.baseVal.value);\n    this.owner.translateToParent(center);\n    const diameter = circle.r.baseVal.value * 2 + this.offset * 2;\n\n    return getEllipseAnchorPoint(center, diameter, diameter, reference);\n  }\n\n  private getEllipseLocation(ellipse: SVGEllipseElement, reference: Point): Point {\n    const center: Point = new Point(ellipse.cx.baseVal.value, ellipse.cy.baseVal.value);\n    this.owner.translateToParent(center);\n    const offset2x = this.offset * 2;\n    const width = ellipse.rx.baseVal.value * 2 + offset2x;\n    const height = ellipse.ry.baseVal.value * 2 + offset2x;\n\n    return getEllipseAnchorPoint(center, width, height, reference);\n  }\n\n  private getRectLocation(rect: SVGRectElement, reference: Point): Point {\n    const width = rect.width.baseVal.value;\n    const height = rect.height.baseVal.value;\n\n    const center: Point = new Point(\n      rect.x.baseVal.value + width / 2,\n      rect.y.baseVal.value + height / 2,\n    );\n    this.owner.translateToParent(center);\n\n    const offset2x = this.offset * 2;\n    return getRectAnchorPoint(center, width + offset2x, height + offset2x, reference);\n  }\n\n  private getPathLocation(path: SVGPathElement, reference: Point): Point {\n    const translatedRef = reference.clone();\n    this.owner.translateFromParent(translatedRef);\n    const anchorPoint = getPathAnchorPoint(path, translatedRef);\n    this.owner.translateToParent(anchorPoint);\n    return anchorPoint;\n  }\n\n  private getPolygonLocation(polygon: SVGPolygonElement, reference: Point): Point {\n    const translatedRef = reference.clone();\n    this.owner.translateFromParent(translatedRef);\n    const anchorPoint = getPolygonAnchorPoint(polygon, translatedRef);\n    this.owner.translateToParent(anchorPoint);\n    return anchorPoint;\n  }\n\n  getLocation(reference: Point): Point {\n    if (this.svgElement?.viewportElement) {\n      if (this.svgElement instanceof SVGCircleElement) {\n        return this.getCircleLocation(this.svgElement, reference);\n      }\n\n      if (this.svgElement instanceof SVGEllipseElement) {\n        return this.getEllipseLocation(this.svgElement, reference);\n      }\n\n      if (this.svgElement instanceof SVGRectElement) {\n        return this.getRectLocation(this.svgElement, reference);\n      }\n\n      if (this.svgElement instanceof SVGPathElement) {\n        return this.getPathLocation(this.svgElement, reference);\n      }\n\n      if (this.svgElement instanceof SVGPolygonElement) {\n        return this.getPolygonLocation(this.svgElement, reference);\n      }\n    }\n\n    return this.owner.getBounds().getCenter();\n  }\n\n  getReferencePoint(): Point {\n    if (\n      this.svgElement?.viewportElement &&\n      (this.svgElement instanceof SVGCircleElement ||\n        this.svgElement instanceof SVGEllipseElement ||\n        this.svgElement instanceof SVGRectElement ||\n        this.svgElement instanceof SVGPathElement ||\n        this.svgElement instanceof SVGPolygonElement)\n    ) {\n      const bbox = this.svgElement.getBBox();\n      const ref = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height / 2);\n\n      // this touches the bounds for non-groups\n      this.owner.translateToParent(ref);\n\n      // touch the bounds to force a re-render in case this anchor is for a group\n      this.owner.getBounds();\n\n      return ref;\n    }\n\n    return super.getReferencePoint();\n  }\n}\n","export { default as AbstractAnchor } from './AbstractAnchor';\nexport { default as CenterAnchor } from './CenterAnchor';\nexport { default as EllipseAnchor } from './EllipseAnchor';\nexport { default as RectAnchor } from './RectAnchor';\nexport { default as SVGAnchor } from './SVGAnchor';\n","export * from './dnd-types';\nexport * from './useAnchor';\nexport * from './useBendpoint';\nexport * from './useDndDrag';\nexport * from './useDndDrop';\nexport * from './useDndManager';\nexport * from './useDragNode';\nexport * from './usePanZoom';\nexport * from './useReconnect';\nexport * from './useSelection';\nexport * from './useSvgAnchor';\nexport * from './withContextMenu';\nexport * from './withCreateConnector';\nexport * from './withRemoveConnector';\n","import * as React from 'react';\nimport { action } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { isNode, Anchor, Node, AnchorEnd } from '../types';\nimport ElementContext from '../utils/ElementContext';\n\ntype AnchorConstructor = new (element?: Node) => Anchor;\n\nexport const useAnchor = (\n  anchorCallback: ((element: Node) => Anchor | undefined) | AnchorConstructor,\n  end: AnchorEnd = AnchorEnd.both,\n  type?: string,\n): void => {\n  const element = React.useContext(ElementContext);\n  if (!isNode(element)) {\n    throw new Error('useAnchor must be used within the scope of a Node');\n  }\n  React.useEffect(() => {\n    action(() => {\n      const anchor = anchorCallback.prototype\n        ? new (anchorCallback as any)(element)\n        : (anchorCallback as any)(element);\n      if (anchor) {\n        element.setAnchor(anchor, end, type);\n      }\n    })();\n  }, [anchorCallback, element, end, type]);\n};\n\nexport const withAnchor = <P extends {} = {}>(anchor: Anchor, end?: AnchorEnd, type?: string) => (\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<P> = (props) => {\n    useAnchor(\n      React.useCallback(() => anchor, []),\n      end,\n      type,\n    );\n    return <WrappedComponent {...props} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { action } from 'mobx';\nimport * as d3 from 'd3';\nimport { observer } from 'mobx-react';\nimport Point from '../geom/Point';\nimport ElementContext from '../utils/ElementContext';\nimport { isEdge } from '../types';\nimport {\n  ConnectDragSource,\n  DragSourceSpec,\n  DragObjectWithType,\n  DragSpecOperationType,\n  DragOperationWithType,\n} from './dnd-types';\nimport { useDndDrag, WithDndDragProps } from './useDndDrag';\n\nexport type WithBendpoint = {\n  sourceDragRef: ConnectDragSource;\n};\n\nexport const useBendpoint = <DropResult, CollectedProps, Props = {}>(\n  point: Point,\n  spec?: Omit<\n    DragSourceSpec<\n      DragObjectWithType,\n      DragSpecOperationType<DragOperationWithType>,\n      DropResult,\n      CollectedProps\n    >,\n    'type'\n  >,\n  props?: Props,\n): [CollectedProps, ConnectDragSource] => {\n  const element = React.useContext(ElementContext);\n  if (!isEdge(element)) {\n    throw new Error('useBendpoint must be used within the scope of an Edge');\n  }\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n  const pointRef = React.useRef(point);\n  pointRef.current = point;\n\n  const [connect, dragRef] = useDndDrag(\n    React.useMemo(() => {\n      const sourceSpec: DragSourceSpec<any, any, any, any, Props> = {\n        item: { type: '#useBendpoint#' },\n        begin: (monitor, p) => {\n          return spec && spec.begin ? spec.begin(monitor, p) : undefined;\n        },\n        drag: (event, monitor, p) => {\n          // assumes the edge is in absolute coordinate space\n          pointRef.current.translate(event.dx, event.dy);\n          elementRef.current.raise();\n          spec && spec.drag && spec.drag(event, monitor, p);\n        },\n        canDrag: spec ? spec.canDrag : undefined,\n        end: spec ? spec.end : undefined,\n        collect: spec ? spec.collect : undefined,\n      };\n      return sourceSpec;\n    }, [spec]),\n    props,\n  );\n\n  // argh react events don't play nice with d3 pan zoom double click event\n  const ref = React.useCallback(\n    (node) => {\n      d3.select(node).on(\n        'click',\n        action(() => {\n          if (d3.event.shiftKey) {\n            d3.event.stopPropagation();\n            elementRef.current.removeBendpoint(pointRef.current);\n          }\n        }),\n      );\n      dragRef(node);\n    },\n    [dragRef],\n  );\n  return [connect, ref];\n};\n\ntype HocProps = {\n  point: Point;\n};\n\nexport type WithBendpointProps = {\n  dragNodeRef: WithDndDragProps['dndDragRef'];\n};\n\nexport const WithBendpoint = <DropResult, CollectedProps, Props = {}>(\n  spec?: Omit<\n    DragSourceSpec<\n      DragObjectWithType,\n      DragSpecOperationType<DragOperationWithType>,\n      DropResult,\n      CollectedProps,\n      Props\n    >,\n    'type'\n  >,\n) => <P extends WithBendpointProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithBendpointProps> & HocProps> = (props) => {\n    const [dragProps, bendpointRef] = useBendpoint(props.point, spec, props);\n    return <WrappedComponent {...(props as any)} bendpointRef={bendpointRef} {...dragProps} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport * as d3 from 'd3';\nimport { action, computed, comparer, flow } from 'mobx';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport useCallbackRef from '../utils/useCallbackRef';\nimport {\n  DragSourceSpec,\n  ConnectDragSource,\n  DragObjectWithType,\n  DragSourceMonitor,\n  Identifier,\n  DragEvent,\n  DragSpecOperationType,\n  DragSource,\n  DragOperationWithType,\n} from './dnd-types';\nimport { useDndManager } from './useDndManager';\n\nexport const Modifiers = {\n  DEFAULT: 0,\n  ALT: 0x01,\n  CTRL: 0x02,\n  META: 0x04,\n  SHIFT: 0x08,\n};\n\nconst getModifiers = (event: MouseEvent | TouchEvent | KeyboardEvent): number => {\n  let modifiers = Modifiers.DEFAULT;\n  if (event.altKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.ALT;\n  }\n  if (event.ctrlKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.CTRL;\n  }\n  if (event.metaKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.META;\n  }\n  if (event.shiftKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.SHIFT;\n  }\n  return modifiers;\n};\n\nconst getOperation = (\n  operation: DragSpecOperationType<DragOperationWithType> | undefined,\n): DragOperationWithType | undefined => {\n  if (!operation) {\n    return undefined;\n  }\n  if (operation.hasOwnProperty('type')) {\n    return operation as DragOperationWithType;\n  }\n  return (\n    operation[getModifiers((d3.event && d3.event.sourceEvent) || d3.event)] ||\n    operation[Modifiers.DEFAULT]\n  );\n};\n\nconst hasOperation = (\n  operation: DragSpecOperationType<DragOperationWithType> | undefined,\n): boolean => {\n  return !!(operation && (operation.hasOwnProperty('type') || Object.keys(operation).length > 0));\n};\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport const useDndDrag = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DragSourceSpec<\n    DragObject,\n    DragSpecOperationType<DragOperationWithType>,\n    DropResult,\n    CollectedProps,\n    Props\n  >,\n  props?: Props,\n): [CollectedProps, ConnectDragSource] => {\n  const specRef = React.useRef(spec);\n  specRef.current = spec;\n\n  const propsRef = React.useRef<Props>(props != null ? props : (EMPTY_PROPS as Props));\n  propsRef.current = props != null ? props : (EMPTY_PROPS as Props);\n\n  const dndManager = useDndManager();\n\n  const element = React.useContext(ElementContext);\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  const idRef = React.useRef<string>();\n\n  // source monitor\n  const monitor = React.useMemo(() => {\n    const sourceMonitor: DragSourceMonitor = {\n      getHandlerId: (): string | undefined => {\n        return idRef.current;\n      },\n      receiveHandlerId: (sourceId: string | undefined): void => {\n        idRef.current = sourceId;\n      },\n      getDropHints: (): string[] => {\n        return dndManager.getDropHints();\n      },\n      canDrag: (): boolean => {\n        return dndManager.canDragSource(idRef.current);\n      },\n      isDragging: (): boolean => {\n        return dndManager.isDraggingSource(idRef.current);\n      },\n      getItemType: (): Identifier | undefined => {\n        return dndManager.getItemType();\n      },\n      getItem: (): any => {\n        return dndManager.getItem();\n      },\n      getDropResult: (): any => {\n        return dndManager.getDropResult();\n      },\n      didDrop: (): boolean => {\n        return dndManager.didDrop();\n      },\n      getDragEvent: (): DragEvent | undefined => {\n        return dndManager.getDragEvent();\n      },\n      getOperation: (): DragOperationWithType | undefined => {\n        return dndManager.getOperation();\n      },\n      isCancelled: (): boolean => {\n        return dndManager.isCancelled();\n      },\n    };\n    return sourceMonitor;\n  }, [dndManager]);\n\n  const refCallback = useCallbackRef(\n    React.useCallback(\n      (node: SVGElement | null) => {\n        if (node) {\n          let operationChangeEvents:\n            | {\n                begin: [number, number, number, number];\n                drag: [number, number, number, number];\n              }\n            | undefined;\n          let operation: DragSpecOperationType<DragOperationWithType> | undefined;\n          d3.select(node).call(\n            d3\n              .drag()\n              .container(\n                // TODO bridge the gap between scene tree and dom tree\n                () =>\n                  d3\n                    .select(node.ownerSVGElement)\n                    .select('[data-surface=\"true\"]')\n                    .node() as any,\n              )\n              .on('start', function() {\n                operation =\n                  typeof specRef.current.operation === 'function'\n                    ? specRef.current.operation(monitor, propsRef.current)\n                    : specRef.current.operation;\n                const updateOperation = async () => {\n                  if (operation && idRef.current) {\n                    const op = getOperation(operation);\n                    if (dndManager.getOperation() !== op) {\n                      // restart the drag with the new operation\n                      if (dndManager.isDragging()) {\n                        // copy the event otherwise it will be mutated by #cancel()\n                        const event = { ...(dndManager.getDragEvent() as DragEvent) };\n                        const cancelled = dndManager.cancel();\n                        operationChangeEvents = {\n                          begin: [\n                            cancelled ? event.initialX : event.x,\n                            cancelled ? event.initialY : event.y,\n                            cancelled ? event.initialPageX : event.pageX,\n                            cancelled ? event.initialPageY : event.pageY,\n                          ],\n                          drag: [event.x, event.y, event.pageX, event.pageY],\n                        };\n                        await dndManager.endDrag();\n                      }\n                      if (op && operationChangeEvents) {\n                        dndManager.beginDrag(idRef.current, op, ...operationChangeEvents.begin);\n                        dndManager.drag(...operationChangeEvents.drag);\n                        operationChangeEvents = undefined;\n                      }\n                    }\n                  }\n                };\n                d3.select(node.ownerDocument)\n                  .on(\n                    'keydown.useDndDrag',\n                    flow(function*() {\n                      const e = d3.event as KeyboardEvent;\n                      if (e.key === 'Escape') {\n                        if (dndManager.isDragging() && dndManager.cancel()) {\n                          operationChangeEvents = undefined;\n                          d3.select(d3.event.view).on('.drag', null);\n                          d3.select(node.ownerDocument).on('.useDndDrag', null);\n                          yield dndManager.endDrag();\n                        }\n                      } else {\n                        yield updateOperation();\n                      }\n                    }),\n                  )\n                  .on(\n                    'keyup.useDndDrag',\n                    flow(function*() {\n                      yield updateOperation();\n                    }),\n                  );\n              })\n              .on(\n                'drag',\n                action(() => {\n                  const { pageX, pageY } = d3.event.sourceEvent;\n                  const { x, y } = d3.event;\n                  if (dndManager.isDragging()) {\n                    dndManager.drag(x, y, pageX, pageY);\n                  } else if (operationChangeEvents) {\n                    operationChangeEvents.drag = [x, y, pageX, pageY];\n                  } else {\n                    const op = getOperation(operation);\n                    if (op || !hasOperation(operation)) {\n                      if (idRef.current) {\n                        dndManager.beginDrag(idRef.current, op, x, y, pageX, pageY);\n                      }\n                    } else {\n                      operationChangeEvents = {\n                        begin: [x, y, pageX, pageY],\n                        drag: [x, y, pageX, pageY],\n                      };\n                    }\n                  }\n                }),\n              )\n              .on(\n                'end',\n                flow(function*() {\n                  operationChangeEvents = undefined;\n                  operation = undefined;\n                  d3.select(node.ownerDocument).on('.useDndDrag', null);\n                  if (dndManager.isDragging()) {\n                    dndManager.drop();\n                    yield dndManager.endDrag();\n                  }\n                }),\n              )\n              .filter(\n                () =>\n                  !d3.event.ctrlKey && !d3.event.button && dndManager.canDragSource(idRef.current),\n              ),\n          );\n        }\n        return () => {\n          node && d3.select(node).on('mousedown.drag', null);\n        };\n      },\n      [dndManager, monitor],\n    ),\n  );\n\n  React.useEffect(() => {\n    const dragSource: DragSource = {\n      type: spec.item.type,\n      canCancel: () =>\n        typeof specRef.current.canCancel === 'boolean'\n          ? specRef.current.canCancel\n          : typeof specRef.current.canCancel === 'function'\n          ? specRef.current.canCancel(monitor, propsRef.current)\n          : true,\n      canDrag: () =>\n        typeof specRef.current.canDrag === 'boolean'\n          ? specRef.current.canDrag\n          : typeof specRef.current.canDrag === 'function'\n          ? specRef.current.canDrag(monitor, propsRef.current)\n          : true,\n      beginDrag: () =>\n        specRef.current.begin ? specRef.current.begin(monitor, propsRef.current) : undefined,\n      drag: () => {\n        if (specRef.current.drag) {\n          const event = monitor.getDragEvent();\n          if (event) {\n            specRef.current.drag(event, monitor, propsRef.current);\n          }\n        }\n      },\n      endDrag: () =>\n        specRef.current.end\n          ? specRef.current.end(monitor.getDropResult(), monitor, propsRef.current)\n          : undefined,\n    };\n    const [sourceId, unregister] = dndManager.registerSource(dragSource);\n    monitor.receiveHandlerId(sourceId);\n    return unregister;\n  }, [spec.item.type, dndManager, monitor]);\n\n  const collected = React.useMemo(\n    () =>\n      computed(\n        () =>\n          spec.collect ? spec.collect(monitor, propsRef.current) : (({} as any) as CollectedProps),\n        { equals: comparer.shallow },\n      ),\n    [monitor, spec],\n  );\n\n  return [collected.get(), refCallback];\n};\n\nexport type WithDndDragProps = {\n  dndDragRef: ConnectDragSource;\n};\n\nexport const withDndDrag = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DragSourceSpec<\n    DragObject,\n    DragSpecOperationType<DragOperationWithType>,\n    DropResult,\n    CollectedProps,\n    Props\n  >,\n) => <P extends WithDndDragProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithDndDragProps & CollectedProps>> = (props) => {\n    // TODO fix cast to any\n    const [dndDragProps, dndDragRef] = useDndDrag(spec, props as any);\n    return <WrappedComponent {...(props as any)} {...dndDragProps} dndDragRef={dndDragRef} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport * as d3 from 'd3';\nimport { observer } from 'mobx-react';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { pointInSvgPath } from 'point-in-svg-path';\nimport { comparer, computed } from 'mobx';\nimport ElementContext from '../utils/ElementContext';\nimport Point from '../geom/Point';\nimport { GraphElement } from '../types';\nimport {\n  ConnectDropTarget,\n  DropTargetSpec,\n  DropTargetMonitor,\n  Identifier,\n  DragEvent,\n  DropTarget,\n  DragOperationWithType,\n} from './dnd-types';\nimport { useDndManager } from './useDndManager';\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport const useDndDrop = <\n  DragObject,\n  DropResult = GraphElement,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DropTargetSpec<DragObject, DropResult, CollectedProps, Props>,\n  props?: Props,\n): [CollectedProps, ConnectDropTarget] => {\n  const specRef = React.useRef(spec);\n  specRef.current = spec;\n\n  const propsRef = React.useRef(props != null ? props : (EMPTY_PROPS as Props));\n  propsRef.current = props != null ? props : (EMPTY_PROPS as Props);\n\n  const dndManager = useDndManager();\n\n  const nodeRef = React.useRef<SVGElement | null>(null);\n  const idRef = React.useRef<string>();\n\n  const monitor = React.useMemo((): DropTargetMonitor => {\n    const targetMonitor: DropTargetMonitor = {\n      getHandlerId: (): string | undefined => {\n        return idRef.current;\n      },\n      receiveHandlerId: (sourceId: string | undefined): void => {\n        idRef.current = sourceId;\n      },\n      canDrop: (): boolean => {\n        return dndManager.canDropOnTarget(idRef.current);\n      },\n      isDragging: (): boolean => {\n        return dndManager.isDragging();\n      },\n      hasDropTarget: (): boolean => {\n        return dndManager.hasDropTarget();\n      },\n      getDropHints: (): string[] => {\n        return dndManager.getDropHints();\n      },\n      isOver(options?: { shallow?: boolean }): boolean {\n        return dndManager.isOverTarget(idRef.current, options);\n      },\n      getItemType: (): Identifier | undefined => {\n        return dndManager.getItemType();\n      },\n      getItem: (): any => {\n        return dndManager.getItem();\n      },\n      getDropResult: (): any => {\n        return dndManager.getDropResult();\n      },\n      didDrop: (): boolean => {\n        return dndManager.didDrop();\n      },\n      getDragEvent: (): DragEvent | undefined => {\n        return dndManager.getDragEvent();\n      },\n      getOperation: (): DragOperationWithType | undefined => {\n        return dndManager.getOperation();\n      },\n      isCancelled: (): boolean => {\n        return dndManager.isCancelled();\n      },\n    };\n    return targetMonitor;\n  }, [dndManager]);\n\n  const element = React.useContext(ElementContext);\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  React.useEffect(() => {\n    const dropTarget: DropTarget = {\n      type: spec.accept,\n      dropHint: () => {\n        return typeof specRef.current.dropHint === 'string'\n          ? specRef.current.dropHint\n          : typeof specRef.current.dropHint === 'function'\n          ? specRef.current.dropHint(monitor.getItem(), monitor, propsRef.current)\n          : elementRef.current.getType();\n      },\n      hitTest: (x: number, y: number) => {\n        if (specRef.current.hitTest) {\n          return specRef.current.hitTest(x, y, propsRef.current);\n        }\n        if (nodeRef.current) {\n          if (!(nodeRef.current instanceof SVGGraphicsElement)) {\n            return false;\n          }\n\n          // Rounding the coordinates due to an issue with `point-in-svg-path` returning false\n          // when the coordinates clearly are within the path.\n          const point = Point.singleUse(Math.round(x), Math.round(y));\n          // Translate to this element's coordinates.\n          // Assumes the node is not within an svg element containing another transform.\n          elementRef.current.translateFromAbsolute(point);\n\n          // perform a fast bounds check\n          const { x: bboxx, y: bboxy, width, height } = nodeRef.current.getBBox();\n          if (\n            point.x < bboxx ||\n            point.x > bboxx + width ||\n            point.y < bboxy ||\n            point.y > bboxy + height\n          ) {\n            return false;\n          }\n\n          if (nodeRef.current instanceof SVGPathElement) {\n            const d = nodeRef.current.getAttribute('d');\n            return pointInSvgPath(d, point.x, point.y);\n          }\n          if (nodeRef.current instanceof SVGCircleElement) {\n            const { cx, cy, r } = nodeRef.current;\n            return (\n              Math.sqrt((point.x - cx.animVal.value) ** 2 + (point.y - cy.animVal.value) ** 2) <\n              r.animVal.value\n            );\n          }\n          if (nodeRef.current instanceof SVGEllipseElement) {\n            const { cx, cy, rx, ry } = nodeRef.current;\n            return (\n              (point.x - cx.animVal.value) ** 2 / rx.animVal.value ** 2 +\n                (point.y - cy.animVal.value) ** 2 / ry.animVal.value ** 2 <=\n              1\n            );\n          }\n          if (nodeRef.current instanceof SVGPolygonElement) {\n            const arr = (nodeRef.current.getAttribute('points') || '')\n              .replace(/,/g, ' ')\n              .split(' ')\n              .map((s) => +s);\n            const points: [number, number][] = [];\n            for (let i = 0; i < arr.length; i += 2) {\n              points.push(arr.slice(i, i + 2) as [number, number]);\n            }\n            return d3.polygonContains(points, [point.x, point.y]);\n          }\n          // TODO support round rect\n\n          // already passed the bbox test\n          return true;\n        }\n        return false;\n      },\n      hover: () => {\n        specRef.current.hover &&\n          specRef.current.hover(monitor.getItem(), monitor, propsRef.current);\n      },\n      canDrop: () =>\n        typeof specRef.current.canDrop === 'boolean'\n          ? specRef.current.canDrop\n          : typeof specRef.current.canDrop === 'function'\n          ? specRef.current.canDrop(monitor.getItem(), monitor, propsRef.current)\n          : true,\n      drop: () =>\n        specRef.current.drop\n          ? specRef.current.drop(monitor.getItem(), monitor, propsRef.current)\n          : !monitor.didDrop()\n          ? elementRef.current\n          : undefined,\n    };\n    const [targetId, unregister] = dndManager.registerTarget(dropTarget);\n    monitor.receiveHandlerId(targetId);\n    return unregister;\n  }, [spec.accept, dndManager, monitor]);\n\n  const collected = React.useMemo(\n    () =>\n      computed(\n        () =>\n          spec.collect ? spec.collect(monitor, propsRef.current) : (({} as any) as CollectedProps),\n        { equals: comparer.shallow },\n      ),\n    [monitor, spec],\n  );\n\n  return [collected.get(), nodeRef as any];\n};\n\nexport type WithDndDropProps = {\n  dndDropRef: ConnectDropTarget;\n};\n\nexport const withDndDrop = <\n  DragObject,\n  DropResult = GraphElement,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DropTargetSpec<DragObject, DropResult, CollectedProps, Props>,\n) => <P extends WithDndDropProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithDndDropProps & CollectedProps>> = (props) => {\n    // TODO fix cast to any\n    const [dndDropProps, dndDropRef] = useDndDrop(spec, props as any);\n    return <WrappedComponent {...(props as any)} {...dndDropProps} dndDropRef={dndDropRef} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { computed, observable } from 'mobx';\nimport ControllerContext from '../utils/ControllerContext';\nimport {\n  DndManager,\n  Identifier,\n  DropTarget,\n  DragEvent,\n  DndStore,\n  DragSource,\n  Unregister,\n  DndState,\n  DndStateContainer,\n  DragOperationWithType,\n} from './dnd-types';\n\nlet nextUniqueId = 0;\n\nconst getNextUniqueId = (): number => {\n  return nextUniqueId++;\n};\n\nexport const matchesType = (\n  targetType: Identifier | Identifier[] | undefined,\n  draggedItemType: Identifier | undefined,\n): boolean => {\n  if (draggedItemType === null) {\n    return targetType === null;\n  }\n  return Array.isArray(targetType)\n    ? targetType.some((t) => t === draggedItemType)\n    : targetType === draggedItemType;\n};\n\nexport class DndManagerImpl implements DndManager {\n  private state: DndState;\n\n  constructor(state: DndState) {\n    this.state = state;\n  }\n\n  // TODO are these really required to be observable?\n  @observable.shallow\n  private sources: { [key: string]: DragSource } = {};\n\n  @observable.shallow\n  private targets: { [key: string]: DropTarget } = {};\n\n  @computed\n  get dropHints(): string[] {\n    return this.state.targetIds\n      ? (this.state.targetIds\n          .map((id) => {\n            const target = this.getTarget(id);\n            return target ? target.dropHint(this) : [];\n          })\n          .filter((x) => x) as string[])\n      : [];\n  }\n\n  registerSource(source: DragSource): [string, Unregister] {\n    const key = `S${getNextUniqueId()}`;\n    this.sources[key] = source;\n    return [\n      key,\n      () => {\n        delete this.sources[key];\n      },\n    ];\n  }\n\n  registerTarget(target: DropTarget): [string, Unregister] {\n    const key = `T${getNextUniqueId()}`;\n    this.targets[key] = target;\n    return [\n      key,\n      () => {\n        delete this.targets[key];\n      },\n    ];\n  }\n\n  getDropHints(): string[] {\n    return this.dropHints;\n  }\n\n  canDragSource(sourceId: string | undefined): boolean {\n    const source = this.getSource(sourceId);\n    if (!source || this.isDragging()) {\n      return false;\n    }\n    return source && source.canDrag(this);\n  }\n\n  canDropOnTarget(targetId: string | undefined): boolean {\n    const target = this.getTarget(targetId);\n    if (!target || !this.isDragging() || this.didDrop()) {\n      return false;\n    }\n\n    const draggedItemType = this.getItemType();\n    return matchesType(target.type, draggedItemType) && target.canDrop(this);\n  }\n\n  isDragging(): boolean {\n    return !!this.state.isDragging;\n  }\n\n  isDraggingSource(sourceId: string | undefined): boolean {\n    return this.state.sourceId != null && this.state.sourceId === sourceId;\n  }\n\n  isOverTarget(targetId: string | undefined, options = { shallow: false }): boolean {\n    if (!targetId) {\n      return false;\n    }\n\n    const { shallow } = options;\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    const target = this.targets[targetId];\n    const draggedItemType = this.getItemType();\n    if (draggedItemType && !matchesType(target.type, draggedItemType)) {\n      return false;\n    }\n\n    const targetIds = this.getTargetIds();\n    if (!targetIds.length) {\n      return false;\n    }\n\n    const index = targetIds.indexOf(targetId);\n    if (shallow) {\n      return index === targetIds.length - 1;\n    }\n    return index > -1;\n  }\n\n  getItemType(): Identifier | undefined {\n    return this.state.itemType;\n  }\n\n  getItem(): any {\n    return this.state.item;\n  }\n\n  getSourceId(): string | undefined {\n    return this.state.sourceId;\n  }\n\n  getTargetIds(): string[] {\n    return this.state.targetIds || [];\n  }\n\n  hasDropTarget(): boolean {\n    return !!this.getTargetIds().find((id) => this.canDropOnTarget(id));\n  }\n\n  getDropResult(): any {\n    return this.state.dropResult;\n  }\n\n  didDrop(): boolean {\n    return !!this.state.didDrop;\n  }\n\n  getDragEvent(): DragEvent | undefined {\n    return this.state.event;\n  }\n\n  getOperation(): DragOperationWithType | undefined {\n    return this.state.operation;\n  }\n\n  isCancelled(): boolean {\n    return !!this.state.cancelled;\n  }\n\n  beginDrag(\n    sourceIds: string | string[],\n    operation: DragOperationWithType | undefined,\n    x: number,\n    y: number,\n    pageX: number,\n    pageY: number,\n  ): void {\n    const ids = Array.isArray(sourceIds) ? sourceIds : [sourceIds];\n    if (ids.length) {\n      let sourceId: string | null = null;\n      for (let i = ids.length - 1; i >= 0; i--) {\n        if (this.canDragSource(ids[i])) {\n          sourceId = ids[i];\n          break;\n        }\n      }\n      if (sourceId) {\n        const source = this.getSource(sourceId);\n        if (source) {\n          this.state.sourceId = sourceId;\n          this.state.itemType = source.type;\n          this.state.event = {\n            initialPageX: pageX,\n            initialPageY: pageY,\n            pageX,\n            pageY,\n            initialX: x,\n            initialY: y,\n            x,\n            y,\n            dx: 0,\n            dy: 0,\n          };\n          this.state.operation = operation;\n          this.state.isDragging = true;\n          this.state.item = source.beginDrag(this);\n        }\n      }\n    }\n    this.performHitTests();\n  }\n\n  hover(targetIds: string[]): void {\n    const ids: string[] = targetIds.filter((id) => this.getTarget(id));\n    this.state.targetIds = ids;\n    ids.forEach((id) => {\n      const target = this.getTarget(id);\n      if (target) {\n        target.hover(this);\n      }\n    });\n  }\n\n  async endDrag(): Promise<void> {\n    const source = this.getSource(this.getSourceId());\n    try {\n      if (source) {\n        await source.endDrag(this);\n      }\n    } finally {\n      // clear state\n      delete this.state.didDrop;\n      delete this.state.dropResult;\n      delete this.state.event;\n      delete this.state.isDragging;\n      delete this.state.item;\n      delete this.state.sourceId;\n      delete this.state.targetIds;\n      delete this.state.operation;\n      delete this.state.cancelled;\n    }\n  }\n\n  drop(): void {\n    this.getTargetIds()\n      .filter((id) => this.canDropOnTarget(id))\n      .reverse()\n      .forEach((id, idx) => {\n        const target = this.getTarget(id);\n        if (target) {\n          let result = target.drop(this);\n          if (typeof result === 'undefined') {\n            result = idx === 0 ? {} : this.state.dropResult;\n          }\n          this.state.dropResult = result;\n          this.state.didDrop = true;\n        }\n      });\n  }\n\n  drag(x: number, y: number, pageX: number, pageY: number): void {\n    if (!this.state.event) {\n      throw new Error('Drag event not initialized');\n    }\n    this.state.event.dx = x - this.state.event.x;\n    this.state.event.dy = y - this.state.event.y;\n    this.state.event.x = x;\n    this.state.event.y = y;\n    this.state.event.pageX = pageX;\n    this.state.event.pageY = pageY;\n\n    const source = this.getSource(this.getSourceId());\n    if (source) {\n      source.drag(this);\n    }\n    this.performHitTests();\n  }\n\n  cancel(): boolean {\n    if (!this.state.event) {\n      throw new Error('Drag event not initialized');\n    }\n    if (this.state.cancelled) {\n      return true;\n    }\n    const source = this.getSource(this.getSourceId());\n    if (source && source.canCancel(this)) {\n      this.state.cancelled = true;\n      this.drag(\n        this.state.event.initialX,\n        this.state.event.initialY,\n        this.state.event.pageX,\n        this.state.event.pageY,\n      );\n      return true;\n    }\n    return false;\n  }\n\n  private performHitTests(): void {\n    const draggedItemType = this.getItemType();\n    const event = this.getDragEvent();\n    if (event && draggedItemType) {\n      const targetIds: string[] = [];\n      Object.keys(this.targets).forEach((targetId) => {\n        const target = this.getTarget(targetId);\n        if (\n          target &&\n          matchesType(target.type, draggedItemType) &&\n          target.hitTest(event.x, event.y)\n        ) {\n          targetIds.push(targetId);\n        }\n      });\n\n      this.hover(targetIds);\n    }\n  }\n\n  private getSource(sourceId: string | undefined): DragSource | undefined {\n    return sourceId ? this.sources[sourceId] : undefined;\n  }\n\n  private getTarget(targetId: string | undefined): DropTarget | undefined {\n    return targetId ? this.targets[targetId] : undefined;\n  }\n}\n\nexport const useDndManager = () => {\n  const controller = React.useContext(ControllerContext);\n  const store = controller.getStore<DndStore>();\n  let { dndManager } = store;\n  if (!dndManager) {\n    const state = controller.getState<DndStateContainer>();\n    let { dragDrop } = state;\n    if (!dragDrop) {\n      dragDrop = observable.object<DndState>({});\n      state.dragDrop = dragDrop;\n    }\n    dndManager = new DndManagerImpl(dragDrop);\n    store.dndManager = dndManager;\n  }\n  return dndManager;\n};\n","import * as React from 'react';\nimport { action } from 'mobx';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport { EventListener, isNode, Node } from '../types';\nimport { useDndDrag, WithDndDragProps, Modifiers } from './useDndDrag';\nimport {\n  DragSourceSpec,\n  DragEvent,\n  ConnectDragSource,\n  DragObjectWithType,\n  DragSpecOperationType,\n  DragOperationWithType,\n  DragSourceMonitor,\n} from './dnd-types';\nimport { useDndManager } from './useDndManager';\n\nexport const DRAG_NODE_EVENT = 'drag_node';\nexport const DRAG_NODE_START_EVENT = `${DRAG_NODE_EVENT}_start`;\nexport const DRAG_NODE_END_EVENT = `${DRAG_NODE_EVENT}_end`;\n\nexport type DragNodeEventListener = EventListener<[Node, DragEvent, DragOperationWithType]>;\n\nexport const DRAG_MOVE_OPERATION = 'move.useDragNode';\n\nconst defaultOperation = {\n  [Modifiers.DEFAULT]: { type: DRAG_MOVE_OPERATION },\n};\n\nexport const useDragNode = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec?: Omit<\n    DragSourceSpec<\n      DragObject,\n      DragSpecOperationType<DragOperationWithType>,\n      DropResult,\n      CollectedProps,\n      Props\n    >,\n    'item'\n  > & {\n    item?: DragObject;\n  },\n  props?: Props,\n): [CollectedProps, ConnectDragSource] => {\n  const element = React.useContext(ElementContext);\n  if (!isNode(element)) {\n    throw new Error('useDragNode must be used within the scope of a Node');\n  }\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  const dndManager = useDndManager();\n\n  return useDndDrag(\n    React.useMemo(() => {\n      const sourceSpec: DragSourceSpec<any, any, any, any, Props> = {\n        item: (spec && spec.item) || { type: '#useDragNode#' },\n        operation: (monitor: DragSourceMonitor, p: Props) => {\n          if (spec) {\n            const operation =\n              typeof spec.operation === 'function' ? spec.operation(monitor, p) : spec.operation;\n            if (typeof operation === 'object' && Object.keys(operation).length > 0) {\n              return {\n                ...defaultOperation,\n                ...operation,\n              };\n            }\n          }\n          return defaultOperation;\n        },\n        begin: (monitor, p) => {\n          elementRef.current.raise();\n          if (elementRef.current.isGroup()) {\n            elementRef.current.getChildren().forEach((c) => {\n              c.raise();\n            });\n          }\n\n          const result = spec && spec.begin && spec.begin(monitor, p);\n\n          elementRef.current\n            .getController()\n            .fireEvent(\n              DRAG_NODE_START_EVENT,\n              elementRef.current,\n              monitor.getDragEvent(),\n              monitor.getOperation(),\n            );\n\n          return result || elementRef.current;\n        },\n        drag: (event, monitor, p) => {\n          const { dx, dy } = event;\n\n          function moveElement(e: Node) {\n            let moved = true;\n            if (e.isGroup()) {\n              const nodeChildren = e.getChildren().filter(isNode);\n              if (nodeChildren.length) {\n                moved = false;\n                nodeChildren.forEach(moveElement);\n              }\n            }\n            if (moved) {\n              e.setPosition(\n                e\n                  .getPosition()\n                  .clone()\n                  .translate(dx, dy),\n              );\n            }\n          }\n\n          moveElement(elementRef.current);\n\n          spec && spec.drag && spec.drag(event, monitor, p);\n\n          elementRef.current\n            .getController()\n            .fireEvent(DRAG_NODE_EVENT, elementRef.current, event, monitor.getOperation());\n        },\n        canDrag: spec ? spec.canDrag : undefined,\n        end: async (dropResult, monitor, p) => {\n          // FIXME: Get the controller up front due it issues with model updates during dnd operations\n          const controller = elementRef.current.getController();\n          if (spec && spec.end) {\n            try {\n              await spec.end(dropResult, monitor, p);\n            } catch {\n              dndManager.cancel();\n            }\n          }\n\n          action(() => {\n            controller.fireEvent(\n              DRAG_NODE_END_EVENT,\n              elementRef.current,\n              monitor.getDragEvent(),\n              monitor.getOperation(),\n            );\n          })();\n        },\n        collect: spec ? spec.collect : undefined,\n        canCancel: spec ? spec.canCancel : true,\n      };\n      return sourceSpec;\n    }, [spec, dndManager]),\n    props,\n  );\n};\n\nexport type WithDragNodeProps = {\n  dragNodeRef: WithDndDragProps['dndDragRef'];\n};\n\nexport const withDragNode = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec?: Omit<\n    DragSourceSpec<\n      DragObject,\n      DragSpecOperationType<DragOperationWithType>,\n      DropResult,\n      CollectedProps,\n      Props\n    >,\n    'item'\n  > & {\n    item?: DragObject;\n  },\n) => <P extends WithDragNodeProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithDragNodeProps>> = (props) => {\n    // TODO fix cast to any\n    const [dragNodeProps, dragNodeRef] = useDragNode(spec, props as any);\n    return <WrappedComponent {...(props as any)} dragNodeRef={dragNodeRef} {...dragNodeProps} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport * as d3 from 'd3';\nimport { observer } from 'mobx-react';\nimport { action, autorun, IReactionDisposer } from 'mobx';\nimport ElementContext from '../utils/ElementContext';\nimport useCallbackRef from '../utils/useCallbackRef';\nimport Point from '../geom/Point';\nimport { Graph, isGraph, ModelKind } from '../types';\nimport { ATTR_DATA_KIND } from '../const';\n\nexport type PanZoomRef = (node: SVGGElement | null) => void;\n\n// Used to send events prevented by d3.zoom to the document allowing modals, dropdowns, etc, to close\nconst propagatePanZoomMouseEvent = (e: Event): void => {\n  document.dispatchEvent(new MouseEvent(e.type, e));\n};\n\nexport const usePanZoom = (): PanZoomRef => {\n  const element = React.useContext(ElementContext);\n  if (!isGraph(element)) {\n    throw new Error('usePanZoom must be used within the scope of a Graph');\n  }\n  const elementRef = React.useRef<Graph>(element);\n  elementRef.current = element;\n\n  return useCallbackRef<PanZoomRef>((node: SVGGElement | null) => {\n    let disposeListener: IReactionDisposer | undefined;\n    if (node) {\n      // TODO fix any type\n      const $svg = d3.select(node.ownerSVGElement) as any;\n      if (node && node.ownerSVGElement) {\n        node.ownerSVGElement.addEventListener('mousedown', propagatePanZoomMouseEvent);\n        node.ownerSVGElement.addEventListener('click', propagatePanZoomMouseEvent);\n      }\n      const zoom = d3\n        .zoom()\n        .scaleExtent(elementRef.current.getScaleExtent())\n        .on(\n          'zoom',\n          action(() => {\n            elementRef.current.setPosition(new Point(d3.event.transform.x, d3.event.transform.y));\n            elementRef.current.setScale(d3.event.transform.k);\n          }),\n        )\n        .filter(() => {\n          if (d3.event.ctrlKey || d3.event.button) {\n            return false;\n          }\n          // only allow zoom from double clicking the graph directly\n          if (d3.event.type === 'dblclick') {\n            // check if target is not within a node or edge\n            const svg = node.ownerSVGElement;\n            let p: Node | null = d3.event.target;\n            while (p && p !== svg) {\n              if (p instanceof Element) {\n                const kind = p.getAttribute(ATTR_DATA_KIND);\n                if (kind) {\n                  if (kind !== ModelKind.graph) {\n                    return false;\n                  }\n                  break;\n                }\n              }\n              p = p.parentNode;\n            }\n          }\n          return true;\n        });\n      zoom($svg);\n\n      // Update the d3 transform whenever the scale or bounds change.\n      // This is kinda hacky because when d3 has already made the most recent transform update,\n      // we listen for the model change, due to the above, only to update the d3 transform again.\n      disposeListener = autorun(() => {\n        const scale = elementRef.current.getScale();\n        const scaleExtent = elementRef.current.getScaleExtent();\n\n        // update the min scaling value such that the user can zoom out to the new scale in case\n        // it is smaller than the default zoom out scale\n        zoom.scaleExtent([Math.min(scale, scaleExtent[0]), scaleExtent[1]]);\n        const b = elementRef.current.getBounds();\n\n        // update d3 zoom data directly\n        // eslint-disable-next-line no-underscore-dangle\n        Object.assign($svg.node().__zoom, {\n          k: scale,\n          x: b.x,\n          y: b.y,\n        });\n      });\n\n      // disable double click zoom\n      // $svg.on('dblclick.zoom', null);\n    }\n    return () => {\n      disposeListener && disposeListener();\n      if (node) {\n        // remove all zoom listeners\n        d3.select(node.ownerSVGElement).on('.zoom', null);\n        if (node.ownerSVGElement) {\n          node.ownerSVGElement.removeEventListener('mousedown', propagatePanZoomMouseEvent);\n          node.ownerSVGElement.removeEventListener('click', propagatePanZoomMouseEvent);\n        }\n      }\n    };\n  });\n};\n\nexport type WithPanZoomProps = {\n  panZoomRef: PanZoomRef;\n};\n\nexport const withPanZoom = () => <P extends WithPanZoomProps>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithPanZoomProps>> = (props) => {\n    const panZoomRef = usePanZoom();\n    return <WrappedComponent {...(props as any)} panZoomRef={panZoomRef} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { useDndDrag } from './useDndDrag';\nimport {\n  ConnectDragSource,\n  DragObjectWithType,\n  DragOperationWithType,\n  DragSourceSpec,\n  DragSpecOperationType,\n} from './dnd-types';\n\nexport type WithSourceDragProps = {\n  sourceDragRef: ConnectDragSource;\n};\n\nexport const withSourceDrag = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DragSourceSpec<\n    DragObject,\n    DragSpecOperationType<DragOperationWithType>,\n    DropResult,\n    CollectedProps,\n    Props\n  >,\n) => <P extends WithSourceDragProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithSourceDragProps & CollectedProps>> = (props) => {\n    // TODO fix cast to any\n    const [dndDragProps, dndDragRef] = useDndDrag(spec, props as any);\n    return <WrappedComponent {...(props as any)} sourceDragRef={dndDragRef} {...dndDragProps} />;\n  };\n  return observer(Component);\n};\n\nexport type WithTargetDragProps = {\n  targetDragRef: ConnectDragSource;\n};\n\nexport const withTargetDrag = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DragSourceSpec<\n    DragObject,\n    DragSpecOperationType<DragOperationWithType>,\n    DropResult,\n    CollectedProps,\n    Props\n  >,\n) => <P extends WithSourceDragProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithSourceDragProps & CollectedProps>> = (props) => {\n    // TODO fix cast to any\n    const [dndDragProps, dndDragRef] = useDndDrag(spec, props as any);\n    return <WrappedComponent {...(props as any)} targetDragRef={dndDragRef} {...dndDragProps} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { action, computed } from 'mobx';\nimport { observer } from 'mobx-react';\nimport { EventListener } from '../types';\nimport ElementContext from '../utils/ElementContext';\n\nexport const SELECTION_EVENT = 'selection';\n\nexport type SelectionEventListener = EventListener<[string[]]>;\n\ntype SelectionHandlerState = {\n  selectedIds?: string[];\n};\n\nexport type OnSelect = (e: React.MouseEvent) => void;\n\nexport const useSelection = (\n  multi: boolean = false,\n  controlled: boolean = false,\n): [boolean, OnSelect] => {\n  const element = React.useContext(ElementContext);\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  const selected = React.useMemo(\n    () =>\n      computed(() => {\n        const { selectedIds } = element.getController().getState<SelectionHandlerState>();\n        return !!selectedIds && selectedIds.includes(element.getId());\n      }),\n    [element],\n  );\n\n  const onSelect = React.useCallback(\n    action((e: React.MouseEvent): void => {\n      e.stopPropagation();\n      const id = elementRef.current.getId();\n      const state = elementRef.current.getController().getState<SelectionHandlerState>();\n      const idx = state.selectedIds ? state.selectedIds.indexOf(id) : -1;\n      let selectedIds: string[];\n      let raise = false;\n      if (multi && (e.ctrlKey || e.metaKey)) {\n        if (!state.selectedIds) {\n          raise = true;\n          selectedIds = [id];\n        } else {\n          selectedIds = [...state.selectedIds];\n          if (idx === -1) {\n            raise = true;\n            selectedIds.push(id);\n          } else {\n            selectedIds.splice(idx, 1);\n          }\n        }\n      } else if (idx === -1 || multi) {\n        raise = true;\n        selectedIds = [id];\n      } else {\n        selectedIds = [];\n      }\n      if (!controlled) {\n        state.selectedIds = selectedIds;\n      }\n      elementRef.current.getController().fireEvent(SELECTION_EVENT, selectedIds);\n      if (raise) {\n        elementRef.current.raise();\n      }\n    }),\n    [],\n  );\n  return [selected.get(), onSelect];\n};\n\nexport type WithSelectionProps = {\n  selected: boolean;\n  onSelect: OnSelect;\n};\n\nexport const withSelection = (multi: boolean = false, controlled: boolean = false) => <\n  P extends WithSelectionProps\n>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithSelectionProps>> = (props) => {\n    const [selected, onSelect] = useSelection(multi, controlled);\n    return <WrappedComponent {...(props as any)} selected={selected} onSelect={onSelect} />;\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { action } from 'mobx';\nimport { isNode, AnchorEnd } from '../types';\nimport ElementContext from '../utils/ElementContext';\nimport SVGAnchor from '../anchors/SVGAnchor';\n\nexport type SvgAnchorRef = (node: SVGElement | null) => void;\n\nexport const useSvgAnchor = (\n  end: AnchorEnd = AnchorEnd.both,\n  type: string = '',\n): ((node: SVGElement | null) => void) => {\n  const element = React.useContext(ElementContext);\n  if (!isNode(element)) {\n    throw new Error('useSvgAnchor must be used within the scope of a Node');\n  }\n\n  const setAnchorSvgRef = React.useCallback<SvgAnchorRef>(\n    action((node: SVGElement | null) => {\n      if (node) {\n        const anchor = new SVGAnchor(element);\n        anchor.setSVGElement(node);\n        element.setAnchor(anchor, end, type);\n      }\n    }),\n    [element, type, end],\n  );\n\n  return setAnchorSvgRef;\n};\n\nexport type WithSvgAnchorProps = {\n  svgAnchorRef: SvgAnchorRef;\n};\n\nexport const withSvgAnchor = (end?: AnchorEnd, type?: string) => <\n  P extends WithSvgAnchorProps\n>() => (WrappedComponent: React.ComponentType<P>) => {\n  const Component: React.FC<Omit<P, keyof WithSvgAnchorProps>> = (props) => {\n    const svgAnchorRef = useSvgAnchor(end, type);\n    return <WrappedComponent {...(props as any)} svgAnchorRef={svgAnchorRef} />;\n  };\n  return Component;\n};\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { GraphElement as TopologyElement } from '../types';\nimport ElementContext from '../utils/ElementContext';\nimport ContextMenu from '../components/contextmenu/ContextMenu';\n\ntype Reference = React.ComponentProps<typeof ContextMenu>['reference'];\n\nexport type WithContextMenuProps = {\n  onContextMenu: (e: React.MouseEvent) => void;\n  contextMenuOpen: boolean;\n};\n\nexport const withContextMenu = <E extends TopologyElement>(\n  actions: (element: E) => React.ReactElement[],\n  container?: Element | null | undefined | (() => Element),\n  className?: string,\n  atPoint: boolean = true,\n) => <P extends WithContextMenuProps>(WrappedComponent: React.ComponentType<P>) => {\n  const Component: React.FC<Omit<P, keyof WithContextMenuProps>> = (props) => {\n    const element = React.useContext(ElementContext);\n    const [reference, setReference] = React.useState<Reference | null>(null);\n    const onContextMenu = React.useCallback((e: React.MouseEvent) => {\n      e.preventDefault();\n      e.stopPropagation();\n      setReference(\n        atPoint\n          ? {\n              x: e.pageX,\n              y: e.pageY,\n            }\n          : e.currentTarget,\n      );\n    }, []);\n\n    return (\n      <>\n        <WrappedComponent\n          {...(props as any)}\n          onContextMenu={onContextMenu}\n          contextMenuOpen={!!reference}\n        />\n        {reference ? (\n          <ContextMenu\n            reference={reference}\n            container={container}\n            className={className}\n            open\n            onRequestClose={() => setReference(null)}\n          >\n            {actions(element as E)}\n          </ContextMenu>\n        ) : null}\n      </>\n    );\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { hullPath } from '../utils/svg-utils';\nimport DefaultCreateConnector from '../components/DefaultCreateConnector';\nimport Point from '../geom/Point';\nimport Layer from '../components/layers/Layer';\nimport { ContextMenu, ContextMenuItem } from '../components/contextmenu';\nimport { Node, isNode, AnchorEnd, GraphElement, isGraph, Graph } from '../types';\nimport { DragSourceSpec, DragSourceMonitor, DragEvent } from './dnd-types';\nimport { useDndDrag } from './useDndDrag';\n\nexport const CREATE_CONNECTOR_OPERATION = '#createconnector#';\nexport const CREATE_CONNECTOR_DROP_TYPE = '#createConnector#';\n\nexport type ConnectorChoice = {\n  label: string;\n};\n\nexport type CreateConnectorOptions = {\n  handleAngle?: number;\n  handleLength?: number;\n};\n\ntype ConnectorComponentProps = {\n  startPoint: Point;\n  endPoint: Point;\n  hints: string[];\n  dragging: boolean;\n};\n\ntype CreateConnectorRenderer = React.ComponentType<ConnectorComponentProps>;\n\ntype CreateConnectorWidgetProps = {\n  element: Node;\n  onKeepAlive: (isAlive: boolean) => void;\n  onCreate: (\n    element: Node,\n    target: Node | Graph,\n    event: DragEvent,\n    choice?: ConnectorChoice,\n  ) => ConnectorChoice[] | void | undefined | null | React.ReactElement[];\n  ConnectorComponent: CreateConnectorRenderer;\n  contextMenuClass?: string;\n} & CreateConnectorOptions;\n\ntype CollectProps = {\n  event?: DragEvent;\n  dragging: boolean;\n  hints?: string[] | undefined;\n};\n\ntype PromptData = {\n  element: Node;\n  target: Node | Graph;\n  event: DragEvent;\n  choices: (ConnectorChoice | React.ReactElement)[];\n};\n\nconst DEFAULT_HANDLE_ANGLE = 12 * (Math.PI / 180);\nconst DEFAULT_HANDLE_LENGTH = 32;\n\nconst CreateConnectorWidget: React.FC<CreateConnectorWidgetProps> = observer((props) => {\n  const {\n    element,\n    onKeepAlive,\n    onCreate,\n    ConnectorComponent,\n    handleAngle = DEFAULT_HANDLE_ANGLE,\n    handleLength = DEFAULT_HANDLE_LENGTH,\n    contextMenuClass,\n  } = props;\n  const [prompt, setPrompt] = React.useState<PromptData | null>(null);\n  const [active, setActive] = React.useState(false);\n  const hintsRef = React.useRef<string[] | undefined>();\n\n  const spec = React.useMemo(() => {\n    const dragSourceSpec: DragSourceSpec<any, any, any, CollectProps> = {\n      item: { type: CREATE_CONNECTOR_DROP_TYPE },\n      operation: { type: CREATE_CONNECTOR_OPERATION },\n      begin: (monitor: DragSourceMonitor, dragProps: CreateConnectorWidgetProps) => {\n        setActive(true);\n        return dragProps.element;\n      },\n      drag: (event: DragEvent, monitor: DragSourceMonitor, p: CreateConnectorWidgetProps) => {\n        p.element.raise();\n      },\n      end: (\n        dropResult: GraphElement,\n        monitor: DragSourceMonitor,\n        dragProps: CreateConnectorWidgetProps,\n      ) => {\n        const event = monitor.getDragEvent();\n        if ((isNode(dropResult) || isGraph(dropResult)) && event) {\n          const choices = dragProps.onCreate(dragProps.element, dropResult, event);\n          if (choices && choices.length) {\n            setPrompt({ element: dragProps.element, target: dropResult, event, choices });\n            return;\n          }\n        }\n        setActive(false);\n        dragProps.onKeepAlive(false);\n      },\n      collect: (monitor) => ({\n        dragging: !!monitor.getItem(),\n        event: monitor.isDragging() ? monitor.getDragEvent() : undefined,\n        hints: monitor.getDropHints(),\n      }),\n    };\n    return dragSourceSpec;\n  }, [setActive]);\n  const [{ dragging, event, hints }, dragRef] = useDndDrag(spec, props);\n\n  if (!active && dragging && !event) {\n    // another connector is dragging right now\n    return null;\n  }\n\n  if (dragging) {\n    // store the latest hints\n    hintsRef.current = hints;\n  }\n\n  const dragEvent = prompt ? prompt.event : event;\n\n  let startPoint: Point;\n  let endPoint: Point;\n\n  if (dragEvent) {\n    endPoint = new Point(dragEvent.x, dragEvent.y);\n    startPoint = element.getAnchor(AnchorEnd.source).getLocation(endPoint);\n  } else {\n    const bounds = element.getBounds();\n    const referencePoint = new Point(\n      bounds.right(),\n      Math.tan(handleAngle) * (bounds.width / 2) + bounds.y + bounds.height / 2,\n    );\n    startPoint = element.getAnchor(AnchorEnd.source).getLocation(referencePoint);\n    endPoint = new Point(\n      Math.cos(handleAngle) * handleLength + startPoint.x,\n      Math.sin(handleAngle) * handleLength + startPoint.y,\n    );\n  }\n\n  // bring into the coordinate space of the element\n  element.translateFromParent(startPoint);\n  element.translateFromParent(endPoint);\n\n  return (\n    <>\n      <Layer id=\"top\">\n        <g\n          className=\"topology-create-connector\"\n          ref={dragRef}\n          onMouseEnter={!active ? () => onKeepAlive(true) : undefined}\n          onMouseLeave={!active ? () => onKeepAlive(false) : undefined}\n        >\n          <ConnectorComponent\n            startPoint={startPoint}\n            endPoint={endPoint}\n            dragging={dragging}\n            hints={hintsRef.current || []}\n          />\n          {!active && (\n            <path\n              d={hullPath(\n                [\n                  [startPoint.x, startPoint.y],\n                  [endPoint.x, endPoint.y],\n                ],\n                7,\n              )}\n              fillOpacity=\"0\"\n            />\n          )}\n        </g>\n      </Layer>\n      {prompt && (\n        <ContextMenu\n          reference={{ x: prompt.event.pageX, y: prompt.event.pageY }}\n          className={contextMenuClass}\n          open\n          onRequestClose={() => {\n            setActive(false);\n            onKeepAlive(false);\n          }}\n        >\n          {React.isValidElement(prompt.choices?.[0])\n            ? prompt.choices\n            : prompt.choices.map((c: ConnectorChoice) => (\n                <ContextMenuItem\n                  key={c.label}\n                  onClick={() => {\n                    onCreate(prompt.element, prompt.target, prompt.event, c);\n                  }}\n                >\n                  {c.label}\n                </ContextMenuItem>\n              ))}\n        </ContextMenu>\n      )}\n    </>\n  );\n});\n\ntype ElementProps = {\n  element: Node;\n};\n\nexport type WithCreateConnectorProps = {\n  onShowCreateConnector: () => void;\n  onHideCreateConnector: () => void;\n};\n\nexport const withCreateConnector = <P extends WithCreateConnectorProps & ElementProps>(\n  onCreate: React.ComponentProps<typeof CreateConnectorWidget>['onCreate'],\n  ConnectorComponent: CreateConnectorRenderer = DefaultCreateConnector,\n  contextMenuClass?: string,\n  options?: CreateConnectorOptions,\n) => (WrappedComponent: React.ComponentType<P>) => {\n  const Component: React.FC<Omit<P, keyof WithCreateConnectorProps>> = (props) => {\n    const [show, setShow] = React.useState(false);\n    const [alive, setKeepAlive] = React.useState(false);\n    const onShowCreateConnector = React.useCallback(() => setShow(true), []);\n    const onHideCreateConnector = React.useCallback(() => setShow(false), []);\n    const onKeepAlive = React.useCallback((isAlive: boolean) => setKeepAlive(isAlive), [\n      setKeepAlive,\n    ]);\n    return (\n      <>\n        <WrappedComponent\n          {...(props as any)}\n          onShowCreateConnector={onShowCreateConnector}\n          onHideCreateConnector={onHideCreateConnector}\n        />\n        {(show || alive) && (\n          <CreateConnectorWidget\n            {...options}\n            element={props.element}\n            onCreate={onCreate}\n            onKeepAlive={onKeepAlive}\n            ConnectorComponent={ConnectorComponent}\n            contextMenuClass={contextMenuClass}\n          />\n        )}\n      </>\n    );\n  };\n  return observer(Component);\n};\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { Edge } from '../types';\nimport DefaultRemoveConnector from '../components/DefaultRemoveConnector';\n\ntype ElementProps = {\n  element: Edge;\n};\n\nexport type WithRemoveConnectorProps = {\n  onShowRemoveConnector?: () => void;\n  onHideRemoveConnector?: () => void;\n};\n\ntype RemoveRenderer = (\n  edge: Edge,\n  onRemove: (edge: Edge) => void,\n  size?: number,\n) => React.ReactElement;\n\nconst defaultRenderRemove: RemoveRenderer = (edge: Edge, onRemove: (edge: Edge) => void) => {\n  const removeEdge = () => {\n    onRemove(edge);\n  };\n\n  return (\n    <DefaultRemoveConnector\n      startPoint={edge.getStartPoint()}\n      endPoint={edge.getEndPoint()}\n      onRemove={removeEdge}\n    />\n  );\n};\n\nexport const withRemoveConnector = <P extends WithRemoveConnectorProps & ElementProps>(\n  onRemove: (edge: Edge) => void,\n  renderRemove: RemoveRenderer = defaultRenderRemove,\n) => (WrappedComponent: React.ComponentType<P>) => {\n  const Component: React.FC<Omit<P, keyof WithRemoveConnectorProps>> = (props) => {\n    const [show, setShow] = React.useState(false);\n    const onShowRemoveConnector = React.useCallback(() => setShow(true), []);\n    const onHideRemoveConnector = React.useCallback(() => setShow(false), []);\n\n    return (\n      <WrappedComponent\n        {...(props as any)}\n        onShowRemoveConnector={onShowRemoveConnector}\n        onHideRemoveConnector={onHideRemoveConnector}\n      >\n        {show && renderRemove(props.element, onRemove)}\n      </WrappedComponent>\n    );\n  };\n  return observer(Component);\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport * as _ from 'lodash';\nimport Point from '../geom/Point';\nimport { ConnectDragSource } from '../behavior/dnd-types';\nimport './ConnectorArrow.scss';\n\ntype ConnectorArrowProps = {\n  startPoint: Point;\n  endPoint: Point;\n  className?: string;\n  isTarget?: boolean;\n  size?: number;\n  dragRef?: ConnectDragSource;\n};\n\nconst pointsStringFromPoints = (points: [number, number][]): string => {\n  return _.reduce(\n    points,\n    (result: string, nextPoint: [number, number]) => {\n      return `${result} ${nextPoint[0]},${nextPoint[1]}`;\n    },\n    '',\n  );\n};\n\nconst ConnectorArrow: React.FC<ConnectorArrowProps> = ({\n  startPoint,\n  endPoint,\n  className = '',\n  isTarget = true,\n  size = 10,\n  dragRef,\n}) => {\n  if (!startPoint || !endPoint) {\n    return null;\n  }\n  const arrowEndPoint: [number, number] = isTarget\n    ? [endPoint.x, endPoint.y]\n    : [startPoint.x, startPoint.y];\n  const prevPoint: [number, number] = isTarget\n    ? [startPoint.x, startPoint.y]\n    : [endPoint.x, endPoint.y];\n\n  const length = Math.sqrt(\n    (arrowEndPoint[0] - prevPoint[0]) ** 2 + (arrowEndPoint[1] - prevPoint[1]) ** 2,\n  );\n  if (!length) {\n    return null;\n  }\n\n  const ratio = (length - size) / length;\n  const arrowStartPoint: [number, number] = [\n    prevPoint[0] + (arrowEndPoint[0] - prevPoint[0]) * ratio,\n    prevPoint[1] + (arrowEndPoint[1] - prevPoint[1]) * ratio,\n  ];\n\n  const arrowPoints: [number, number][] = [\n    [0, size / 2],\n    [0, -size / 2],\n    [size, 0],\n  ];\n  const padding = Math.max(size, 8);\n  const deltaY = padding / 2;\n  const boundingBox: [number, number][] = [\n    [0, -deltaY],\n    [padding, -deltaY],\n    [padding, deltaY],\n    [0, deltaY],\n  ];\n\n  const angleDeg =\n    180 -\n    (Math.atan2(arrowEndPoint[1] - prevPoint[1], prevPoint[0] - arrowEndPoint[0]) * 180) / Math.PI;\n\n  return (\n    <g\n      transform={`translate(${arrowStartPoint[0]}, ${arrowStartPoint[1]}) rotate(${angleDeg})`}\n      ref={dragRef}\n      className={classNames('topology-connector-arrow', className)}\n    >\n      <polygon points={pointsStringFromPoints(arrowPoints)} />\n      <polygon points={pointsStringFromPoints(boundingBox)} fillOpacity={0} strokeWidth={0} />\n    </g>\n  );\n};\n\nexport default ConnectorArrow;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { AddCircleOIcon } from '@patternfly/react-icons';\nimport { Tooltip } from '@patternfly/react-core';\nimport Point from '../geom/Point';\nimport ConnectorArrow from './ConnectorArrow';\n\nimport './DefaultCreateConnector.scss';\n\nconst cursorSize = 20;\n\ntype DefaultCreateConnectorProps = {\n  startPoint: Point;\n  endPoint: Point;\n  hints: string[];\n  dragging: boolean;\n  className?: string;\n  tipContents?: React.ReactNode;\n};\n\nconst DefaultCreateConnector: React.FC<DefaultCreateConnectorProps> = ({\n  startPoint,\n  endPoint,\n  hints,\n  tipContents,\n  className,\n}) => {\n  const classes = classNames('topology-default-create-connector', className);\n  return (\n    <g className={classes}>\n      <line\n        className=\"topology-default-create-connector__line\"\n        x1={startPoint.x}\n        y1={startPoint.y}\n        x2={endPoint.x}\n        y2={endPoint.y}\n      />\n      {hints && hints[hints.length - 1] === 'create' ? (\n        <g\n          transform={`translate(${endPoint.x - cursorSize / 2},${endPoint.y - cursorSize / 2})`}\n          className=\"topology-default-create-connector__create\"\n        >\n          <circle\n            className=\"topology-default-create-connector__create__bg\"\n            cx={cursorSize / 2}\n            cy={cursorSize / 2}\n            r={cursorSize / 2}\n          />\n          {tipContents ? (\n            <Tooltip\n              content={tipContents}\n              trigger=\"manual\"\n              isVisible\n              tippyProps={{ duration: 0, delay: 0 }}\n            >\n              <AddCircleOIcon\n                className=\"topology-default-create-connector__create__cursor\"\n                style={{ fontSize: cursorSize }}\n              />\n            </Tooltip>\n          ) : (\n            <AddCircleOIcon\n              className=\"topology-default-create-connector__create__cursor\"\n              style={{ fontSize: cursorSize }}\n            />\n          )}\n        </g>\n      ) : (\n        <ConnectorArrow startPoint={startPoint} endPoint={endPoint} />\n      )}\n    </g>\n  );\n};\n\nexport default DefaultCreateConnector;\n","import * as React from 'react';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { TrashIcon } from '@patternfly/react-icons';\nimport Point from '../geom/Point';\n\ntype DefaultRemoveConnectorProps = {\n  startPoint: Point;\n  endPoint: Point;\n  onRemove(): void;\n  size?: number;\n};\n\nfunction computeTooltipPosition(startPoint: Point, endPoint: Point): TooltipPosition {\n  const angle = Math.abs(\n    (Math.atan2(endPoint.y - startPoint.y, endPoint.x - startPoint.x) * 180) / Math.PI,\n  );\n  return angle < 135 && angle > 90\n    ? TooltipPosition.left\n    : angle > 45 && angle <= 90\n    ? TooltipPosition.right\n    : TooltipPosition.top;\n}\n\nconst DefaultRemoveConnector: React.FC<DefaultRemoveConnectorProps> = ({\n  startPoint,\n  endPoint,\n  onRemove,\n  size = 14,\n}) => (\n  <Tooltip content=\"Delete Connector\" position={computeTooltipPosition(startPoint, endPoint)}>\n    <g\n      transform={`translate(${startPoint.x + (endPoint.x - startPoint.x) * 0.5}, ${startPoint.y +\n        (endPoint.y - startPoint.y) * 0.5})`}\n      onClick={(e) => {\n        e.stopPropagation();\n        onRemove();\n      }}\n    >\n      <circle className=\"topology-connector__remove-bg\" cx={0} cy={0} r={size} />\n      <g transform={`translate(-${size / 2}, -${size / 2})`}>\n        <TrashIcon\n          className=\"topology-connector__remove-icon\"\n          style={{ fontSize: size }}\n          alt=\"Delete Connector\"\n        />\n      </g>\n    </g>\n  </Tooltip>\n);\n\nexport default DefaultRemoveConnector;\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport * as _ from 'lodash';\nimport { Edge } from '../types';\nimport { ConnectDragSource } from '../behavior/dnd-types';\nimport ConnectorArrow from './ConnectorArrow';\n\ntype EdgeConnectorArrowProps = {\n  edge: Edge;\n  className?: string;\n  isTarget?: boolean;\n  size?: number;\n  dragRef?: ConnectDragSource;\n};\n\nconst EdgeConnectorArrow: React.FC<EdgeConnectorArrowProps> = ({\n  edge,\n  isTarget = true,\n  ...others\n}) => {\n  const bendPoints = edge.getBendpoints();\n  const startPoint = isTarget\n    ? _.last(bendPoints) || edge.getStartPoint()\n    : _.head(bendPoints) || edge.getEndPoint();\n  const endPoint = isTarget ? edge.getEndPoint() : edge.getStartPoint();\n  return <ConnectorArrow startPoint={startPoint} endPoint={endPoint} {...others} />;\n};\n\nexport default observer(EdgeConnectorArrow);\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport { GraphElement, isGraph, isEdge, isNode } from '../types';\nimport { ATTR_DATA_ID, ATTR_DATA_KIND, ATTR_DATA_TYPE } from '../const';\n\ntype ElementWrapperProps = {\n  element: GraphElement;\n};\n\n// in a separate component so that changes to behaviors do not re-render children\nconst ElementComponent: React.FC<ElementWrapperProps> = observer(({ element }) => {\n  const kind = element.getKind();\n  const type = element.getType();\n\n  const Component = React.useMemo(() => {\n    return element.getController().getComponent(kind, type);\n  }, [element, kind, type]);\n\n  return (\n    <ElementContext.Provider value={element}>\n      <Component {...element.getState()} element={element} />\n    </ElementContext.Provider>\n  );\n});\n\nconst ElementChildren: React.FC<ElementWrapperProps> = observer(({ element }) => {\n  return (\n    <>\n      {element\n        .getChildren()\n        .filter(isEdge)\n        .map((e) => (\n          <ElementWrapper key={e.getId()} element={e} />\n        ))}\n      {element\n        .getChildren()\n        .filter(isNode)\n        .map((e) => (\n          <ElementWrapper key={e.getId()} element={e} />\n        ))}\n    </>\n  );\n});\n\nconst ElementWrapper: React.FC<ElementWrapperProps> = observer(({ element }) => {\n  if (!element.isVisible()) {\n    return null;\n  }\n\n  if (isEdge(element)) {\n    const source = element.getSourceAnchorNode();\n    const target = element.getTargetAnchorNode();\n    if ((source && !source.isVisible()) || (target && !target.isVisible())) {\n      return null;\n    }\n  }\n  const commonAttrs = {\n    [ATTR_DATA_ID]: element.getId(),\n    [ATTR_DATA_KIND]: element.getKind(),\n    [ATTR_DATA_TYPE]: element.getType(),\n  };\n  if (isGraph(element)) {\n    return (\n      <g {...commonAttrs}>\n        <ElementComponent element={element} />\n      </g>\n    );\n  }\n  if (isNode(element) && (!element.isGroup() || element.isCollapsed())) {\n    const { x, y } = element.getPosition();\n    return (\n      <g {...commonAttrs} transform={`translate(${x}, ${y})`}>\n        <ElementComponent element={element} />\n        <ElementChildren element={element} />\n      </g>\n    );\n  }\n  return (\n    <g {...commonAttrs}>\n      <ElementComponent element={element} />\n      <ElementChildren element={element} />\n    </g>\n  );\n});\n\nexport default ElementWrapper;\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { Graph } from '../types';\nimport { WithPanZoomProps } from '../behavior/usePanZoom';\nimport { WithDndDropProps } from '../behavior/useDndDrop';\nimport { WithSelectionProps } from '../behavior/useSelection';\nimport { WithContextMenuProps } from '../behavior/withContextMenu';\nimport LayersProvider from './layers/LayersProvider';\nimport ElementWrapper from './ElementWrapper';\n\ntype ElementProps = {\n  element: Graph;\n};\n\ntype GraphComponentProps = ElementProps &\n  WithPanZoomProps &\n  WithDndDropProps &\n  WithSelectionProps &\n  WithContextMenuProps;\n\n// This inner Component will prevent the re-rendering of all children when the transform changes\nconst ElementChildren: React.FC<ElementProps> = observer(({ element }) => {\n  return (\n    <>\n      {element.getEdges().map((e) => (\n        <ElementWrapper key={e.getId()} element={e} />\n      ))}\n      {element.getNodes().map((e) => (\n        <ElementWrapper key={e.getId()} element={e} />\n      ))}\n    </>\n  );\n});\n\n// This inner Component will prevent re-rendering layers when the transform changes\nconst Inner: React.FC<ElementProps> = React.memo(\n  observer(({ element }) => (\n    <LayersProvider layers={element.getLayers()}>\n      <ElementChildren element={element} />\n    </LayersProvider>\n  )),\n);\n\nconst GraphComponent: React.FC<GraphComponentProps> = ({\n  element,\n  panZoomRef,\n  dndDropRef,\n  onSelect,\n  onContextMenu,\n}) => {\n  const layout = element.getLayout();\n  React.useEffect(() => {\n    element.layout();\n    // Only re-run if the layout changes\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [layout]);\n\n  const { x, y, width, height } = element.getBounds();\n  return (\n    <>\n      <rect\n        ref={dndDropRef}\n        x={0}\n        y={0}\n        width={width}\n        height={height}\n        fillOpacity={0}\n        onClick={onSelect}\n        onContextMenu={onContextMenu}\n      />\n      <g\n        data-surface=\"true\"\n        ref={panZoomRef}\n        transform={`translate(${x}, ${y}) scale(${element.getScale()})`}\n      >\n        <Inner element={element} />\n      </g>\n    </>\n  );\n};\n\nexport default observer(GraphComponent);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { action } from 'mobx';\nimport { observer } from 'mobx-react';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore-next-line\nimport ReactMeasure from 'react-measure';\nimport ControllerContext from '../utils/ControllerContext';\nimport { State } from '../types';\nimport Visualization from '../Visualization';\nimport SVGDefsProvider from './defs/SVGDefsProvider';\nimport ElementWrapper from './ElementWrapper';\nimport Dimensions from '../geom/Dimensions';\n\nimport './VisualizationSurface.scss';\n\ninterface VisualizationSurfaceProps {\n  visualization: Visualization;\n  state?: State;\n}\n\nfunction stopEvent(e: React.MouseEvent): void {\n  e.preventDefault();\n  e.stopPropagation();\n}\n\nconst VisualizationSurface: React.FC<VisualizationSurfaceProps> = ({ visualization, state }) => {\n  React.useEffect(() => {\n    state && visualization.setState(state);\n  }, [visualization, state]);\n\n  const onMeasure = React.useMemo(\n    () =>\n      _.debounce<any>(\n        action((contentRect: { client: { width: number; height: number } }) => {\n          visualization\n            .getGraph()\n            .setDimensions(new Dimensions(contentRect.client.width, contentRect.client.height));\n        }),\n        100,\n        { leading: true, trailing: true },\n      ),\n    [visualization],\n  );\n\n  // dispose of onMeasure\n  React.useEffect(() => () => onMeasure.cancel(), [onMeasure]);\n\n  const graph = visualization.getGraph();\n\n  return (\n    <ControllerContext.Provider value={visualization}>\n      <ReactMeasure client onResize={onMeasure}>\n        {({ measureRef }: { measureRef: React.LegacyRef<any> }) => (\n          // render an outer div because react-measure doesn't seem to fire events properly on svg resize\n          <div data-test-id=\"topology\" className=\"topology-visualization-surface\" ref={measureRef}>\n            <svg className=\"topology-visualization-surface__svg\" onContextMenu={stopEvent}>\n              <SVGDefsProvider>\n                <ElementWrapper element={graph} />\n              </SVGDefsProvider>\n            </svg>\n          </div>\n        )}\n      </ReactMeasure>\n    </ControllerContext.Provider>\n  );\n};\n\nexport default observer(VisualizationSurface);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { DropdownMenu, DropdownContext } from '@patternfly/react-core';\nimport styles from '@patternfly/react-styles/css/components/Dropdown/dropdown';\n// FIXME fully qualified due to the effect of long build times on storybook\nimport Popper from '@console/shared/src/components/popper/Popper';\n\nimport './ContextMenu.scss';\n\ntype ContextMenuProps = Pick<\n  React.ComponentProps<typeof Popper>,\n  'container' | 'className' | 'open' | 'reference' | 'onRequestClose'\n>;\n\nconst ContextMenu: React.FC<ContextMenuProps> = ({\n  children,\n  open = true,\n  onRequestClose,\n  ...other\n}) => {\n  const [isOpen, setOpen] = React.useState(!!open);\n  React.useEffect(() => {\n    setOpen(open);\n  }, [open]);\n\n  const handleOnRequestClose = React.useCallback(() => {\n    onRequestClose ? onRequestClose() : setOpen(false);\n  }, [onRequestClose]);\n\n  return (\n    <Popper\n      {...other}\n      closeOnEsc\n      closeOnOutsideClick\n      open={isOpen}\n      onRequestClose={handleOnRequestClose}\n    >\n      <DropdownContext.Provider\n        value={{\n          onSelect: handleOnRequestClose,\n          toggleTextClass: styles.dropdownToggleText,\n          toggleIconClass: styles.dropdownToggleIcon,\n          menuClass: styles.dropdownMenu,\n          itemClass: styles.dropdownMenuItem,\n          toggleClass: styles.dropdownToggle,\n          baseClass: styles.dropdown,\n          baseComponent: 'div',\n          sectionClass: styles.dropdownGroup,\n          sectionTitleClass: styles.dropdownGroupTitle,\n          sectionComponent: 'section',\n          disabledClass: styles.modifiers.disabled,\n          hoverClass: styles.modifiers.hover,\n          separatorClass: styles.dropdownSeparator,\n        }}\n      >\n        <div className=\"pf-c-dropdown pf-m-expanded topology-context-menu\">\n          <DropdownMenu className=\"pf-c-dropdown__menu \" autoFocus>\n            {children}\n          </DropdownMenu>\n        </div>\n      </DropdownContext.Provider>\n    </Popper>\n  );\n};\n\nexport default ContextMenu;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { DropdownMenu, DropdownItem } from '@patternfly/react-core';\n// FIXME fully qualified due to the effect of long build times on storybook\nimport Popper from '@console/shared/src/components/popper/Popper';\nimport { AngleRightIcon } from '@patternfly/react-icons';\n\nimport './ContextSubMenuItem.scss';\n\ntype ContextSubMenuItemProps = {\n  label: React.ReactNode;\n  children: React.ReactNode[];\n};\n\nconst ContextSubMenuItem: React.FC<ContextSubMenuItemProps> = ({ label, children, ...other }) => {\n  const nodeRef = React.useRef<HTMLButtonElement>(null);\n  const subMenuRef = React.useRef<HTMLDivElement>(null);\n  const [open, setOpen] = React.useState(false);\n  const referenceCb = React.useCallback(() => nodeRef.current || { x: 0, y: 0 }, []);\n\n  return (\n    <>\n      <DropdownItem\n        {...other}\n        className=\"topology-context-sub-menu\"\n        component={\n          <button\n            ref={nodeRef}\n            type=\"button\"\n            // prevent this DropdownItem from executing like a normal action item\n            onClick={(e) => e.stopPropagation()}\n            // mouse enter will open the sub menu\n            onMouseEnter={() => setOpen(true)}\n            onMouseLeave={(e) => {\n              // if the mouse leaves this item, close the sub menu only if the mouse did not enter the sub menu itself\n              if (!subMenuRef.current || !subMenuRef.current.contains(e.relatedTarget as Node)) {\n                setOpen(false);\n              }\n            }}\n            onKeyDown={(e) => {\n              // open the sub menu on enter or right arrow\n              if (e.keyCode === 39 || e.keyCode === 13) {\n                setOpen(true);\n                e.stopPropagation();\n              }\n            }}\n          >\n            {label}\n            <AngleRightIcon className=\"topology-context-sub-menu__arrow\" />\n          </button>\n        }\n      />\n      <Popper\n        open={open}\n        placement=\"right-start\"\n        closeOnEsc\n        closeOnOutsideClick\n        onRequestClose={(e) => {\n          // only close the sub menu if clicking anywhere outside the menu item that owns the sub menu\n          if (!e || !nodeRef.current || !nodeRef.current.contains(e.target as Node)) {\n            setOpen(false);\n          }\n        }}\n        reference={referenceCb}\n        // use the parent node to capture the li\n        container={nodeRef.current ? nodeRef.current.parentElement : nodeRef.current}\n        returnFocus\n      >\n        <div\n          ref={subMenuRef}\n          role=\"presentation\"\n          className=\"pf-c-dropdown pf-m-expanded\"\n          onMouseLeave={(e) => {\n            // only close the sub menu if the mouse does not enter the item\n            if (!nodeRef.current || !nodeRef.current.contains(e.relatedTarget as Node)) {\n              setOpen(false);\n            }\n          }}\n          onKeyDown={(e) => {\n            // close the sub menu on left arrow\n            if (e.keyCode === 37) {\n              setOpen(false);\n              e.stopPropagation();\n            }\n          }}\n        >\n          <DropdownMenu className=\"pf-c-dropdown__menu\" autoFocus>\n            {children}\n          </DropdownMenu>\n        </div>\n      </Popper>\n    </>\n  );\n};\n\nexport default ContextSubMenuItem;\n","export { default as ContextMenu } from './ContextMenu';\nexport { default as ContextSubMenuItem } from './ContextSubMenuItem';\n\n// re-export dropdown components as context menu components\nexport {\n  DropdownItem as ContextMenuItem,\n  DropdownSeparator as ContextMenuSeparator,\n} from '@patternfly/react-core';\n","import * as React from 'react';\nimport SVGDefsContext, { SVGDefsContextProps } from './SVGDefsContext';\n\ntype SVGDefsProps = {\n  id: string;\n  children: React.ReactNode;\n};\n\ntype SVGDefsSetterProps = SVGDefsContextProps & SVGDefsProps;\n\nexport class SVGDefsSetter extends React.Component<SVGDefsSetterProps> {\n  static contextType = SVGDefsContext;\n\n  componentDidMount() {\n    const { addDef, id, children } = this.props;\n    addDef(id, children);\n  }\n\n  componentDidUpdate() {\n    const { addDef, id, children } = this.props;\n    addDef(id, children);\n  }\n\n  componentWillUnmount() {\n    const { removeDef, id } = this.props;\n    removeDef(id);\n  }\n\n  render() {\n    return null;\n  }\n}\n\n/**\n * Contributes `children` to the parent SVG `<defs>` element.\n * A contribution is assumed to be static in nature in that the children will never change\n * for a given ID. This is because there may be multiple children referencing the same defs contribution.\n * The assumption must be that there is not a single owner but many owners and therefore each\n * owner must be contributing the same def.\n */\nexport default class SVGDefs extends React.Component<SVGDefsProps> {\n  shouldComponentUpdate() {\n    return false;\n  }\n\n  render() {\n    return (\n      <SVGDefsContext.Consumer>\n        {({ addDef, removeDef }) => (\n          <SVGDefsSetter {...this.props} addDef={addDef} removeDef={removeDef} />\n        )}\n      </SVGDefsContext.Consumer>\n    );\n  }\n}\n","import { createContext, ReactNode } from 'react';\n\nexport type SVGDefsContextProps = {\n  addDef(id: string, node: ReactNode): void;\n  removeDef(id: string): void;\n};\n\nconst SVGDefsContext = createContext<SVGDefsContextProps>(undefined as any);\n\nexport default SVGDefsContext;\n","import * as React from 'react';\nimport SVGDefsContext, { SVGDefsContextProps } from './SVGDefsContext';\n\ntype DefsMap = {\n  [id: string]: {\n    count: number;\n    node: React.ReactNode;\n  };\n};\n\nexport type DefsState = {\n  defs?: DefsMap;\n};\n\nexport class Defs extends React.PureComponent<{}, DefsState> {\n  constructor(props: {}) {\n    super(props);\n    this.state = {};\n  }\n\n  public setDefs(defs: DefsMap) {\n    // setting the state will re-render this component\n    this.setState({ defs: { ...defs } });\n  }\n\n  render() {\n    const { defs } = this.state;\n    return defs ? (\n      <defs>\n        {Object.keys(defs).map((id) => (\n          <React.Fragment key={id}>{defs[id].node}</React.Fragment>\n        ))}\n      </defs>\n    ) : null;\n  }\n}\n\nexport interface SVGDefsProviderProps {\n  children?: React.ReactNode;\n}\n\n/**\n * Renders a `<defs>` element and sets up a {@link SVGDefsContext} provider such that child components\n * may contribute to the `<defs>` without the parent component needing explicit knowledge of each contribution.\n * This helps decouple the parent implementation from the children and ensures that duplicate defs entries,\n * such as filters, are eliminated.\n */\nclass SVGDefsProvider extends React.Component<SVGDefsProviderProps> {\n  private readonly defsRef = React.createRef<Defs>();\n\n  private readonly defs: DefsMap = {};\n\n  private contextValue: SVGDefsContextProps = {\n    addDef: (id, node) => {\n      const defObj = this.defs[id];\n      if (defObj) {\n        defObj.count++;\n      } else {\n        this.defs[id] = {\n          count: 1,\n          node,\n        };\n        this.updateDefs();\n      }\n    },\n    removeDef: (id) => {\n      const defObj = this.defs[id];\n      if (--defObj.count === 0) {\n        delete this.defs[id];\n        this.updateDefs();\n      }\n    },\n  };\n\n  private updateDefs() {\n    // Set the defs directly on the child component so that only it will re-render.\n    // Does not use `setState` because otherwise all child components would be re-renders again\n    // when only the `Defs` component needs to be rendered.\n    this.defsRef.current && this.defsRef.current.setDefs(this.defs);\n  }\n\n  render() {\n    return (\n      <SVGDefsContext.Provider value={this.contextValue}>\n        <Defs ref={this.defsRef} />\n        {this.props.children}\n      </SVGDefsContext.Provider>\n    );\n  }\n}\n\nexport default SVGDefsProvider;\n","export { default as SVGDefs } from './SVGDefs';\nexport { default as SVGDefsProvider } from './SVGDefsProvider';\n","export * from './contextmenu';\nexport * from './defs';\nexport * from './layers';\nexport { default as ConnectorArrow } from './ConnectorArrow';\nexport { default as EdgeConnectorArrow } from './EdgeConnectorArrow';\nexport { default as GraphComponent } from './GraphComponent';\nexport { default as VisualizationSurface } from './VisualizationSurface';\nexport { default as DefaultCreateConnector } from './DefaultCreateConnector';\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { createPortal } from 'react-dom';\nimport ElementContext from '../../utils/ElementContext';\nimport LayersContext from './LayersContext';\nimport LayerContainer from './LayerContainer';\n\ntype LayerProps = {\n  id?: string;\n  children: React.ReactNode;\n  orderKey?: number;\n};\n\ntype LayerDelegateProps = {\n  id: string;\n  children: React.ReactNode;\n  orderKey?: number;\n};\n\nconst ORDER_KEY = '__order__';\n\nconst compare = (a: ChildNode, b: ChildNode): number => {\n  if (a === b) {\n    return 0;\n  }\n  const ao = a[ORDER_KEY];\n  const bo = b[ORDER_KEY];\n\n  if (ao == null || bo == null) {\n    return 0;\n  }\n\n  for (let i = 0; i < ao.length; i++) {\n    if (ao[i] !== bo[i]) {\n      return ao[i] - bo[i];\n    }\n  }\n  return ao.length === bo.length ? 0 : ao.length - bo.length;\n};\n\nconst LayerDelegate: React.FC<LayerDelegateProps> = observer(({ id, children, orderKey }) => {\n  const getLayerNode = React.useContext(LayersContext);\n  const layerNode = getLayerNode(id);\n\n  const element = React.useContext(ElementContext);\n  const nodeRef = React.useRef<SVGGElement | null>(null);\n  const order = id ? (orderKey != null ? orderKey : element.getOrderKey()) : undefined;\n\n  React.useEffect(() => {\n    // TODO use bisection search\n    if (nodeRef.current && layerNode != null) {\n      nodeRef.current[ORDER_KEY] = order;\n      const { childNodes } = layerNode;\n      // childNodes is not an array, disable false positive\n      // eslint-disable-next-line @typescript-eslint/prefer-for-of\n      for (let i = 0; i < childNodes.length; i++) {\n        const result = compare(nodeRef.current, childNodes[i]);\n        if (result < 0) {\n          if (i > 0 && childNodes[i - 1] !== nodeRef.current) {\n            layerNode.insertBefore(nodeRef.current, childNodes[i]);\n          }\n          return;\n        }\n      }\n      if (childNodes[childNodes.length - 1] !== nodeRef.current) {\n        layerNode.appendChild(nodeRef.current);\n      }\n    }\n  }, [order, layerNode]);\n\n  return createPortal(<LayerContainer ref={nodeRef}>{children}</LayerContainer>, layerNode);\n});\n\nconst Layer: React.FC<LayerProps> = ({ id, children, orderKey }) => {\n  return id ? (\n    <LayerDelegate id={id} orderKey={orderKey}>\n      {children}\n    </LayerDelegate>\n  ) : (\n    <>{children}</>\n  );\n};\n\nexport default Layer;\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../../utils/ElementContext';\nimport { isNode } from '../../types';\nimport { ATTR_DATA_ID, ATTR_DATA_KIND, ATTR_DATA_TYPE } from '../../const';\n\ntype LayerContainerProps = {\n  children: React.ReactNode;\n};\n\nconst LayerContainer: React.RefForwardingComponent<SVGGElement, LayerContainerProps> = (\n  { children },\n  ref,\n) => {\n  // accumulate parent positions\n  const element = React.useContext(ElementContext);\n  let p = element;\n  let x = 0;\n  let y = 0;\n  while (isNode(p)) {\n    if (!p.isGroup() || p.isCollapsed()) {\n      const { x: px, y: py } = p.getPosition();\n      x += px;\n      y += py;\n    }\n    p = p.getParent();\n  }\n  const commonAttrs = {\n    [ATTR_DATA_ID]: element.getId(),\n    [ATTR_DATA_KIND]: element.getKind(),\n    [ATTR_DATA_TYPE]: element.getType(),\n  };\n  return (\n    <g ref={ref} transform={`translate(${x}, ${y})`} {...commonAttrs}>\n      {children}\n    </g>\n  );\n};\n\nexport default observer(React.forwardRef(LayerContainer));\n","import { createContext } from 'react';\n\ntype LayersContextProps = (id: string) => Element;\n\nconst LayersContext = createContext<LayersContextProps>(undefined as any);\n\nexport default LayersContext;\n","import * as React from 'react';\nimport { DEFAULT_LAYER } from '../../const';\nimport LayersContext from './LayersContext';\n\ntype LayersProviderProps = {\n  layers?: string[];\n  children?: React.ReactNode;\n};\n\ntype State = { [id: string]: Element };\n\nexport default class LayersProvider extends React.Component<LayersProviderProps, State> {\n  constructor(props: LayersProviderProps) {\n    super(props);\n    this.state = {};\n  }\n\n  private contextValue = (id: string): Element => {\n    if (this.state[id]) {\n      return this.state[id];\n    }\n    throw new Error(`Unknown layer '${id}'`);\n  };\n\n  private setDomLayers = (node: SVGGElement | null, id: string) => {\n    if (node && this.state[id] !== node) {\n      this.setState((state) => ({ ...state, [id]: node }));\n    }\n  };\n\n  getLayerNode = (id: string): Element => {\n    const node = this.state[id];\n    if (node) {\n      return node;\n    }\n    throw new Error(`Unknown layer '${id}'`);\n  };\n\n  render() {\n    const { layers, children } = this.props;\n    if (layers && !layers.includes(DEFAULT_LAYER)) {\n      throw new Error('Missing default layer.');\n    }\n    const layerIds = layers || [DEFAULT_LAYER];\n    return (\n      <LayersContext.Provider value={this.contextValue}>\n        {layerIds.map((id) => (\n          <g key={id} data-layer-id={id} ref={(r) => this.setDomLayers(r, id)}>\n            {id === DEFAULT_LAYER && this.state[id] ? children : undefined}\n          </g>\n        ))}\n      </LayersContext.Provider>\n    );\n  }\n}\n","export { default as Layer } from './Layer';\nexport { default as LayersProvider } from './LayersProvider';\n","export const ATTR_DATA_KIND = 'data-kind';\nexport const ATTR_DATA_TYPE = 'data-type';\nexport const ATTR_DATA_ID = 'data-id';\n\nexport const TOP_LAYER = 'top';\nexport const DEFAULT_LAYER = 'default';\nexport const GROUPS_LAYER = 'groups';\nexport const BOTTOM_LAYER = 'bottom';\n\nexport const DEFAULT_LAYERS = [BOTTOM_LAYER, GROUPS_LAYER, DEFAULT_LAYER, TOP_LAYER];\n","import { observable, computed } from 'mobx';\nimport Point from '../geom/Point';\nimport { Edge, Node, EdgeModel, ModelKind, AnchorEnd, Anchor } from '../types';\nimport { getTopCollapsedParent } from '../utils';\nimport BaseElement from './BaseElement';\n\nexport default class BaseEdge<E extends EdgeModel = EdgeModel, D = any> extends BaseElement<E, D>\n  implements Edge<E, D> {\n  @observable.ref\n  private source?: Node;\n\n  @observable.ref\n  private target?: Node;\n\n  @observable.shallow\n  private bendpoints?: Point[];\n\n  @observable.ref\n  private startPoint?: Point;\n\n  @observable.ref\n  private endPoint?: Point;\n\n  @computed\n  private get sourceAnchor(): Anchor {\n    return this.getSourceAnchorNode().getAnchor(AnchorEnd.source, this.getType());\n  }\n\n  @computed\n  private get targetAnchor(): Anchor {\n    return this.getTargetAnchorNode().getAnchor(AnchorEnd.target, this.getType());\n  }\n\n  getKind(): ModelKind {\n    return ModelKind.edge;\n  }\n\n  getSource(): Node {\n    if (!this.source) {\n      throw new Error(`Edge with ID '${this.getId()}' has no source.`);\n    }\n    return this.source;\n  }\n\n  setSource(source: Node) {\n    this.source = source;\n  }\n\n  getTarget(): Node {\n    if (!this.target) {\n      throw new Error(`Edge with ID '${this.getId()}' has no target.`);\n    }\n    return this.target;\n  }\n\n  setTarget(target: Node) {\n    this.target = target;\n  }\n\n  getSourceAnchorNode(): Node {\n    if (!this.source) {\n      throw new Error(`Edge with ID '${this.getId()}' has no source.`);\n    }\n    return getTopCollapsedParent(this.source);\n  }\n\n  getTargetAnchorNode(): Node {\n    if (!this.target) {\n      throw new Error(`Edge with ID '${this.getId()}' has no target.`);\n    }\n    return getTopCollapsedParent(this.target);\n  }\n\n  getBendpoints(): Point[] {\n    return this.bendpoints || [];\n  }\n\n  setBendpoints(points: Point[]) {\n    this.bendpoints = points;\n  }\n\n  removeBendpoint(point: Point | number): void {\n    if (this.bendpoints) {\n      if (typeof point === 'number') {\n        this.bendpoints.splice(point, 1);\n      } else {\n        const idx = this.bendpoints.indexOf(point);\n        if (idx !== -1) {\n          this.bendpoints.splice(idx, 1);\n        }\n      }\n    }\n  }\n\n  getStartPoint(): Point {\n    if (this.startPoint) {\n      return this.startPoint;\n    }\n    const bendpoints = this.getBendpoints();\n    let referencePoint: Point;\n    if (bendpoints && bendpoints.length > 0) {\n      [referencePoint] = bendpoints;\n    } else if (this.endPoint) {\n      referencePoint = this.endPoint;\n    } else {\n      referencePoint = this.targetAnchor.getReferencePoint();\n    }\n    return this.sourceAnchor.getLocation(referencePoint);\n  }\n\n  setStartPoint(x?: number, y?: number): void {\n    if (x == null || y == null) {\n      this.startPoint = undefined;\n    } else {\n      this.startPoint = new Point(x, y);\n    }\n  }\n\n  getEndPoint(): Point {\n    if (this.endPoint) {\n      return this.endPoint;\n    }\n    const bendpoints = this.getBendpoints();\n    let referencePoint: Point;\n    if (bendpoints && bendpoints.length > 0) {\n      referencePoint = bendpoints[bendpoints.length - 1];\n    } else if (this.startPoint) {\n      referencePoint = this.startPoint;\n    } else {\n      referencePoint = this.sourceAnchor.getReferencePoint();\n    }\n    return this.targetAnchor.getLocation(referencePoint);\n  }\n\n  setEndPoint(x?: number, y?: number): void {\n    if (x == null || y == null) {\n      this.endPoint = undefined;\n    } else {\n      this.endPoint = new Point(x, y);\n    }\n  }\n\n  setModel(model: E): void {\n    super.setModel(model);\n    if (model.source) {\n      const node = this.getController().getNodeById(model.source);\n      if (!node) {\n        throw new Error(`No source node found with ID '${model.source}'.`);\n      }\n      this.source = node;\n    }\n    if (model.target) {\n      const node = this.getController().getNodeById(model.target);\n      if (!node) {\n        throw new Error(`No target node found with ID '${model.target}'.`);\n      }\n      this.target = node;\n    }\n    if ('bendpoints' in model) {\n      this.bendpoints = model.bendpoints ? model.bendpoints.map((b) => new Point(b[0], b[1])) : [];\n    }\n  }\n}\n","import { observable, computed } from 'mobx';\nimport * as _ from 'lodash';\nimport {\n  ElementModel,\n  Graph,\n  GraphElement,\n  isGraph,\n  isNode,\n  Controller,\n  ModelKind,\n  ADD_CHILD_EVENT,\n  REMOVE_CHILD_EVENT,\n  ELEMENT_VISIBILITY_CHANGE_EVENT,\n} from '../types';\nimport Stateful from '../utils/Stateful';\nimport { Translatable } from '../geom/types';\n\nexport default abstract class BaseElement<E extends ElementModel = ElementModel, D = any>\n  extends Stateful\n  implements GraphElement<E, D> {\n  private id: string = '';\n\n  @observable\n  private type: string = '';\n\n  @observable.ref\n  private data?: D;\n\n  @observable.ref\n  private parent?: GraphElement;\n\n  @observable\n  private visible: boolean = true;\n\n  @observable.shallow\n  private children: GraphElement[] = [];\n\n  @observable.ref\n  private controller?: Controller;\n\n  @observable\n  private label?: string;\n\n  @observable\n  private style: any = {};\n\n  abstract getKind(): ModelKind;\n\n  @computed({ equals: _.isEqual })\n  private get ordering(): number[] {\n    if (!this.parent) {\n      return [];\n    }\n    const idx = this.parent.getChildren().indexOf(this);\n    const result = [...this.parent.getOrderKey(), idx];\n    return result;\n  }\n\n  getLabel(): string {\n    return this.label || '';\n  }\n\n  setLabel(label: string): void {\n    this.label = label;\n  }\n\n  getOrderKey(): number[] {\n    return this.ordering;\n  }\n\n  getController(): Controller {\n    if (!this.controller) {\n      throw new Error(`GraphElement with ID '${this.getId()}' has no controller.`);\n    }\n    return this.controller;\n  }\n\n  setController(controller: Controller): void {\n    this.controller = controller;\n  }\n\n  getGraph(): Graph {\n    // TODO fix project eslint rules\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    let p: GraphElement = this;\n    while (!isGraph(p)) {\n      p = p.getParent();\n    }\n    return p;\n  }\n\n  getParent(): GraphElement {\n    if (!this.parent) {\n      throw new Error(`GraphElement with ID '${this.getId()}' has no parent.`);\n    }\n    return this.parent;\n  }\n\n  setParent(parent: GraphElement): void {\n    if (this.parent !== parent) {\n      if (this.parent) {\n        this.remove();\n      }\n      this.parent = parent;\n    }\n  }\n\n  hasParent(): boolean {\n    return this.parent !== undefined;\n  }\n\n  getId(): string {\n    return this.id;\n  }\n\n  setId(id: string): void {\n    this.id = id;\n  }\n\n  getType(): string {\n    return this.type;\n  }\n\n  setType(type: string): void {\n    this.type = type;\n  }\n\n  setVisible(visible: boolean): void {\n    if (this.visible !== visible) {\n      this.visible = visible;\n      if (this.controller) {\n        this.controller.fireEvent(ELEMENT_VISIBILITY_CHANGE_EVENT, { visible, target: this });\n      }\n    }\n  }\n\n  isVisible(): boolean {\n    return (\n      this.visible &&\n      (!this.parent ||\n        (this.parent.isVisible() && (!isNode(this.parent) || !this.parent.isCollapsed())))\n    );\n  }\n\n  getData(): D | undefined {\n    return this.data;\n  }\n\n  setData(data: D | undefined): void {\n    this.data = data;\n  }\n\n  getStyle<T extends {}>(): T {\n    return this.style;\n  }\n\n  getChildren(): GraphElement[] {\n    return this.children;\n  }\n\n  insertChild(child: GraphElement, index: number) {\n    if (\n      this.children.length === 0 ||\n      index >= this.children.length ||\n      this.children[index] !== child\n    ) {\n      const idx = this.children.indexOf(child);\n      if (idx !== -1) {\n        this.children.splice(idx, 1);\n        this.children.splice(index, 0, child);\n      } else {\n        // remove from old parent\n        child.remove();\n        child.setParent(this);\n        this.children.splice(index, 0, child);\n\n        if (this.controller) {\n          this.controller.fireEvent(ADD_CHILD_EVENT, { target: this, child });\n        }\n      }\n    }\n  }\n\n  appendChild(child: GraphElement) {\n    if (this.children.length === 0 || this.children[this.children.length - 1] !== child) {\n      const idx = this.children.indexOf(child);\n      if (idx !== -1) {\n        this.children.splice(idx, 1);\n        this.children.push(child);\n      } else {\n        // remove from old parent\n        child.remove();\n        child.setParent(this);\n        this.children.push(child);\n\n        if (this.controller) {\n          this.controller.fireEvent(ADD_CHILD_EVENT, { target: this, child });\n        }\n      }\n    }\n  }\n\n  removeChild(child: GraphElement) {\n    if (this.children) {\n      const idx = this.children.indexOf(child);\n      if (idx !== -1) {\n        this.children.splice(idx, 1);\n        child.setParent(undefined);\n\n        if (this.controller) {\n          this.controller.fireEvent(REMOVE_CHILD_EVENT, { target: this, child });\n        }\n      }\n    }\n  }\n\n  remove(): void {\n    if (this.parent) {\n      this.parent.removeChild(this);\n    }\n  }\n\n  setModel(model: E): void {\n    if ('type' in model) {\n      this.setType(model.type);\n    }\n    if ('visible' in model) {\n      this.setVisible(!!model.visible);\n    }\n    if (Array.isArray(model.children)) {\n      const controller = this.getController();\n\n      const childElements = model.children.map((id) => {\n        const element = controller.getElementById(id);\n        if (!element) {\n          throw new Error(`No element found with ID '${id}'.`);\n        }\n        return element;\n      });\n\n      // remove children\n      _.difference(this.children, childElements).forEach((child) => this.removeChild(child));\n\n      // add children\n      const toAdd = _.difference(childElements, this.children);\n      toAdd.reverse().forEach((child) => this.insertChild(child, 0));\n    }\n    if ('data' in model) {\n      this.data = model.data;\n    }\n    if ('label' in model) {\n      this.label = model.label;\n    }\n    if ('style' in model) {\n      _.merge(this.style, model.style);\n    }\n  }\n\n  raise(): void {\n    const { parent } = this;\n    if (parent) {\n      parent.appendChild(this);\n      parent.raise();\n    }\n  }\n\n  translateToAbsolute(t: Translatable): void {\n    this.translateToParent(t);\n    const { parent } = this;\n    if (parent) {\n      parent.translateToAbsolute(t);\n    }\n  }\n\n  translateFromAbsolute(t: Translatable): void {\n    const { parent } = this;\n    if (parent) {\n      parent.translateFromAbsolute(t);\n    }\n    this.translateFromParent(t);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  translateToParent(t: Translatable): void {\n    // nothing to do\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  translateFromParent(t: Translatable): void {\n    // nothing to do\n  }\n\n  destroy(): void {\n    // nothing to do\n  }\n}\n","import { computed, observable } from 'mobx';\nimport Rect from '../geom/Rect';\nimport Point from '../geom/Point';\nimport Dimensions from '../geom/Dimensions';\nimport { DEFAULT_LAYERS } from '../const';\nimport {\n  Graph,\n  Edge,\n  Node,\n  GraphModel,\n  ModelKind,\n  isNode,\n  isEdge,\n  Layout,\n  ScaleExtent,\n} from '../types';\nimport BaseElement from './BaseElement';\n\nexport default class BaseGraph<E extends GraphModel = GraphModel, D = any> extends BaseElement<E, D>\n  implements Graph<E, D> {\n  @observable.ref\n  private layers = DEFAULT_LAYERS;\n\n  @observable\n  private scale = 1;\n\n  @observable\n  private layoutType?: string;\n\n  @observable.ref\n  private dimensions = new Dimensions();\n\n  @observable.ref\n  private position = new Point();\n\n  private currentLayout?: Layout;\n\n  @observable.ref\n  private scaleExtent: ScaleExtent = [0.25, 4];\n\n  @computed\n  private get edges(): Edge[] {\n    return this.getChildren().filter(isEdge);\n  }\n\n  @computed\n  private get nodes(): Node[] {\n    return this.getChildren().filter(isNode);\n  }\n\n  getKind(): ModelKind {\n    return ModelKind.graph;\n  }\n\n  getLayers(): string[] {\n    return this.layers;\n  }\n\n  setLayers(layers: string[]): void {\n    this.layers = layers;\n  }\n\n  getScaleExtent(): ScaleExtent {\n    return this.scaleExtent;\n  }\n\n  setScaleExtent(scaleExtent: ScaleExtent): void {\n    this.scaleExtent = scaleExtent;\n  }\n\n  getBounds(): Rect {\n    const {\n      position: { x, y },\n      dimensions: { width, height },\n    } = this;\n    return new Rect(x, y, width, height);\n  }\n\n  setBounds(bounds: Rect): void {\n    const { width, height } = this.dimensions;\n    if (bounds.width !== width || bounds.height !== height) {\n      this.dimensions = new Dimensions(bounds.width, bounds.height);\n    }\n    const { x, y } = this.position;\n    if (bounds.x !== x || bounds.y !== y) {\n      this.position = new Point(bounds.x, bounds.y);\n    }\n  }\n\n  getPosition(): Point {\n    return this.position;\n  }\n\n  setPosition(point: Point): void {\n    this.position = point;\n  }\n\n  getDimensions(): Dimensions {\n    return this.dimensions;\n  }\n\n  setDimensions(dimensions: Dimensions): void {\n    this.dimensions = dimensions;\n  }\n\n  getNodes(): Node[] {\n    return this.nodes;\n  }\n\n  getEdges(): Edge[] {\n    return this.edges;\n  }\n\n  getLayout(): string | undefined {\n    return this.layoutType;\n  }\n\n  setLayout(layout: string | undefined): void {\n    if (layout === this.layoutType) {\n      return;\n    }\n\n    if (this.currentLayout) {\n      this.currentLayout.destroy();\n    }\n\n    this.layoutType = layout;\n    this.currentLayout = layout ? this.getController().getLayout(layout) : undefined;\n  }\n\n  layout(): void {\n    if (this.currentLayout) {\n      this.currentLayout.layout();\n    }\n  }\n\n  getScale(): number {\n    return this.scale;\n  }\n\n  setScale(scale: number): void {\n    this.scale = scale;\n  }\n\n  reset(): void {\n    this.scale = 1;\n    this.position = new Point(0, 0);\n  }\n\n  scaleBy(scale: number, location?: Point): void {\n    const b = this.getBounds();\n    let { x, y } = b;\n    const c = location || b.getCenter().translate(-x, -y);\n    x = (c.x - x) / this.scale;\n    y = (c.y - y) / this.scale;\n    const newScale = Math.max(\n      Math.min(this.scale * scale, this.scaleExtent[1]),\n      this.scaleExtent[0],\n    );\n    this.setScale(newScale);\n    x = c.x - x * this.scale;\n    y = c.y - y * this.scale;\n    this.position = new Point(x, y);\n  }\n\n  fit(padding = 0): void {\n    let rect: Rect | undefined;\n    this.getNodes().forEach((c) => {\n      const b = c.getBounds();\n      if (!rect) {\n        rect = b.clone();\n      } else {\n        rect.union(b);\n      }\n    });\n    if (!rect) {\n      return;\n    }\n\n    const { width, height } = rect;\n\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    const { width: fullWidth, height: fullHeight } = this.getDimensions();\n    const midX = rect.x + width / 2;\n    const midY = rect.y + height / 2;\n\n    // set the max scale to be the current zoom level or 1\n    const maxScale = Math.max(this.getScale(), 1);\n\n    // compute the scale\n    const scale = Math.min(\n      1 /\n        Math.max(\n          width / Math.max(1, fullWidth - padding),\n          height / Math.max(1, fullHeight - padding),\n        ),\n      maxScale,\n    );\n\n    // translate to center\n    const tx = fullWidth / 2 - midX * scale;\n    const ty = fullHeight / 2 - midY * scale;\n\n    // TODO should scale and bound be kept in a single geom Transform object instead of separately?\n    this.scale = scale;\n    this.position = new Point(tx, ty);\n  }\n\n  panIntoView = (\n    nodeElement: Node,\n    { offset = 0, minimumVisible = 0 }: { offset?: number; minimumVisible?: number } = {},\n  ): void => {\n    if (!nodeElement) {\n      return;\n    }\n    const { x: viewX, y: viewY, width: viewWidth, height: viewHeight } = this.getBounds();\n    const boundingBox = nodeElement\n      .getBounds()\n      .clone()\n      .scale(this.scale)\n      .translate(viewX, viewY);\n    const { x, y, width, height } = boundingBox;\n    let move = false;\n    const panOffset = offset * this.scale;\n    const minVisibleSize = minimumVisible * this.scale;\n\n    const newLocation = {\n      x: viewX,\n      y: viewY,\n    };\n\n    if (x + width - minVisibleSize < 0) {\n      newLocation.x -= x - panOffset;\n      move = true;\n    }\n    if (x + minVisibleSize > viewWidth) {\n      newLocation.x -= x + width - viewWidth + panOffset;\n      move = true;\n    }\n    if (y + height - minVisibleSize < 0) {\n      newLocation.y -= y - panOffset;\n      move = true;\n    }\n    if (y + minVisibleSize > viewHeight) {\n      newLocation.y -= y + height - viewHeight + panOffset;\n      move = true;\n    }\n\n    if (move) {\n      this.setBounds(new Rect(newLocation.x, newLocation.y, viewWidth, viewHeight));\n    }\n  };\n\n  setModel(model: E): void {\n    super.setModel(model);\n\n    if ('layers' in model && model.layers) {\n      this.setLayers(model.layers);\n    }\n    if ('layout' in model) {\n      this.setLayout(model.layout);\n    }\n    if (model.scaleExtent?.length === 2) {\n      this.setScaleExtent(model.scaleExtent);\n    }\n    if ('scale' in model && typeof model.scale === 'number') {\n      this.setScale(+model.scale);\n    }\n    let p: Point | undefined;\n    if ('x' in model && model.x != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.x = model.x;\n    }\n    if ('y' in model && model.y != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.y = model.y;\n    }\n    if (p) {\n      this.setPosition(p);\n    }\n  }\n\n  translateToAbsolute(): void {\n    // do nothing\n  }\n\n  translateFromAbsolute(): void {\n    // do nothing\n  }\n\n  destroy(): void {\n    if (this.currentLayout) {\n      this.currentLayout.destroy();\n    }\n  }\n}\n","import { observable, computed } from 'mobx';\nimport {\n  Node,\n  Anchor,\n  NodeModel,\n  ModelKind,\n  isNode,\n  isEdge,\n  AnchorEnd,\n  NodeStyle,\n  NodeShape,\n  Edge,\n  GraphElement,\n  NODE_COLLAPSE_CHANGE_EVENT,\n} from '../types';\nimport CenterAnchor from '../anchors/CenterAnchor';\nimport Rect from '../geom/Rect';\nimport { Translatable } from '../geom/types';\nimport BaseElement from './BaseElement';\nimport Dimensions from '../geom/Dimensions';\nimport Point from '../geom/Point';\n\nconst createAnchorKey = (end: AnchorEnd = AnchorEnd.both, type: string = ''): string =>\n  `${end}:${type}`;\n\nexport default class BaseNode<E extends NodeModel = NodeModel, D = any> extends BaseElement<E, D>\n  implements Node<E, D> {\n  @observable.shallow\n  private anchors: { [type: string]: Anchor } = {\n    [createAnchorKey()]: new CenterAnchor(this),\n  };\n\n  @observable.ref\n  private dimensions = new Dimensions();\n\n  @observable.ref\n  private position = new Point();\n\n  @computed\n  private get nodes(): Node[] {\n    if (this.isCollapsed()) {\n      return [];\n    }\n\n    return this.getChildren().filter(isNode);\n  }\n\n  @observable\n  private group = false;\n\n  @observable\n  private collapsed = false;\n\n  @observable\n  private shape: NodeShape | undefined;\n\n  @computed\n  private get groupBounds(): Rect {\n    const children = this.getChildren()\n      .filter(isNode)\n      .filter((n) => n.isVisible());\n    if (!children.length) {\n      return this.getInternalBounds();\n    }\n\n    let rect: Rect | undefined;\n    children.forEach((c) => {\n      if (isNode(c)) {\n        const { padding } = c.getStyle<NodeStyle>();\n        const b = c.getBounds();\n        // Currently non-group nodes do not include their padding in the bounds\n        if (!c.isGroup() && padding) {\n          b.padding(c.getStyle<NodeStyle>().padding);\n        }\n        if (!rect) {\n          rect = b.clone();\n        } else {\n          rect.union(b);\n        }\n      }\n    });\n\n    if (!rect) {\n      rect = new Rect();\n    }\n\n    const { padding } = this.getStyle<NodeStyle>();\n\n    return rect.padding(padding);\n  }\n\n  @computed\n  private get sourceEdges(): Edge[] {\n    return this.getGraph()\n      .getEdges()\n      .filter((e) => e.getSource() === this);\n  }\n\n  @computed\n  private get targetEdges(): Edge[] {\n    return this.getGraph()\n      .getEdges()\n      .filter((e) => e.getTarget() === this);\n  }\n\n  getChildren(): GraphElement[] {\n    if (this.isCollapsed()) {\n      return super.getChildren().filter(isEdge);\n    }\n    return super.getChildren();\n  }\n\n  getKind(): ModelKind {\n    return ModelKind.node;\n  }\n\n  private getInternalBounds(): Rect {\n    const { position, dimensions } = this;\n    return new Rect(position.x, position.y, dimensions.width, dimensions.height);\n  }\n\n  getBounds(): Rect {\n    return this.group && !this.collapsed ? this.groupBounds : this.getInternalBounds();\n  }\n\n  setBounds(bounds: Rect): void {\n    const { width, height } = this.dimensions;\n    if (bounds.width !== width || bounds.height !== height) {\n      this.dimensions = new Dimensions(bounds.width, bounds.height);\n    }\n    const { x, y } = this.position;\n    if (bounds.x !== x || bounds.y !== y) {\n      this.position = new Point(bounds.x, bounds.y);\n    }\n  }\n\n  getPosition(): Point {\n    return this.position;\n  }\n\n  setPosition(point: Point): void {\n    this.position = point;\n  }\n\n  getDimensions(): Dimensions {\n    return this.dimensions;\n  }\n\n  setDimensions(dimensions: Dimensions): void {\n    this.dimensions = dimensions;\n  }\n\n  getAnchor(end?: AnchorEnd, type?: string): Anchor {\n    let anchor = this.anchors[createAnchorKey(end, type)];\n    if (!anchor && type) {\n      anchor = this.anchors[createAnchorKey(end)];\n    }\n    if (!anchor && (end === AnchorEnd.source || end === AnchorEnd.target)) {\n      anchor = this.anchors[createAnchorKey(AnchorEnd.both, type)];\n      if (!anchor && type) {\n        anchor = this.anchors[createAnchorKey(AnchorEnd.both)];\n      }\n    }\n    return anchor;\n  }\n\n  setAnchor(anchor: Anchor, end?: AnchorEnd, type?: string): void {\n    const key = createAnchorKey(end, type);\n    if (anchor) {\n      this.anchors[key] = anchor;\n    } else {\n      delete this.anchors[key];\n    }\n  }\n\n  getNodes(): Node[] {\n    return this.nodes;\n  }\n\n  isGroup(): boolean {\n    return this.group;\n  }\n\n  setGroup(group: boolean): void {\n    this.group = group;\n  }\n\n  isCollapsed(): boolean {\n    return this.collapsed;\n  }\n\n  setCollapsed(collapsed: boolean): void {\n    if (collapsed !== this.collapsed) {\n      // Get the location prior to the collapse change and apply it after the collapse.\n      // This updates the new node(s) location(s) to be what the node was originally, basically\n      // keeping the nodes ln place so the layout doesn't start fresh (putting the new nodes at 0,0\n      // TODO: Update to better position the nodes at a point location rather than relying on the setCenter updating the nodes.\n      const prevCenter = this.getBounds().getCenter();\n      this.collapsed = collapsed;\n      this.setBounds(this.getBounds().setCenter(prevCenter.x, prevCenter.y));\n      this.getController().fireEvent(NODE_COLLAPSE_CHANGE_EVENT, { node: this });\n    }\n  }\n\n  getNodeShape(): NodeShape {\n    return this.shape || (this.group ? NodeShape.rect : NodeShape.circle);\n  }\n\n  setNodeShape(shape: NodeShape): void {\n    this.shape = shape;\n  }\n\n  getSourceEdges(): Edge[] {\n    return this.sourceEdges;\n  }\n\n  getTargetEdges(): Edge[] {\n    return this.targetEdges;\n  }\n\n  setModel(model: E): void {\n    super.setModel(model);\n    let d: Dimensions | undefined;\n    let p: Point | undefined;\n\n    if ('width' in model && model.width != null) {\n      if (!d) {\n        d = this.dimensions.clone();\n      }\n      d.width = model.width;\n    }\n    if ('height' in model && model.height != null) {\n      if (!d) {\n        d = this.dimensions.clone();\n      }\n      d.height = model.height;\n    }\n    if (d) {\n      this.setDimensions(d);\n    }\n\n    if ('x' in model && model.x != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.x = model.x;\n    }\n    if ('y' in model && model.y != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.y = model.y;\n    }\n    if (p) {\n      this.setPosition(p);\n    }\n\n    if ('group' in model) {\n      this.setGroup(!!model.group);\n    }\n    if ('shape' in model) {\n      this.shape = model.shape;\n    }\n    if ('collapsed' in model) {\n      this.setCollapsed(!!model.collapsed);\n    }\n  }\n\n  translateToParent(t: Translatable): void {\n    if (!this.group || this.isCollapsed()) {\n      const { x, y } = this.getPosition();\n      t.translate(x, y);\n    }\n  }\n\n  translateFromParent(t: Translatable): void {\n    if (!this.group || this.isCollapsed()) {\n      const { x, y } = this.getPosition();\n      t.translate(-x, -y);\n    }\n  }\n}\n","import { ElementFactory, GraphElement, ModelKind } from '../types';\nimport BaseEdge from './BaseEdge';\nimport BaseGraph from './BaseGraph';\nimport BaseNode from './BaseNode';\n\nconst defaultElementFactory: ElementFactory = (kind: ModelKind): GraphElement | undefined => {\n  switch (kind) {\n    case ModelKind.graph:\n      return new BaseGraph();\n    case ModelKind.node:\n      return new BaseNode();\n    case ModelKind.edge:\n      return new BaseEdge();\n    default:\n      return undefined;\n  }\n};\n\nexport default defaultElementFactory;\n","export { default as BaseEdge } from './BaseEdge';\nexport { default as BaseElement } from './BaseElement';\nexport { default as BaseGraph } from './BaseGraph';\nexport { default as BaseNode } from './BaseNode';\nexport { default as defaultElementFactory } from './defaultElementFactory';\n","import { IDimensions } from './types';\n\nexport default class Dimensions implements IDimensions {\n  static readonly EMPTY = new Dimensions();\n\n  width: number = 0;\n\n  height: number = 0;\n\n  private static SINGLETON = new Dimensions();\n\n  static singleUse(width: number = 0, height: number = 0) {\n    Dimensions.SINGLETON.width = width;\n    Dimensions.SINGLETON.height = height;\n    return Dimensions.SINGLETON;\n  }\n\n  static fromDimensions(dimension: IDimensions): Dimensions {\n    return new Dimensions(dimension.width, dimension.height);\n  }\n\n  constructor(width: number = 0, height: number = 0) {\n    this.width = width;\n    this.height = height;\n  }\n\n  isEmpty(): boolean {\n    return this.width <= 0 || this.height <= 0;\n  }\n\n  setSize(w: number, h: number): Dimensions {\n    this.width = w;\n    this.height = h;\n    return this;\n  }\n\n  scale(scaleX: number, scaleY?: number): Dimensions {\n    const sy = scaleY != null ? scaleY : scaleX;\n    this.width *= scaleX;\n    this.height *= sy;\n    return this;\n  }\n\n  resize(dw: number, dh: number): Dimensions {\n    this.width += dw;\n    this.height += dh;\n    return this;\n  }\n\n  expand(h: number, v: number): Dimensions {\n    this.height += v * 2;\n    this.width += h * 2;\n    return this;\n  }\n\n  clone(): Dimensions {\n    return Dimensions.fromDimensions(this);\n  }\n\n  equals(r: IDimensions) {\n    return r.width === this.width && r.height === this.height;\n  }\n}\n","import { Translatable, IPoint } from './types';\n\nexport default class Point implements Translatable, IPoint {\n  static readonly EMPTY = new Point();\n\n  x: number;\n\n  y: number;\n\n  private static SINGLETON = new Point();\n\n  static singleUse(x: number = 0, y: number = 0) {\n    Point.SINGLETON.x = x;\n    Point.SINGLETON.y = y;\n    return Point.SINGLETON;\n  }\n\n  static fromPoint(point: IPoint): Point {\n    return new Point(point.x, point.y);\n  }\n\n  constructor(x: number = 0, y: number = 0) {\n    this.x = x;\n    this.y = y;\n  }\n\n  setLocation(x: number, y: number): Point {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  negate(): Point {\n    this.x = -this.x;\n    this.y = -this.y;\n    return this;\n  }\n\n  translate(dx: number, dy: number): Point {\n    this.x += dx;\n    this.y += dy;\n    return this;\n  }\n\n  scale(scaleX: number, scaleY?: number): Point {\n    this.x *= scaleX;\n    this.y *= scaleY != null ? scaleY : scaleX;\n    return this;\n  }\n\n  clone(): Point {\n    return Point.fromPoint(this);\n  }\n\n  equals(p: IPoint) {\n    return p.x === this.x && p.y === this.y;\n  }\n}\n","import { Padding, Translatable, IRect } from './types';\nimport Point from './Point';\n\nexport default class Rect implements Translatable, IRect {\n  static readonly EMPTY = new Rect();\n\n  width: number = 0;\n\n  height: number = 0;\n\n  x: number = 0;\n\n  y: number = 0;\n\n  private static SINGLETON = new Rect();\n\n  static singleUse(x: number = 0, y: number = 0, width: number = 0, height: number = 0) {\n    Rect.SINGLETON.x = x;\n    Rect.SINGLETON.y = y;\n    Rect.SINGLETON.width = width;\n    Rect.SINGLETON.height = height;\n    return Rect.SINGLETON;\n  }\n\n  static fromRect(rect: IRect): Rect {\n    return new Rect(rect.x, rect.y, rect.width, rect.height);\n  }\n\n  constructor(x: number = 0, y: number = 0, width: number = 0, height: number = 0) {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n  }\n\n  isEmpty(): boolean {\n    return this.width <= 0 || this.height <= 0;\n  }\n\n  setLocation(x: number, y: number): Rect {\n    this.x = x;\n    this.y = y;\n    return this;\n  }\n\n  setSize(w: number, h: number): Rect {\n    this.width = w;\n    this.height = h;\n    return this;\n  }\n\n  getCenter(): Point {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n\n  setCenter(x: number, y: number): Rect {\n    this.x = x - this.width / 2;\n    this.y = y - this.height / 2;\n    return this;\n  }\n\n  translate(dx: number, dy: number): Rect {\n    this.x += dx;\n    this.y += dy;\n    return this;\n  }\n\n  scale(scaleX: number, scaleY?: number): Rect {\n    const sy = scaleY != null ? scaleY : scaleX;\n    const xx = this.x;\n    const yy = this.y;\n    this.x *= scaleX;\n    this.y *= sy;\n    this.width = (xx + this.width) * scaleX - this.x;\n    this.height = (yy + this.height) * sy - this.y;\n    return this;\n  }\n\n  resize(dw: number, dh: number): Rect {\n    this.width += dw;\n    this.height += dh;\n    return this;\n  }\n\n  bottom(): number {\n    return this.y + this.height;\n  }\n\n  right(): number {\n    return this.x + this.width;\n  }\n\n  union({ x, y, width, height }: Rect): Rect {\n    const right = Math.max(this.x + this.width, x + width);\n    const bottom = Math.max(this.y + this.height, y + height);\n    this.x = Math.min(this.x, x);\n    this.y = Math.min(this.y, y);\n    this.width = right - this.x;\n    this.height = bottom - this.y;\n    return this;\n  }\n\n  expand(h: number, v: number): Rect {\n    this.y -= v;\n    this.height += v * 2;\n    this.x -= h;\n    this.width += h * 2;\n    return this;\n  }\n\n  //\n  // Padding Format:  [all], [vertical, horizontal], [top, horizontal, bottom], [top, right, bottom, left]\n  //\n  padding(padding?: Padding): Rect {\n    if (padding) {\n      if (typeof padding === 'number') {\n        this.expand(padding, padding);\n      } else if (padding.length === 1) {\n        this.expand(padding[0], padding[0]);\n      } else if (padding.length === 2) {\n        this.expand(padding[1], padding[0]);\n      } else if (padding.length === 3) {\n        this.y -= padding[0];\n        this.height += padding[0] + padding[2];\n        this.width += padding[1];\n      } else if (padding.length === 4) {\n        this.y -= padding[0];\n        this.height += padding[0] + padding[2];\n        this.x -= padding[1];\n        this.width += padding[1] + padding[3];\n      }\n    }\n    return this;\n  }\n\n  setBounds(x: number, y: number, width: number, height: number): Rect {\n    this.x = x;\n    this.y = y;\n    this.width = width;\n    this.height = height;\n    return this;\n  }\n\n  clone(): Rect {\n    return Rect.fromRect(this);\n  }\n\n  equals(r: IRect) {\n    return r.x === this.x && r.y === this.y && r.width === this.width && r.height === this.height;\n  }\n}\n","export { default as Point } from './Point';\nexport { default as Rect } from './Rect';\nexport * from './types';\n","export * from './anchors';\nexport * from './behavior';\nexport * from './components';\nexport * from './const';\nexport * from './elements';\nexport * from './geom';\nexport * from './layouts';\nexport * from './utils';\nexport * from './mobx-exports';\nexport * from './types';\nexport { default as Visualization } from './Visualization';\n","import * as _ from 'lodash';\nimport { action } from 'mobx';\nimport {\n  Edge,\n  Graph,\n  Layout,\n  Node,\n  ADD_CHILD_EVENT,\n  REMOVE_CHILD_EVENT,\n  GRAPH_LAYOUT_END_EVENT,\n  ElementChildEventListener,\n  NODE_COLLAPSE_CHANGE_EVENT,\n  NodeCollapseChangeEventListener,\n  NodeStyle,\n  ElementVisibilityChangeEventListener,\n  ELEMENT_VISIBILITY_CHANGE_EVENT,\n  ElementVisibilityChangeEvent,\n} from '../types';\nimport {\n  leafNodeElements,\n  groupNodeElements,\n  getClosestVisibleParent,\n} from '../utils/element-utils';\nimport {\n  DRAG_MOVE_OPERATION,\n  DRAG_NODE_END_EVENT,\n  DRAG_NODE_START_EVENT,\n  DragEvent,\n  DragNodeEventListener,\n  DragOperationWithType,\n} from '../behavior';\nimport { BaseEdge } from '../elements';\nimport { ForceSimulation } from './ForceSimulation';\nimport { Rect } from '../geom';\n\nclass LayoutNode {\n  protected readonly node: Node;\n\n  protected xx?: number;\n\n  protected yy?: number;\n\n  protected nodeWidth: number;\n\n  protected nodeHeight: number;\n\n  protected nodeRadius: number;\n\n  public readonly distance: number;\n\n  public parent: LayoutGroup;\n\n  public index: number;\n\n  // isFixed is used locally for Force simulation during drag events\n  public isFixed: boolean = false;\n\n  constructor(node: Node, distance: number, index: number = -1) {\n    this.node = node;\n    this.distance = distance;\n    this.index = index;\n\n    // Currently we support only fixed node sizes, this will need to change if/when dynamic node sizes are supported\n    const bounds = this.nodeBounds;\n    this.nodeWidth = bounds.width + this.distance * 2;\n    this.nodeHeight = bounds.height + this.distance * 2;\n    this.nodeRadius = Math.max(bounds.width, bounds.height) / 2;\n  }\n\n  get element(): Node {\n    return this.node;\n  }\n\n  get id(): string {\n    return this.node.getId();\n  }\n\n  get x(): number {\n    return this.xx || this.node.getBounds().getCenter().x;\n  }\n\n  set x(x: number) {\n    if (!Number.isNaN(x)) {\n      this.xx = x;\n    }\n  }\n\n  get y(): number {\n    return this.yy || this.node.getBounds().getCenter().y;\n  }\n\n  set y(y: number) {\n    if (!Number.isNaN(y)) {\n      this.yy = y;\n    }\n  }\n\n  get fx(): number | undefined {\n    return this.isFixed ? this.node.getBounds().getCenter().x : undefined;\n  }\n\n  get fy(): number | undefined {\n    return this.isFixed ? this.node.getBounds().getCenter().y : undefined;\n  }\n\n  setPosition(x: number, y: number) {\n    this.node.setBounds(\n      this.node\n        .getBounds()\n        .clone()\n        .setCenter(x, y),\n    );\n  }\n\n  get nodeBounds(): Rect {\n    const { padding } = this.node.getStyle<NodeStyle>();\n    // Currently non-group nodes do not include their padding in the bounds\n    if (!this.node.isGroup() && padding) {\n      return this.node\n        .getBounds()\n        .clone()\n        .padding(padding);\n    }\n    return this.node.getBounds();\n  }\n\n  get width(): number {\n    return this.nodeWidth;\n  }\n\n  get height(): number {\n    return this.nodeHeight;\n  }\n\n  update() {\n    if (this.xx != null && this.yy != null) {\n      this.node.setBounds(\n        this.node\n          .getBounds()\n          .clone()\n          .setCenter(this.xx, this.yy),\n      );\n    }\n    this.xx = undefined;\n    this.yy = undefined;\n  }\n\n  get radius(): number {\n    return this.nodeRadius;\n  }\n\n  get collisionRadius(): number {\n    return this.radius + this.distance;\n  }\n}\n\nclass LayoutGroup {\n  protected readonly node: Node;\n\n  public leaves: LayoutNode[];\n\n  public groups: LayoutGroup[];\n\n  public parent: LayoutGroup;\n\n  public padding: number;\n\n  public index: number;\n\n  constructor(node: Node, padding: number, index: number) {\n    this.node = node;\n    this.padding = padding;\n    this.index = index;\n  }\n\n  get element(): Node {\n    return this.node;\n  }\n\n  get id(): string {\n    return this.node.getId();\n  }\n}\n\nclass LayoutLink {\n  private readonly edge: Edge;\n\n  public sourceNode: LayoutNode;\n\n  public targetNode: LayoutNode;\n\n  public isFalse: boolean;\n\n  constructor(edge: Edge, source: LayoutNode, target: LayoutNode, isFalse: boolean = false) {\n    this.edge = edge;\n    this.sourceNode = source;\n    this.targetNode = target;\n    this.isFalse = isFalse;\n  }\n\n  get element(): Edge {\n    return this.edge;\n  }\n\n  get id(): string {\n    return this.edge.getId();\n  }\n\n  get source(): any {\n    return this.sourceNode;\n  }\n\n  get target(): any {\n    return this.targetNode;\n  }\n}\n\ntype LayoutOptions = {\n  linkDistance: number;\n  nodeDistance: number;\n  groupDistance: number;\n  collideDistance: number;\n  simulationSpeed: number;\n  chargeStrength: number;\n  allowDrag: boolean;\n  layoutOnDrag: boolean;\n};\n\nconst LAYOUT_DEFAULTS: LayoutOptions = {\n  linkDistance: 60,\n  nodeDistance: 35,\n  groupDistance: 35,\n  collideDistance: 0,\n  simulationSpeed: 10,\n  chargeStrength: 0,\n  allowDrag: true,\n  layoutOnDrag: true,\n};\n\nclass BaseLayout implements Layout {\n  private graph: Graph;\n\n  protected forceSimulation: ForceSimulation;\n\n  protected options: LayoutOptions;\n\n  protected scheduleHandle?: number;\n\n  private scheduleRestart = false;\n\n  protected nodes: LayoutNode[] = [];\n\n  protected edges: LayoutLink[] = [];\n\n  protected groups: LayoutGroup[] = [];\n\n  protected nodesMap: { [id: string]: LayoutNode } = {};\n\n  constructor(graph: Graph, options?: Partial<LayoutOptions>) {\n    this.graph = graph;\n    this.options = {\n      ...LAYOUT_DEFAULTS,\n      ...options,\n    };\n\n    if (this.options.allowDrag) {\n      graph\n        .getController()\n        .addEventListener<DragNodeEventListener>(DRAG_NODE_START_EVENT, this.handleDragStart)\n        .addEventListener<DragNodeEventListener>(DRAG_NODE_END_EVENT, this.handleDragEnd);\n    }\n\n    this.forceSimulation = new ForceSimulation(this.options);\n  }\n\n  destroy(): void {\n    if (this.options.allowDrag) {\n      this.graph\n        .getController()\n        .removeEventListener(DRAG_NODE_START_EVENT, this.handleDragStart)\n        .removeEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);\n    }\n\n    this.stopListening();\n\n    this.forceSimulation.destroy();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected initDrag(element: Node, event: DragEvent, operation: DragOperationWithType): void {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected endDrag(element: Node, event: DragEvent, operation: DragOperationWithType): void {}\n\n  handleDragStart = (element: Node, event: DragEvent, operation: DragOperationWithType) => {\n    this.initDrag(element, event, operation);\n\n    if (!this.options.layoutOnDrag) {\n      return;\n    }\n\n    if (operation.type !== DRAG_MOVE_OPERATION) {\n      this.forceSimulation.stopSimulation();\n      return;\n    }\n\n    const id = element.getId();\n    let found = false;\n    const dragNode: LayoutNode | undefined = this.nodes.find((node: LayoutNode) => node.id === id);\n    if (dragNode) {\n      dragNode.isFixed = true;\n      found = true;\n    }\n    if (!found) {\n      const dragGroup: LayoutGroup | undefined = this.groups.find(\n        (group: LayoutGroup) => group.id === id,\n      );\n      if (dragGroup) {\n        const groupNodes = dragGroup.leaves;\n        groupNodes.forEach((node: LayoutNode) => {\n          node.isFixed = true;\n        });\n        found = true;\n      }\n    }\n\n    if (found) {\n      this.forceSimulation.alphaTarget(0.1);\n      this.forceSimulation.restart();\n    }\n  };\n\n  handleDragEnd = (element: Node, event: DragEvent, operation: DragOperationWithType) => {\n    this.endDrag(element, event, operation);\n\n    if (!this.options.layoutOnDrag) {\n      return;\n    }\n\n    if (operation.type !== DRAG_MOVE_OPERATION) {\n      this.forceSimulation.restart();\n      return;\n    }\n\n    const id = element.getId();\n    const dragNode: LayoutNode | undefined = this.nodes.find((node: LayoutNode) => node.id === id);\n    if (dragNode) {\n      dragNode.isFixed = false;\n    } else {\n      const dragGroup: LayoutGroup | undefined = this.groups.find(\n        (group: LayoutGroup) => group.id === id,\n      );\n      if (dragGroup) {\n        const groupNodes = dragGroup.leaves;\n        groupNodes.forEach((node: LayoutNode) => {\n          node.isFixed = false;\n        });\n      }\n    }\n    this.forceSimulation.alphaTarget(0);\n  };\n\n  layout = () => {\n    this.stopListening();\n\n    this.runLayout(true);\n\n    this.startListening();\n  };\n\n  private startListening(): void {\n    const controller = this.graph.getController();\n    if (controller) {\n      controller.addEventListener(ADD_CHILD_EVENT, this.handleChildAdded);\n      controller.addEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);\n      controller.addEventListener(\n        ELEMENT_VISIBILITY_CHANGE_EVENT,\n        this.handleElementVisibilityChange,\n      );\n      controller.addEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);\n    }\n  }\n\n  private stopListening(): void {\n    const controller = this.graph.getController();\n    if (this.scheduleHandle) {\n      window.cancelAnimationFrame(this.scheduleHandle);\n    }\n    if (controller) {\n      controller.removeEventListener(ADD_CHILD_EVENT, this.handleChildAdded);\n      controller.removeEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);\n      controller.removeEventListener(\n        ELEMENT_VISIBILITY_CHANGE_EVENT,\n        this.handleElementVisibilityChange,\n      );\n      controller.removeEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);\n    }\n  }\n\n  protected handleChildAdded: ElementChildEventListener = ({ child }): void => {\n    if (!this.nodesMap[child.getId()]) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  protected handleChildRemoved: ElementChildEventListener = ({ child }): void => {\n    if (this.nodesMap[child.getId()]) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  protected handleElementVisibilityChange: ElementVisibilityChangeEventListener = (\n    event: ElementVisibilityChangeEvent,\n  ): void => {\n    if (event.visible === (this.nodesMap[event.target.getId()] === undefined)) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  private handleNodeCollapse: NodeCollapseChangeEventListener = ({ node }): void => {\n    if (!node.isCollapsed()) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  private scheduleLayout = (): void => {\n    if (!this.scheduleHandle) {\n      this.scheduleHandle = window.requestAnimationFrame(() => {\n        delete this.scheduleHandle;\n        this.runLayout(false, this.scheduleRestart);\n        this.scheduleRestart = false;\n      });\n    }\n  };\n\n  protected getFixedNodeDistance = (link: LayoutLink): number => {\n    return Math.sqrt(\n      (link.sourceNode.x - link.targetNode.x) ** 2 + (link.sourceNode.y - link.targetNode.y) ** 2,\n    );\n  };\n\n  protected getLayoutNode(nodes: LayoutNode[], node: Node | null): LayoutNode | undefined {\n    if (!node) {\n      return undefined;\n    }\n\n    let layoutNode = _.find(nodes, { id: node.getId() });\n    if (!layoutNode && _.size(node.getChildren())) {\n      layoutNode = _.find(nodes, { id: node.getChildren()[0].getId() });\n    }\n    if (!layoutNode) {\n      layoutNode = this.getLayoutNode(nodes, getClosestVisibleParent(node));\n    }\n\n    return layoutNode;\n  }\n\n  protected getFauxEdges(groups: LayoutGroup[], nodes: LayoutNode[]): LayoutLink[] {\n    const fauxEdges: LayoutLink[] = [];\n    groups.forEach((group: LayoutGroup) => {\n      const groupNodes = group.element.getNodes();\n      for (let i = 0; i < groupNodes.length; i++) {\n        for (let j = i + 1; j < groupNodes.length; j++) {\n          const fauxEdge = new BaseEdge();\n          const source = this.getLayoutNode(nodes, groupNodes[i]);\n          const target = this.getLayoutNode(nodes, groupNodes[j]);\n          if (source && target) {\n            const link = this.createLayoutLink(fauxEdge, source, target, true);\n            fauxEdge.setController(target.element.getController());\n            fauxEdges.push(link);\n          }\n        }\n      }\n    });\n\n    return fauxEdges;\n  }\n\n  protected createLayoutNode(node: Node, nodeDistance: number, index: number) {\n    return new LayoutNode(node, nodeDistance, index);\n  }\n\n  protected createLayoutLink(\n    edge: Edge,\n    source: LayoutNode,\n    target: LayoutNode,\n    isFalse: boolean = false,\n  ): LayoutLink {\n    return new LayoutLink(edge, source, target, isFalse);\n  }\n\n  protected createLayoutGroup(node: Node, padding: number, index: number) {\n    return new LayoutGroup(node, padding, index);\n  }\n\n  protected getNodes(leafNodes: Node[], nodeDistance: number): LayoutNode[] {\n    return leafNodes.map((n, index) => this.createLayoutNode(n, nodeDistance, index));\n  }\n\n  // Default is to clear any initial bend points\n  protected initializeEdgeBendpoints = (edge: Edge): void => {\n    // remove any bendpoints\n    if (edge.getBendpoints().length > 0) {\n      edge.setBendpoints([]);\n    }\n  };\n\n  protected getLinks(edges: Edge[]): LayoutLink[] {\n    const links: LayoutLink[] = [];\n    edges.forEach((e) => {\n      const source = this.getLayoutNode(this.nodes, e.getSource());\n      const target = this.getLayoutNode(this.nodes, e.getTarget());\n      if (source && target) {\n        this.initializeEdgeBendpoints(e);\n        links.push(this.createLayoutLink(e, source, target));\n      }\n    });\n\n    return links;\n  }\n\n  // Turn empty groups into nodes\n  protected getNodesFromGroups(\n    groups: Node[],\n    nodeDistance: number,\n    nodeCount: number,\n  ): LayoutNode[] {\n    let count = 0;\n    const groupNodes: LayoutNode[] = [];\n    groups.forEach((group: Node) => {\n      if (group.getChildren().filter((c) => c.isVisible()).length === 0) {\n        groupNodes.push(this.createLayoutNode(group, nodeDistance, nodeCount + count++));\n      }\n    });\n\n    return groupNodes;\n  }\n\n  protected getGroups(groups: Node[], nodes: LayoutNode[], padding: number): LayoutGroup[] {\n    let nodeIndex = nodes.length;\n    // Create groups only for those with children\n    const layoutGroups: LayoutGroup[] = groups\n      .filter((g) => g.getChildren().filter((c) => c.isVisible()).length > 0)\n      .map((group: Node) => this.createLayoutGroup(group, padding, nodeIndex++));\n\n    layoutGroups.forEach((groupNode: LayoutGroup) => {\n      const leaves: LayoutNode[] = [];\n      const leafElements = groupNode.element\n        .getChildren()\n        .filter((node: Node) => !node.isGroup() || node.getChildren().length === 0);\n      leafElements.forEach((leaf: Node) => {\n        const layoutLeaf = nodes.find((n) => n.id === leaf.getId());\n        if (layoutLeaf) {\n          leaves.push(layoutLeaf);\n          layoutLeaf.parent = groupNode;\n        }\n      });\n      groupNode.leaves = leaves;\n      const childGroups: LayoutGroup[] = [];\n      const groupElements = groupNode.element\n        .getChildren()\n        .filter((node: Node) => node.isGroup() && !node.isCollapsed());\n      groupElements.forEach((group: Node) => {\n        const layoutGroup = layoutGroups.find((g) => g.id === group.getId());\n        if (layoutGroup) {\n          childGroups.push(layoutGroup);\n          layoutGroup.parent = groupNode;\n        }\n      });\n      groupNode.groups = childGroups;\n    });\n\n    return layoutGroups;\n  }\n\n  protected initializeNodePositions(\n    newNodes: LayoutNode[],\n    graph: Graph,\n    force: boolean = false,\n  ): void {\n    const { width, height } = graph.getBounds();\n    const cx = width / 2;\n    const cy = height / 2;\n    newNodes.forEach((node: LayoutNode) => {\n      // only init position for nodes that are still at 0, 0\n      const { x, y } = node.element.getPosition();\n      if (force || (x === 0 && y === 0)) {\n        node.setPosition(cx, cy);\n      }\n    });\n  }\n\n  protected setupLayout(\n    graph: Graph, // eslint-disable-line @typescript-eslint/no-unused-vars\n    nodes: LayoutNode[], // eslint-disable-line @typescript-eslint/no-unused-vars\n    edges: LayoutLink[], // eslint-disable-line @typescript-eslint/no-unused-vars\n    groups: LayoutGroup[], // eslint-disable-line @typescript-eslint/no-unused-vars\n  ): void {}\n\n  protected updateExistingNodes(existingNodes: LayoutNode[]): void {\n    existingNodes.forEach((n) => {\n      (n as LayoutNode).isFixed = true;\n    });\n  }\n\n  protected stopSimulation(): void {\n    this.forceSimulation.haltForceSimulation();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected startLayout(graph: Graph, initialRun: boolean, addingNodes: boolean): void {}\n\n  protected updateLayout(): void {\n    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);\n    this.forceSimulation.alpha(0.2);\n  }\n\n  @action\n  private runLayout(initialRun: boolean, restart = true): void {\n    const prevGroups = this.groups;\n\n    // create datum\n    const leafNodes = leafNodeElements(this.graph.getNodes()).filter((n) => n.isVisible());\n    const groups = groupNodeElements(this.graph.getNodes()).filter((g) => g.isVisible());\n\n    this.nodes = this.getNodes(leafNodes, this.options.nodeDistance);\n\n    const groupNodes: LayoutNode[] = this.getNodesFromGroups(\n      groups,\n      this.options.nodeDistance,\n      this.nodes.length,\n    );\n    if (groupNodes) {\n      this.nodes.push(...groupNodes);\n    }\n\n    this.groups = this.getGroups(groups, this.nodes, this.options.groupDistance);\n\n    const newNodes: LayoutNode[] = initialRun\n      ? this.nodes\n      : this.nodes.filter((node) => !this.nodesMap[node.element.getId()]);\n    let addingNodes = restart && newNodes.length > 0;\n\n    if (!initialRun && restart && !addingNodes) {\n      this.groups.forEach((group) => {\n        const prevGroup = prevGroups.find((g) => g.element.getId() === group.element.getId());\n        if (!prevGroup) {\n          addingNodes = true;\n          newNodes.push(...group.leaves);\n        } else {\n          group.leaves.forEach((node) => {\n            if (!prevGroup.leaves.find((l) => l.element.getId() === node.element.getId())) {\n              newNodes.push(node);\n            }\n          });\n        }\n      });\n      addingNodes = newNodes.length > 0;\n    }\n\n    this.edges = this.getLinks(this.graph.getEdges());\n\n    // initialize new node positions\n    this.initializeNodePositions(newNodes, this.graph, initialRun);\n\n    // re-create the nodes map\n    this.nodesMap = this.nodes.reduce((acc, n) => {\n      acc[n.id] = n;\n      return acc;\n    }, {});\n\n    // Add faux edges to keep grouped items together\n    this.edges.push(...this.getFauxEdges(this.groups, this.nodes));\n\n    this.setupLayout(this.graph, this.nodes, this.edges, this.groups);\n\n    this.updateExistingNodes(this.nodes.filter((n) => !newNodes.includes(n)));\n\n    if (initialRun || addingNodes) {\n      // Reset the force simulation\n      this.stopSimulation();\n\n      this.startLayout(this.graph, initialRun, addingNodes);\n    } else if (restart && this.options.layoutOnDrag) {\n      this.updateLayout();\n    }\n    this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });\n  }\n}\n\nexport { BaseLayout, LayoutNode, LayoutGroup, LayoutLink, LayoutOptions, LAYOUT_DEFAULTS };\n","import * as webcola from 'webcola';\nimport * as d3 from 'd3';\nimport { action } from 'mobx';\nimport { Edge, Graph, Layout, Node } from '../types';\nimport { getGroupPadding } from '../utils/element-utils';\nimport { BaseLayout, LayoutGroup, LayoutLink, LayoutNode, LayoutOptions } from './BaseLayout';\n\nclass ColaNode extends LayoutNode implements webcola.Node {\n  // fixed is used by Cola during node additions: 1 for fixed\n  public fixed: number = 0;\n\n  constructor(node: Node, distance: number, index: number = -1) {\n    super(node, distance, index);\n\n    // TODO: Investigate why the issue with rectangular nodes causing the layout to become vertical\n    //       this setting will be a problem if nodes can change size dynamically\n    // Cola layout has issues with non-square nodes\n    const maxDimension = Math.max(this.nodeWidth, this.nodeHeight);\n    this.nodeWidth = maxDimension;\n    this.nodeHeight = maxDimension;\n  }\n}\n\nclass ColaGroup extends LayoutGroup implements webcola.Group {}\n\nclass ColaLink extends LayoutLink implements webcola.Link<ColaNode | number> {\n  constructor(edge: Edge, source: LayoutNode | number, target: LayoutNode | number) {\n    super(edge, source as LayoutNode, target as LayoutNode);\n  }\n}\n\ntype ColaLayoutOptions = {\n  maxTicks: number;\n  initialUnconstrainedIterations: number;\n  initialUserConstraintIterations: number;\n  initialAllConstraintsIterations: number;\n  gridSnapIterations: number;\n};\n\nconst COLA_LAYOUT_DEFAULTS: ColaLayoutOptions = {\n  maxTicks: 300,\n  initialUnconstrainedIterations: 200,\n  initialUserConstraintIterations: 50,\n  initialAllConstraintsIterations: 150,\n  gridSnapIterations: 50,\n};\n\nclass ColaLayout extends BaseLayout implements Layout {\n  private d3Cola: any;\n\n  private colaOptions: ColaLayoutOptions;\n\n  private tickCount = 0;\n\n  private destroyed = false;\n\n  constructor(graph: Graph, options?: Partial<ColaLayoutOptions & LayoutOptions>) {\n    super(graph, options);\n    this.colaOptions = {\n      ...COLA_LAYOUT_DEFAULTS,\n      ...options,\n    };\n    this.initializeLayout();\n  }\n\n  protected getLinkDistance = (link: ColaLink): number => {\n    let distance = this.options.linkDistance + link.source.radius + link.target.radius;\n    if (link.source.element.getParent() !== link.target.element.getParent()) {\n      distance += getGroupPadding(link.source.element.getParent());\n      distance += getGroupPadding(link.target.element.getParent());\n    }\n\n    return distance;\n  };\n\n  protected initializeLayout(): void {\n    this.d3Cola = webcola.d3adaptor(d3);\n    this.d3Cola.handleDisconnected(true);\n    this.d3Cola.avoidOverlaps(true);\n    this.d3Cola.linkDistance(this.getLinkDistance);\n    this.d3Cola.on('tick', () => {\n      this.tickCount++;\n      if (this.tickCount === 1 || this.tickCount % this.options.simulationSpeed === 0) {\n        action(() => this.nodes.forEach((d) => d.update()))();\n      }\n      if (this.colaOptions.maxTicks >= 0 && this.tickCount > this.colaOptions.maxTicks) {\n        this.d3Cola.stop();\n      }\n    });\n    this.d3Cola.on('end', () => {\n      this.tickCount = 0;\n      action(() => {\n        if (this.destroyed) {\n          return;\n        }\n        this.nodes.forEach((d) => {\n          d.update();\n          (d as ColaNode).fixed = 0;\n        });\n        if (this.options.layoutOnDrag) {\n          this.forceSimulation.useForceSimulation(\n            this.nodes,\n            this.edges,\n            this.getFixedNodeDistance,\n          );\n        }\n      })();\n    });\n  }\n\n  destroy(): void {\n    super.destroy();\n\n    this.destroyed = true;\n    this.d3Cola.stop();\n  }\n\n  initDrag() {\n    // Set the alpha to 0 to halt any ticks that may be occurring\n    this.d3Cola.alpha(0);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected getConstraints(nodes: ColaNode[], groups: ColaGroup[], edges: ColaLink[]): any[] {\n    return [];\n  }\n\n  protected createLayoutNode(node: Node, nodeDistance: number, index: number) {\n    return new ColaNode(node, nodeDistance, index);\n  }\n\n  protected createLayoutLink(edge: Edge, source: LayoutNode, target: LayoutNode): LayoutLink {\n    return new ColaLink(edge, source, target);\n  }\n\n  protected createLayoutGroup(node: Node, padding: number, index: number) {\n    return new ColaGroup(node, padding, index);\n  }\n\n  protected setupLayout(\n    graph: Graph,\n    nodes: LayoutNode[],\n    edges: LayoutLink[],\n    groups: LayoutGroup[],\n  ): void {\n    const { width, height } = graph.getBounds();\n    this.d3Cola.size([width, height]);\n\n    // Get any custom constraints\n    this.d3Cola.constraints(this.getConstraints(nodes as ColaNode[], groups as ColaGroup[], edges));\n\n    this.d3Cola.nodes(nodes);\n    this.d3Cola.links(edges);\n    this.d3Cola.groups(groups);\n  }\n\n  protected updateExistingNodes(existingNodes: LayoutNode[]) {\n    existingNodes.forEach((n) => {\n      (n as ColaNode).fixed = 1;\n    });\n  }\n\n  protected startLayout(graph: Graph, initialRun: boolean, addingNodes: boolean): void {\n    // start the layout\n    this.d3Cola.alpha(0.2);\n    this.tickCount = 0;\n    this.d3Cola.start(\n      addingNodes ? 0 : this.colaOptions.initialUnconstrainedIterations,\n      addingNodes ? 0 : this.colaOptions.initialUserConstraintIterations,\n      addingNodes ? 0 : this.colaOptions.initialAllConstraintsIterations,\n      addingNodes ? 0 : this.colaOptions.gridSnapIterations,\n      true,\n      !addingNodes,\n    );\n  }\n}\n\nexport { ColaLayout, ColaNode, ColaGroup, ColaLink, ColaLayoutOptions };\n","import * as dagre from 'dagre';\nimport * as _ from 'lodash';\nimport { Edge, Graph, Layout, Node } from '../types';\nimport Point from '../geom/Point';\nimport {\n  BaseLayout,\n  LayoutGroup,\n  LayoutLink,\n  LayoutNode,\n  LayoutOptions,\n  LAYOUT_DEFAULTS,\n} from './BaseLayout';\n\nclass DagreNode extends LayoutNode implements dagre.Node {\n  getUpdatableNode(): dagre.Node {\n    return {\n      id: this.id,\n      width: this.width,\n      height: this.height,\n      x: this.x,\n      y: this.y,\n    };\n  }\n\n  updateToNode(updatedNode: dagre.Node | undefined): void {\n    if (updatedNode) {\n      this.x = updatedNode.x;\n      this.y = updatedNode.y;\n      this.update();\n    }\n  }\n}\n\nclass DagreGroup extends LayoutGroup {}\n\nclass DagreLink extends LayoutLink {\n  public points: any[];\n\n  updateBendpoints(): void {\n    if (this.points && !this.isFalse && this.points.length > 2) {\n      this.element.setBendpoints(\n        this.points.slice(1, -1).map((point: any) => new Point(point.x, point.y)),\n      );\n    }\n  }\n}\n\ntype DagreLayoutOptions = LayoutOptions & dagre.GraphLabel;\n\nclass DagreLayout extends BaseLayout implements Layout {\n  private dagreOptions: DagreLayoutOptions;\n\n  constructor(graph: Graph, options?: Partial<DagreLayoutOptions>) {\n    super(graph, options);\n    this.dagreOptions = {\n      ...this.options,\n      marginx: 0,\n      marginy: 0,\n      nodesep: this.options.nodeDistance,\n      edgesep: this.options.linkDistance,\n      ranker: 'tight-tree',\n      rankdir: 'TB',\n      ...options,\n    };\n  }\n\n  protected createLayoutNode(node: Node, nodeDistance: number, index: number) {\n    return new DagreNode(node, nodeDistance, index);\n  }\n\n  protected createLayoutLink(\n    edge: Edge,\n    source: LayoutNode,\n    target: LayoutNode,\n    isFalse: boolean,\n  ): LayoutLink {\n    return new DagreLink(edge, source, target, isFalse);\n  }\n\n  protected createLayoutGroup(node: Node, padding: number, index: number) {\n    return new DagreGroup(node, padding, index);\n  }\n\n  protected updateEdgeBendpoints(edges: DagreLink[]): void {\n    _.forEach(edges, (edge) => {\n      const link = edge as DagreLink;\n      link.updateBendpoints();\n    });\n  }\n\n  protected startLayout(graph: Graph, initialRun: boolean, addingNodes: boolean): void {\n    if (initialRun || addingNodes) {\n      const dagreGraph = new dagre.graphlib.Graph({ compound: true });\n      dagreGraph.setGraph(_.omit(this.dagreOptions, Object.keys(LAYOUT_DEFAULTS)));\n\n      _.forEach(this.groups, (group) => {\n        dagreGraph.setNode(group.id, group);\n        dagreGraph.setParent(group.id, group.element.getParent().getId());\n      });\n\n      const updatedNodes: dagre.Node[] = [];\n      _.forEach(this.nodes, (node) => {\n        const updateNode = (node as DagreNode).getUpdatableNode();\n        updatedNodes.push(updateNode);\n        dagreGraph.setNode(node.id, updateNode);\n        dagreGraph.setParent(node.id, node.element.getParent().getId());\n      });\n\n      _.forEach(this.edges, (dagreEdge) => {\n        dagreGraph.setEdge(dagreEdge.source.id, dagreEdge.target.id, dagreEdge);\n      });\n\n      dagre.layout(dagreGraph);\n      this.nodes.forEach((node) => {\n        (node as DagreNode).updateToNode(updatedNodes.find((n) => n.id === node.id));\n      });\n\n      this.updateEdgeBendpoints(this.edges as DagreLink[]);\n    }\n\n    if (this.options.layoutOnDrag) {\n      this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);\n    }\n  }\n}\n\nexport { DagreLayout, DagreNode, DagreLink, DagreGroup, DagreLayoutOptions };\n","import { Graph, Layout } from '../types';\nimport { getGroupPadding } from '../utils/element-utils';\nimport { BaseLayout, LayoutLink, LayoutOptions } from './BaseLayout';\n\nexport default class ForceLayout extends BaseLayout implements Layout {\n  constructor(graph: Graph, options?: Partial<LayoutOptions>) {\n    super(graph, {\n      ...options,\n      layoutOnDrag: true,\n    });\n  }\n\n  protected getLinkDistance = (e: LayoutLink) => {\n    let distance = this.options.linkDistance + e.source.radius + e.target.radius;\n    if (!e.isFalse && e.source.element.getParent() !== e.target.element.getParent()) {\n      // find the group padding\n      distance += getGroupPadding(e.source.element.getParent());\n      distance += getGroupPadding(e.target.element.getParent());\n    }\n\n    return distance;\n  };\n\n  protected startLayout(graph: Graph): void {\n    const { width, height } = graph.getBounds();\n    const cx = width / 2;\n    const cy = height / 2;\n    this.forceSimulation.forceCenter(cx, cy);\n    this.forceSimulation.alpha(1);\n    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getLinkDistance);\n    this.forceSimulation.restart();\n  }\n\n  protected updateLayout(): void {\n    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);\n    this.forceSimulation.alpha(0.2);\n    this.forceSimulation.restart();\n  }\n}\n","import * as d3 from 'd3';\nimport { action } from 'mobx';\n\nexport interface ForceSimulationNode extends d3.SimulationNodeDatum {\n  id: string;\n  collisionRadius: number;\n  update(): void;\n}\n\ntype ForceSimulationOptions = {\n  collideDistance: number;\n  simulationSpeed: number;\n  chargeStrength: number;\n};\n\nclass ForceSimulation {\n  private forceLink: d3.ForceLink<ForceSimulationNode, d3.SimulationLinkDatum<ForceSimulationNode>>;\n\n  private simulation: any;\n\n  private options: ForceSimulationOptions;\n\n  private destroyed = false;\n\n  constructor(options?: Partial<ForceSimulationOptions>) {\n    this.options = {\n      ...{\n        collideDistance: 0,\n        simulationSpeed: 10,\n        chargeStrength: 0,\n      },\n      ...options,\n    };\n\n    this.setupForceSimulation();\n  }\n\n  private setupForceSimulation(): void {\n    this.simulation = d3.forceSimulation<ForceSimulationNode>();\n    this.simulation.force(\n      'collide',\n      d3\n        .forceCollide<ForceSimulationNode>()\n        .radius((d) => d.collisionRadius + this.options.collideDistance),\n    );\n    this.simulation.force('charge', d3.forceManyBody().strength(this.options.chargeStrength));\n    this.simulation.alpha(0);\n    this.forceLink = d3\n      .forceLink<ForceSimulationNode, d3.SimulationLinkDatum<ForceSimulationNode>>()\n      .id((e) => e.id);\n\n    this.simulation.force('link', this.forceLink);\n    this.simulation.on(\n      'tick',\n      action(() => {\n        // speed up the simulation\n        for (let i = 0; i < this.options.simulationSpeed; i++) {\n          this.simulation.tick();\n        }\n        this.simulation.nodes().forEach((d: ForceSimulationNode) => !this.destroyed && d.update());\n      }),\n    );\n  }\n\n  public destroy(): void {\n    this.destroyed = true;\n    this.simulation.stop();\n  }\n\n  public useForceSimulation(\n    nodes: ForceSimulationNode[],\n    links: d3.SimulationLinkDatum<ForceSimulationNode>[],\n    distance: (\n      link: d3.SimulationLinkDatum<ForceSimulationNode>,\n      i: number,\n      links: d3.SimulationLinkDatum<ForceSimulationNode>[],\n    ) => number,\n  ): void {\n    this.forceLink.distance(distance);\n\n    // first remove the links so that the layout doesn't error\n    this.forceLink.links([]);\n\n    this.simulation.nodes([...nodes]);\n    this.forceLink.links([...links]);\n  }\n\n  public haltForceSimulation(): void {\n    this.simulation.alpha(0);\n    this.simulation.nodes([]);\n    this.forceLink.links([]);\n  }\n\n  public forceCenter(cx: number, cy: number): void {\n    this.simulation.force('center', d3.forceCenter(cx, cy));\n  }\n\n  public stopSimulation(): void {\n    this.simulation.stop();\n  }\n\n  public restart() {\n    this.simulation.restart();\n  }\n\n  public alpha(value: number) {\n    this.simulation.alpha(value);\n  }\n\n  public alphaTarget(value: number) {\n    this.simulation.alphaTarget(value);\n  }\n}\n\nexport { ForceSimulation };\n","export * from './BaseLayout';\nexport * from './ColaLayout';\nexport * from './DagreLayout';\nexport { default as ForceLayout } from './ForceLayout';\n","import { observer } from 'mobx-react';\n\n// re-exports observer for ease of use externally\nexport { observer };\n","import { ComponentType } from 'react';\nimport Point from './geom/Point';\nimport Dimensions from './geom/Dimensions';\nimport Rect from './geom/Rect';\nimport { Padding, Translatable } from './geom/types';\n\n// x, y\nexport type PointTuple = [number, number];\n\nexport interface Layout {\n  layout(): void;\n  destroy(): void;\n}\n\nexport type Model = {\n  graph?: GraphModel;\n  nodes?: NodeModel[];\n  edges?: EdgeModel[];\n};\n\nexport enum AnchorEnd {\n  target,\n  source,\n  both,\n}\n\nexport type NodeStyle = {\n  padding?: Padding;\n};\n\nexport enum NodeShape {\n  circle,\n  rect,\n}\n\nexport enum ModelKind {\n  graph = 'graph',\n  node = 'node',\n  edge = 'edge',\n}\n\nexport interface ElementModel {\n  id: string;\n  type: string;\n  label?: string;\n  visible?: boolean;\n  children?: string[];\n  data?: any;\n  style?: { [key: string]: any };\n}\n\nexport interface NodeModel extends ElementModel {\n  x?: number;\n  y?: number;\n  width?: number;\n  height?: number;\n  group?: boolean;\n  shape?: NodeShape;\n  collapsed?: boolean;\n}\n\nexport interface EdgeModel extends ElementModel {\n  source?: string;\n  target?: string;\n  bendpoints?: PointTuple[];\n}\n\n// Scale extent: [min scale, max scale]\nexport type ScaleExtent = [number, number];\n\nexport interface GraphModel extends ElementModel {\n  layout?: string;\n  x?: number;\n  y?: number;\n  scale?: number;\n  scaleExtent?: ScaleExtent;\n  maxScale?: number;\n  layers?: string[];\n}\n\nexport interface Anchor {\n  getLocation(reference: Point): Point;\n  getReferencePoint(): Point;\n}\n\nexport interface GraphElement<E extends ElementModel = ElementModel, D = any> extends WithState {\n  destroy(): void;\n  getKind(): ModelKind;\n  getLabel(): string;\n  setLabel(label: string): void;\n  getOrderKey(): number[];\n  getController(): Controller;\n  setController(controller?: Controller): void;\n  getGraph(): Graph;\n  getParent(): GraphElement;\n  hasParent(): boolean;\n  setParent(parent: GraphElement | undefined): void;\n  getId(): string;\n  setId(id: string): void;\n  getType(): string;\n  setType(type: string): void;\n  setVisible(visible: boolean): void;\n  isVisible(): boolean;\n  getData(): D | undefined;\n  setData(data: D | undefined): void;\n  getChildren(): GraphElement[];\n  insertChild(child: GraphElement, index: number): void;\n  appendChild(child: GraphElement): void;\n  removeChild(child: GraphElement): void;\n  remove(): void;\n  setModel(model: E): void;\n  raise(): void;\n  getStyle<T extends {}>(): T;\n  translateToAbsolute(t: Translatable): void;\n  translateFromAbsolute(t: Translatable): void;\n  translateToParent(t: Translatable): void;\n  translateFromParent(t: Translatable): void;\n}\n\nexport interface Node<E extends NodeModel = NodeModel, D = any> extends GraphElement<E, D> {\n  getAnchor(end: AnchorEnd, type?: string): Anchor;\n  setAnchor(anchor: Anchor, end?: AnchorEnd, type?: string): void;\n  getNodes(): Node[];\n  // TODO return an immutable bounds, position, dimensions?\n  getBounds(): Rect;\n  setBounds(bounds: Rect): void;\n  getPosition(): Point;\n  setPosition(location: Point): void;\n  getDimensions(): Dimensions;\n  setDimensions(dimensions: Dimensions): void;\n  isGroup(): boolean;\n  setGroup(group: boolean): void;\n  isCollapsed(): boolean;\n  setCollapsed(collapsed: boolean): void;\n  getNodeShape(): NodeShape;\n  setNodeShape(shape: NodeShape): void;\n  getSourceEdges(): Edge[];\n  getTargetEdges(): Edge[];\n}\n\nexport interface Edge<E extends EdgeModel = EdgeModel, D = any> extends GraphElement<E, D> {\n  getSource(): Node;\n  setSource(source: Node): void;\n  getTarget(): Node;\n  setTarget(target: Node): void;\n  getSourceAnchorNode(): Node;\n  getTargetAnchorNode(): Node;\n  getStartPoint(): Point;\n  setStartPoint(x?: number, y?: number): void;\n  getEndPoint(): Point;\n  setEndPoint(x?: number, y?: number): void;\n  getBendpoints(): Point[];\n  setBendpoints(points: Point[]): void;\n  removeBendpoint(point: Point | number): void;\n}\n\nexport interface Graph<E extends GraphModel = GraphModel, D = any> extends GraphElement<E, D> {\n  getNodes(): Node[];\n  getEdges(): Edge[];\n  getBounds(): Rect;\n  setBounds(bounds: Rect): void;\n  getPosition(): Point;\n  setPosition(location: Point): void;\n  getDimensions(): Dimensions;\n  setDimensions(dimensions: Dimensions): void;\n  getScaleExtent(): ScaleExtent;\n  setScaleExtent(scaleExtent: ScaleExtent): void;\n  getScale(): number;\n  setScale(scale: number): void;\n  getLayout(): string | undefined;\n  setLayout(type: string | undefined): void;\n  layout(): void;\n  getLayers(): string[];\n  setLayers(layers: string[]): void;\n\n  // viewport operations\n  reset(): void;\n  scaleBy(scale: number, location?: Point): void;\n  fit(padding?: number): void;\n  panIntoView(element: Node, options?: { offset?: number; minimumVisible?: number }): void;\n}\n\nexport const isGraph = (element: GraphElement): element is Graph => {\n  return element && element.getKind() === ModelKind.graph;\n};\n\nexport const isNode = (element: GraphElement): element is Node => {\n  return element && element.getKind() === ModelKind.node;\n};\n\nexport const isEdge = (element: GraphElement): element is Edge => {\n  return element && element.getKind() === ModelKind.edge;\n};\n\nexport type EventListener<Args extends any[] = any[]> = (...args: Args) => void;\n\nexport type State = { [key: string]: any };\n\nexport interface WithState {\n  getState<S extends {} = {}>(): S;\n  setState(state: State): void;\n}\n\nexport type LayoutFactory = (type: string, graph: Graph) => Layout | undefined;\n\nexport type ComponentFactory = (\n  kind: ModelKind,\n  type: string,\n) => ComponentType<{ element: GraphElement }> | undefined;\n\nexport type ElementFactory = (kind: ModelKind, type: string) => GraphElement | undefined;\n\nexport interface Controller extends WithState {\n  getStore<S extends {} = {}>(): S;\n  fromModel(model: Model): void;\n  getGraph(): Graph;\n  setGraph(graph: Graph): void;\n  getLayout(type: string | undefined): Layout | undefined;\n  getElementById(id: string): GraphElement | undefined;\n  getNodeById(id: string): Node | undefined;\n  getEdgeById(id: string): Edge | undefined;\n  addElement(element: GraphElement): void;\n  removeElement(element: GraphElement): void;\n  getComponent(kind: ModelKind, type: string): ComponentType<{ element: GraphElement }>;\n  registerLayoutFactory(factory: LayoutFactory): void;\n  registerComponentFactory(factory: ComponentFactory): void;\n  registerElementFactory(factory: ElementFactory): void;\n  addEventListener<L extends EventListener = EventListener>(type: string, listener: L): Controller;\n  removeEventListener(type: string, listener: EventListener): Controller;\n  fireEvent(type: string, ...args: any): void;\n  getElements(): GraphElement[];\n}\n\nexport type ElementEvent = { target: GraphElement };\nexport type ElementVisibilityChangeEvent = ElementEvent & { visible: boolean };\n\nexport type ElementChildEventListener = EventListener<[ElementEvent & { child: GraphElement }]>;\nexport type ElementVisibilityChangeEventListener = EventListener<[ElementVisibilityChangeEvent]>;\n\nexport type NodeCollapseChangeEventListener = EventListener<[{ node: Node }]>;\n\nexport type GraphLayoutEndEventListener = EventListener<[{ graph: Graph }]>;\n\nexport const ADD_CHILD_EVENT = 'element-add-child';\nexport const ELEMENT_VISIBILITY_CHANGE_EVENT = 'element-visibility-change';\nexport const REMOVE_CHILD_EVENT = 'element-remove-child';\nexport const NODE_COLLAPSE_CHANGE_EVENT = 'node-collapse-change';\nexport const GRAPH_LAYOUT_END_EVENT = 'graph-layout-end';\n","import { createContext } from 'react';\nimport { Controller } from '../types';\n\nconst ControllerContext = createContext<Controller>(undefined as any);\n\nexport default ControllerContext;\n","import { createContext } from 'react';\nimport { GraphElement } from '../types';\n\nconst ElementContext = createContext<GraphElement>(undefined as any);\n\nexport default ElementContext;\n","import { action, observable } from 'mobx';\nimport { WithState, State } from '../types';\n\nexport default class Stateful implements WithState {\n  @observable.shallow\n  private state: State = {};\n\n  getState<S = {}>(): S {\n    return this.state as S;\n  }\n\n  @action\n  setState(state: State): void {\n    if (state) {\n      Object.assign(this.state, state);\n    }\n  }\n}\n","import Point from '../geom/Point';\n\nconst getEllipseAnchorPoint = (\n  center: Point,\n  width: number,\n  height: number,\n  reference: Point,\n): Point => {\n  const { x, y } = reference;\n  if (width === 0 || height === 0 || (center.x === x && center.y === y)) {\n    return center;\n  }\n\n  const dispX = (center.x - x) / (width / 2);\n  const dispY = (center.y - y) / (height / 2);\n\n  const len = Math.sqrt(dispX * dispX + dispY * dispY);\n\n  const newLength = len - 1;\n\n  const lenProportion = newLength / len;\n\n  return new Point((center.x - x) * lenProportion + x, (center.y - y) * lenProportion + y);\n};\n\nconst getRectAnchorPoint = (\n  center: Point,\n  width: number,\n  height: number,\n  reference: Point,\n): Point => {\n  let dx = reference.x - center.x;\n  let dy = reference.y - center.y;\n\n  if ((dx === 0 && dy === 0) || (width === 0 && height === 0)) {\n    return center;\n  }\n\n  const scale =\n    0.5 /\n    Math.max(width === 0 ? 0 : Math.abs(dx) / width, height === 0 ? 0 : Math.abs(dy) / height);\n\n  dx *= scale;\n  dy *= scale;\n\n  return center.clone().translate(dx, dy);\n};\n\nconst svgPointToPoint = (p: SVGPoint): Point => {\n  return new Point(p.x, p.y);\n};\n\nconst distanceToPoint = (p: Point, reference: Point): number => {\n  const dx = p.x - reference.x;\n  const dy = p.y - reference.y;\n\n  return dx * dx + dy * dy;\n};\n\nconst isBetween = (a: number, b1: number, b2: number): boolean => {\n  return Math.ceil(a) >= Math.min(b1, b2) && Math.floor(a) <= Math.max(b1, b2);\n};\n\nconst getLinesIntersection = (line1: [Point, Point], line2: [Point, Point]): Point | null => {\n  const line1xDelta = line1[0].x - line1[1].x;\n  const line1yDelta = line1[0].y - line1[1].y;\n  const line2xDelta = line2[0].x - line2[1].x;\n  const line2yDelta = line2[0].y - line2[1].y;\n\n  const denominator = line1xDelta * line2yDelta - line1yDelta * line2xDelta;\n  if (denominator === 0) {\n    // parallel lines do not intersect\n    return null;\n  }\n\n  const d1 = line1[0].x * line1[1].y - line1[0].y * line1[1].x;\n  const d2 = line2[0].x * line2[1].y - line2[0].y * line2[1].x;\n  const xValue = d1 * line2xDelta - line1xDelta * d2;\n  const yValue = d1 * line2yDelta - d2 * line1yDelta;\n  const intersection: Point = new Point(xValue / denominator, yValue / denominator);\n\n  if (\n    !isBetween(intersection.x, line1[0].x, line1[1].x) ||\n    !isBetween(intersection.y, line1[0].y, line1[1].y) ||\n    !isBetween(intersection.x, line2[0].x, line2[1].x) ||\n    !isBetween(intersection.y, line2[0].y, line2[1].y)\n  ) {\n    // intersection is not in range\n    return null;\n  }\n\n  return intersection;\n};\n\nconst getPathIntersectionPoint = (pathNode: SVGPathElement, line: [Point, Point]): Point => {\n  const pathLength = pathNode.getTotalLength();\n  const numSegments = Math.min(Math.round(pathLength / 5), 100);\n  for (let i = 0; i < numSegments; i++) {\n    const pos1 = pathNode.getPointAtLength((pathLength * i) / numSegments);\n    const pos2 = pathNode.getPointAtLength((pathLength * (i + 1)) / numSegments);\n    const intersectPoint = getLinesIntersection(\n      [svgPointToPoint(pos1), svgPointToPoint(pos2)],\n      line,\n    );\n    if (intersectPoint) {\n      return intersectPoint;\n    }\n  }\n\n  // No intersection found, return the center point\n  const pathBox = pathNode.getBBox();\n  return new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);\n};\n\nconst getPathClosestPoint = (pathNode: SVGPathElement, reference: Point) => {\n  const pathLength = pathNode.getTotalLength();\n  let precision = 8;\n  let best: SVGPoint = pathNode.getPointAtLength(0);\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    const scan: SVGPoint = pathNode.getPointAtLength(scanLength);\n    const scanDistance: number = distanceToPoint(svgPointToPoint(scan), reference);\n    if (scanDistance < bestDistance) {\n      best = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  while (precision > 0.5) {\n    const beforeLength: number = bestLength - precision;\n\n    const before: SVGPoint = pathNode.getPointAtLength(beforeLength);\n    const beforeDistance: number = distanceToPoint(svgPointToPoint(before), reference);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      best = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else {\n      const afterLength: number = bestLength + precision;\n      const after: SVGPoint = pathNode.getPointAtLength(afterLength);\n      const afterDistance: number = distanceToPoint(svgPointToPoint(after), reference);\n\n      if (afterLength <= pathLength && afterDistance < bestDistance) {\n        best = after;\n        bestLength = afterLength;\n        bestDistance = afterDistance;\n      } else {\n        precision /= 2;\n      }\n    }\n  }\n\n  return svgPointToPoint(best);\n};\n\nconst getPathAnchorPoint = (\n  pathNode: SVGPathElement,\n  reference: Point,\n  useClosestPathPoint: boolean = false,\n) => {\n  if (useClosestPathPoint) {\n    return getPathClosestPoint(pathNode, reference);\n  }\n\n  const pathBox = pathNode.getBBox();\n  const pathCenter = new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);\n  return getPathIntersectionPoint(pathNode, [reference, pathCenter]);\n};\n\nconst getPolygonAnchorPoint = (polygonNode: SVGPolygonElement, reference: Point) => {\n  const polygonBox = polygonNode.getBBox();\n  const polygonCenter = new Point(\n    polygonBox.x + polygonBox.width / 2,\n    polygonBox.y + polygonBox.height / 2,\n  );\n  const { points } = polygonNode;\n  let bestPoint: Point = polygonCenter;\n  let bestDistance = Infinity;\n\n  for (let i = 0; i < points.length; i++) {\n    const intersectPoint: Point | null = getLinesIntersection(\n      [svgPointToPoint(points[i]), svgPointToPoint(points[i === points.length - 1 ? 0 : i + 1])],\n      [polygonCenter, reference],\n    );\n    if (intersectPoint) {\n      const intersectDistance: number = distanceToPoint(intersectPoint, reference);\n      if (intersectDistance < bestDistance) {\n        bestPoint = intersectPoint;\n        bestDistance = intersectDistance;\n      }\n    }\n  }\n\n  return bestPoint;\n};\n\nexport { getEllipseAnchorPoint, getRectAnchorPoint, getPathAnchorPoint, getPolygonAnchorPoint };\n","import * as _ from 'lodash';\nimport { EdgeModel, NodeModel } from '../types';\n\nconst getNodeParent = (nodeId: string, nodes: NodeModel[]): NodeModel | undefined => {\n  return nodes.find((n) => n.children?.includes(nodeId));\n};\n\nconst getDisplayedNodeForNode = (\n  nodeId: string | undefined,\n  nodes: NodeModel[] | undefined,\n): string => {\n  if (!nodeId || !nodes) {\n    return '';\n  }\n\n  let displayedNode = nodes && nodes.find((n) => n.id === nodeId);\n  let parent = displayedNode ? getNodeParent(displayedNode.id, nodes) : null;\n  while (parent) {\n    if (parent.collapsed) {\n      displayedNode = parent;\n    }\n    parent = getNodeParent(parent.id, nodes);\n  }\n  return displayedNode ? displayedNode.id : '';\n};\n\nconst createAggregateEdges = (\n  aggregateEdgeType: string,\n  edges: EdgeModel[] | undefined,\n  nodes: NodeModel[] | undefined,\n): EdgeModel[] => {\n  const aggregateEdges: EdgeModel[] = [];\n\n  return _.reduce(\n    edges,\n    (newEdges: EdgeModel[], edge: EdgeModel) => {\n      const source = getDisplayedNodeForNode(edge.source, nodes);\n      const target = getDisplayedNodeForNode(edge.target, nodes);\n\n      // Make sure visible is defined so that changes override what could already be in the element\n      edge.visible = 'visible' in edge ? edge.visible : true;\n\n      if (source !== edge.source || target !== edge.target) {\n        if (source !== target) {\n          const existing = aggregateEdges.find(\n            (e) =>\n              (e.source === source || e.source === target) &&\n              (e.target === target || e.target === source),\n          );\n\n          if (existing) {\n            // At least one other edge, add this edge and add the aggregate edge to the edges\n\n            // Add this edge to the aggregate and set it not visible\n            existing.children && existing.children.push(edge.id);\n            edge.visible = false;\n\n            // Hide edges that are depicted by this aggregate edge\n            _.forEach(existing.children, (existingChild) => {\n              const updateEdge = newEdges.find((newEdge) => newEdge.id === existingChild);\n              if (updateEdge) {\n                updateEdge.visible = false;\n              }\n            });\n\n            // Update the aggregate edges bidirectional flag\n            existing.data.bidirectional =\n              existing.data.bidirectional || existing.source !== edge.source;\n\n            // Check if this edge has already been added\n            if (\n              !newEdges.find(\n                (e) =>\n                  (e.source === source || e.source === target) &&\n                  (e.target === target || e.target === source),\n              )\n            ) {\n              newEdges.push(existing);\n            }\n          } else {\n            const newEdge: EdgeModel = {\n              data: { bidirectional: false },\n              children: [edge.id],\n              source,\n              target,\n              id: `aggregate_${source}_${target}`,\n              type: aggregateEdgeType,\n            };\n            aggregateEdges.push(newEdge);\n          }\n        } else {\n          // Hide edges that connect to a non-visible node to its ancestor\n          edge.visible = false;\n        }\n      }\n      newEdges.push(edge);\n      return newEdges;\n    },\n    [] as EdgeModel[],\n  );\n};\n\nexport { createAggregateEdges };\n","import * as _ from 'lodash';\nimport { GraphElement, Node, isNode, isGraph, NodeStyle } from '../types';\n\nconst groupNodeElements = (nodes: GraphElement[]): Node[] => {\n  if (!_.size(nodes)) {\n    return [];\n  }\n  const groupNodes: Node[] = [];\n  _.forEach(nodes, (nextNode) => {\n    if (isNode(nextNode) && nextNode.isGroup() && !nextNode.isCollapsed()) {\n      groupNodes.push(nextNode);\n      groupNodes.push(...groupNodeElements(nextNode.getChildren()));\n    }\n  });\n  return groupNodes;\n};\n\nconst leafNodeElements = (nodeElements: Node | Node[] | null): Node[] => {\n  const nodes: Node[] = [];\n\n  if (!nodeElements) {\n    return nodes;\n  }\n\n  if (Array.isArray(nodeElements)) {\n    _.forEach(nodeElements, (nodeElement: Node) => {\n      nodes.push(...leafNodeElements(nodeElement));\n    });\n    return nodes;\n  }\n\n  if (nodeElements.isGroup() && !nodeElements.isCollapsed()) {\n    const leafNodes: Node[] = [];\n    const children: GraphElement[] = nodeElements.getChildren();\n    if (_.size(children)) {\n      _.forEach(\n        children.filter((e) => isNode(e)),\n        (element: Node) => {\n          leafNodes.push(...leafNodeElements(element));\n        },\n      );\n    }\n    return leafNodes;\n  }\n\n  return [nodeElements];\n};\n\nconst getTopCollapsedParent = (node: Node): Node => {\n  let returnNode: Node = node;\n  try {\n    let parent = !isGraph(node) && node.getParent();\n    while (parent && !isGraph(parent)) {\n      if ((parent as Node).isCollapsed()) {\n        returnNode = parent as Node;\n      }\n      parent = parent.getParent();\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  return returnNode;\n};\n\nconst getClosestVisibleParent = (node: Node): Node | null => {\n  if (!node) {\n    return null;\n  }\n\n  let returnNode = null;\n  try {\n    let parent = node.getParent();\n    while (parent) {\n      if (!parent.isVisible()) {\n        // parent isn't visible so no descendant could be visible\n        returnNode = null;\n      } else if ((parent as Node).isCollapsed() || !returnNode) {\n        // parent is collapsed, no descendant is visible, but parent is\n        returnNode = parent as Node;\n      }\n      parent = parent.getParent();\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  return returnNode;\n};\n\nconst getElementPadding = (element: GraphElement): number => {\n  const stylePadding = element.getStyle<NodeStyle>().padding;\n  if (!stylePadding) {\n    return 0;\n  }\n\n  if (Array.isArray(stylePadding)) {\n    // For a padding that is not consistent on all sides, use the max padding\n    return stylePadding.reduce((val, current) => {\n      return Math.max(val, current);\n    }, 0);\n  }\n\n  return stylePadding as number;\n};\n\nconst getGroupPadding = (element: GraphElement, padding = 0): number => {\n  if (isGraph(element)) {\n    return padding;\n  }\n  let newPadding = padding;\n  if (isNode(element) && element.isGroup() && !element.isCollapsed()) {\n    newPadding += getElementPadding(element);\n  }\n  if (element.getParent()) {\n    return getGroupPadding(element.getParent(), newPadding);\n  }\n  return newPadding;\n};\n\nexport {\n  groupNodeElements,\n  leafNodeElements,\n  getTopCollapsedParent,\n  getClosestVisibleParent,\n  getElementPadding,\n  getGroupPadding,\n};\n","import { Padding } from '../geom/types';\n\nexport const maxPadding = (padding?: Padding): number => {\n  if (typeof padding === 'number') {\n    return +padding;\n  }\n  if (Array.isArray(padding)) {\n    return padding.reduce((max, p) => Math.max(max, p), 0);\n  }\n  return 0;\n};\n","export * from './anchor-utils';\nexport { default as ControllerContext } from './ControllerContext';\nexport { default as ElementContext } from './ElementContext';\nexport * from './element-utils';\nexport * from './geom-utils';\nexport * from './svg-utils';\nexport { default as useCallbackRef } from './useCallbackRef';\nexport { default as useCombineRefs } from './useCombineRefs';\nexport { default as useHover } from './useHover';\nexport * from './useSize';\nexport * from './createAggregateEdges';\n","import { PointTuple } from '../types';\n\nexport function createSvgIdUrl(id: string): string {\n  return `url(${`${window.location.pathname}${window.location.search}`}#${id})`;\n}\n\nexport type HullPaddingGetter = (point: PointTuple) => number;\n\n// Returns the vector 'v' scaled by 'scale'.\nexport function vecScale(scale: number, v: PointTuple): PointTuple {\n  return [scale * v[0], scale * v[1]];\n}\n\n// Returns the sum of two vectors, or a combination of a point and a vector.\nexport function vecSum(pv1: PointTuple, pv2: PointTuple): PointTuple {\n  return [pv1[0] + pv2[0], pv1[1] + pv2[1]];\n}\n\n// Returns the unit normal to the line segment from p0 to p1.\nexport function unitNormal(p0: PointTuple, p1: PointTuple): PointTuple {\n  const n = [p0[1] - p1[1], p1[0] - p0[0]];\n  const nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n  return nLength > 0 ? [n[0] / nLength, n[1] / nLength] : [0, 0];\n}\n\n// Returns the path for a rounded hull around a single point (a circle).\nfunction roundedHull1(polyPoints: PointTuple[], hp: HullPaddingGetter): string {\n  const padding = hp(polyPoints[0]);\n  const p1 = [polyPoints[0][0], polyPoints[0][1] - padding];\n  const p2 = [polyPoints[0][0], polyPoints[0][1] + padding];\n\n  return `M ${p1} A ${padding},${padding},0,0,0,${p2} A ${padding},${padding},0,0,0,${p1}`;\n}\n\n// Returns the path for a rounded hull around two points (a \"capsule\" shape).\nexport function boundingBoxForLine(\n  startPoint: PointTuple,\n  endPoint: PointTuple,\n  padding: number | HullPaddingGetter = 0,\n): [PointTuple, PointTuple, PointTuple, PointTuple] {\n  const hp = typeof padding === 'number' ? () => padding : padding;\n  const offsetVector1 = vecScale(hp(startPoint), unitNormal(startPoint, endPoint));\n  const invOffsetVector1 = vecScale(-1, offsetVector1);\n\n  const offsetVector2 = vecScale(hp(endPoint), unitNormal(startPoint, endPoint));\n  const invOffsetVector2 = vecScale(-1, offsetVector2);\n\n  const p0 = vecSum(startPoint, offsetVector1);\n  const p1 = vecSum(endPoint, offsetVector2);\n  const p2 = vecSum(endPoint, invOffsetVector2);\n  const p3 = vecSum(startPoint, invOffsetVector1);\n\n  return [p0, p1, p2, p3];\n}\n\n// Returns the path for a rounded hull around two points (a \"capsule\" shape).\nfunction roundedHull2(polyPoints: PointTuple[], hp: HullPaddingGetter): string {\n  const points = boundingBoxForLine(polyPoints[0], polyPoints[1], hp);\n\n  return `M ${points[0]} L ${points[1]} A ${hp(polyPoints[1])},${hp(polyPoints[1])},0,0,0,${\n    points[2]\n  } ${' '}\n   L ${points[3]} A ${hp(polyPoints[0])},${hp(polyPoints[0])},0,0,0,${points[0]}`;\n}\n\n// Returns the SVG path data string representing the polygon, expanded and rounded.\nexport function hullPath(\n  polyPoints: PointTuple[],\n  hullPadding: number | HullPaddingGetter = 0,\n): string {\n  const hp = typeof hullPadding === 'number' ? () => hullPadding : hullPadding;\n\n  // Handle special cases\n  if (!polyPoints || polyPoints.length < 1) {\n    return '';\n  }\n  if (polyPoints.length === 1) {\n    return roundedHull1(polyPoints, hp);\n  }\n  if (polyPoints.length === 2) {\n    return roundedHull2(polyPoints, hp);\n  }\n\n  const segments: PointTuple[][] = new Array(polyPoints.length);\n\n  // Calculate each offset (outwards) segment of the convex hull.\n  for (let segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\n    const p0 =\n      segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\n    const p1 = polyPoints[segmentIndex];\n\n    // Compute the offset vector for the line segment, with length = hullPadding.\n    // const offset = vecScale(hullPadding, unitNormal(p0, p1));\n    segments[segmentIndex] = [\n      vecSum(p0, vecScale(hp(p0), unitNormal(p0, p1))),\n      vecSum(p1, vecScale(hp(p1), unitNormal(p0, p1))),\n    ];\n  }\n\n  return segments\n    .map((segment, index) => {\n      const p0 = index === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[index - 1];\n      return `${index === 0 ? `M ${segments[segments.length - 1][1]} ` : ''}A ${hp(p0)},${hp(\n        p0,\n      )},0,0,0,${segment[0]} L ${segment[1]}`;\n    })\n    .join(' ');\n}\n","import { useRef, useCallback } from 'react';\n\nexport default function useCallbackRef<T extends (...args: any[]) => any>(rawCallback: T) {\n  const cleanupRef = useRef<(() => any) | null>(null);\n  const callback = useCallback<T>(\n    ((node) => {\n      if (cleanupRef.current) {\n        cleanupRef.current();\n        cleanupRef.current = null;\n      }\n      if (node) {\n        cleanupRef.current = rawCallback(node);\n      }\n    }) as T,\n    [rawCallback],\n  );\n\n  return callback;\n}\n","// FIXME fully qualified due to the effect of long build times on storybook\nimport { useCombineRefs } from '@console/shared/src/utils/useCombineRefs';\n\nexport default useCombineRefs;\n","import * as React from 'react';\nimport useCallbackRef from './useCallbackRef';\n\nconst useHover = <T extends Element>(\n  delayIn: number = 200,\n  delayOut: number = 200,\n): [boolean, (node: T) => (() => void) | undefined] => {\n  const [hover, setHover] = React.useState<boolean>(false);\n  const unmountRef = React.useRef(false);\n\n  // need to ensure we do not start the unset timer on unmount\n  React.useEffect(\n    () => () => {\n      unmountRef.current = true;\n    },\n    [],\n  );\n\n  // The unset handle needs to be referred by listeners in different closures.\n  const unsetHandle = React.useRef<number>();\n\n  const callbackRef = useCallbackRef(\n    React.useCallback(\n      (node: T) => {\n        if (node) {\n          // store locally instead of a ref because it only needs to be referred by inner closures\n          let delayHandle: any;\n\n          const delayedStateChange = (newState: boolean, delay: number) => {\n            clearTimeout(unsetHandle.current);\n            clearTimeout(delayHandle);\n\n            if (delay != null) {\n              delayHandle = window.setTimeout(() => {\n                clearTimeout(unsetHandle.current);\n                setHover(newState);\n              }, delay);\n            } else {\n              setHover(newState);\n            }\n          };\n\n          const onMouseEnter = () => {\n            delayedStateChange(true, delayIn);\n          };\n\n          const onMouseLeave = () => {\n            delayedStateChange(false, delayOut);\n          };\n\n          node.addEventListener('mouseenter', onMouseEnter);\n          node.addEventListener('mouseleave', onMouseLeave);\n\n          return () => {\n            node.removeEventListener('mouseenter', onMouseEnter);\n            node.removeEventListener('mouseleave', onMouseLeave);\n            clearTimeout(delayHandle);\n            if (!unmountRef.current) {\n              // Queue the unset in case reattaching to a new node in the same location.\n              // This can happen with layers. Rendering a node to a new layer will unmount the old node\n              // and remount a new node at the same location. This will prevent flickering and getting\n              // stuck in a hover state.\n              unsetHandle.current = window.setTimeout(\n                () => setHover(false),\n                Math.max(delayIn, delayOut),\n              );\n            }\n          };\n        }\n        return undefined;\n      },\n      [delayIn, delayOut],\n    ),\n  );\n\n  return [hover, callbackRef];\n};\n\nexport default useHover;\n","import * as React from 'react';\n\ntype Size = {\n  width: number;\n  height: number;\n};\n\nconst EMPTY: any[] = [];\n\nexport const useSize = (\n  dependencies: any[] = EMPTY,\n): [Size | undefined, (node: SVGGraphicsElement) => void] => {\n  const [size, setSize] = React.useState<Size>();\n  const sizeRef = React.useRef<Size | undefined>();\n  sizeRef.current = size;\n\n  const callbackRef = React.useCallback((node: SVGGraphicsElement): void => {\n    if (node != null) {\n      const bb = node.getBBox();\n      if (\n        !sizeRef.current ||\n        sizeRef.current.width !== bb.width ||\n        sizeRef.current.height !== bb.height\n      ) {\n        setSize({ width: bb.width, height: bb.height });\n      }\n    }\n    // dynamic dependencies\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, dependencies);\n  return [size, callbackRef];\n};\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAgBA;AAOA;AAKA;AAMA;AACA;AACA;AAMA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;AC7CA;AACA;AACA;AAkBA;AACA;AAEA;AAAA;;AAEA;AAKA;AAEA;AAEA;AAEA;AAGA;AA0OA;AAxOA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAxPA;AADA;AACA;AAGA;AADA;AACA;AAWA;AADA;AACA;AAOA;AADA;AA6DA;AAUA;AADA;AAUA;;;;;;;;;;;;;AC3HA;AAAA;AAAA;AAQA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvBA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;ACfA;AACA;AACA;AAMA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAvGA;AADA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACbA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAIA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAKA;AACA;AACA;AACA;;;;;;;;;;;;;ACzCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAQA;AAMA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAUA;AAcA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9GA;AACA;AACA;AACA;AACA;AACA;AAYA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;AACA;AAEA;AAEA;AAeA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAMA;AACA,wGAEA;AACA;AACA;AACA,2DAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAMA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC1VA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAEA;AAEA;AASA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAMA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChOA;AACA;AACA;AAcA;AAEA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAIA;AAEA;AAGA;AARA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAtSA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AAUA;AAyRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClWA;AACA;AACA;AACA;AACA;AACA;AAUA;AAEA;AACA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AAoBA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAMA;AAqBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3LA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gEACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAaA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAgBA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAUA;AAIA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAOA;AAKA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAIA;AAIA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAMA;AAGA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AASA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAKA;AAaA;AACA;AACA;;;;;;;;;;;;;ACzDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AA8CA;AACA;AAEA;;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAMA;AAMA;AAIA;AACA;AACA;AAQA;AAMA;AACA;AACA;AAGA;AACA;AAIA;AACA;AASA;AAWA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAYA;AACA;AACA;;;;;;;;;;;;;ACxPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAiBA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;;;;;;;;;;;;ACtDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAGA;AAWA;AACA;AAGA;AACA;AAGA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAMA;AACA;AAGA;AAEA;;;;;;;;;;;;ACvFA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAWA;AAOA;AACA;AAEA;AAOA;AAKA;AAMA;AAOA;AAiBA;AAEA;;;;;;;;;;;;;AC1EA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAUA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAUA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AClDA;AACA;AACA;AAGA;AAUA;AAAA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AC5BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AAGA;AAEA;;;;;;;;;;;;;ACtFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AAYA;AACA;AACA;AAEA;AAGA;AAKA;AAEA;AACA;AAGA;AAKA;AAOA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAUA;AAKA;AAIA;AAEA;;;;;;;;;;;;ACjFA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAOA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAQA;AAEA;;;;;;;;;;;;ACpEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAAA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAQA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAEA;;;;;;;;;;;;AChEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AASA;AAGA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAnBA;AAsBA;;;;;;AAMA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAOA;AAEA;;;;;;;;;;;;;ACTA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AAMA;;;;;AAKA;AACA;AAAA;;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAiBA;AAfA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;;;;;;;;;;;;;AC3FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAcA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAOA;AAEA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;;;;;;;;;;;;;ACvCA;AAAA;AAAA;AAAA;AAIA;AAEA;;;;;;;;;;;;;ACNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AASA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAtBA;AACA;AAuBA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;;;;;;;;;;;;;ACtDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;;;;;;;;;;;;;ACDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AAEA;AAkBA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAzJA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AAGA;AAGA;AADA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AACA;AAYA;AAGA;AAAA;;AAGA;AAGA;AASA;AAGA;AASA;AA2PA;AAtPA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAhRA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAKA;AADA;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACxDA;AACA;AACA;AACA;AACA;AACA;AAWA;AAEA;AAAA;;AAGA;AAGA;AAMA;AAGA;AAKA;AA6KA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAgDA;AArQA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AA+CA;;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAzRA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAKA;AADA;AACA;AAGA;AADA;AAGA;AAGA;AADA;AAGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;AChDA;AACA;AAcA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AAAA;;AAGA;AACA;AACA;AAGA;AAGA;AAYA;AAGA;AAsOA;AAlPA;AACA;AACA;AACA;AAEA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AA7PA;AADA;AAGA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AAOA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AACA;AAGA;AADA;AAiCA;AAGA;AADA;AAKA;AAGA;AADA;AAKA;;;;;;;;;;;;;ACvGA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAmBA;AAhBA;AAEA;AAeA;AACA;AACA;AAbA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AA1DA;AAMA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAmBA;AACA;AACA;AACA;AAbA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AArDA;AAMA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAEA;AAyBA;AAtBA;AAEA;AAEA;AAEA;AAiBA;AACA;AACA;AACA;AACA;AAjBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AASA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;AAjJA;AAUA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACVA;AACA;AACA;AAgBA;AAKA;AAQA;AACA;AAGA;AAsBA;AAHA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAaA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAmBA;AAVA;AAEA;AAEA;AAEA;AAEA;AAsCA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AA+BA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AA4DA;AACA;AACA;AACA;AACA;AACA;AACA;AA1PA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AA8EA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAgDA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAKA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAtEA;AADA;AAsEA;AAGA;;;;;;;;;;;;;ACtrBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AAJA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AACA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AACA;AALA;AAEA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAfA;AAIA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAQA;AACA;AAEA;;;;;;;;;;;;;ACjLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AAEA;AAGA;AACA;AACA;AAGA;AACA;AACA;AAIA;AAGA;AACA;AACA;AAUA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AC7HA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAXA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtCA;AAAA;AAAA;AAAA;AAAA;AACA;AAcA;AASA;AAFA;AAGA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA,wFAGA;AACA;AAEA;AACA;AACA,qEACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AASA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AClHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;;;;;;;;;;;;;ACiBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AA+IA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAmDA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACvPA;AAAA;AAAA;AAAA;AAGA;AAEA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;ACLA;AAGA;AAAA;AAEA;AAYA;AAVA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AAZA;AADA;AACA;AAOA;AADA;AAKA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAEA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;AC3MA;AAAA;AAAA;AAAA;AAGA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAEA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAGA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;;;;;;;;;;;;;ACtGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AClHA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACRA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAGA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;;;;;;;;;;;;;AC3GA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AACA;AAEA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAKA;AACA;AAEA;;;;;;;;;;;;;AC9EA;AAAA;AAAA;AAAA;AAAA;AAOA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}