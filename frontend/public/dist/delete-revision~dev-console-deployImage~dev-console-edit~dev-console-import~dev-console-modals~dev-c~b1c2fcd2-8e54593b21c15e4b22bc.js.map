{"version":3,"file":"delete-revision~dev-console-deployImage~dev-console-edit~dev-console-import~dev-console-modals~dev-c~b1c2fcd2-8e54593b21c15e4b22bc.js","sources":["webpack:///./packages/dev-console/src/utils/application-utils.ts"],"sourcesContent":["import * as _ from 'lodash';\nimport {\n  K8sKind,\n  k8sGet,\n  k8sList,\n  k8sPatch,\n  k8sKill,\n  K8sResourceKind,\n  modelFor,\n  k8sCreate,\n  LabelSelector,\n  referenceFor,\n  referenceForModel,\n} from '@console/internal/module/k8s';\nimport {\n  ImageStreamModel,\n  BuildConfigModel,\n  ServiceModel,\n  DeploymentConfigModel,\n  DeploymentModel,\n  RouteModel,\n  SecretModel,\n  DaemonSetModel,\n  StatefulSetModel,\n} from '@console/internal/models';\nimport { ClusterServiceVersionModel } from '@console/operator-lifecycle-manager';\nimport {\n  ServiceModel as KnativeServiceModel,\n  RouteModel as KnativeRouteModel,\n} from '@console/knative-plugin';\nimport { isDynamicEventResourceKind } from '@console/knative-plugin/src/utils/fetch-dynamic-eventsources-utils';\nimport { checkAccess } from '@console/internal/components/utils';\nimport { getOperatorBackedServiceKindMap } from '@console/shared';\nimport { CREATE_APPLICATION_KEY, UNASSIGNED_KEY } from '../const';\nimport { TopologyDataObject, ConnectsToData } from '../components/topology/topology-types';\nimport { detectGitType } from '../components/import/import-validation-utils';\nimport { ServiceBindingRequestModel } from '../models';\n\nexport const sanitizeApplicationValue = (\n  application: string,\n  applicationType: string = application,\n): string => {\n  switch (applicationType) {\n    case UNASSIGNED_KEY:\n    case CREATE_APPLICATION_KEY:\n      return '';\n    default:\n      return application;\n  }\n};\n\nexport const edgesFromAnnotations = (annotations): (string | ConnectsToData)[] => {\n  let edges: (string | ConnectsToData)[] = [];\n  if (_.has(annotations, ['app.openshift.io/connects-to'])) {\n    try {\n      edges = JSON.parse(annotations['app.openshift.io/connects-to']);\n    } catch (e) {\n      // connects-to annotation should hold a JSON string value but failed to parse\n      // treat value as a comma separated list of strings\n      edges = annotations['app.openshift.io/connects-to'].split(',').map((v) => v.trim());\n    }\n  }\n\n  return edges;\n};\n\nexport const edgesFromServiceBinding = (\n  source: K8sResourceKind,\n  sbrs: K8sResourceKind[],\n): K8sResourceKind[] => {\n  const sourceBindings = [];\n  _.forEach(sbrs, (sbr) => {\n    let edgeExists = false;\n    if (_.get(sbr, 'spec.applicationSelector.resource') === modelFor(referenceFor(source)).plural) {\n      if (_.get(sbr, 'spec.applicationSelector.resourceRef') === source.metadata.name) {\n        edgeExists = true;\n      } else {\n        const matchLabels = _.has(sbr, 'spec.applicationSelector.matchLabels');\n        if (matchLabels) {\n          const sbrSelector = new LabelSelector(sbr.spec.applicationSelector);\n          if (sbrSelector.matches(source)) {\n            edgeExists = true;\n          }\n        }\n      }\n    }\n    edgeExists && sourceBindings.push(sbr);\n  });\n  return sourceBindings;\n};\n\nconst listInstanceResources = (\n  namespace: string,\n  instanceName: string,\n  labelSelector: any = {},\n): Promise<any> => {\n  const lists: Promise<any>[] = [];\n  const instanceLabelSelector = {\n    'app.kubernetes.io/instance': instanceName,\n    ...labelSelector,\n  };\n\n  const kinds = ['ReplicationController', 'Route', 'Service', 'ReplicaSet', 'BuildConfig', 'Build'];\n  _.forEach(kinds, (kind) => {\n    lists.push(\n      k8sList(modelFor(kind), {\n        ns: namespace,\n        labelSelector: instanceLabelSelector,\n      }).then((values) => {\n        return _.map(values, (value) => {\n          value.kind = kind;\n          return value;\n        });\n      }),\n    );\n  });\n\n  return Promise.all(lists);\n};\n\n// Updates the resource's labels to set its application grouping\nconst updateItemAppLabel = (\n  resourceKind: K8sKind,\n  item: K8sResourceKind,\n  application: string,\n): Promise<any> => {\n  const labels = { ...item.metadata.labels, 'app.kubernetes.io/part-of': application || undefined };\n\n  if (!resourceKind) {\n    return Promise.reject();\n  }\n\n  const patch = [\n    {\n      op: _.isEmpty(labels) ? 'add' : 'replace',\n      path: '/metadata/labels',\n      value: labels,\n    },\n  ];\n\n  return k8sPatch(resourceKind, item, patch);\n};\n\n// Updates the given resource and its associated resources to the given application grouping\nexport const updateResourceApplication = (\n  resourceKind: K8sKind,\n  resource: K8sResourceKind,\n  application: string,\n): Promise<any> => {\n  if (!resource) {\n    return Promise.reject(new Error('Error: no resource provided to update application for.'));\n  }\n  if (!resourceKind) {\n    return Promise.reject(\n      new Error('Error: invalid resource kind provided for updating application.'),\n    );\n  }\n\n  const instanceName = _.get(resource, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n  const prevApplication = _.get(resource, ['metadata', 'labels', 'app.kubernetes.io/part-of']);\n\n  const patches: Promise<any>[] = [updateItemAppLabel(resourceKind, resource, application)];\n\n  // If there is no instance label, only update this item\n  if (!instanceName) {\n    return Promise.all(patches);\n  }\n\n  // selector is for the instance name and current application if there is one\n  const labelSelector = {\n    'app.kubernetes.io/instance': instanceName,\n  };\n  if (prevApplication) {\n    labelSelector['app.kubernetes.io/part-of'] = prevApplication;\n  }\n\n  // Update all the instance's resources that were part of the previous application\n  return listInstanceResources(resource.metadata.namespace, instanceName, {\n    'app.kubernetes.io/part-of': prevApplication,\n  }).then((listsValue) => {\n    _.forEach(listsValue, (list) => {\n      _.forEach(list, (item) => {\n        // verify the case of no previous application\n        if (prevApplication || !_.get(item, ['metadata', 'labels', 'app.kubernetes.io/part-of'])) {\n          patches.push(updateItemAppLabel(modelFor(item.kind), item, application));\n        }\n      });\n    });\n\n    return Promise.all(patches);\n  });\n};\n\n// Updates the item to add an new connect's to value replacing an old value if provided\nconst updateItemAppConnectTo = (\n  item: K8sResourceKind,\n  connections: (string | ConnectsToData)[],\n  connectValue: ConnectsToData,\n  oldValueIndex: number,\n) => {\n  const model = modelFor(referenceFor(item) || item.kind);\n\n  if (!model) {\n    return Promise.reject(new Error(`Unable to retrieve model for: ${item.kind}`));\n  }\n\n  const tags = _.toPairs(item.metadata.annotations);\n  let op = _.size(tags) ? 'replace' : 'add';\n\n  const existingTag = _.find(tags, (tag) => tag[0] === 'app.openshift.io/connects-to');\n  if (existingTag) {\n    if (connections.includes(connectValue)) {\n      return Promise.resolve();\n    }\n\n    if (!connectValue) {\n      _.pullAt(connections, [oldValueIndex]);\n    } else if (oldValueIndex >= 0) {\n      connections[oldValueIndex] = connectValue;\n    } else {\n      connections.push(connectValue);\n    }\n    existingTag[1] = _.size(connections) && JSON.stringify(connections);\n\n    if (!existingTag[1]) {\n      _.remove(tags, (tag) => tag === existingTag);\n      if (!_.size(tags)) {\n        op = 'remove';\n      }\n    }\n  } else {\n    if (!connectValue) {\n      // Removed connection not found, no need to remove\n      return Promise.resolve();\n    }\n\n    const connectionTag: [string, string] = [\n      'app.openshift.io/connects-to',\n      JSON.stringify([connectValue]),\n    ];\n    tags.push(connectionTag);\n  }\n\n  const patch = [{ path: '/metadata/annotations', op, value: _.fromPairs(tags) }];\n\n  return k8sPatch(model, item, patch);\n};\n\nexport const createServiceBinding = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n\n  const targetName = _.get(target, 'metadata.name');\n  const sourceName = _.get(source, 'metadata.name');\n  const namespace = _.get(source, 'metadata.namespace');\n  const sourceGroup = _.split(_.get(source, 'apiVersion'), '/');\n  const targetResourceGroup = _.split(_.get(target, 'metadata.ownerReferences[0].apiVersion'), '/');\n  const targetResourceKind = _.get(target, 'metadata.ownerReferences[0].kind');\n  const targetResourceRefName = _.get(target, 'metadata.ownerReferences[0].name');\n  const sbrName = `${sourceName}-${modelFor(referenceFor(source)).abbr}-${targetName}-${\n    modelFor(target.kind).abbr\n  }`;\n\n  const serviceBindingRequest = {\n    apiVersion: 'apps.openshift.io/v1alpha1',\n    kind: 'ServiceBindingRequest',\n    metadata: {\n      name: sbrName,\n      namespace,\n    },\n    spec: {\n      applicationSelector: {\n        resourceRef: sourceName,\n        group: sourceGroup[0],\n        version: sourceGroup[1],\n        resource: modelFor(referenceFor(source)).plural,\n      },\n      backingServiceSelector: {\n        group: targetResourceGroup[0],\n        version: targetResourceGroup[1],\n        kind: targetResourceKind,\n        resourceRef: targetResourceRefName,\n      },\n      detectBindingResources: true,\n    },\n  };\n\n  return k8sCreate(ServiceBindingRequestModel, serviceBindingRequest);\n};\n\nexport const removeServiceBinding = (sbr: K8sResourceKind): Promise<any> => {\n  return k8sKill(ServiceBindingRequestModel, sbr);\n};\n\n// Get the index of the replaced target of the visual connector\nconst getReplacedTargetIndex = (\n  replacedTarget: K8sResourceKind,\n  connections: (string | ConnectsToData)[],\n): number => {\n  if (replacedTarget) {\n    const replaceTargetName = replacedTarget.metadata?.name;\n    const replaceTargetKind = replacedTarget.kind;\n    const replaceTargetApiVersion = replacedTarget.apiVersion;\n    const replaceValue = {\n      apiVersion: replaceTargetApiVersion,\n      kind: replaceTargetKind,\n      name: replaceTargetName,\n    };\n    const replaceTargetInstanceName =\n      replacedTarget.metadata?.labels?.['app.kubernetes.io/instance'];\n    let index = _.findIndex(connections, replaceValue);\n    if (index === -1) {\n      index = _.findIndex(\n        connections,\n        (connection) => connection === (replaceTargetInstanceName || replaceTargetName),\n      );\n    }\n    return index;\n  }\n  return -1;\n};\n\n// Create a connection from the source to the target replacing the connection to replacedTarget if provided\nexport const createResourceConnection = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n  replacedTarget: K8sResourceKind = null,\n): Promise<K8sResourceKind[] | K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n\n  const connectTargetName = target.metadata?.name;\n  const connectTargetKind = target.kind;\n  const connectTargetApiVersion = target.apiVersion;\n  const connectValue = {\n    apiVersion: connectTargetApiVersion,\n    kind: connectTargetKind,\n    name: connectTargetName,\n  };\n\n  const connections = edgesFromAnnotations(source.metadata?.annotations);\n\n  const replacedTargetIndex = getReplacedTargetIndex(replacedTarget, connections);\n\n  const instanceName = _.get(source, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n\n  const patches: Promise<K8sResourceKind>[] = [\n    updateItemAppConnectTo(source, connections, connectValue, replacedTargetIndex),\n  ];\n\n  // If there is no instance label, only update this item\n  if (!instanceName) {\n    return Promise.all(patches);\n  }\n\n  // Update all the instance's resources that were part of the previous application\n  return listInstanceResources(source.metadata.namespace, instanceName).then((listsValue) => {\n    _.forEach(listsValue, (list) => {\n      _.forEach(list, (item) => {\n        patches.push(updateItemAppConnectTo(item, connections, connectValue, replacedTargetIndex));\n      });\n    });\n\n    return Promise.all(patches);\n  });\n};\n\n// Remove the connection from the source to the target\nexport const removeResourceConnection = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n): Promise<any> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n  const connections = edgesFromAnnotations(source.metadata?.annotations);\n\n  const replacedTargetIndex = getReplacedTargetIndex(target, connections);\n\n  const instanceName = _.get(source, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n\n  const patches: Promise<any>[] = [\n    updateItemAppConnectTo(source, connections, null, replacedTargetIndex),\n  ];\n\n  // If there is no instance label, only update this item\n  if (!instanceName) {\n    return Promise.all(patches);\n  }\n\n  // Update all the instance's resources that were part of the previous application\n  return listInstanceResources(source.metadata.namespace, instanceName).then((listsValue) => {\n    _.forEach(listsValue, (list) => {\n      _.forEach(list, (item) => {\n        patches.push(updateItemAppConnectTo(item, connections, null, replacedTargetIndex));\n      });\n    });\n\n    return Promise.all(patches);\n  });\n};\n\nconst safeKill = async (model: K8sKind, obj: K8sResourceKind) => {\n  const resp = await checkAccess({\n    group: model.apiGroup,\n    resource: model.plural,\n    verb: 'delete',\n    name: obj.metadata.name,\n    namespace: obj.metadata.namespace,\n  });\n  if (resp.status.allowed) {\n    return k8sKill(model, obj);\n  }\n  return null;\n};\n\nconst deleteWebhooks = (\n  resource: K8sResourceKind,\n  workload: TopologyDataObject<{ isKnativeResource?: boolean }>,\n) => {\n  const isKnativeResource = workload?.data?.isKnativeResource ?? false;\n  const deploymentsAnnotations = resource.metadata?.annotations ?? {};\n  const gitType = detectGitType(deploymentsAnnotations['app.openshift.io/vcs-uri']);\n  const buildConfigs = workload?.resources?.buildConfigs;\n  return buildConfigs?.reduce((requests, bc) => {\n    const triggers = bc.spec?.triggers ?? [];\n    const reqs = triggers.reduce((a, t) => {\n      let obj: K8sResourceKind;\n      const webhookType = t.generic ? 'generic' : gitType;\n      const webhookTypeObj = t.generic || (!isKnativeResource && t[gitType]);\n      if (webhookTypeObj) {\n        obj = {\n          ...resource,\n          metadata: {\n            name:\n              webhookTypeObj.secretReference?.name ??\n              `${resource.metadata.name}-${webhookType}-webhook-secret`,\n            namespace: resource.metadata.namespace,\n          },\n        };\n      }\n      return obj ? [...a, safeKill(SecretModel, obj)] : a;\n    }, []);\n    return [...requests, ...reqs];\n  }, []);\n};\n\nexport const cleanUpWorkload = (\n  resource: K8sResourceKind,\n  workload: TopologyDataObject,\n): Promise<K8sResourceKind[]> => {\n  const reqs = [];\n  const isBuildConfigPresent = !_.isEmpty(workload?.resources?.buildConfigs);\n\n  const deleteModels = [ServiceModel, RouteModel];\n  const knativeDeleteModels = [KnativeServiceModel, KnativeRouteModel, ImageStreamModel];\n  if (isBuildConfigPresent) {\n    deleteModels.push(BuildConfigModel);\n    knativeDeleteModels.push(BuildConfigModel);\n  }\n  const resourceData = _.cloneDeep(resource);\n  const deleteRequest = (model: K8sKind, resourceObj: K8sResourceKind) => {\n    const req = safeKill(model, resourceObj);\n    req && reqs.push(req);\n  };\n  const batchDeleteRequests = (models: K8sKind[], resourceObj: K8sResourceKind): void => {\n    models.forEach((model) => deleteRequest(model, resourceObj));\n  };\n  if (isDynamicEventResourceKind(referenceFor(resource)))\n    deleteRequest(modelFor(referenceFor(resource)), resource);\n  switch (resource.kind) {\n    case DaemonSetModel.kind:\n    case StatefulSetModel.kind:\n      deleteRequest(modelFor(resource.kind), resource);\n      break;\n    case DeploymentModel.kind:\n    case DeploymentConfigModel.kind:\n      deleteRequest(modelFor(resource.kind), resource);\n      batchDeleteRequests(deleteModels, resource);\n      deleteRequest(ImageStreamModel, resource); // delete imageStream\n      break;\n    case KnativeServiceModel.kind:\n      batchDeleteRequests(knativeDeleteModels, resourceData);\n      break;\n    default:\n      break;\n  }\n  isBuildConfigPresent && reqs.push(...deleteWebhooks(resource, workload));\n  return Promise.all(reqs);\n};\n\nexport const doContextualBinding = async (\n  resources: K8sResourceKind[],\n  contextualSource: string,\n  serviceBindingAvailable: boolean = false,\n): Promise<K8sResourceKind[]> => {\n  if (!contextualSource) {\n    return Promise.reject(new Error('Cannot do a contextual binding without a source'));\n  }\n\n  const linkingModelRefs = [\n    referenceForModel(DeploymentConfigModel),\n    referenceForModel(DeploymentModel),\n  ];\n  const newResource: K8sResourceKind = resources.find((resource) =>\n    linkingModelRefs.includes(referenceFor(resource)),\n  );\n\n  if (!newResource) {\n    // Not a resource we want to connect to\n    return resources;\n  }\n\n  const {\n    metadata: { namespace },\n  } = newResource;\n  const [groupVersionKind, resourceName] = contextualSource.split('/');\n  const contextualResource: K8sResourceKind = await k8sGet(\n    modelFor(groupVersionKind),\n    resourceName,\n    namespace,\n  );\n\n  if (!contextualResource) {\n    return Promise.reject(\n      new Error(`Cannot find resource (${contextualSource}) to do a contextual binding to`),\n    );\n  }\n\n  if (serviceBindingAvailable) {\n    const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(\n      await k8sList(ClusterServiceVersionModel, { ns: namespace }),\n    );\n    const ownerResourceKind = newResource?.metadata?.ownerReferences?.[0]?.kind;\n    const isOperatorBacked = ownerResourceKind in operatorBackedServiceKindMap;\n\n    if (isOperatorBacked) {\n      await createServiceBinding(contextualResource, newResource);\n    }\n  }\n\n  await createResourceConnection(contextualResource, newResource);\n\n  return resources;\n};\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAaA;AAWA;AACA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAKA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAMA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;;AAIA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;;AACA;AACA;;AACA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAMA;AACA;AAGA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;;;;;A","sourceRoot":""}