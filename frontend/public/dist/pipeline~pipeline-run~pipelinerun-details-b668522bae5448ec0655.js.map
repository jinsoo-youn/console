{"version":3,"file":"pipeline~pipeline-run~pipelinerun-details-b668522bae5448ec0655.js","sources":["webpack:///./packages/dev-console/src/components/pipelineruns/detail-page-tabs/PipelineRunLogs.scss?9b49","webpack:///./packages/dev-console/src/components/pipelineruns/detail-page-tabs/PipelineRunLogs.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/detail-page-tabs/PipelineRunVisualization.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/detail-page-tabs/TriggeredBySection.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/logs/Logs.scss?654d","webpack:///./packages/dev-console/src/components/pipelineruns/logs/Logs.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/logs/LogsWrapperComponent.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/logs/MultiStreamLogs.scss?06f8","webpack:///./packages/dev-console/src/components/pipelineruns/logs/MultiStreamLogs.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/logs/logs-utils.ts","webpack:///./packages/dev-console/src/components/pipelines/resource-overview/ResourceLinkList.tsx"],"sourcesContent":["// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { RouteComponentProps } from 'react-router';\nimport { Link } from 'react-router-dom';\nimport { Nav, NavItem, NavList } from '@patternfly/react-core';\nimport { StatusIcon } from '@console/shared';\nimport { Firehose, resourcePathFromModel } from '@console/internal/components/utils';\nimport { pipelineRunFilterReducer } from '../../../utils/pipeline-filter-reducer';\nimport { PipelineRun } from '../../../utils/pipeline-augment';\nimport { PipelineRunModel } from '../../../../../../../frontend/public/models/index';\nimport LogsWrapperComponent from '../logs/LogsWrapperComponent';\nimport { getDownloadAllLogsCallback } from '../logs/logs-utils';\nimport './PipelineRunLogs.scss';\n\ninterface PipelineRunLogsProps {\n  obj: PipelineRun;\n  activeTask?: string;\n}\ninterface PipelineRunLogsState {\n  activeItem: string;\n  navUntouched: boolean;\n}\nclass PipelineRunLogs extends React.Component<PipelineRunLogsProps, PipelineRunLogsState> {\n  constructor(props) {\n    super(props);\n    this.state = { activeItem: null, navUntouched: true };\n  }\n\n  componentDidMount() {\n    const { obj, activeTask } = this.props;\n    const taskRunFromYaml = _.merge(_.get(obj, ['status', 'taskRuns'], {}), _.get(obj, ['status', 'runs'], {}));\n    const taskRuns = this.getSortedTaskRun(taskRunFromYaml);\n    const activeItem = this.getActiveTaskRun(taskRuns, activeTask);\n    this.setState({ activeItem });\n  }\n\n  UNSAFE_componentWillReceiveProps(nextProps) {\n    if (this.props.obj !== nextProps.obj) {\n      const { obj, activeTask } = this.props;\n      const taskRunFromYaml = _.merge(_.get(obj, ['status', 'taskRuns'], {}), _.get(obj, ['status', 'runs'], {}));\n      const taskRuns = this.getSortedTaskRun(taskRunFromYaml);\n      const activeItem = this.getActiveTaskRun(taskRuns, activeTask);\n      this.state.navUntouched && this.setState({ activeItem });\n    }\n  }\n\n  getActiveTaskRun = (taskRuns: string[], activeTask: string): string =>\n    activeTask\n      ? taskRuns.find((taskRun) => taskRun.includes(activeTask))\n      : taskRuns[taskRuns.length - 1];\n\n  getSortedTaskRun = (taskRunFromYaml) => {\n    const taskRuns = Object.keys(taskRunFromYaml).sort((a, b) => {\n      if (_.get(taskRunFromYaml, [a, 'status', 'completionTime'], false)) {\n        return taskRunFromYaml[b].status.completionTime &&\n          new Date(taskRunFromYaml[a].status.completionTime) >\n            new Date(taskRunFromYaml[b].status.completionTime)\n          ? 1\n          : -1;\n      }\n      return taskRunFromYaml[b].status.completionTime ||\n        new Date(taskRunFromYaml[a].status?.startTime) >\n          new Date(taskRunFromYaml[b].status?.startTime)\n        ? 1\n        : -1;\n    });\n    return taskRuns;\n  };\n\n  onNavSelect = (item) => {\n    this.setState({\n      activeItem: item.itemId,\n      navUntouched: false,\n    });\n  };\n\n  render() {\n    const { obj } = this.props;\n    const { activeItem } = this.state;\n    const taskRunFromYaml = _.merge(_.get(obj, ['status', 'taskRuns'], {}), _.get(obj, ['status', 'runs'], {}));\n    const taskRuns = this.getSortedTaskRun(taskRunFromYaml);\n\n    const taskCount = taskRuns.length;\n    const downloadAllCallback =\n      taskCount > 1\n        ? getDownloadAllLogsCallback(\n            taskRuns,\n            taskRunFromYaml,\n            obj.metadata?.namespace,\n            obj.metadata?.name,\n          )\n        : undefined;\n    const resources = taskCount > 0 && [\n      {\n        name: _.get(taskRunFromYaml[activeItem], ['status', 'podName'], ''),\n        kind: 'Pod',\n        namespace: obj.metadata.namespace,\n        prop: `obj`,\n        isList: false,\n      },\n    ];\n    const path = `${resourcePathFromModel(\n      PipelineRunModel,\n      obj.metadata.name,\n      obj.metadata.namespace,\n    )}/logs/`;\n    return (\n      <div className=\"odc-pipeline-run-logs\">\n        <div className=\"odc-pipeline-run-logs__tasklist\" data-test-id=\"logs-tasklist\">\n          {taskCount > 0 ? (\n            <Nav onSelect={this.onNavSelect}>\n              <NavList className=\"odc-pipeline-run-logs__nav\">\n                {taskRuns.map((task) => {\n                  return (\n                    <NavItem\n                      key={task}\n                      itemId={task}\n                      isActive={activeItem === task}\n                      className=\"odc-pipeline-run-logs__navitem\"\n                    >\n                      <Link to={path + _.get(taskRunFromYaml, [task, `pipelineTaskName`], '-')}>\n                        <StatusIcon\n                          status={pipelineRunFilterReducer(\n                            _.merge(_.get(obj, ['status', 'taskRuns'], {}), _.get(obj, ['status', 'runs'], {})),\n                          )}\n                        />\n                        <span className=\"odc-pipeline-run-logs__namespan\">\n                          {_.get(taskRunFromYaml, [task, `pipelineTaskName`], '-')}\n                        </span>\n                      </Link>\n                    </NavItem>\n                  );\n                })}\n              </NavList>\n            </Nav>\n          ) : (\n            <div className=\"odc-pipeline-run-logs__nav\">No Task Runs Found</div>\n          )}\n        </div>\n        <div className=\"odc-pipeline-run-logs__container\">\n          {activeItem && resources[0].name ? (\n            <Firehose key={activeItem} resources={resources}>\n              <LogsWrapperComponent\n                taskName={_.get(taskRunFromYaml, [activeItem, 'pipelineTaskName'], '-')}\n                downloadAllLabel=\"Download All Task Logs\"\n                onDownloadAll={downloadAllCallback}\n              />\n            </Firehose>\n          ) : (\n            <>\n              <div className=\"odc-pipeline-run-logs__taskName\">\n                {_.get(taskRunFromYaml, [activeItem, 'pipelineTaskName'], '-')}\n              </div>\n              <div className=\"odc-pipeline-run-logs__log\">\n                <span className=\"odc-pipeline-run-logs__message\">No Logs Found</span>\n              </div>\n            </>\n          )}\n        </div>\n      </div>\n    );\n  }\n}\n\ntype PipelineRunLogsWithActiveTaskProps = {\n  obj: PipelineRun;\n  params?: RouteComponentProps;\n};\n\nexport const PipelineRunLogsWithActiveTask: React.FC<PipelineRunLogsWithActiveTaskProps> = ({\n  obj,\n  params,\n}) => {\n  const activeTask = _.get(params, 'match.params.name');\n  return <PipelineRunLogs obj={obj} activeTask={activeTask} />;\n};\n\nexport default PipelineRunLogs;\n","import * as React from 'react';\nimport { Alert } from '@patternfly/react-core';\nimport { k8sGet } from '@console/internal/module/k8s';\nimport { PipelineModel } from '../../../models';\nimport PipelineVisualization from '../../pipelines/detail-page-tabs/pipeline-details/PipelineVisualization';\nimport { Pipeline, PipelineRun, pipelineRefExists, PipelineTask } from '../../../utils/pipeline-augment';\n\ntype PipelineRunVisualizationProps = {\n  pipelineRun: PipelineRun;\n};\n\nconst PipelineRunVisualization: React.FC<PipelineRunVisualizationProps> = ({ pipelineRun }) => {\n  const [errorMessage, setErrorMessage] = React.useState<string>(null);\n  const [pipeline, setPipeline] = React.useState<Pipeline>(null);\n\n  React.useEffect(() => {\n    if (pipelineRefExists(pipelineRun)) {\n      k8sGet(PipelineModel, pipelineRun.spec.pipelineRef.name, pipelineRun.metadata.namespace)\n        .then((res: Pipeline) => setPipeline(res))\n        .catch((error) =>\n          setErrorMessage(error?.message || 'Could not load visualization at this time.'),\n        );\n    } else {\n      const p: Pipeline = {\n        spec: {\n          tasks: pipelineRun.spec.pipelineSpec.tasks.map((task): PipelineTask => {\n            return {\n              name: task.name,\n              params: task.params,\n              taskRef: {\n                name: task.name,\n              },\n              runAfter: task.runAfter,\n              resources: task.resources\n            }\n          })\n        }\n      };\n      setPipeline(p);\n    }\n  }, [pipelineRun, setPipeline]);\n\n  if (errorMessage) {\n    return <Alert variant=\"danger\" isInline title={errorMessage} />;\n  }\n\n  if (!pipeline || !pipelineRun) {\n    return null;\n  }\n\n  return <PipelineVisualization pipeline={pipeline} pipelineRun={pipelineRun} />;\n};\n\nexport default PipelineRunVisualization;\n","import * as React from 'react';\nimport { ResourceLink } from '@console/internal/components/utils';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { EventListenerModel } from '../../../models';\nimport { PipelineRun } from '../../../utils/pipeline-augment';\nimport { StartedByLabel } from '../../pipelines/const';\n\ntype TriggeredByProps = {\n  pipelineRun: PipelineRun;\n};\n\nconst TriggeredBySection: React.FC<TriggeredByProps> = (props) => {\n  const {\n    pipelineRun: {\n      metadata: { namespace, labels },\n    },\n  } = props;\n\n  const manualTrigger = labels[StartedByLabel.user];\n  const autoTrigger = labels[StartedByLabel.triggers];\n\n  if (!manualTrigger && !autoTrigger) {\n    return null;\n  }\n\n  let value = null;\n  if (manualTrigger) {\n    value = manualTrigger;\n  } else if (autoTrigger) {\n    value = (\n      <ResourceLink\n        kind={referenceForModel(EventListenerModel)}\n        name={autoTrigger}\n        namespace={namespace}\n      />\n    );\n  } else {\n    return null;\n  }\n\n  return (\n    <dl>\n      <dt>Triggered by:</dt>\n      <dd>{value}</dd>\n    </dl>\n  );\n};\n\nexport default TriggeredBySection;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Base64 } from 'js-base64';\nimport { Alert } from '@patternfly/react-core';\nimport { resourceURL, modelFor, PodKind, ContainerSpec } from '@console/internal/module/k8s';\nimport { WSFactory } from '@console/internal/module/ws-factory';\nimport { LOG_SOURCE_TERMINATED } from '@console/internal/components/utils';\nimport { coFetchText } from '@console/internal/co-fetch';\nimport './Logs.scss';\n\ntype LogsProps = {\n  resource: PodKind;\n  resourceStatus: string;\n  container: ContainerSpec;\n  render: boolean;\n  autoScroll?: boolean;\n  onComplete: (containerName: string) => void;\n};\n\nconst Logs: React.FC<LogsProps> = ({\n  resource,\n  resourceStatus,\n  container,\n  onComplete,\n  render,\n  autoScroll = true,\n}) => {\n  const { name } = container;\n  const { kind, metadata = {} } = resource;\n  const { name: resName, namespace: resNamespace } = metadata;\n  const contentRef = React.useRef<HTMLDivElement>(null);\n  const [error, setError] = React.useState<boolean>(false);\n  const resourceStatusRef = React.useRef<string>(resourceStatus);\n  const onCompleteRef = React.useRef<(name) => void>();\n  onCompleteRef.current = onComplete;\n  const appendMessage = React.useRef<(blockContent) => void>();\n  appendMessage.current = React.useCallback(\n    (blockContent) => {\n      const contentLines = blockContent.split('\\n').filter((line) => !!line);\n      if (contentRef.current && contentLines.length >= 0) {\n        const elements = contentLines.map((content) => {\n          const customElement = document.createElement('div');\n          customElement.textContent = content;\n          return customElement;\n        });\n        elements.forEach((element) => {\n          contentRef.current.append(element);\n        });\n        const lastElement = elements[elements.length - 1];\n        if (render && lastElement && autoScroll) {\n          lastElement.scrollIntoView({ behavior: 'smooth', block: 'end' });\n        }\n      }\n    },\n    [autoScroll, render],\n  );\n\n  if (resourceStatusRef.current !== resourceStatus) {\n    resourceStatusRef.current = resourceStatus;\n  }\n\n  React.useEffect(() => {\n    let loaded: boolean = false;\n    let ws: WSFactory;\n    const urlOpts = {\n      ns: resNamespace,\n      name: resName,\n      path: 'log',\n      queryParams: {\n        container: name,\n        follow: 'true',\n      },\n    };\n    const watchURL = resourceURL(modelFor(kind), urlOpts);\n    if (resourceStatusRef.current === LOG_SOURCE_TERMINATED) {\n      coFetchText(watchURL)\n        .then((res) => {\n          if (loaded) return;\n          appendMessage.current(res);\n          onCompleteRef.current(name);\n        })\n        .catch(() => {\n          if (loaded) return;\n          setError(true);\n          onCompleteRef.current(name);\n        });\n    } else {\n      const wsOpts = {\n        host: 'auto',\n        path: watchURL,\n        subprotocols: ['base64.binary.k8s.io'],\n      };\n      ws = new WSFactory(watchURL, wsOpts);\n      ws.onmessage((msg) => {\n        if (loaded) return;\n        const message = Base64.decode(msg);\n        appendMessage.current(message);\n      })\n        .onclose(() => {\n          onCompleteRef.current(name);\n        })\n        .onerror(() => {\n          if (loaded) return;\n          setError(true);\n          onCompleteRef.current(name);\n        });\n    }\n    return () => {\n      loaded = true;\n      ws && ws.destroy();\n    };\n  }, [kind, name, resName, resNamespace]);\n\n  React.useEffect(() => {\n    if (contentRef.current && render && autoScroll) {\n      contentRef.current.scrollIntoView({ behavior: 'smooth', block: 'end' });\n    }\n  }, [autoScroll, render]);\n  return (\n    <div className=\"odc-logs\" style={{ display: render ? '' : 'none' }}>\n      <p className=\"odc-logs__name\">{name}</p>\n      {error && (\n        <Alert\n          variant=\"danger\"\n          isInline\n          title=\"An error occurred while retrieving the requested logs.\"\n        />\n      )}\n      <div className=\"odc-logs__content\" ref={contentRef} />\n    </div>\n  );\n};\n\nexport default Logs;\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { MultiStreamLogs } from './MultiStreamLogs';\nimport { FirehoseResult } from '@console/internal/components/utils';\nimport { PodKind } from '@console/internal/module/k8s';\n\ntype LogsWrapperComponentProps = {\n  obj?: FirehoseResult<PodKind>;\n  taskName: string;\n  downloadAllLabel?: string;\n  onDownloadAll?: () => Promise<Error>;\n};\n\nconst LogsWrapperComponent: React.FC<LogsWrapperComponentProps> = ({ obj, ...props }) => {\n  const ref = React.useRef(obj?.data);\n  if (!_.isEmpty(obj?.data)) {\n    ref.current = obj.data;\n  }\n  return ref.current ? <MultiStreamLogs {...props} resource={ref.current} /> : null;\n};\n\nexport default LogsWrapperComponent;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { saveAs } from 'file-saver';\nimport { Button, Flex, FlexItem, FlexModifiers } from '@patternfly/react-core';\nimport { DownloadIcon, CompressIcon, ExpandIcon } from '@patternfly/react-icons';\nimport { ContainerStatus, PodKind, ContainerSpec } from '@console/internal/module/k8s';\nimport { LoadingInline, LOG_SOURCE_WAITING } from '@console/internal/components/utils';\nimport { errorModal } from '@console/internal/components/modals/error-modal';\nimport { useFullscreen, useScrollDirection, ScrollDirection } from '@console/shared';\nimport { containerToLogSourceStatus } from '../../../utils/pipeline-utils';\nimport { getRenderContainers } from './logs-utils';\nimport Logs from './Logs';\nimport './MultiStreamLogs.scss';\n\ntype MultiStreamLogsProps = {\n  resource: PodKind;\n  taskName: string;\n  downloadAllLabel?: string;\n  onDownloadAll?: () => Promise<Error>;\n};\n\nexport const MultiStreamLogs: React.FC<MultiStreamLogsProps> = ({\n  resource,\n  taskName,\n  downloadAllLabel,\n  onDownloadAll,\n}) => {\n  const scrollPane = React.useRef<HTMLDivElement>();\n  const completedRef = React.useRef<boolean[]>([]);\n  const [renderToCount, setRenderToCount] = React.useState(0);\n  const [isFullscreen, fullscreenRef, fullscreenToggle] = useFullscreen<HTMLDivElement>();\n  const [scrollDirection, handleScrollCallback] = useScrollDirection();\n  const [autoScroll, setAutoScroll] = React.useState(true);\n  const { containers, stillFetching } = getRenderContainers(resource);\n  const [downloadAllStatus, setDownloadAllStatus] = React.useState(false);\n  const dataRef = React.useRef<ContainerSpec[]>(null);\n  dataRef.current = containers;\n\n  const handleComplete = React.useCallback((containerName) => {\n    const index = dataRef.current.findIndex(({ name }) => name === containerName);\n    completedRef.current[index] = true;\n    const newRenderTo = dataRef.current.findIndex((c, i) => completedRef.current[i] !== true);\n    if (newRenderTo === -1) {\n      setRenderToCount(dataRef.current.length);\n    } else {\n      setRenderToCount(newRenderTo);\n    }\n  }, []);\n\n  React.useEffect(() => {\n    if (!scrollDirection) return;\n    if (scrollDirection === ScrollDirection.scrollingUp && autoScroll === true) {\n      setAutoScroll(false);\n    }\n    if (scrollDirection === ScrollDirection.scrolledToBottom && autoScroll === false) {\n      setAutoScroll(true);\n    }\n  }, [autoScroll, scrollDirection]);\n  const startDownloadAll = () => {\n    setDownloadAllStatus(true);\n    onDownloadAll()\n      .then(() => {\n        setDownloadAllStatus(false);\n      })\n      .catch((err: Error) => {\n        setDownloadAllStatus(false);\n        const error = err.message || 'Error downloading logs.';\n        errorModal({ error });\n      });\n  };\n  const downloadLogs = () => {\n    if (!scrollPane.current) return;\n    const logString = scrollPane.current.innerText;\n    const blob = new Blob([logString], {\n      type: 'text/plain;charset=utf-8',\n    });\n    saveAs(blob, `${taskName}.log`);\n  };\n\n  const containerStatus: ContainerStatus[] = resource.status?.containerStatuses ?? [];\n  const divider = <FlexItem className=\"odc-multi-stream-logs__divider\">|</FlexItem>;\n  return (\n    <div ref={fullscreenRef} className=\"odc-multi-stream-logs\">\n      <Flex\n        className={classNames({\n          'odc-multi-stream-logs--fullscreen': isFullscreen,\n        })}\n      >\n        <FlexItem\n          className=\"odc-multi-stream-logs__button\"\n          breakpointMods={[{ modifier: FlexModifiers['align-right'] }]}\n        >\n          <Button variant=\"link\" onClick={downloadLogs} isInline>\n            <DownloadIcon className=\"odc-multi-stream-logs__icon\" />\n            Download\n          </Button>\n        </FlexItem>\n        {divider}\n        {onDownloadAll && (\n          <>\n            <FlexItem className=\"odc-multi-stream-logs__button\">\n              <Button\n                variant=\"link\"\n                onClick={startDownloadAll}\n                isDisabled={downloadAllStatus}\n                isInline\n              >\n                <DownloadIcon className=\"odc-multi-stream-logs__icon\" />\n                {downloadAllLabel || 'Download All'}\n                {downloadAllStatus && <LoadingInline />}\n              </Button>\n            </FlexItem>\n            {divider}\n          </>\n        )}\n        {fullscreenToggle && (\n          <FlexItem className=\"odc-multi-stream-logs__button\">\n            <Button variant=\"link\" onClick={fullscreenToggle} isInline>\n              {isFullscreen ? (\n                <>\n                  <CompressIcon className=\"odc-multi-stream-logs__icon\" />\n                  Collapse\n                </>\n              ) : (\n                <>\n                  <ExpandIcon className=\"odc-multi-stream-logs__icon\" />\n                  Expand\n                </>\n              )}\n            </Button>\n          </FlexItem>\n        )}\n      </Flex>\n      <div className=\"odc-multi-stream-logs__taskName\">\n        {taskName}\n        {stillFetching && (\n          <span className=\"odc-multi-stream-logs__taskName__loading-indicator\">\n            <LoadingInline />\n          </span>\n        )}\n      </div>\n      <div className=\"odc-multi-stream-logs__container\" data-test-id=\"logs-task-container\">\n        <div\n          className=\"odc-multi-stream-logs__container__logs\"\n          ref={scrollPane}\n          onScroll={handleScrollCallback}\n        >\n          {containers.map((container, idx) => {\n            const resourceStatus = containerToLogSourceStatus(containerStatus[idx]);\n            return (\n              resourceStatus !== LOG_SOURCE_WAITING && (\n                <Logs\n                  key={container.name}\n                  resource={resource}\n                  container={container}\n                  resourceStatus={resourceStatus}\n                  onComplete={handleComplete}\n                  render={renderToCount >= idx}\n                  autoScroll={autoScroll}\n                />\n              )\n            );\n          })}\n        </div>\n      </div>\n    </div>\n  );\n};\n","import { saveAs } from 'file-saver';\nimport {\n  PodKind,\n  ContainerSpec,\n  ContainerStatus,\n  resourceURL,\n  k8sGet,\n} from '@console/internal/module/k8s';\nimport {\n  LOG_SOURCE_TERMINATED,\n  LOG_SOURCE_WAITING,\n  LineBuffer,\n} from '@console/internal/components/utils';\nimport { PodModel } from '@console/internal/models';\nimport { coFetchText } from '@console/internal/co-fetch';\nimport { errorModal } from '@console/internal/components/modals';\nimport { containerToLogSourceStatus } from '../../../utils/pipeline-utils';\nimport { TaskRuns } from '../../../utils/pipeline-augment';\n\nconst getSortedContainerStatus = (\n  containers: ContainerSpec[],\n  containerStatuses: ContainerStatus[],\n): ContainerStatus[] => {\n  const containerNames = containers.map((c) => c.name);\n  const sortedContainerStatus = [];\n  containerStatuses.forEach((cs) => {\n    const containerIndex = containerNames.indexOf(cs.name);\n    sortedContainerStatus[containerIndex] = cs;\n  });\n  return sortedContainerStatus;\n};\n\nexport const getRenderContainers = (\n  pod: PodKind,\n): { containers: ContainerSpec[]; stillFetching: boolean } => {\n  const containers: ContainerSpec[] = pod.spec?.containers ?? [];\n  const containerStatuses: ContainerStatus[] = pod.status?.containerStatuses ?? [];\n\n  const sortedContainerStatuses = getSortedContainerStatus(containers, containerStatuses);\n\n  const firstRunningCont = sortedContainerStatuses.findIndex(\n    (container) => containerToLogSourceStatus(container) !== LOG_SOURCE_TERMINATED,\n  );\n  return {\n    containers: containers.slice(\n      0,\n      firstRunningCont === -1 ? containers.length : firstRunningCont + 1,\n    ),\n    stillFetching: firstRunningCont !== -1,\n  };\n};\n\nconst getOrderedStepsFromPod = (name: string, ns: string): Promise<ContainerStatus[]> => {\n  return k8sGet(PodModel, name, ns)\n    .then((pod: PodKind) => {\n      return getSortedContainerStatus(\n        pod.spec.containers ?? [],\n        pod.status?.containerStatuses ?? [],\n      );\n    })\n    .catch((err) => {\n      errorModal({ error: err.message || 'Error downloading logs.' });\n      return [];\n    });\n};\n\ntype StepsWatchUrl = {\n  [key: string]: {\n    name: string;\n    steps: { [step: string]: WatchURLStatus };\n  };\n};\n\ntype WatchURLStatus = {\n  status: string;\n  url: string;\n};\n\nexport const getDownloadAllLogsCallback = (\n  sortedTaskRuns: string[],\n  taskRunFromYaml: TaskRuns,\n  namespace: string,\n  pipelineRunName: string,\n): (() => Promise<Error>) => {\n  const getWatchUrls = async (): Promise<StepsWatchUrl> => {\n    const stepsList: ContainerStatus[][] = await Promise.all(\n      sortedTaskRuns.map((currTask) => {\n        const { status = {} } = taskRunFromYaml[currTask];\n        const { podName } = status;\n        return getOrderedStepsFromPod(podName, namespace);\n      }),\n    );\n    return sortedTaskRuns.reduce((acc, currTask, i) => {\n      const { pipelineTaskName, status = {} } = taskRunFromYaml[currTask];\n      const { podName } = status;\n      const steps = stepsList[i];\n      const allStepUrls = steps.reduce((stepUrls, currentStep) => {\n        const { name } = currentStep;\n        const currentStatus = containerToLogSourceStatus(currentStep);\n        if (currentStatus === LOG_SOURCE_WAITING) return stepUrls;\n        const urlOpts = {\n          ns: namespace,\n          name: podName,\n          path: 'log',\n          queryParams: {\n            container: name,\n            follow: 'true',\n          },\n        };\n        return {\n          ...stepUrls,\n          [name]: {\n            status: currentStatus,\n            url: resourceURL(PodModel, urlOpts),\n          } as WatchURLStatus,\n        };\n      }, {});\n      acc[currTask] = {\n        name: pipelineTaskName,\n        steps: { ...allStepUrls },\n      };\n      return acc;\n    }, {});\n  };\n\n  const fetchLogs = async (tasksPromise: Promise<StepsWatchUrl>) => {\n    const tasks = await tasksPromise;\n    const allRequests: Promise<string>[] = sortedTaskRuns.reduce((acc, currTask) => {\n      const task = tasks[currTask];\n      const promises: Promise<string>[] = Object.keys(task.steps).map((step, i) => {\n        let heading = '';\n        if (i === 0) {\n          heading += `${task.name}\\n\\n`;\n        }\n        heading += `${step}\\n\\n`;\n        const { url, status } = task.steps[step];\n        const getContentPromise = coFetchText(url).then((logs) => {\n          return `${heading}${logs}\\n\\n`;\n        });\n        if (status === LOG_SOURCE_TERMINATED) {\n          // If we are done, we want this log content\n          return getContentPromise;\n        }\n        // If we are not done, let's not wait indefinitely\n        return Promise.race([\n          getContentPromise,\n          new Promise<string>((resolve) => {\n            setTimeout(() => resolve(''), 1000);\n          }),\n        ]);\n      });\n      return [...acc, ...promises];\n    }, []);\n    const buffer = new LineBuffer(null);\n    return Promise.all(allRequests).then((allLogs) => {\n      buffer.ingest(allLogs.join(''));\n      const blob = buffer.getBlob({\n        type: 'text/plain;charset=utf-8',\n      });\n      saveAs(blob, `${pipelineRunName}.log`);\n      return null;\n    });\n  };\n  return (): Promise<Error> => {\n    return fetchLogs(getWatchUrls());\n  };\n};\n","import * as React from 'react';\nimport { K8sKind } from '@console/internal/module/k8s';\nimport DynamicResourceLinkList from './DynamicResourceLinkList';\n\ntype ResourceLinkListProps = {\n  namespace: string;\n  model: K8sKind;\n  links: string[];\n};\nconst ResourceLinkList: React.FC<ResourceLinkListProps> = ({ links, model, namespace }) => {\n  return (\n    <DynamicResourceLinkList\n      links={links.map((name) => ({ model, name }))}\n      namespace={namespace}\n      title={model.labelPlural}\n    />\n  );\n};\n\nexport default ResourceLinkList;\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAUA;AACA;AACA;AAsBA;AAEA;AACA;AAEA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAjDA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAgCA;;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAGA;AAEA;AAOA;AACA;AAKA;AAMA;AAOA;AAGA;AAQA;AAGA;AACA;AAOA;AACA;AAOA;AAIA;AACA;AACA;AAEA;;;;;;;;;;;;;ACjLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAMA;AACA;AAMA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AAOA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;;;;;;;;;;;;AChDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAWA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAOA;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACpIA;AACA;AACA;AAWA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;ACrBA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AASA;;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAMA;AACA;AACA;AAGA;AAGA;AAEA;AAGA;AAEA;AAGA;AAEA;AAMA;AACA;AACA;AAEA;AAIA;AACA;AAMA;AACA;AAaA;AAKA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACvKA;AACA;AAOA;AAKA;AACA;AACA;AACA;AAGA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAGA;AACA;AAEA;AAEA;AAGA;AACA;AAIA;AACA;AACA;AAEA;AACA;AACA;;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AAcA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACtKA;AAAA;AAAA;AAAA;AAAA;AAEA;AAOA;AACA;AAOA;AAEA;;;;;A","sourceRoot":""}