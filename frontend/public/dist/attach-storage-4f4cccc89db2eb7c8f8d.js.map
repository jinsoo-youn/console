{"version":3,"file":"attach-storage-4f4cccc89db2eb7c8f8d.js","sources":["webpack:///./public/components/container-selector.tsx","webpack:///./public/components/storage/attach-storage.tsx"],"sourcesContent":["import * as React from 'react';\n\nimport { ContainerSpec } from '../module/k8s';\nimport { Checkbox } from '@patternfly/react-core';\n\nexport const ContainerSelector: React.FC<ContainerSelectorProps> = ({\n  containers,\n  onChange,\n  selected,\n}) => (\n  <div className=\"pf-c-form__checkbox-row\">\n    {containers.map((container: ContainerSpec) => (\n      <Checkbox\n        key={container.name}\n        label={`${container.name} from image ${container.image}`}\n        id={container.name}\n        isChecked={selected.includes(container.name)}\n        onChange={onChange}\n      />\n    ))}\n  </div>\n);\n\nexport type ContainerSelectorProps = {\n  containers: ContainerSpec[];\n  onChange: (checked: boolean, event: React.FormEvent<HTMLInputElement>) => void;\n  selected: string[];\n};\n","import * as _ from 'lodash-es';\nimport * as React from 'react';\nimport { Helmet } from 'react-helmet';\nimport { ActionGroup, Button } from '@patternfly/react-core';\n\nimport { connectToPlural } from '../../kinds';\nimport {\n  ContainerSpec,\n  k8sCreate,\n  k8sGet,\n  K8sKind,\n  k8sPatch,\n  referenceFor,\n} from '../../module/k8s';\nimport {\n  ButtonBar,\n  history,\n  ListDropdown,\n  LoadingBox,\n  ResourceLink,\n  resourceObjPath,\n} from '../utils';\nimport { Checkbox } from '../checkbox';\nimport { RadioInput } from '../radio';\nimport { CreatePVCForm } from './create-pvc';\nimport { PersistentVolumeClaimModel } from '../../models';\nimport { ContainerSelector } from '../container-selector';\n\nconst PVCDropdown: React.FC<PVCDropdownProps> = (props) => {\n  const kind = 'PersistentVolumeClaim';\n  const { namespace, selectedKey } = props;\n  const resources = [{ kind, namespace }];\n  return (\n    <ListDropdown\n      {...props}\n      desc=\"Persistent Volume Claim\"\n      resources={resources}\n      selectedKeyKind={kind}\n      placeholder=\"Select claim\"\n      selectedKey={selectedKey}\n    />\n  );\n};\n\nexport const AttachStorageForm: React.FC<AttachStorageFormProps> = (props) => {\n  const [obj, setObj] = React.useState(null);\n  const [inProgress, setInProgress] = React.useState(false);\n  const [useContainerSelector, setUseContainerSelector] = React.useState(false);\n  const [claimName, setClaimName] = React.useState('');\n  const [volumeName, setVolumeName] = React.useState('');\n  const [mountPath, setMountPath] = React.useState('');\n  const [subPath, setSubPath] = React.useState('');\n  const [mountAsReadOnly, setMountAsReadOnly] = React.useState(false);\n  const [selectedContainers, setSelectedContainers] = React.useState([]);\n  const [volumeAlreadyMounted, setVolumeAlreadyMounted] = React.useState(false);\n  const [error, setError] = React.useState('');\n  const [showCreatePVC, setShowCreatePVC] = React.useState('existing');\n  const [newPVCObj, setNewPVCObj] = React.useState(null);\n\n  const { kindObj, resourceName, namespace } = props;\n  const supportedKinds = [\n    'Deployment',\n    'DeploymentConfig',\n    'ReplicaSet',\n    'ReplicationController',\n    'StatefulSet',\n    'DaemonSet',\n  ];\n\n  React.useEffect(() => {\n    // Get the current resource so we can add to its definition\n    k8sGet(kindObj, resourceName, namespace).then(setObj);\n  }, [kindObj, resourceName, namespace]);\n\n  React.useEffect(() => {\n    // If the PVC or its name changes, check if there is already a volume with that name\n    const newClaimName =\n      showCreatePVC === 'existing' ? claimName : _.get(newPVCObj, 'metadata.name', '');\n    const volumes = _.get(obj, 'spec.template.spec.volumes');\n    const volume = _.find(volumes, {\n      persistentVolumeClaim: {\n        claimName: newClaimName,\n      },\n    }) as any;\n\n    const newVolumeName = volume ? volume.name : newClaimName;\n    const newVolumeAlreadyMounted = !!volume;\n    setVolumeName(newVolumeName);\n    setVolumeAlreadyMounted(newVolumeAlreadyMounted);\n  }, [newPVCObj, obj, claimName, showCreatePVC]);\n\n  if (!kindObj || !_.includes(supportedKinds, kindObj.kind)) {\n    setError('Unsupported kind.');\n    return;\n  }\n\n  const handleShowCreatePVCChange: React.ReactEventHandler<HTMLInputElement> = (event) => {\n    setShowCreatePVC(event.currentTarget.value);\n  };\n\n  const handleSelectContainers = () => {\n    setUseContainerSelector(!useContainerSelector);\n    setSelectedContainers([]);\n  };\n\n  const handleContainerSelectionChange = (checked, event) => {\n    const checkedItems = [...selectedContainers];\n    checked\n      ? checkedItems.push(event.currentTarget.id)\n      : _.pull(checkedItems, event.currentTarget.id);\n    setSelectedContainers(checkedItems);\n  };\n\n  const isContainerSelected = ({ name }) => {\n    return !useContainerSelector || selectedContainers.includes(name);\n  };\n\n  const getMountPaths = (podTemplate: any): string[] => {\n    const containers: ContainerSpec[] = _.get(podTemplate, 'spec.containers', []);\n    return containers.reduce((acc: string[], container: ContainerSpec) => {\n      if (!isContainerSelected(container)) {\n        return acc;\n      }\n      const mountPaths: string[] = _.map(container.volumeMounts, 'mountPath');\n      return acc.concat(mountPaths);\n    }, []);\n  };\n\n  const validateMountPaths = (path: string) => {\n    const existingMountPaths = getMountPaths(obj.spec.template);\n    const err = existingMountPaths.includes(path) ? 'Mount path is already in use.' : '';\n    setError(err);\n  };\n\n  // Add logic to check this handler for if a mount path is not unique\n  const handleMountPathChange: React.ReactEventHandler<HTMLInputElement> = (event) => {\n    setMountPath(event.currentTarget.value);\n    // Look at the existing mount paths so that we can warn if the new value is not unique.\n    validateMountPaths(event.currentTarget.value);\n  };\n\n  const handleSubPathChange: React.ReactEventHandler<HTMLInputElement> = (event) => {\n    setSubPath(event.currentTarget.value);\n  };\n\n  const handlePVCChange = (newClaimName: string) => {\n    setClaimName(newClaimName);\n  };\n\n  const onMountAsReadOnlyChanged: React.ReactEventHandler<HTMLInputElement> = () => {\n    setMountAsReadOnly(!mountAsReadOnly);\n  };\n\n  const createPVCIfNecessary = () => {\n    return showCreatePVC === 'new'\n      ? k8sCreate(PersistentVolumeClaimModel, newPVCObj).then((claim) => claim.metadata.name)\n      : Promise.resolve(claimName);\n  };\n\n  const getVolumePatches = (pvClaimName: string) => {\n    const mount = {\n      name: volumeName,\n      mountPath,\n      subPath,\n      readOnly: mountAsReadOnly,\n    };\n\n    const containers: ContainerSpec[] = _.get(obj, 'spec.template.spec.containers', []);\n    const patches = containers.reduce((patch, container, i) => {\n      // Only add to selected containers\n      if (isContainerSelected(container)) {\n        if (_.isEmpty(container.volumeMounts)) {\n          patch.push({\n            op: 'add',\n            path: `/spec/template/spec/containers/${i}/volumeMounts`,\n            value: [mount],\n          });\n        } else {\n          patch.push({\n            op: 'add',\n            path: `/spec/template/spec/containers/${i}/volumeMounts/-`,\n            value: mount,\n          });\n        }\n      }\n      return patch;\n    }, []);\n    const volume = {\n      name: volumeName,\n      persistentVolumeClaim: {\n        claimName: pvClaimName,\n      },\n    };\n\n    if (!volumeAlreadyMounted) {\n      const existingVolumes = _.get(obj, 'spec.template.spec.volumes');\n      const volumePatch = _.isEmpty(existingVolumes)\n        ? { op: 'add', path: '/spec/template/spec/volumes', value: [volume] }\n        : { op: 'add', path: '/spec/template/spec/volumes/-', value: volume };\n      return [...patches, volumePatch];\n    }\n    return patches;\n  };\n\n  const save = (event: React.FormEvent<EventTarget>) => {\n    event.preventDefault();\n    if (useContainerSelector && selectedContainers.length === 0) {\n      setError('You must choose at least one container to mount to.');\n      return;\n    }\n    setInProgress(true);\n    createPVCIfNecessary().then(\n      (pvClaimName: string) => {\n        return k8sPatch(kindObj, obj, getVolumePatches(pvClaimName)).then((resource) => {\n          setInProgress(false);\n          history.push(resourceObjPath(resource, referenceFor(resource)));\n        });\n      },\n      (err) => {\n        setError(err.message);\n        setInProgress(false);\n      },\n    );\n  };\n\n  const title = 'Add Storage';\n  return (\n    <div className=\"co-m-pane__body\">\n      <Helmet>\n        <title>{title}</title>\n      </Helmet>\n      <form className=\"co-m-pane__body-group co-m-pane__form\" onSubmit={save}>\n        <h1 className=\"co-m-pane__heading\">{title}</h1>\n        {kindObj && (\n          <div className=\"co-m-pane__explanation\">\n            Add a persistent volume claim to{' '}\n            <ResourceLink inline kind={kindObj.kind} name={resourceName} namespace={namespace} />\n          </div>\n        )}\n        <label className=\"control-label co-required\">Persistent Volume Claim</label>\n        <div className=\"form-group\">\n          <RadioInput\n            title=\"Use existing claim\"\n            value=\"existing\"\n            key=\"existing\"\n            onChange={handleShowCreatePVCChange}\n            checked={showCreatePVC === 'existing'}\n            name=\"showCreatePVC\"\n          />\n        </div>\n\n        {showCreatePVC === 'existing' && (\n          <div className=\"form-group co-form-subsection\">\n            <PVCDropdown\n              namespace={namespace}\n              onChange={handlePVCChange}\n              id=\"claimName\"\n              selectedKey={claimName}\n            />\n          </div>\n        )}\n        <div className=\"form-group\">\n          <RadioInput\n            title=\"Create new claim\"\n            value=\"new\"\n            key=\"new\"\n            onChange={handleShowCreatePVCChange}\n            checked={showCreatePVC === 'new'}\n            name=\"showCreatePVC\"\n          />\n        </div>\n\n        {showCreatePVC === 'new' && (\n          <div className=\"co-form-subsection\">\n            <CreatePVCForm onChange={setNewPVCObj} namespace={namespace} />\n          </div>\n        )}\n\n        <div className=\"form-group\">\n          <label className=\"control-label co-required\" htmlFor=\"mount-path\">\n            Mount Path\n          </label>\n          <div>\n            <input\n              className=\"pf-c-form-control\"\n              type=\"text\"\n              onChange={handleMountPathChange}\n              aria-describedby=\"mount-path-help\"\n              name=\"mountPath\"\n              id=\"mount-path\"\n              value={mountPath}\n              required\n            />\n            <p className=\"help-block\" id=\"mount-path-help\">\n              Mount path for the volume inside the container.\n            </p>\n          </div>\n        </div>\n        <Checkbox\n          label=\"Mount as read-only\"\n          onChange={onMountAsReadOnlyChanged}\n          checked={mountAsReadOnly}\n          name=\"mountAsReadOnly\"\n        />\n        <div className=\"form-group\">\n          <label className=\"control-label\" htmlFor=\"subpath\">\n            Subpath\n          </label>\n          <div>\n            <input\n              className=\"pf-c-form-control\"\n              type=\"text\"\n              onChange={handleSubPathChange}\n              aria-describedby=\"subpath-help\"\n              id=\"subpath\"\n              name=\"subPath\"\n              value={subPath}\n            />\n            <p className=\"help-block\" id=\"subpath-help\">\n              Optional path within the volume from which it will be mounted into the container.\n              Defaults to the root of volume.\n            </p>\n          </div>\n        </div>\n        {!useContainerSelector && (\n          <p>\n            The volume will be mounted into all containers. You can{' '}\n            <Button type=\"button\" onClick={handleSelectContainers} variant=\"link\" isInline>\n              select specific containers\n            </Button>{' '}\n            instead.\n          </p>\n        )}\n        {useContainerSelector && (\n          <div className=\"form-group co-break-word\">\n            <label className=\"control-label\">Containers</label>\n            <Button type=\"button\" onClick={handleSelectContainers} variant=\"link\">\n              (use all containers)\n            </Button>\n            <ContainerSelector\n              containers={obj.spec.template.spec.containers}\n              selected={selectedContainers}\n              onChange={handleContainerSelectionChange}\n            />\n            <p className=\"help-block\" id=\"subpath-help\">\n              Select which containers to mount volume into.\n            </p>\n          </div>\n        )}\n        <ButtonBar errorMessage={error} inProgress={inProgress}>\n          <ActionGroup className=\"pf-c-form\">\n            <Button type=\"submit\" variant=\"primary\" id=\"save-changes\">\n              Save\n            </Button>\n            <Button type=\"button\" variant=\"secondary\" onClick={history.goBack}>\n              Cancel\n            </Button>\n          </ActionGroup>\n        </ButtonBar>\n      </form>\n    </div>\n  );\n};\n\nconst AttachStorage_ = ({ kindObj, kindsInFlight, match: { params } }) => {\n  if (!kindObj && kindsInFlight) {\n    return <LoadingBox />;\n  }\n\n  return <AttachStorageForm namespace={params.ns} resourceName={params.name} kindObj={kindObj} />;\n};\nexport const AttachStorage = connectToPlural(AttachStorage_);\n\nexport type PVCDropdownProps = {\n  namespace: string;\n  selectedKey: string;\n  onChange: (string) => void;\n  id: string;\n};\n\nexport type AttachStorageFormProps = {\n  kindObj: K8sKind;\n  namespace: string;\n  resourceName: string;\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAGA;AAEA;;;;;;;;;;;;;ACLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AACA;AAQA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AAGA;AACA;AACA;AAUA;AAEA;AAQA;AACA;AAUA;AAEA;AAIA;AACA;AAGA;AACA;AAUA;AAKA;AAMA;AACA;AAGA;AACA;AASA;AAMA;;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AAGA;AAKA;AAKA;AACA;AACA;AAGA;AAQA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;;;;;A","sourceRoot":""}