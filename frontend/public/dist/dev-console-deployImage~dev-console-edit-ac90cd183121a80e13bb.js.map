{"version":3,"file":"dev-console-deployImage~dev-console-edit-ac90cd183121a80e13bb.js","sources":["webpack:///./packages/dev-console/src/components/import/deployImage-submit-utils.ts","webpack:///./packages/dev-console/src/components/import/deployImage-validation-utils.ts","webpack:///./packages/dev-console/src/components/import/image-search/ImageSearch.tsx","webpack:///./packages/dev-console/src/components/import/image-search/ImageSearchSection.tsx","webpack:///./packages/dev-console/src/components/import/image-search/ImageStream.scss?ede0","webpack:///./packages/dev-console/src/components/import/image-search/ImageStream.tsx","webpack:///./packages/dev-console/src/components/import/image-search/ImageStreamContext.ts","webpack:///./packages/dev-console/src/components/import/image-search/ImageStreamDropdown.tsx","webpack:///./packages/dev-console/src/components/import/image-search/ImageStreamNsDropdown.tsx","webpack:///./packages/dev-console/src/components/import/image-search/ImageStreamTagDropdown.tsx"],"sourcesContent":["import * as _ from 'lodash';\nimport {\n  DeploymentConfigModel,\n  DeploymentModel,\n  ImageStreamModel,\n  ServiceModel,\n  RouteModel,\n  RoleBindingModel,\n} from '@console/internal/models';\nimport { k8sCreate, K8sResourceKind, K8sVerb, k8sUpdate } from '@console/internal/module/k8s';\nimport { ServiceModel as KnServiceModel } from '@console/knative-plugin';\nimport { getKnativeServiceDepResource } from '@console/knative-plugin/src/utils/create-knative-utils';\nimport { getRandomChars } from '@console/shared/src/utils';\nimport {\n  getAppLabels,\n  getPodLabels,\n  mergeData,\n  getCommonAnnotations,\n  getTriggerAnnotation,\n} from '../../utils/resource-label-utils';\nimport { createRoute, createService, dryRunOpt } from '../../utils/shared-submit-utils';\nimport { getProbesData } from '../health-checks/create-health-checks-probe-utils';\nimport { RegistryType, getRuntime } from '../../utils/imagestream-utils';\nimport { AppResources } from '../edit-application/edit-application-types';\nimport { DeployImageFormData, Resources } from './import-types';\n\nexport const createSystemImagePullerRoleBinding = (\n  formData: DeployImageFormData,\n  dryRun: boolean,\n): Promise<K8sResourceKind> => {\n  const { imageStream } = formData;\n  const roleBinding = {\n    kind: RoleBindingModel.kind,\n    apiVersion: `${RoleBindingModel.apiGroup}/${RoleBindingModel.apiVersion}`,\n    metadata: {\n      name: 'system:image-puller',\n      namespace: imageStream.namespace,\n    },\n    subjects: [\n      {\n        kind: 'ServiceAccount',\n        name: 'default',\n        namespace: formData.project.name,\n      },\n    ],\n    roleRef: {\n      apiGroup: RoleBindingModel.apiGroup,\n      kind: 'ClusterRole',\n      name: 'system:image-puller',\n    },\n  };\n  return k8sCreate(RoleBindingModel, roleBinding, dryRun ? dryRunOpt : {});\n};\n\nexport const createOrUpdateImageStream = (\n  formData: DeployImageFormData,\n  dryRun: boolean,\n  originalImageStream?: K8sResourceKind,\n  verb: K8sVerb = 'create',\n  generatedImageStreamName: string = '',\n): Promise<K8sResourceKind> => {\n  const {\n    project: { name: namespace },\n    application: { name: application },\n    name,\n    isi: { name: isiName, tag },\n    labels: userLabels,\n  } = formData;\n  const defaultLabels = getAppLabels(name, application);\n  const newImageStream = {\n    apiVersion: 'image.openshift.io/v1',\n    kind: 'ImageStream',\n    metadata: {\n      name: `${generatedImageStreamName || name}`,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n    },\n    spec: {\n      tags: [\n        {\n          name: tag,\n          annotations: {\n            ...getCommonAnnotations(),\n            'openshift.io/imported-from': isiName,\n          },\n          from: {\n            kind: 'DockerImage',\n            name: `${isiName}`,\n          },\n          importPolicy: {},\n        },\n      ],\n    },\n  };\n  const imageStream = mergeData(originalImageStream, newImageStream);\n\n  return verb === 'update'\n    ? k8sUpdate(ImageStreamModel, imageStream)\n    : k8sCreate(ImageStreamModel, newImageStream, dryRun ? dryRunOpt : {});\n};\n\nconst getMetadata = (formData: DeployImageFormData) => {\n  const {\n    application: { name: application },\n    name,\n    isi: { image },\n    labels: userLabels,\n    imageStream: { tag: imgTag, namespace: imgNamespace },\n  } = formData;\n  const imgStreamName = getRuntime(image.metadata?.labels);\n  const defaultLabels = getAppLabels(name, application, imgStreamName, imgTag, imgNamespace);\n  const labels = { ...defaultLabels, ...userLabels };\n  const podLabels = getPodLabels(name);\n\n  const volumes = [];\n  const volumeMounts = [];\n  let volumeNumber = 0;\n  _.each(_.get(image, ['dockerImageMetadata', 'Config', 'Volumes']), (value, path) => {\n    volumeNumber++;\n    const volumeName = `${name}-${volumeNumber}`;\n    volumes.push({\n      name: volumeName,\n      emptyDir: {},\n    });\n    volumeMounts.push({\n      name: volumeName,\n      mountPath: path,\n    });\n  });\n\n  return { labels, podLabels, volumes, volumeMounts };\n};\n\nexport const createOrUpdateDeployment = (\n  formData: DeployImageFormData,\n  dryRun: boolean,\n  originalDeployment?: K8sResourceKind,\n  verb: K8sVerb = 'create',\n): Promise<K8sResourceKind> => {\n  const {\n    registry,\n    project: { name: namespace },\n    name,\n    isi: { image, ports, tag: imageStreamTag },\n    deployment: {\n      env,\n      replicas,\n      triggers: { image: imageChange },\n    },\n    labels: userLabels,\n    limits: { cpu, memory },\n    imageStream: { image: imgName, namespace: imgNamespace },\n    healthChecks,\n  } = formData;\n\n  const annotations = getCommonAnnotations();\n  const defaultAnnotations = {\n    ...annotations,\n    'alpha.image.policy.openshift.io/resolve-names': '*',\n    ...getTriggerAnnotation(\n      imgName || name,\n      imgNamespace || namespace,\n      imageChange,\n      imageStreamTag,\n    ),\n  };\n\n  const { labels, podLabels, volumes, volumeMounts } = getMetadata(formData);\n\n  const imageRef =\n    registry === RegistryType.External\n      ? `${name}:${imageStreamTag}`\n      : _.get(image, 'dockerImageReference');\n\n  const newDeployment = {\n    kind: 'Deployment',\n    apiVersion: 'apps/v1',\n    metadata: {\n      name,\n      namespace,\n      labels,\n      annotations: defaultAnnotations,\n    },\n    spec: {\n      replicas,\n      selector: {\n        matchLabels: {\n          app: name,\n        },\n      },\n      template: {\n        metadata: {\n          labels: { ...userLabels, ...podLabels },\n          annotations,\n        },\n        spec: {\n          volumes,\n          containers: [\n            {\n              name,\n              image: imageRef,\n              ports,\n              volumeMounts,\n              env,\n              resources: {\n                ...((cpu.limit || memory.limit) && {\n                  limits: {\n                    ...(cpu.limit && { cpu: `${cpu.limit}${cpu.limitUnit}` }),\n                    ...(memory.limit && { memory: `${memory.limit}${memory.limitUnit}` }),\n                  },\n                }),\n                ...((cpu.request || memory.request) && {\n                  requests: {\n                    ...(cpu.request && { cpu: `${cpu.request}${cpu.requestUnit}` }),\n                    ...(memory.request && { memory: `${memory.request}${memory.requestUnit}` }),\n                  },\n                }),\n              },\n              ...getProbesData(healthChecks),\n            },\n          ],\n        },\n      },\n    },\n  };\n\n  const deployment = mergeData(originalDeployment, newDeployment);\n\n  return verb === 'update'\n    ? k8sUpdate(DeploymentModel, deployment)\n    : k8sCreate(DeploymentModel, deployment, dryRun ? dryRunOpt : {});\n};\n\nexport const createOrUpdateDeploymentConfig = (\n  formData: DeployImageFormData,\n  dryRun: boolean,\n  originalDeploymentConfig?: K8sResourceKind,\n  verb: K8sVerb = 'create',\n): Promise<K8sResourceKind> => {\n  const {\n    project: { name: namespace },\n    name,\n    isi: { image, tag, ports },\n    deployment: { env, replicas, triggers },\n    labels: userLabels,\n    limits: { cpu, memory },\n    imageStream: { image: imgName, namespace: imgNamespace },\n    healthChecks,\n  } = formData;\n\n  const { labels, podLabels, volumes, volumeMounts } = getMetadata(formData);\n  const annotations = getCommonAnnotations();\n  const newDeploymentConfig = {\n    kind: 'DeploymentConfig',\n    apiVersion: 'apps.openshift.io/v1',\n    metadata: {\n      name,\n      namespace,\n      labels,\n      annotations,\n    },\n    spec: {\n      replicas,\n      selector: podLabels,\n      template: {\n        metadata: {\n          labels: { ...userLabels, ...podLabels },\n          annotations,\n        },\n        spec: {\n          volumes,\n          containers: [\n            {\n              name,\n              image: _.get(image, ['dockerImageMetadata', 'Config', 'Image']),\n              ports,\n              volumeMounts,\n              env,\n              resources: {\n                ...((cpu.limit || memory.limit) && {\n                  limits: {\n                    ...(cpu.limit && { cpu: `${cpu.limit}${cpu.limitUnit}` }),\n                    ...(memory.limit && { memory: `${memory.limit}${memory.limitUnit}` }),\n                  },\n                }),\n                ...((cpu.request || memory.request) && {\n                  requests: {\n                    ...(cpu.request && { cpu: `${cpu.request}${cpu.requestUnit}` }),\n                    ...(memory.request && { memory: `${memory.request}${memory.requestUnit}` }),\n                  },\n                }),\n              },\n              ...getProbesData(healthChecks),\n            },\n          ],\n        },\n      },\n      triggers: [\n        {\n          type: 'ImageChange',\n          imageChangeParams: {\n            automatic: triggers.image,\n            containerNames: [name],\n            from: {\n              kind: 'ImageStreamTag',\n              name: `${imgName || name}:${tag}`,\n              namespace: imgNamespace || namespace,\n            },\n          },\n        },\n        ...(triggers.config ? [{ type: 'ConfigChange' }] : []),\n      ],\n    },\n  };\n\n  const deploymentConfig = mergeData(originalDeploymentConfig, newDeploymentConfig);\n\n  return verb === 'update'\n    ? k8sUpdate(DeploymentConfigModel, deploymentConfig)\n    : k8sCreate(DeploymentConfigModel, deploymentConfig, dryRun ? dryRunOpt : {});\n};\n\nexport const ensurePortExists = (formData: DeployImageFormData): DeployImageFormData => {\n  const {\n    isi: { ports },\n    route: { defaultUnknownPort, unknownTargetPort },\n  } = formData;\n\n  let values = formData;\n  if (!Array.isArray(ports) || ports.length === 0) {\n    // If we lack pre-defined ports but they have specified a custom target port, use that instead\n    const containerPort = unknownTargetPort ? parseInt(unknownTargetPort, 10) : defaultUnknownPort;\n    const suppliedPorts = [{ containerPort, protocol: 'TCP' }];\n\n    values = {\n      ...values,\n      isi: {\n        ...values.isi,\n        ports: suppliedPorts,\n      },\n    };\n  }\n\n  return values;\n};\n\nexport const createOrUpdateDeployImageResources = async (\n  rawFormData: DeployImageFormData,\n  dryRun: boolean = false,\n  verb: K8sVerb = 'create',\n  appResources?: AppResources,\n): Promise<K8sResourceKind[]> => {\n  const formData = ensurePortExists(rawFormData);\n  const {\n    name,\n    registry,\n    project: { name: namespace },\n    route: { create: canCreateRoute, disable },\n    isi: { ports, tag: imageStreamTag, image },\n    imageStream: { image: internalImageStreamName, namespace: internalImageStreamNamespace },\n    deployment: {\n      triggers: { image: imageChange },\n    },\n  } = formData;\n  const internalImageName = getRuntime(image.metadata?.labels);\n  const requests: Promise<K8sResourceKind>[] = [];\n  if (registry === RegistryType.Internal) {\n    formData.imageStream.grantAccess &&\n      requests.push(createSystemImagePullerRoleBinding(formData, dryRun));\n  }\n  const imageStreamList = appResources?.imageStream?.data;\n  const imageStreamData = _.orderBy(imageStreamList, ['metadata.resourceVersion'], ['desc']);\n  const originalImageStream = (imageStreamData.length && imageStreamData[0]) || {};\n  if (formData.resources !== Resources.KnativeService) {\n    registry === RegistryType.External &&\n      (await createOrUpdateImageStream(formData, dryRun, originalImageStream, verb));\n    if (formData.resources === Resources.Kubernetes) {\n      requests.push(\n        createOrUpdateDeployment(\n          formData,\n          dryRun,\n          _.get(appResources, 'editAppResource.data'),\n          verb,\n        ),\n      );\n    } else {\n      requests.push(\n        createOrUpdateDeploymentConfig(\n          formData,\n          dryRun,\n          _.get(appResources, 'editAppResource.data'),\n          verb,\n        ),\n      );\n    }\n    if (!_.isEmpty(ports)) {\n      const service = createService(formData, undefined, _.get(appResources, 'service.data'));\n      requests.push(\n        verb === 'update'\n          ? k8sUpdate(ServiceModel, service)\n          : k8sCreate(ServiceModel, service, dryRun ? dryRunOpt : {}),\n      );\n      const route = createRoute(formData, undefined, _.get(appResources, 'route.data'));\n      if (verb === 'update' && disable) {\n        requests.push(k8sUpdate(RouteModel, route));\n      } else if (canCreateRoute) {\n        requests.push(k8sCreate(RouteModel, route, dryRun ? dryRunOpt : {}));\n      }\n    }\n  } else if (!dryRun) {\n    // Do not run serverless call during the dry run.\n    let imageStreamUrl: string = image?.dockerImageReference;\n    if (registry === RegistryType.External) {\n      let generatedImageStreamName: string = '';\n      if (verb === 'update') {\n        if (imageStreamList && imageStreamList.length) {\n          const originalImageStreamTag = _.find(originalImageStream?.status?.tags, [\n            'tag',\n            imageStreamTag,\n          ]);\n          if (!_.isEmpty(originalImageStreamTag)) {\n            generatedImageStreamName = `${name}-${getRandomChars()}`;\n          }\n        } else {\n          generatedImageStreamName = `${name}-${getRandomChars()}`;\n        }\n      }\n      const imageStreamResponse = await createOrUpdateImageStream(\n        formData,\n        dryRun,\n        originalImageStream,\n        generatedImageStreamName ? 'create' : verb,\n        generatedImageStreamName,\n      );\n      const imageStreamRepo = imageStreamResponse.status.dockerImageRepository;\n      imageStreamUrl = imageStreamTag ? `${imageStreamRepo}:${imageStreamTag}` : imageStreamRepo;\n    }\n    const originalAnnotations = appResources?.editAppResource?.data?.metadata?.annotations || {};\n    const triggerAnnotations = getTriggerAnnotation(\n      internalImageStreamName || name,\n      internalImageStreamNamespace || namespace,\n      imageChange,\n      imageStreamTag,\n    );\n    const annotations = {\n      ...originalAnnotations,\n      ...triggerAnnotations,\n    };\n    const knDeploymentResource = getKnativeServiceDepResource(\n      formData,\n      imageStreamUrl,\n      internalImageName || name,\n      imageStreamTag,\n      internalImageStreamNamespace,\n      annotations,\n      _.get(appResources, 'editAppResource.data'),\n    );\n    requests.push(\n      verb === 'update'\n        ? k8sUpdate(KnServiceModel, knDeploymentResource)\n        : k8sCreate(KnServiceModel, knDeploymentResource),\n    );\n  }\n\n  return Promise.all(requests);\n};\n","import * as yup from 'yup';\nimport {\n  nameValidationSchema,\n  projectNameValidationSchema,\n  applicationNameValidationSchema,\n  deploymentValidationSchema,\n  serverlessValidationSchema,\n  limitsValidationSchema,\n  routeValidationSchema,\n  isiValidationSchema,\n  resourcesValidationSchema,\n} from './validation-schema';\nimport { healthChecksProbesValidationSchema } from '../health-checks/health-checks-probe-validation-utils';\n\nexport const deployValidationSchema = yup.object().shape({\n  project: projectNameValidationSchema,\n  application: applicationNameValidationSchema,\n  name: nameValidationSchema,\n  isi: isiValidationSchema,\n  serverless: serverlessValidationSchema,\n  deployment: deploymentValidationSchema,\n  route: routeValidationSchema,\n  limits: limitsValidationSchema,\n  resources: resourcesValidationSchema,\n  healthChecks: healthChecksProbesValidationSchema,\n});\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { k8sCreate, ContainerPort } from '@console/internal/module/k8s';\nimport { ImageStreamImportsModel } from '@console/internal/models';\nimport { useFormikContext, FormikValues, FormikTouched } from 'formik';\nimport {\n  TextInputTypes,\n  Alert,\n  AlertActionCloseButton,\n  Button,\n  ValidatedOptions,\n} from '@patternfly/react-core';\nimport { SecretTypeAbstraction } from '@console/internal/components/secrets/create-secret';\nimport { InputField, useDebounceCallback } from '@console/shared';\nimport { getSuggestedName, getPorts, makePortName } from '../../../utils/imagestream-utils';\nimport { secretModalLauncher } from '../CreateSecretModal';\nimport { UNASSIGNED_KEY, CREATE_APPLICATION_KEY } from '../../../const';\n\nconst ImageSearch: React.FC = () => {\n  const { values, setFieldValue, dirty, initialValues, touched } = useFormikContext<FormikValues>();\n  const [newImageSecret, setNewImageSecret] = React.useState('');\n  const [alertVisible, shouldHideAlert] = React.useState(true);\n  const [validated, setValidated] = React.useState<ValidatedOptions>(ValidatedOptions.default);\n  const namespace = values.project.name;\n  const { application = {}, name: nameTouched } = touched;\n  const { name: applicationNameTouched } = application as FormikTouched<{ name: boolean }>;\n\n  const handleSearch = React.useCallback(\n    (searchTermImage: string) => {\n      setFieldValue('isSearchingForImage', true);\n      setValidated(ValidatedOptions.default);\n      const importImage = {\n        kind: 'ImageStreamImport',\n        apiVersion: 'image.openshift.io/v1',\n        metadata: {\n          name: 'newapp',\n          namespace: values.project.name,\n        },\n        spec: {\n          import: false,\n          images: [\n            {\n              from: {\n                kind: 'DockerImage',\n                name: _.trim(searchTermImage),\n              },\n            },\n          ],\n        },\n        status: {},\n      };\n\n      k8sCreate(ImageStreamImportsModel, importImage)\n        .then((imageStreamImport) => {\n          const status = _.get(imageStreamImport, 'status.images[0].status');\n          if (status.status === 'Success') {\n            const name = _.get(imageStreamImport, 'spec.images[0].from.name');\n            const image = _.get(imageStreamImport, 'status.images[0].image');\n            const tag = _.get(imageStreamImport, 'status.images[0].tag');\n            const isi = { name, image, tag, status };\n            const ports = getPorts(isi);\n            setFieldValue('isSearchingForImage', false);\n            setFieldValue('isi.name', name);\n            setFieldValue('isi.image', image);\n            setFieldValue('isi.tag', tag);\n            setFieldValue('isi.status', status);\n            setFieldValue('isi.ports', ports);\n            setFieldValue('image.ports', ports);\n            setFieldValue('image.tag', tag);\n            !values.name && setFieldValue('name', getSuggestedName(name));\n            !values.application.name &&\n              values.application.selectedKey !== UNASSIGNED_KEY &&\n              setFieldValue('application.name', `${getSuggestedName(name)}-app`);\n            // set default port value\n            const targetPort =\n              (!initialValues.route.targetPort || touched.searchTerm) && _.head(ports);\n            targetPort && setFieldValue('route.targetPort', makePortName(targetPort));\n            setValidated(ValidatedOptions.success);\n          } else {\n            setFieldValue('isSearchingForImage', false);\n            setFieldValue('isi', {});\n            setFieldValue('isi.status', status);\n            setFieldValue('route.targetPort', null);\n            setValidated(ValidatedOptions.error);\n          }\n        })\n        .catch((error) => {\n          setFieldValue('isi', {});\n          setFieldValue('isi.status', { metadata: {}, status: '', message: error.message });\n          setFieldValue('isSearchingForImage', false);\n          setValidated(ValidatedOptions.error);\n        });\n    },\n    [\n      setFieldValue,\n      touched,\n      values.application.name,\n      values.application.selectedKey,\n      values.name,\n      values.project.name,\n      initialValues.route.targetPort,\n    ],\n  );\n\n  const debouncedHandleSearch = useDebounceCallback(handleSearch, [handleSearch]);\n\n  const handleSave = React.useCallback(\n    (name: string) => {\n      setNewImageSecret(name);\n      values.searchTerm && handleSearch(values.searchTerm);\n    },\n    [handleSearch, values.searchTerm],\n  );\n\n  const getHelpText = () => {\n    if (values.isSearchingForImage) {\n      return 'Validating...';\n    }\n    if (!values.isSearchingForImage && validated === ValidatedOptions.success) {\n      return 'Validated';\n    }\n    return '';\n  };\n\n  const resetFields = () => {\n    if (values.formType === 'edit') {\n      values.application.selectedKey !== UNASSIGNED_KEY &&\n        values.application.selectedKey === CREATE_APPLICATION_KEY &&\n        !applicationNameTouched &&\n        setFieldValue('application.name', '');\n      return;\n    }\n    !nameTouched && setFieldValue('name', '');\n    values.application.selectedKey !== UNASSIGNED_KEY &&\n      !applicationNameTouched &&\n      setFieldValue('application.name', '');\n  };\n\n  const helpTextInvalid = validated === ValidatedOptions.error && (\n    <span>{values.searchTerm === '' ? 'Required' : values.isi.status?.message}</span>\n  );\n\n  React.useEffect(() => {\n    !dirty && values.searchTerm && handleSearch(values.searchTerm);\n  }, [dirty, handleSearch, values.searchTerm]);\n\n  React.useEffect(() => {\n    if (touched.searchTerm && initialValues.searchTerm !== values.searchTerm) {\n      const targetPort: ContainerPort = _.head(values.isi.ports);\n      targetPort && setFieldValue('route.targetPort', makePortName(targetPort));\n    }\n  }, [\n    touched.searchTerm,\n    setFieldValue,\n    values.isi.ports,\n    initialValues.searchTerm,\n    values.searchTerm,\n  ]);\n\n  return (\n    <>\n      <InputField\n        type={TextInputTypes.text}\n        name=\"searchTerm\"\n        placeholder=\"Enter an image name\"\n        helpText={getHelpText()}\n        helpTextInvalid={helpTextInvalid}\n        validated={validated}\n        onChange={(e: KeyboardEvent) => {\n          resetFields();\n          setFieldValue('isi', {});\n          setValidated(ValidatedOptions.default);\n          debouncedHandleSearch((e.target as HTMLInputElement).value);\n        }}\n        data-test-id=\"deploy-image-search-term\"\n        required\n      />\n      <div className=\"help-block\" id=\"image-name-help\">\n        To deploy an image from a private repository, you must{' '}\n        <Button\n          variant=\"link\"\n          isInline\n          onClick={() =>\n            secretModalLauncher({\n              namespace,\n              save: handleSave,\n              secretType: SecretTypeAbstraction.image,\n            })\n          }\n        >\n          create an image pull secret\n        </Button>{' '}\n        with your image registry credentials.\n      </div>\n      {newImageSecret && alertVisible && (\n        <Alert\n          isInline\n          className=\"co-alert\"\n          variant=\"success\"\n          title={`Secret ${newImageSecret} was created.`}\n          action={<AlertActionCloseButton onClose={() => shouldHideAlert(false)} />}\n        />\n      )}\n    </>\n  );\n};\n\nexport default ImageSearch;\n","import * as React from 'react';\nimport { useFormikContext, FormikValues } from 'formik';\nimport { RadioGroupField } from '@console/shared';\nimport FormSection from '../section/FormSection';\nimport { imageRegistryType } from '../../../utils/imagestream-utils';\nimport ImageStream from './ImageStream';\nimport ImageSearch from './ImageSearch';\n\nconst ImageSearchSection: React.FC = () => {\n  const { values, setFieldValue, initialValues } = useFormikContext<FormikValues>();\n  const [registry, setRegistry] = React.useState(values.registry);\n  React.useEffect(() => {\n    if (values.registry !== registry) {\n      setRegistry(values.registry);\n      setFieldValue('searchTerm', initialValues.searchTerm);\n      setFieldValue('isi', initialValues.isi);\n      setFieldValue('imageStream', initialValues.imageStream);\n    }\n  }, [\n    initialValues.imageStream,\n    initialValues.isi,\n    initialValues.searchTerm,\n    registry,\n    setFieldValue,\n    values,\n  ]);\n\n  return (\n    <FormSection\n      title=\"Image\"\n      subTitle=\"Deploy an existing image from an image stream or image registry.\"\n    >\n      <RadioGroupField\n        name=\"registry\"\n        options={[\n          {\n            label: imageRegistryType.External.label,\n            value: imageRegistryType.External.value,\n            isDisabled: values.formType === 'edit' && values.registry === 'internal',\n            activeChildren: <ImageSearch />,\n          },\n          {\n            label: imageRegistryType.Internal.label,\n            value: imageRegistryType.Internal.value,\n            isDisabled: values.formType === 'edit' && values.registry === 'external',\n            activeChildren: <ImageStream />,\n          },\n        ]}\n      />\n    </FormSection>\n  );\n};\n\nexport default ImageSearchSection;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { Alert, FormGroup, ValidatedOptions } from '@patternfly/react-core';\nimport { ExclamationCircleIcon } from '@patternfly/react-icons';\nimport { useFormikContext, FormikValues } from 'formik';\nimport { CheckboxField } from '@console/shared';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport {\n  RegistryType,\n  BuilderImagesNamespace,\n  getImageStreamTags,\n} from '../../../utils/imagestream-utils';\nimport { ImageStreamState, ImageStreamAction, ImageStreamActions } from '../import-types';\nimport { ImageStreamContext } from './ImageStreamContext';\nimport ImageStreamNsDropdown from './ImageStreamNsDropdown';\nimport ImageStreamDropdown from './ImageStreamDropdown';\nimport ImageStreamTagDropdown from './ImageStreamTagDropdown';\n\nimport './ImageStream.scss';\n\nexport const initialState: ImageStreamState = {\n  hasAccessToPullImage: true,\n  loading: false,\n  accessLoading: false,\n  hasCreateAccess: false,\n  selectedImageStream: {},\n};\n\nexport const ImageStreamReducer = (state: ImageStreamState, action: ImageStreamAction) => {\n  const { value } = action;\n  switch (action.type) {\n    case ImageStreamActions.setHasAccessToPullImage:\n      return { ...state, hasAccessToPullImage: value };\n    case ImageStreamActions.setLoading:\n      return { ...state, loading: value };\n    case ImageStreamActions.setAccessLoading:\n      return { ...state, accessLoading: value };\n    case ImageStreamActions.setHasCreateAccess:\n      return { ...state, hasCreateAccess: value };\n    case ImageStreamActions.setSelectedImageStream:\n      return { ...state, selectedImageStream: value };\n    default:\n      throw new Error('Invalid action was provided in imagestream reducer');\n  }\n};\n\nconst ImageStream: React.FC = () => {\n  const {\n    values: { imageStream, project, registry, isi },\n    setFieldValue,\n  } = useFormikContext<FormikValues>();\n  const [validated, setValidated] = React.useState<ValidatedOptions>(ValidatedOptions.default);\n  const [state, dispatch] = React.useReducer(ImageStreamReducer, initialState);\n  const [hasImageStreams, setHasImageStreams] = React.useState(false);\n  const {\n    hasAccessToPullImage,\n    loading,\n    accessLoading,\n    hasCreateAccess,\n    selectedImageStream,\n  } = state;\n\n  React.useEffect(() => {\n    if (imageStream.namespace !== BuilderImagesNamespace.Openshift) {\n      setFieldValue('imageStream.grantAccess', true);\n    }\n  }, [imageStream.namespace, setFieldValue]);\n  const imageStreamTagList = getImageStreamTags(selectedImageStream as K8sResourceKind);\n  const isNamespaceSelected = imageStream.namespace !== '' && !accessLoading;\n  const isStreamsAvailable = isNamespaceSelected && hasImageStreams && !loading;\n  const isTagsAvailable = isStreamsAvailable && !_.isEmpty(imageStreamTagList);\n  const isImageStreamSelected = imageStream.image !== '';\n  const canGrantAccess =\n    hasCreateAccess &&\n    isStreamsAvailable &&\n    isTagsAvailable &&\n    !hasAccessToPullImage &&\n    isNamespaceSelected &&\n    registry === RegistryType.Internal &&\n    imageStream.namespace !== BuilderImagesNamespace.Openshift &&\n    project.name !== imageStream.namespace;\n  const helperTextInvalid = validated === ValidatedOptions.error && isi.status?.message && (\n    <>\n      <ExclamationCircleIcon />\n      &nbsp;{isi.status?.message}\n    </>\n  );\n\n  return (\n    <>\n      <ImageStreamContext.Provider\n        value={{ state, dispatch, hasImageStreams, setHasImageStreams, setValidated }}\n      >\n        <FormGroup\n          fieldId=\"image-stream-dropdowns\"\n          validated={validated}\n          helperTextInvalid={helperTextInvalid}\n        >\n          <div className=\"row\">\n            <div className=\"col-lg-4 col-md-4 col-sm-4 col-xs-12\">\n              <ImageStreamNsDropdown />\n            </div>\n            <div className=\"col-lg-4 col-md-4 col-sm-4 col-xs-12\">\n              <ImageStreamDropdown />\n              <div className=\"odc-imagestream-separator\">/</div>\n            </div>\n            <div className=\"col-lg-4 col-md-4 col-sm-4 col-xs-12\">\n              <ImageStreamTagDropdown />\n              <div className=\"odc-imagestream-separator\">:</div>\n            </div>\n          </div>\n        </FormGroup>\n        {isNamespaceSelected && isImageStreamSelected && !isTagsAvailable && hasCreateAccess && (\n          <div className=\"odc-imagestream-alert\">\n            <Alert variant=\"warning\" title=\"No Image streams tags found\" isInline>\n              No tags are available in image stream {imageStream.image}\n            </Alert>\n          </div>\n        )}\n        {isNamespaceSelected && !loading && !isStreamsAvailable && hasCreateAccess && (\n          <div className=\"odc-imagestream-alert\">\n            <Alert variant=\"warning\" title=\"No Image streams found\" isInline>\n              No image streams are available in project {imageStream.namespace}\n            </Alert>\n          </div>\n        )}\n        {isNamespaceSelected && !accessLoading && !hasCreateAccess && (\n          <div className=\"odc-imagestream-alert\">\n            <Alert variant=\"warning\" title=\"Permission denied\" isInline>\n              Service account default does not have authority to pull images from{' '}\n              {imageStream.namespace}. Select another project to continue.\n            </Alert>\n          </div>\n        )}\n        {canGrantAccess && (\n          <div className=\"odc-imagestream-alert\">\n            <CheckboxField\n              name=\"imageStream.grantAccess\"\n              label={`Grant service account default authority to pull images from\n                ${imageStream.namespace}`}\n            />\n          </div>\n        )}\n      </ImageStreamContext.Provider>\n    </>\n  );\n};\n\nexport default React.memo(ImageStream);\n","import * as React from 'react';\nimport { ImageStreamContextProps } from '../import-types';\n\nexport const ImageStreamContext = React.createContext<ImageStreamContextProps>(undefined as any);\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { useFormikContext, FormikValues } from 'formik';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { ResourceDropdownField } from '@console/shared';\nimport { getImageStreamResource } from '../../../utils/imagestream-utils';\nimport { ImageStreamActions } from '../import-types';\nimport { ImageStreamContext } from './ImageStreamContext';\n\nconst ImageStreamDropdown: React.FC = () => {\n  const imgCollection = {};\n\n  const {\n    values: { imageStream },\n    setFieldValue,\n    initialValues,\n  } = useFormikContext<FormikValues>();\n  const { state, dispatch, hasImageStreams, setHasImageStreams } = React.useContext(\n    ImageStreamContext,\n  );\n  const { accessLoading, loading, hasCreateAccess } = state;\n  const isNamespaceSelected = imageStream.namespace !== '' && !accessLoading;\n  const isStreamsAvailable = isNamespaceSelected && hasImageStreams && !loading;\n  const collectImageStreams = (namespace: string, resource: K8sResourceKind): void => {\n    if (!imgCollection[namespace]) {\n      imgCollection[namespace] = {};\n    }\n    imgCollection[namespace][resource.metadata.name] = resource;\n  };\n  const getTitle = () => {\n    return loading && !isStreamsAvailable\n      ? ''\n      : !isStreamsAvailable || !hasCreateAccess\n      ? 'No Image Stream'\n      : 'Select Image Stream';\n  };\n\n  const onDropdownChange = React.useCallback(\n    (img: string) => {\n      setFieldValue('imageStream.tag', initialValues.imageStream.tag);\n      setFieldValue('isi', initialValues.isi);\n      const image = _.get(imgCollection, [imageStream.namespace, img], {});\n      dispatch({ type: ImageStreamActions.setSelectedImageStream, value: image });\n    },\n    [\n      setFieldValue,\n      initialValues.imageStream.tag,\n      initialValues.isi,\n      imgCollection,\n      imageStream.namespace,\n      dispatch,\n    ],\n  );\n  const onLoad = (imgstreams) => {\n    const imageStreamAvailable = !_.isEmpty(imgstreams);\n    setHasImageStreams(imageStreamAvailable);\n    loading &&\n      isNamespaceSelected &&\n      dispatch({ type: ImageStreamActions.setLoading, value: false });\n  };\n  const resourceFilter = (resource: K8sResourceKind) => {\n    const {\n      metadata: { namespace },\n    } = resource;\n    collectImageStreams(namespace, resource);\n    return namespace === imageStream.namespace;\n  };\n\n  React.useEffect(() => {\n    imageStream.image && onDropdownChange(imageStream.image);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, [imageStream.image, isStreamsAvailable]);\n\n  React.useEffect(() => {\n    if (initialValues.imageStream.image !== imageStream.image) {\n      initialValues.imageStream.tag = '';\n    }\n  }, [imageStream.image, initialValues.imageStream.image, initialValues.imageStream.tag]);\n\n  return (\n    <ResourceDropdownField\n      name=\"imageStream.image\"\n      label=\"ImageStreams\"\n      resources={getImageStreamResource(imageStream.namespace)}\n      dataSelector={['metadata', 'name']}\n      key={imageStream.namespace}\n      fullWidth\n      required\n      title={imageStream.image || getTitle()}\n      disabled={!hasCreateAccess || !isStreamsAvailable}\n      onChange={onDropdownChange}\n      onLoad={onLoad}\n      resourceFilter={resourceFilter}\n    />\n  );\n};\n\nexport default ImageStreamDropdown;\n","import * as React from 'react';\nimport { useFormikContext, FormikValues } from 'formik';\nimport { k8sGet } from '@console/internal/module/k8s';\nimport { RoleBindingModel } from '@console/internal/models';\nimport { checkAccess } from '@console/internal/components/utils';\nimport { ResourceDropdownField } from '@console/shared';\nimport { getProjectResource, BuilderImagesNamespace } from '../../../utils/imagestream-utils';\nimport { ImageStreamActions as Action } from '../import-types';\nimport { ImageStreamContext } from './ImageStreamContext';\n\nconst ImageStreamNsDropdown: React.FC = () => {\n  const { values, setFieldValue, initialValues } = useFormikContext<FormikValues>();\n  const { dispatch } = React.useContext(ImageStreamContext);\n  const onDropdownChange = React.useCallback(\n    (selectedProject: string) => {\n      const promiseArr = [];\n      setFieldValue('imageStream.image', initialValues.imageStream.image);\n      setFieldValue('imageStream.tag', initialValues.imageStream.tag);\n      setFieldValue('isi', initialValues.isi);\n      dispatch({ type: Action.setLoading, value: true });\n      dispatch({ type: Action.setAccessLoading, value: true });\n      if (selectedProject === BuilderImagesNamespace.Openshift) {\n        dispatch({ type: Action.setHasCreateAccess, value: true });\n        dispatch({ type: Action.setHasAccessToPullImage, value: true });\n        setFieldValue('imageStream.grantAccess', false);\n      } else {\n        promiseArr.push(\n          checkAccess({\n            group: RoleBindingModel.apiGroup,\n            resource: RoleBindingModel.plural,\n            verb: 'create',\n            name: 'system:image-puller',\n            namespace: selectedProject,\n          })\n            .then((resp) =>\n              dispatch({ type: Action.setHasCreateAccess, value: resp.status.allowed }),\n            )\n            .catch(() => dispatch({ type: Action.setHasAccessToPullImage, value: false })),\n        );\n        promiseArr.push(\n          k8sGet(RoleBindingModel, 'system:image-puller', selectedProject)\n            .then(() => {\n              dispatch({\n                type: Action.setHasAccessToPullImage,\n                value: true,\n              });\n              setFieldValue('imageStream.grantAccess', false);\n            })\n            .catch(() => dispatch({ type: Action.setHasAccessToPullImage, value: false })),\n        );\n      }\n      return Promise.all(promiseArr).then(() =>\n        dispatch({ type: Action.setAccessLoading, value: false }),\n      );\n    },\n    [\n      dispatch,\n      initialValues.imageStream.image,\n      initialValues.imageStream.tag,\n      initialValues.isi,\n      setFieldValue,\n    ],\n  );\n\n  React.useEffect(() => {\n    values.imageStream.namespace && onDropdownChange(values.imageStream.namespace);\n  }, [onDropdownChange, values.imageStream.namespace]);\n\n  React.useEffect(() => {\n    if (initialValues.imageStream.namespace !== values.imageStream.namespace) {\n      initialValues.imageStream.image = '';\n      initialValues.imageStream.tag = '';\n    }\n  }, [\n    initialValues.imageStream.image,\n    initialValues.imageStream.namespace,\n    initialValues.imageStream.tag,\n    values.imageStream.namespace,\n  ]);\n\n  return (\n    <ResourceDropdownField\n      name=\"imageStream.namespace\"\n      label=\"Projects\"\n      title=\"Select Project\"\n      fullWidth\n      required\n      resources={getProjectResource()}\n      dataSelector={['metadata', 'name']}\n      onChange={onDropdownChange}\n      appendItems={{ openshift: BuilderImagesNamespace.Openshift }}\n    />\n  );\n};\nexport default ImageStreamNsDropdown;\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport * as fuzzy from 'fuzzysearch';\nimport { useFormikContext, FormikValues, getIn } from 'formik';\nimport { ValidatedOptions } from '@patternfly/react-core';\nimport { DropdownField } from '@console/shared';\nimport { k8sGet, K8sResourceKind, ContainerPort } from '@console/internal/module/k8s';\nimport { ImageStreamTagModel } from '@console/internal/models';\nimport { UNASSIGNED_KEY } from '../../../const';\nimport {\n  getImageStreamTags,\n  getPorts,\n  getSuggestedName,\n  makePortName,\n  imageStreamLabels,\n} from '../../../utils/imagestream-utils';\nimport { ImageStreamContext } from './ImageStreamContext';\n\nconst ImageStreamTagDropdown: React.FC = () => {\n  let imageStreamTagList = {};\n  const {\n    values: {\n      name: resourceName,\n      imageStream,\n      application,\n      formType,\n      isi: { ports: isiPorts },\n    },\n    setFieldValue,\n    initialValues,\n    touched,\n  } = useFormikContext<FormikValues>();\n  const { state, hasImageStreams, setValidated } = React.useContext(ImageStreamContext);\n  const { selectedImageStream, accessLoading, loading } = state;\n  imageStreamTagList = getImageStreamTags(selectedImageStream as K8sResourceKind);\n  const isNamespaceSelected = imageStream.namespace !== '' && !accessLoading;\n  const isStreamsAvailable = isNamespaceSelected && hasImageStreams && !loading;\n  const isTagsAvailable = isStreamsAvailable && !_.isEmpty(imageStreamTagList);\n  const isImageStreamSelected = imageStream.image !== '';\n\n  const searchImageTag = React.useCallback(\n    (selectedTag: string) => {\n      setFieldValue('isSearchingForImage', true);\n      k8sGet(ImageStreamTagModel, `${imageStream.image}:${selectedTag}`, imageStream.namespace)\n        .then((imageStreamImport) => {\n          const {\n            image,\n            tag,\n            status,\n            metadata: { labels },\n          } = imageStreamImport;\n\n          const imgStreamLabels = _.pick(labels, imageStreamLabels);\n          const name = imageStream.image;\n          const isi = { name, image, tag, status };\n          const ports = getPorts(isi);\n          setFieldValue('isSearchingForImage', false);\n          setFieldValue('isi.name', name);\n          setFieldValue('isi.image', _.merge(image, { metadata: { labels: imgStreamLabels } }));\n          setFieldValue('isi.tag', selectedTag);\n          setFieldValue('isi.ports', ports);\n          setFieldValue('image.ports', ports);\n          !resourceName && formType !== 'edit' && setFieldValue('name', getSuggestedName(name));\n          application.selectedKey !== UNASSIGNED_KEY &&\n            !application.name &&\n            setFieldValue('application.name', `${getSuggestedName(name)}-app`);\n          // set default port value\n          const targetPort =\n            (!initialValues.route.targetPort || getIn(touched.imageStream, 'image')) &&\n            !getIn(touched.route, 'targetPort') &&\n            _.head(ports);\n          targetPort && setFieldValue('route.targetPort', makePortName(targetPort));\n          setValidated(ValidatedOptions.success);\n        })\n        .catch((error) => {\n          setFieldValue('isi', {});\n          setFieldValue('isi.status', { metadata: {}, status: '', message: error.message });\n          setFieldValue('isSearchingForImage', false);\n          setValidated(ValidatedOptions.error);\n        });\n    },\n    [\n      setFieldValue,\n      imageStream.image,\n      formType,\n      application.selectedKey,\n      application.name,\n      resourceName,\n      setValidated,\n      imageStream.namespace,\n      initialValues.route.targetPort,\n      touched.imageStream,\n      touched.route,\n    ],\n  );\n\n  React.useEffect(() => {\n    imageStream.tag && searchImageTag(imageStream.tag);\n  }, [imageStream.tag, searchImageTag]);\n\n  React.useEffect(() => {\n    if (\n      getIn(touched.imageStream, 'image') &&\n      !getIn(touched.route, 'targetPort') &&\n      !_.isEqual(initialValues.imageStream.image, imageStream.image)\n    ) {\n      const targetPort: ContainerPort = _.head(isiPorts);\n      targetPort && setFieldValue('route.targetPort', makePortName(targetPort));\n    }\n  }, [\n    touched.route,\n    touched.imageStream,\n    initialValues.imageStream.image,\n    imageStream.image,\n    setFieldValue,\n    isiPorts,\n  ]);\n\n  return (\n    <DropdownField\n      name=\"imageStream.tag\"\n      label=\"Tag\"\n      items={imageStreamTagList}\n      key={imageStream.image}\n      autocompleteFilter={fuzzy}\n      title={\n        imageStream.tag ||\n        (isNamespaceSelected && isImageStreamSelected && !isTagsAvailable ? 'No Tag' : 'Select Tag')\n      }\n      disabled={!isImageStreamSelected || !isTagsAvailable}\n      fullWidth\n      required\n      onChange={(tag) => {\n        tag !== '' && searchImageTag(tag);\n      }}\n    />\n  );\n};\n\nexport default ImageStreamTagDropdown;\n"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AAQA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;AACA;AAOA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AAgBA;AACA;AAWA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAGA;AAIA;AAEA;AAIA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AAGA;AAIA;AAEA;AAIA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAOA;AAEA;AACA;AAEA;;AAMA;AACA;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAAA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAMA;AAIA;AASA;AAEA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;;ACjdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAWA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAIA;;AACA;AACA;AAKA;AACA;AACA;AACA;AAIA;AAEA;AACA;AAWA;AAEA;;;;;;;;;;;;;AC/MA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;ACrDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAIA;AACA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAAA;AAIA;AAEA;AAGA;AAKA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AAEA;;AACA;AAIA;AAEA;;AACA;AAIA;AAEA;;AACA;AACA;AACA;AAGA;AAEA;AAGA;AAOA;AAEA;;;;;;;;;;;;;ACpJA;AAAA;AAAA;AAAA;AAAA;AAGA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAKA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAgBA;AAEA;;;;;;;;;;;;;ACjGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAaA;AACA;;;;;;;;;;;;;AC9FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;AACA;AACA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AAMA;AACA;AAGA;AAEA;;;;;A","sourceRoot":""}