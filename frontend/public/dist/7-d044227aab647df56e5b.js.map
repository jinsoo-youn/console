{"version":3,"file":"7-d044227aab647df56e5b.js","sources":["webpack:///./packages/console-shared/src/components/editor/ShortcutsLink.tsx","webpack:///./packages/console-shared/src/components/editor/YAMLEditor.scss?26ec","webpack:///./packages/console-shared/src/components/editor/YAMLEditor.tsx","webpack:///./packages/console-shared/src/components/editor/YAMLEditorToolbar.scss?93c0","webpack:///./packages/console-shared/src/components/editor/YAMLEditorToolbar.tsx","webpack:///./packages/console-shared/src/components/editor/yaml-editor-utils.ts","webpack:///./public/module/k8s/openapi-to-json-schema.ts"],"sourcesContent":["import * as React from 'react';\nimport { Popover, Button } from '@patternfly/react-core';\nimport { QuestionCircleIcon } from '@patternfly/react-icons';\nimport { ShortcutTable, Shortcut } from '../shortcuts';\nimport { useTranslation } from 'react-i18next';\n\ninterface ShortcutsLinkProps {\n  onHideShortcuts?: () => {};\n}\n\nconst ShortcutsLink: React.FC<ShortcutsLinkProps> = ({ onHideShortcuts }) => {\n  const { t } = useTranslation();\n  return (\n    <Popover\n      aria-label=\"Shortcuts\"\n      bodyContent={\n        <ShortcutTable>\n          <Shortcut ctrl keyName=\"space\">\n            Activate auto complete\n        </Shortcut>\n          <Shortcut ctrlCmd shift keyName=\"o\">\n            View document outline\n        </Shortcut>\n          <Shortcut hover>View property descriptions</Shortcut>\n          <Shortcut ctrlCmd keyName=\"s\">\n            Save\n        </Shortcut>\n        </ShortcutTable>\n      }\n      maxWidth=\"25rem\"\n      distance={18}\n      onHide={onHideShortcuts}\n    >\n      <Button type=\"button\" variant=\"link\" isInline>\n        <QuestionCircleIcon className=\"co-icon-space-r co-p-has-sidebar__sidebar-link-icon\" />\n        {t('COMMON:MSG_COMMON_BUTTON_ETC_10')}\n      </Button>\n    </Popover>\n  );\n}\n\nexport default ShortcutsLink;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport Measure from 'react-measure';\nimport MonacoEditor from 'react-monaco-editor';\n\nimport { registerYAMLinMonaco, defaultEditorOptions } from './yaml-editor-utils';\nimport YAMLEditorToolbar from './YAMLEditorToolbar';\n\nimport './YAMLEditor.scss';\n\ninterface YAMLEditorProps {\n  value?: string;\n  options?: object;\n  minHeight?: string | number;\n  showShortcuts?: boolean;\n  toolbarLinks?: React.ReactNodeArray;\n  onChange?: (newValue, event) => {};\n  onSave?: () => {};\n}\n\nconst YAMLEditor = React.forwardRef<MonacoEditor, YAMLEditorProps>((props, ref) => {\n  const {\n    value,\n    options = defaultEditorOptions,\n    showShortcuts,\n    toolbarLinks,\n    minHeight,\n    onChange,\n    onSave,\n  } = props;\n\n  const editorDidMount = (editor, monaco) => {\n    editor.layout();\n    editor.focus();\n    registerYAMLinMonaco(monaco);\n    monaco.editor.getModels()[0].updateOptions({ tabSize: 2 });\n    onSave && editor.addCommand(monaco.KeyMod.CtrlCmd | monaco.KeyCode.KEY_S, onSave); // eslint-disable-line no-bitwise\n  };\n\n  return (\n    <>\n      <YAMLEditorToolbar showShortcuts={showShortcuts} toolbarLinks={toolbarLinks} />\n      <Measure bounds>\n        {({ measureRef, contentRect }) => (\n          <div ref={measureRef} className=\"ocs-yaml-editor__root\" style={{ minHeight }}>\n            <div className=\"ocs-yaml-editor__wrapper\">\n              <MonacoEditor\n                ref={ref}\n                language=\"yaml\"\n                theme=\"console\"\n                height={contentRect.bounds.height}\n                width={contentRect.bounds.width}\n                value={value}\n                options={options}\n                editorDidMount={editorDidMount}\n                onChange={onChange}\n              />\n            </div>\n          </div>\n        )}\n      </Measure>\n    </>\n  );\n});\n\nexport default YAMLEditor;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport ShortcutsLink from './ShortcutsLink';\nimport './YAMLEditorToolbar.scss';\n\ninterface YAMLEditorToolbarProps {\n  showShortcuts?: boolean;\n  toolbarLinks?: React.ReactNodeArray;\n}\n\nconst YAMLEditorToolbar: React.FC<YAMLEditorToolbarProps> = ({ showShortcuts, toolbarLinks }) => {\n  if (!showShortcuts && !toolbarLinks?.length) return null;\n\n  return (\n    <div className=\"ocs-yaml-editor-toolbar__links\">\n      {showShortcuts && (\n        <div className=\"ocs-yaml-editor-toolbar__link\">\n          <ShortcutsLink />\n        </div>\n      )}\n      {toolbarLinks &&\n        toolbarLinks.map((link, index) => (\n          // eslint-disable-next-line react/no-array-index-key\n          <div key={`${index}`}>\n            {(showShortcuts || index > 0) && link ? (\n              <div className=\"co-action-divider\">|</div>\n            ) : null}\n            <div className=\"ocs-yaml-editor-toolbar__link\">{link}</div>\n          </div>\n        ))}\n    </div>\n  );\n};\nexport default YAMLEditorToolbar;\n","import * as URL from 'url';\nimport {\n  MonacoToProtocolConverter,\n  ProtocolToMonacoConverter,\n} from 'monaco-languageclient/lib/monaco-converter';\nimport { getLanguageService, TextDocument } from 'yaml-language-server';\nimport { openAPItoJSONSchema } from '@console/internal/module/k8s/openapi-to-json-schema';\nimport { getStoredSwagger } from '@console/internal/module/k8s/swagger';\nimport {\n  global_BackgroundColor_100 as lineNumberActiveForeground,\n  global_BackgroundColor_300 as lineNumberForeground,\n  global_BackgroundColor_dark_100 as editorBackground,\n} from '@patternfly/react-tokens';\n\nwindow.monaco.editor.defineTheme('console', {\n  base: 'vs-dark',\n  inherit: true,\n  rules: [\n    // avoid pf tokens for `rules` since tokens are opaque strings that might not be hex values\n    { token: 'number', foreground: 'ace12e' },\n    { token: 'type', foreground: '73bcf7' },\n    { token: 'string', foreground: 'f0ab00' },\n    { token: 'keyword', foreground: 'cbc0ff' },\n  ],\n  colors: {\n    'editor.background': editorBackground.value,\n    'editorGutter.background': '#292e34', // no pf token defined\n    'editorLineNumber.activeForeground': lineNumberActiveForeground.value,\n    'editorLineNumber.foreground': lineNumberForeground.value,\n  },\n});\n\nexport const defaultEditorOptions = { readOnly: false, scrollBeyondLastLine: false };\n\n// Unfortunately, `editor.focus()` doesn't work when hiding the shortcuts\n// popover. We need to find the actual DOM element.\nexport const hackyFocusEditor = () =>\n  setTimeout(() => document.querySelector<any>('.monaco-editor textarea')?.focus());\n\nexport const registerYAMLLanguage = (monaco) => {\n  // register the YAML language with Monaco\n  monaco.languages.register({\n    id: 'yaml',\n    extensions: ['.yml', '.yaml'],\n    aliases: ['YAML', 'yaml'],\n    mimetypes: ['application/yaml'],\n  });\n};\n\nexport const createYAMLService = () => {\n  const resolveSchema = (url: string): Thenable<string> => {\n    const promise = new Promise((resolve, reject) => {\n      const xhr = new XMLHttpRequest();\n      xhr.onload = () => resolve(xhr.responseText);\n      xhr.onerror = () => reject(xhr.statusText);\n      xhr.open('GET', url, true);\n      xhr.send();\n    });\n    return promise as Thenable<string>;\n  };\n\n  const workspaceContext = {\n    resolveRelativePath: (relativePath, resource) => URL.resolve(resource, relativePath),\n  };\n\n  const yamlService = getLanguageService(resolveSchema, workspaceContext, []);\n\n  // Prepare the schema\n  const yamlOpenAPI = getStoredSwagger();\n\n  // Convert the openAPI schema to something the language server understands\n  const kubernetesJSONSchema = openAPItoJSONSchema(yamlOpenAPI);\n\n  const schemas = [\n    {\n      uri: 'inmemory:yaml',\n      fileMatch: ['*'],\n      schema: kubernetesJSONSchema,\n    },\n  ];\n  yamlService.configure({\n    validate: true,\n    schemas,\n    hover: true,\n    completion: true,\n  });\n  return yamlService;\n};\n\nexport const registerYAMLCompletion = (\n  languageID,\n  monaco,\n  m2p,\n  p2m,\n  createDocument,\n  yamlService,\n) => {\n  monaco.languages.registerCompletionItemProvider(languageID, {\n    provideCompletionItems(model, position) {\n      const document = createDocument(model);\n      return yamlService\n        .doComplete(document, m2p.asPosition(position.lineNumber, position.column), true)\n        .then((list) => {\n          return p2m.asCompletionResult(list);\n        });\n    },\n\n    resolveCompletionItem(item) {\n      return yamlService\n        .doResolve(m2p.asCompletionItem(item))\n        .then((result) => p2m.asCompletionItem(result));\n    },\n  });\n};\n\nexport const registerYAMLDocumentSymbols = (\n  languageID,\n  monaco,\n  p2m,\n  createDocument,\n  yamlService,\n) => {\n  monaco.languages.registerDocumentSymbolProvider(languageID, {\n    provideDocumentSymbols(model) {\n      const document = createDocument(model);\n      return p2m.asSymbolInformations(yamlService.findDocumentSymbols(document));\n    },\n  });\n};\n\nexport const registerYAMLHover = (languageID, monaco, m2p, p2m, createDocument, yamlService) => {\n  monaco.languages.registerHoverProvider(languageID, {\n    provideHover(model, position) {\n      const doc = createDocument(model);\n      return yamlService\n        .doHover(doc, m2p.asPosition(position.lineNumber, position.column))\n        .then((hover) => {\n          return p2m.asHover(hover);\n        })\n        .then((e) => {\n          for (const el of <any>document.getElementsByClassName('monaco-editor-hover')) {\n            el.onclick = (event) => event.preventDefault();\n            el.onauxclick = (event) => {\n              window.open(event.target.getAttribute('data-href'), '_blank').opener = null;\n              event.preventDefault();\n            };\n          }\n          return e;\n        });\n    },\n  });\n};\n\nexport const enableYAMLValidation = (monaco, p2m, monacoURI, createDocument, yamlService) => {\n  const pendingValidationRequests = new Map();\n\n  const getModel = () => monaco.editor.getModels()[0];\n\n  const cleanPendingValidation = (document) => {\n    const request = pendingValidationRequests.get(document.uri);\n    if (request !== undefined) {\n      clearTimeout(request);\n      pendingValidationRequests.delete(document.uri);\n    }\n  };\n\n  const cleanDiagnostics = () =>\n    monaco.editor.setModelMarkers(monaco.editor.getModel(monacoURI), 'default', []);\n\n  const doValidate = (document) => {\n    if (document.getText().length === 0) {\n      cleanDiagnostics();\n      return;\n    }\n    yamlService\n      .doValidation(document, true)\n      .then((diagnostics) => {\n        const markers = p2m.asDiagnostics(diagnostics);\n        monaco.editor.setModelMarkers(getModel(), 'default', markers);\n      })\n      .catch(() => {});\n  };\n\n  getModel().onDidChangeContent(() => {\n    const document = createDocument(getModel());\n    cleanPendingValidation(document);\n    pendingValidationRequests.set(\n      document.uri,\n      setTimeout(() => {\n        pendingValidationRequests.delete(document.uri);\n        doValidate(document);\n      }),\n    );\n  });\n};\n\nexport const registerYAMLinMonaco = (monaco) => {\n  const LANGUAGE_ID = 'yaml';\n  const MODEL_URI = 'inmemory://model.yaml';\n  const MONACO_URI = monaco.Uri.parse(MODEL_URI);\n\n  const m2p = new MonacoToProtocolConverter();\n  const p2m = new ProtocolToMonacoConverter();\n\n  function createDocument(model) {\n    return TextDocument.create(\n      MODEL_URI,\n      model.getModeId(),\n      model.getVersionId(),\n      model.getValue(),\n    );\n  }\n\n  const yamlService = createYAMLService();\n\n  // validation is not a 'registered' feature like the others, it relies on calling the yamlService\n  // directly for validation results when content in the editor has changed\n  enableYAMLValidation(monaco, p2m, MONACO_URI, createDocument, yamlService);\n\n  /**\n   * This exists because react-monaco-editor passes the same monaco\n   * object each time. Without it you would be registering all the features again and\n   * getting duplicate results.\n   *\n   * Monaco does not provide any apis for unregistering or checking if the features have already\n   * been registered for a language.\n   *\n   * We check that > 1 YAML language exists because one is the default and one is the initial register\n   * that setups our features.\n   */\n  if (monaco.languages.getLanguages().filter((x) => x.id === LANGUAGE_ID).length > 1) {\n    return;\n  }\n\n  registerYAMLLanguage(monaco); // register the YAML language with monaco\n  registerYAMLCompletion(LANGUAGE_ID, monaco, m2p, p2m, createDocument, yamlService);\n  registerYAMLDocumentSymbols(LANGUAGE_ID, monaco, p2m, createDocument, yamlService);\n  registerYAMLHover(LANGUAGE_ID, monaco, m2p, p2m, createDocument, yamlService);\n};\n","// contains all the relevant information for transforming openapi specifications (such as kuberneres openapi)\n// to json schemas\n\ninterface GroupVersionKind {\n  kind: string;\n  version: string;\n  group: string;\n}\n\n/**\n * Given an array of GroupVersionKind objects, return their JSON Schema representation as enums\n */\nfunction groupVersionKindToEnums(gvkObjArray: [GroupVersionKind]) {\n  const versionEnum = [];\n  const kindEnum = [];\n  for (const gvkObj of gvkObjArray) {\n    if (gvkObj.group && gvkObj.version) {\n      versionEnum.push(`${gvkObj.group}/${gvkObj.version}`);\n    } else if (gvkObj.version) {\n      versionEnum.push(gvkObj.version);\n    }\n    if (gvkObj.kind) {\n      kindEnum.push(gvkObj.kind);\n    }\n  }\n  return {\n    versionEnum,\n    kindEnum,\n  };\n}\n\n/**\n * Append enums to APIVersion or create the object if it doesn't exist\n */\nfunction createOrAppendAPIVersion(openAPI, apiVersionEnum: string[]) {\n  if (openAPI.apiVersion) {\n    if (openAPI.apiVersion.enum) {\n      openAPI.apiVersion.enum.push(...apiVersionEnum);\n    } else {\n      openAPI.apiVersion.enum = apiVersionEnum;\n    }\n  } else {\n    openAPI.apiVersion = {\n      enum: apiVersionEnum,\n    };\n  }\n}\n\n/**\n * Append enums to kind or create the object if it doesn't exist\n */\nfunction createOrAppendKind(openAPI, kindEnum: string[]) {\n  if (openAPI.kind) {\n    if (openAPI.kind.enum) {\n      openAPI.kind.enum.push(...kindEnum);\n    } else {\n      openAPI.kind.enum = kindEnum;\n    }\n  } else {\n    openAPI.kind = {\n      enum: kindEnum,\n    };\n  }\n}\n\n/**\n * Converts the openAPI kubernetes specification for group, version, kind to JSON Schema\n *\n * Context: The openAPI specification gives the group, version, and kind objects as 'x-kubernetes-group-version-kind'\n * instead of adding the values to the enum's\n */\nfunction convertGroupVersionKindToJSONSchema(openAPI) {\n  for (const definition in openAPI) {\n    if (openAPI.hasOwnProperty(definition)) {\n      const openAPIDefinition = openAPI[definition];\n      const groupVersionKind = openAPIDefinition['x-kubernetes-group-version-kind'];\n\n      // If this object has x-kubernetes-group-version-kind then add their values into correct places in JSON Schema\n      if (groupVersionKind && openAPIDefinition.properties) {\n        const gvkEnums = groupVersionKindToEnums(groupVersionKind);\n        createOrAppendAPIVersion(openAPIDefinition.properties, gvkEnums.versionEnum);\n        createOrAppendKind(openAPIDefinition.properties, gvkEnums.kindEnum);\n      }\n    }\n  }\n  return openAPI;\n}\n\n/**\n * Takes in the stored kubernetes openAPI object and outputs a JSON Schema of the object\n */\nexport function openAPItoJSONSchema(openAPI) {\n  if (!openAPI) {\n    return null;\n  }\n\n  const convertedOpenAPI = convertGroupVersionKindToJSONSchema(openAPI);\n\n  const oneOfSchemas = [];\n  const openAPIDefinitions = {};\n  for (const schemaProperty in convertedOpenAPI) {\n    if (convertedOpenAPI.hasOwnProperty(schemaProperty)) {\n      openAPIDefinitions[schemaProperty] = convertedOpenAPI[schemaProperty];\n      oneOfSchemas.push({\n        $ref: `#/definitions/${schemaProperty}`,\n      });\n    }\n  }\n\n  return {\n    definitions: {\n      ...openAPIDefinitions,\n    },\n    oneOf: oneOfSchemas,\n  };\n}\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AAKA;AAGA;AAGA;AACA;AASA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;ACzCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAEA;AAYA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AACA;AAiBA;AAEA;;;;;;;;;;;;AChEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAOA;AACA;AAAA;AAEA;AAEA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAGA;AAKA;AACA;;;;;;;;;;;;;AChCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAIA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAMA;AAEA;AAEA;AACA;AACA;AAEA;;;;;;;;;;AAUA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC9OA;AAAA;AAAA;AACA;AAQA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;;;;;A","sourceRoot":""}