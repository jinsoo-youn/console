{"version":3,"file":"subscriptions-500787dd44c0115dbf4d.js","sources":["webpack:///./packages/operator-lifecycle-manager/src/components/modals/installplan-approval-modal.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/modals/subscription-channel-modal.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/modals/uninstall-operator-modal.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/operator-group.tsx","webpack:///./packages/operator-lifecycle-manager/src/components/subscription.tsx"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport {\n  createModalLauncher,\n  ModalTitle,\n  ModalBody,\n  ModalSubmitFooter,\n} from '@console/internal/components/factory/modal';\nimport { PromiseComponent } from '@console/internal/components/utils';\nimport {\n  K8sKind,\n  K8sResourceKind,\n  modelFor,\n  referenceFor,\n  referenceForModel,\n} from '@console/internal/module/k8s';\nimport { RadioInput } from '@console/internal/components/radio';\nimport { SubscriptionKind, InstallPlanApproval, InstallPlanKind } from '../../types';\nimport { SubscriptionModel, InstallPlanModel } from '../../models';\n\nconst getApprovalStrategy = (props: InstallPlanApprovalModalProps) =>\n  (referenceFor(props.obj) === referenceForModel(SubscriptionModel) &&\n    _.get(props.obj, 'spec.installPlanApproval')) ||\n  (referenceFor(props.obj) === referenceForModel(InstallPlanModel) &&\n    _.get(props.obj, 'spec.approval')) ||\n  InstallPlanApproval.Automatic;\n\nexport class InstallPlanApprovalModal extends PromiseComponent<\n  InstallPlanApprovalModalProps,\n  InstallPlanApprovalModalState\n> {\n  public state: InstallPlanApprovalModalState;\n\n  constructor(public props: InstallPlanApprovalModalProps) {\n    super(props);\n\n    this.state.selectedApprovalStrategy = getApprovalStrategy(props);\n  }\n\n  private submit(event): void {\n    event.preventDefault();\n\n    const updatedObj = _.cloneDeep(this.props.obj);\n    if (referenceFor(updatedObj) === referenceForModel(SubscriptionModel)) {\n      (updatedObj as SubscriptionKind).spec.installPlanApproval = this.state.selectedApprovalStrategy;\n    } else if (referenceFor(updatedObj) === referenceForModel(InstallPlanModel)) {\n      (updatedObj as InstallPlanKind).spec.approval = this.state.selectedApprovalStrategy;\n    }\n    this.handlePromise(this.props.k8sUpdate(modelFor(referenceFor(this.props.obj)), updatedObj))\n      .then(() => this.props.close())\n      .catch((err) => this.setState({ errorMessage: err }));\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.submit.bind(this)} name=\"form\" className=\"modal-content\">\n        <ModalTitle className=\"modal-header\">Change Update Approval Strategy</ModalTitle>\n        <ModalBody>\n          <div className=\"co-m-form-row\">\n            <p>What strategy is used for approving updates?</p>\n          </div>\n          <div className=\"co-m-form-row row\">\n            <div className=\"col-sm-12\">\n              <RadioInput\n                onChange={(e) => this.setState({ selectedApprovalStrategy: e.target.value })}\n                value={InstallPlanApproval.Automatic}\n                checked={this.state.selectedApprovalStrategy === InstallPlanApproval.Automatic}\n                title={InstallPlanApproval.Automatic}\n                subTitle=\"(default)\"\n              >\n                <div className=\"co-m-radio-desc\">\n                  <p className=\"text-muted\">\n                    New updates will be installed as soon as they become available.\n                  </p>\n                </div>\n              </RadioInput>\n            </div>\n            <div className=\"col-sm-12\">\n              <RadioInput\n                onChange={(e) => this.setState({ selectedApprovalStrategy: e.target.value })}\n                value={InstallPlanApproval.Manual}\n                checked={this.state.selectedApprovalStrategy === InstallPlanApproval.Manual}\n                title={InstallPlanApproval.Manual}\n              >\n                <div className=\"co-m-radio-desc\">\n                  <p className=\"text-muted\">\n                    New updates need to be manually approved before installation begins.\n                  </p>\n                </div>\n              </RadioInput>\n            </div>\n          </div>\n        </ModalBody>\n        <ModalSubmitFooter\n          inProgress={this.state.inProgress}\n          errorMessage={this.state.errorMessage}\n          cancel={() => this.props.cancel()}\n          submitText=\"Save\"\n          submitDisabled={getApprovalStrategy(this.props) === this.state.selectedApprovalStrategy}\n        />\n      </form>\n    );\n  }\n}\n\nexport const createInstallPlanApprovalModal = createModalLauncher<InstallPlanApprovalModalProps>(\n  InstallPlanApprovalModal,\n);\n\nexport type InstallPlanApprovalModalProps = {\n  cancel?: () => void;\n  close?: () => void;\n  k8sUpdate: (kind: K8sKind, newObj: K8sResourceKind) => Promise<any>;\n  obj: InstallPlanKind | SubscriptionKind;\n};\n\nexport type InstallPlanApprovalModalState = {\n  inProgress: boolean;\n  errorMessage: string;\n  selectedApprovalStrategy: InstallPlanApproval;\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport {\n  createModalLauncher,\n  ModalTitle,\n  ModalBody,\n  ModalSubmitFooter,\n} from '@console/internal/components/factory/modal';\nimport { PromiseComponent, ResourceLink } from '@console/internal/components/utils';\nimport { K8sKind, K8sResourceKind, referenceForModel } from '@console/internal/module/k8s';\nimport { RadioInput } from '@console/internal/components/radio';\nimport { SubscriptionKind, PackageManifestKind } from '../../types';\nimport { SubscriptionModel, ClusterServiceVersionModel } from '../../models';\n\nconst getSelectedChannel = (props: SubscriptionChannelModalProps) =>\n  props.subscription.spec.channel || props.pkg.status.channels[0].name;\n\nexport class SubscriptionChannelModal extends PromiseComponent<\n  SubscriptionChannelModalProps,\n  SubscriptionChannelModalState\n> {\n  public state: SubscriptionChannelModalState;\n\n  constructor(public props: SubscriptionChannelModalProps) {\n    super(props);\n\n    this.state.selectedChannel = getSelectedChannel(props);\n  }\n\n  private submit(event): void {\n    event.preventDefault();\n\n    const updatedSub = _.cloneDeep(this.props.subscription);\n    updatedSub.spec.channel = this.state.selectedChannel;\n    this.handlePromise(this.props.k8sUpdate(SubscriptionModel, updatedSub))\n      .then(() => this.props.close())\n      .catch((err) => this.setState({ errorMessage: err }));\n  }\n\n  render() {\n    return (\n      <form onSubmit={this.submit.bind(this)} name=\"form\" className=\"modal-content\">\n        <ModalTitle className=\"modal-header\">Change Subscription Update Channel</ModalTitle>\n        <ModalBody>\n          <div className=\"co-m-form-row\">\n            <p>Which channel is used to receive updates?</p>\n          </div>\n          <div className=\"co-m-form-row row\">\n            {this.props.pkg.status.channels.map((channel) => (\n              <div key={channel.name} className=\"col-sm-12\">\n                <RadioInput\n                  onChange={(e) => this.setState({ selectedChannel: e.target.value })}\n                  value={channel.name}\n                  checked={this.state.selectedChannel === channel.name}\n                  title={channel.name}\n                  subTitle={\n                    <ResourceLink\n                      linkTo={false}\n                      name={channel.currentCSV}\n                      title={channel.currentCSV}\n                      kind={referenceForModel(ClusterServiceVersionModel)}\n                    />\n                  }\n                />\n              </div>\n            ))}\n          </div>\n        </ModalBody>\n        <ModalSubmitFooter\n          inProgress={this.state.inProgress}\n          errorMessage={this.state.errorMessage}\n          cancel={() => this.props.cancel()}\n          submitText=\"Save\"\n          submitDisabled={this.state.selectedChannel === getSelectedChannel(this.props)}\n        />\n      </form>\n    );\n  }\n}\n\nexport const createSubscriptionChannelModal = createModalLauncher<SubscriptionChannelModalProps>(\n  SubscriptionChannelModal,\n);\n\nexport type SubscriptionChannelModalProps = {\n  cancel?: () => void;\n  close?: () => void;\n  k8sUpdate: (kind: K8sKind, newObj: K8sResourceKind) => Promise<any>;\n  subscription: SubscriptionKind;\n  pkg: PackageManifestKind;\n};\n\nexport type SubscriptionChannelModalState = {\n  inProgress: boolean;\n  errorMessage: string;\n  selectedChannel: string;\n};\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport {\n  createModalLauncher,\n  ModalTitle,\n  ModalBody,\n  ModalSubmitFooter,\n} from '@console/internal/components/factory/modal';\nimport {\n  history,\n  resourceListPathFromModel,\n  withHandlePromise,\n} from '@console/internal/components/utils';\nimport { K8sKind, K8sResourceKind } from '@console/internal/module/k8s';\nimport { getActiveNamespace } from '@console/internal/actions/ui';\nimport { YellowExclamationTriangleIcon } from '@console/shared';\nimport { ClusterServiceVersionKind, SubscriptionKind } from '../../types';\nimport { ClusterServiceVersionModel, SubscriptionModel } from '../../models';\n\nexport const UninstallOperatorModal = withHandlePromise((props: UninstallOperatorModalProps) => {\n  const submit = (event) => {\n    event.preventDefault();\n\n    const { subscription, k8sKill } = props;\n    const deleteOptions = {\n      kind: 'DeleteOptions',\n      apiVersion: 'v1',\n      propagationPolicy: 'Foreground',\n    };\n    const promises = [k8sKill(SubscriptionModel, subscription, {}, deleteOptions)].concat(\n      _.get(subscription, 'status.installedCSV')\n        ? k8sKill(\n            ClusterServiceVersionModel,\n            {\n              metadata: {\n                name: subscription.status.installedCSV,\n                namespace: subscription.metadata.namespace,\n              },\n            },\n            {},\n            deleteOptions,\n          ).catch(() => Promise.resolve())\n        : [],\n    );\n\n    props\n      .handlePromise(Promise.all(promises))\n      .then(() => {\n        props.close();\n\n        if (\n          window.location.pathname.split('/').includes(subscription.metadata.name) ||\n          window.location.pathname.split('/').includes(subscription.status.installedCSV)\n        ) {\n          history.push(resourceListPathFromModel(ClusterServiceVersionModel, getActiveNamespace()));\n        }\n      })\n      .catch(_.noop);\n  };\n\n  const name = _.get(props.csv, 'spec.displayName') || props.subscription.spec.name;\n  const context =\n    props.subscription.metadata.namespace === 'openshift-operators' ? (\n      <strong>all namespaces</strong>\n    ) : (\n      <>\n        namespace <strong>{props.subscription.metadata.namespace}</strong>\n      </>\n    );\n  const uninstallMessage =\n    props.csv?.metadata?.annotations['operator.openshift.io/uninstall-message'];\n\n  return (\n    <form onSubmit={submit} name=\"form\" className=\"modal-content co-catalog-install-modal\">\n      <ModalTitle className=\"modal-header\">\n        <YellowExclamationTriangleIcon className=\"co-icon-space-r\" /> Uninstall Operator?\n      </ModalTitle>\n      <ModalBody>\n        This will remove operator <strong>{name}</strong> from {context}. Removing the operator will\n        not remove any of its custom resource definitions or managed resources. If your operator has\n        deployed applications on the cluster or configured off-cluster resources, these will\n        continue to run and need to be cleaned up manually.\n        {uninstallMessage && (\n          <>\n            <h2>Message from operator developer</h2>\n            <p>{uninstallMessage}</p>\n          </>\n        )}\n      </ModalBody>\n      <ModalSubmitFooter\n        inProgress={props.inProgress}\n        errorMessage={props.errorMessage}\n        cancel={props.cancel}\n        submitDanger\n        submitText=\"Uninstall\"\n      />\n    </form>\n  );\n});\n\nexport const createUninstallOperatorModal = createModalLauncher(UninstallOperatorModal);\n\nexport type UninstallOperatorModalProps = {\n  handlePromise: <T>(promise: Promise<T>) => Promise<T>;\n  inProgress: boolean;\n  errorMessage: string;\n  cancel?: () => void;\n  close?: () => void;\n  k8sKill: (kind: K8sKind, resource: K8sResourceKind, options: any, json: any) => Promise<any>;\n  k8sGet: (kind: K8sKind, name: string, namespace: string) => Promise<K8sResourceKind>;\n  k8sPatch: (\n    kind: K8sKind,\n    resource: K8sResourceKind,\n    data: { op: string; path: string; value: any }[],\n  ) => Promise<any>;\n  subscription: SubscriptionKind;\n  csv?: ClusterServiceVersionKind;\n};\n\nUninstallOperatorModal.displayName = 'UninstallOperatorModal';\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { Link } from 'react-router-dom';\nimport { MsgBox } from '@console/internal/components/utils/status-box';\nimport {\n  K8sResourceKind,\n  GroupVersionKind,\n  referenceForModel,\n  referenceForGroupVersionKind,\n} from '@console/internal/module/k8s';\nimport { AsyncComponent } from '@console/internal/components/utils/async';\nimport { getActiveNamespace } from '@console/internal/actions/ui';\nimport { OperatorGroupModel } from '../models';\nimport { OperatorGroupKind, SubscriptionKind, InstallModeType } from '../types';\n\nexport const targetNamespacesFor = (obj: K8sResourceKind) =>\n  _.get(obj, ['metadata', 'annotations', 'olm.targetNamespaces']);\nexport const operatorNamespaceFor = (obj: K8sResourceKind) =>\n  _.get(obj, ['metadata', 'annotations', 'olm.operatorNamespace']);\nexport const operatorGroupFor = (obj: K8sResourceKind) =>\n  _.get(obj, ['metadata', 'annotations', 'olm.operatorGroup']);\n\nexport const NoOperatorGroupMsg: React.SFC = () => (\n  <MsgBox\n    title=\"Namespace Not Enabled\"\n    detail={\n      <p>\n        The Operator Lifecycle Manager will not watch this namespace because it is not configured\n        with an OperatorGroup.{' '}\n        <Link to={`/ns/${getActiveNamespace()}/${referenceForModel(OperatorGroupModel)}/~new`}>\n          Create one here.\n        </Link>\n      </p>\n    }\n  />\n);\n\ntype RequireOperatorGroupProps = {\n  operatorGroup: { loaded: boolean; data?: OperatorGroupKind[] };\n};\n\nexport const OperatorGroupSelector: React.SFC<OperatorGroupSelectorProps> = (props) => (\n  <AsyncComponent\n    loader={() =>\n      import('@console/internal/components/utils/list-dropdown').then((m) => m.ListDropdown)\n    }\n    onChange={\n      props.onChange ||\n      function() {\n        return null;\n      }\n    }\n    desc=\"Operator Groups\"\n    placeholder=\"Select Operator Group\"\n    selectedKeyKind={referenceForModel(OperatorGroupModel)}\n    dataFilter={props.dataFilter}\n    resources={[\n      {\n        kind: referenceForModel(OperatorGroupModel),\n        fieldSelector: `metadata.name!=${props.excludeName}`,\n      },\n    ]}\n  />\n);\n\nexport const requireOperatorGroup = <P extends RequireOperatorGroupProps>(\n  Component: React.ComponentType<P>,\n) => {\n  return class RequireOperatorGroup extends React.Component<P> {\n    static WrappedComponent = Component;\n\n    render() {\n      const namespaceEnabled =\n        !_.get(this.props.operatorGroup, 'loaded') || !_.isEmpty(this.props.operatorGroup.data);\n\n      return namespaceEnabled ? <Component {...this.props} /> : <NoOperatorGroupMsg />;\n    }\n  } as React.ComponentClass<P> & { WrappedComponent: React.ComponentType<P> };\n};\n\nexport type InstallModeSet = { type: InstallModeType; supported: boolean }[];\n\n/**\n * Logic consistent with https://github.com/operator-framework/operator-lifecycle-manager/blob/4ef074e4207f5518d95ddf8c378036dfc4270dda/pkg/api/apis/operators/v1alpha1/clusterserviceversion.go#L165.\n */\nexport const supports = (set: InstallModeSet) => (obj: OperatorGroupKind) => {\n  const namespaces = _.get(obj.status, 'namespaces') || [];\n  const supportedModes = set.filter(({ supported }) => supported).map(({ type }) => type);\n\n  if (namespaces.length === 0) {\n    return false;\n  }\n  if (namespaces.length === 1) {\n    if (namespaces[0] === obj.metadata.namespace) {\n      return supportedModes.includes(InstallModeType.InstallModeTypeOwnNamespace);\n    }\n    if (namespaces[0] === '') {\n      return supportedModes.includes(InstallModeType.InstallModeTypeAllNamespaces);\n    }\n    return supportedModes.includes(InstallModeType.InstallModeTypeSingleNamespace);\n  }\n  if (\n    namespaces.length > 1 &&\n    !supportedModes.includes(InstallModeType.InstallModeTypeMultiNamespace)\n  ) {\n    return false;\n  }\n  if (namespaces.length > 1) {\n    if (\n      namespaces.includes(obj.metadata.namespace) &&\n      !supportedModes.includes(InstallModeType.InstallModeTypeOwnNamespace)\n    ) {\n      return false;\n    }\n    if (namespaces.includes('')) {\n      return false;\n    }\n  }\n\n  return true;\n};\n\nexport const isGlobal = (obj: OperatorGroupKind) =>\n  supports([{ type: InstallModeType.InstallModeTypeAllNamespaces, supported: true }])(obj);\nexport const isSingle = (obj: OperatorGroupKind) =>\n  supports([{ type: InstallModeType.InstallModeTypeSingleNamespace, supported: true }])(obj);\n\n/**\n * Determines if a given Operator package has a `Subscription` that makes it available in the given namespace.\n * Finds any `Subscriptions` for the given package, matches them to their `OperatorGroup`, and checks if the `OperatorGroup` is targeting the given namespace or if it is global.\n */\nexport const subscriptionFor = (allSubscriptions: SubscriptionKind[] = []) => (\n  allGroups: OperatorGroupKind[] = [],\n) => (pkgName: string) => (ns = '') => {\n  return allSubscriptions\n    .filter((sub) => sub.spec.name === pkgName)\n    .find((sub) =>\n      allGroups.some(\n        (og) =>\n          og.metadata.namespace === sub.metadata.namespace &&\n          (isGlobal(og) || _.get(og.status, 'namespaces', [] as string[]).includes(ns)),\n      ),\n    );\n};\n\nexport const installedFor = (allSubscriptions: SubscriptionKind[] = []) => (\n  allGroups: OperatorGroupKind[] = [],\n) => (pkgName: string) => (ns = '') => {\n  return !_.isNil(subscriptionFor(allSubscriptions)(allGroups)(pkgName)(ns));\n};\n\nexport const providedAPIsFor = (og: OperatorGroupKind) =>\n  _.get(og.metadata.annotations, 'olm.providedAPIs', '')\n    .split(',')\n    .map((api) => ({\n      group: api\n        .split('.')\n        .slice(2)\n        .join('.'),\n      version: api.split('.')[1],\n      kind: api.split('.')[0],\n    }))\n    .map(({ group, version, kind }) => referenceForGroupVersionKind(group)(version)(kind));\n\nexport type OperatorGroupSelectorProps = {\n  onChange?: (name: string, kind: GroupVersionKind) => void;\n  excludeName?: string;\n  dataFilter?: (obj: OperatorGroupKind) => boolean;\n};\n\nNoOperatorGroupMsg.displayName = 'NoOperatorGroupMsg';\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { match, Link } from 'react-router-dom';\nimport { sortable } from '@patternfly/react-table';\nimport * as classNames from 'classnames';\nimport { Alert, Button } from '@patternfly/react-core';\nimport { InProgressIcon, PencilAltIcon } from '@patternfly/react-icons';\nimport {\n  DetailsPage,\n  MultiListPage,\n  Table,\n  TableRow,\n  TableData,\n  RowFunction,\n} from '@console/internal/components/factory';\nimport {\n  MsgBox,\n  ResourceLink,\n  ResourceKebab,\n  navFactory,\n  Kebab,\n  ResourceSummary,\n  LoadingInline,\n  SectionHeading,\n} from '@console/internal/components/utils';\nimport { removeQueryArgument } from '@console/internal/components/utils/router';\nimport {\n  referenceForModel,\n  k8sGet,\n  k8sPatch,\n  k8sKill,\n  k8sUpdate,\n  K8sResourceKind,\n} from '@console/internal/module/k8s';\nimport {\n  YellowExclamationTriangleIcon,\n  GreenCheckCircleIcon,\n  getNamespace,\n  getName,\n  WarningStatus,\n} from '@console/shared';\nimport {\n  SubscriptionModel,\n  ClusterServiceVersionModel,\n  CatalogSourceModel,\n  InstallPlanModel,\n  PackageManifestModel,\n  OperatorGroupModel,\n} from '../models';\nimport {\n  SubscriptionKind,\n  SubscriptionState,\n  PackageManifestKind,\n  InstallPlanApproval,\n  ClusterServiceVersionKind,\n  OperatorGroupKind,\n  InstallPlanKind,\n  InstallPlanPhase,\n  CatalogSourceKind,\n} from '../types';\nimport { requireOperatorGroup } from './operator-group';\nimport { createUninstallOperatorModal } from './modals/uninstall-operator-modal';\nimport { createSubscriptionChannelModal } from './modals/subscription-channel-modal';\nimport { createInstallPlanApprovalModal } from './modals/installplan-approval-modal';\n\nexport const catalogSourceForSubscription = (\n  catalogSources: CatalogSourceKind[] = [],\n  subscription: SubscriptionKind,\n): CatalogSourceKind =>\n  _.find(catalogSources, {\n    metadata: {\n      name: _.get(subscription, 'spec.source'),\n      namespace: _.get(subscription, 'spec.sourceNamespace'),\n    },\n  });\n\nexport const installedCSVForSubscription = (\n  clusterServiceVersions: ClusterServiceVersionKind[] = [],\n  subscription: SubscriptionKind,\n): ClusterServiceVersionKind =>\n  _.find(clusterServiceVersions, {\n    metadata: {\n      name: _.get(subscription, 'status.installedCSV'),\n    },\n  });\n\nexport const packageForSubscription = (\n  packageManifests: PackageManifestKind[] = [],\n  subscription: SubscriptionKind,\n): PackageManifestKind =>\n  _.find(packageManifests, {\n    metadata: {\n      name: _.get(subscription, 'spec.name'),\n    },\n    status: {\n      packageName: _.get(subscription, 'spec.name'),\n      catalogSource: _.get(subscription, 'spec.source'),\n      catalogSourceNamespace: _.get(subscription, 'spec.sourceNamespace'),\n    },\n  });\n\nexport const installPlanForSubscription = (\n  installPlans: InstallPlanKind[] = [],\n  subscription: SubscriptionKind,\n): InstallPlanKind =>\n  _.find(installPlans, {\n    metadata: {\n      name: _.get(subscription, 'status.installplan.name'),\n    },\n  });\n\nconst tableColumnClasses = [\n  classNames('col-md-3', 'col-sm-4', 'col-xs-6'),\n  classNames('col-md-3', 'col-sm-4', 'col-xs-6'),\n  classNames('col-lg-2', 'col-md-3', 'col-sm-4', 'hidden-xs'),\n  classNames('col-lg-2', 'col-md-3', 'hidden-sm', 'hidden-xs'),\n  classNames('col-lg-2', 'hidden-md', 'hidden-sm', 'hidden-xs'),\n  Kebab.columnClass,\n];\n\nexport const SubscriptionTableHeader = () => {\n  return [\n    {\n      title: 'Name',\n      sortField: 'metadata.name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: 'Namespace',\n      sortField: 'metadata.namespace',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: 'Status',\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: 'Channel',\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: 'Approval Strategy',\n      props: { className: tableColumnClasses[4] },\n    },\n    {\n      title: '',\n      props: { className: tableColumnClasses[5] },\n    },\n  ];\n};\nSubscriptionTableHeader.displayName = 'SubscriptionTableHeader';\n\nconst subscriptionState = (state: SubscriptionState) => {\n  switch (state) {\n    case SubscriptionState.SubscriptionStateUpgradeAvailable:\n      return (\n        <span>\n          <YellowExclamationTriangleIcon /> Upgrade available\n        </span>\n      );\n    case SubscriptionState.SubscriptionStateUpgradePending:\n      return (\n        <span>\n          <InProgressIcon className=\"text-primary\" /> Upgrading\n        </span>\n      );\n    case SubscriptionState.SubscriptionStateAtLatest:\n      return (\n        <span>\n          <GreenCheckCircleIcon /> Up to date\n        </span>\n      );\n    default:\n      return (\n        <span className={_.isEmpty(state) ? 'text-muted' : ''}>{state || 'Unknown failure'}</span>\n      );\n  }\n};\n\nconst menuActions = [\n  Kebab.factory.Edit,\n  (kind, obj) => ({\n    label: 'Remove Subscription',\n    callback: () => createUninstallOperatorModal({ k8sKill, k8sGet, k8sPatch, subscription: obj }),\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: obj.metadata.name,\n      namespace: obj.metadata.namespace,\n      verb: 'delete',\n    },\n  }),\n  (kind, obj) => {\n    const installedCSV = _.get(obj, 'status.installedCSV');\n    return {\n      label: `View ${ClusterServiceVersionModel.kind}...`,\n      href: `/k8s/ns/${obj.metadata.namespace}/${ClusterServiceVersionModel.plural}/${installedCSV}`,\n      hidden: !installedCSV,\n    };\n  },\n];\n\nexport const SubscriptionTableRow: RowFunction<K8sResourceKind> = ({ obj, index, key, style }) => {\n  return (\n    <TableRow id={obj.metadata.uid} index={index} trKey={key} style={style}>\n      <TableData className={tableColumnClasses[0]}>\n        <ResourceLink\n          kind={referenceForModel(SubscriptionModel)}\n          name={obj.metadata.name}\n          namespace={obj.metadata.namespace}\n          title={obj.metadata.name}\n        />\n      </TableData>\n      <TableData className={tableColumnClasses[1]}>\n        <ResourceLink\n          kind=\"Namespace\"\n          name={obj.metadata.namespace}\n          title={obj.metadata.namespace}\n          displayName={obj.metadata.namespace}\n        />\n      </TableData>\n      <TableData className={tableColumnClasses[2]}>\n        {subscriptionState(_.get(obj.status, 'state'))}\n      </TableData>\n      <TableData className={classNames(tableColumnClasses[3], 'co-truncate', 'co-select-to-copy')}>\n        {obj.spec.channel || 'default'}\n      </TableData>\n      <TableData className={tableColumnClasses[4]}>\n        {obj.spec.installPlanApproval || 'Automatic'}\n      </TableData>\n      <TableData className={tableColumnClasses[5]}>\n        <ResourceKebab\n          actions={menuActions}\n          kind={referenceForModel(SubscriptionModel)}\n          resource={obj}\n        />\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const SubscriptionsList = requireOperatorGroup((props: SubscriptionsListProps) => (\n  <Table\n    {...props}\n    aria-label=\"Operator Subscriptions\"\n    Header={SubscriptionTableHeader}\n    Row={SubscriptionTableRow}\n    EmptyMsg={() => (\n      <MsgBox\n        title=\"No Subscriptions Found\"\n        detail=\"Each namespace can subscribe to a single channel of a package for automatic updates.\"\n      />\n    )}\n    virtualize\n  />\n));\n\nexport const SubscriptionsPage: React.SFC<SubscriptionsPageProps> = (props) => {\n  return (\n    <MultiListPage\n      {...props}\n      resources={[\n        {\n          kind: referenceForModel(SubscriptionModel),\n          namespace: props.namespace,\n          namespaced: true,\n          prop: 'subscription',\n        },\n        {\n          kind: referenceForModel(OperatorGroupModel),\n          namespace: props.namespace,\n          namespaced: true,\n          prop: 'operatorGroup',\n        },\n      ]}\n      flatten={(resources) => _.get(resources.subscription, 'data', [])}\n      title=\"Subscriptions\"\n      canCreate\n      createProps={{ to: '/operatorhub' }}\n      createButtonText=\"Create Subscription\"\n      ListComponent={SubscriptionsList}\n      filterLabel=\"Subscriptions by package\"\n    />\n  );\n};\n\nexport const SubscriptionDetails: React.FC<SubscriptionDetailsProps> = ({\n  catalogSources = [],\n  clusterServiceVersions = [],\n  installPlans = [],\n  obj,\n  packageManifests = [],\n}) => {\n  const catalogSource = catalogSourceForSubscription(catalogSources, obj);\n  const installedCSV = installedCSVForSubscription(clusterServiceVersions, obj);\n  const installPlan = installPlanForSubscription(installPlans, obj);\n  const installStatusPhase = installPlan?.status?.phase;\n  const installFailedCondition = installPlan?.status?.conditions?.find(\n    ({ type, status }) => type === 'Installed' && status === 'False',\n  );\n  const installFailedMessage =\n    installFailedCondition?.message || installFailedCondition?.reason || 'Install plan failed';\n\n  const pkg = packageForSubscription(packageManifests, obj);\n  if (new URLSearchParams(window.location.search).has('showDelete')) {\n    createUninstallOperatorModal({ k8sKill, k8sGet, k8sPatch, subscription: obj })\n      .result.then(() => removeQueryArgument('showDelete'))\n      .catch(_.noop);\n  }\n\n  return (\n    <div className=\"co-m-pane__body\">\n      {!catalogSource && (\n        <Alert isInline className=\"co-alert\" variant=\"warning\" title=\"Catalog Source Removed\">\n          The catalog source for this operator has been removed. The catalog source must be added\n          back in order for this operator to receive any updates.\n        </Alert>\n      )}\n      {installStatusPhase === InstallPlanPhase.InstallPlanPhaseFailed && (\n        <Alert\n          isInline\n          className=\"co-alert co-alert--scrollable\"\n          variant=\"danger\"\n          title={installStatusPhase}\n        >\n          {installFailedMessage}\n        </Alert>\n      )}\n      <SectionHeading text=\"Subscription Details\" />\n      <div className=\"co-m-pane__body-group\">\n        <SubscriptionUpdates\n          catalogSource={catalogSource}\n          pkg={pkg}\n          obj={obj}\n          installedCSV={installedCSV}\n          installPlan={installPlan}\n        />\n      </div>\n      <div className=\"co-m-pane__body-group\">\n        <div className=\"row\">\n          <div className=\"col-sm-6\">\n            <ResourceSummary resource={obj} showAnnotations={false} />\n          </div>\n          <div className=\"col-sm-6\">\n            <dl className=\"co-m-pane__details\">\n              <dt>Installed Version</dt>\n              <dd>\n                {installedCSV ? (\n                  <ResourceLink\n                    kind={referenceForModel(ClusterServiceVersionModel)}\n                    name={getName(installedCSV)}\n                    namespace={getNamespace(installedCSV)}\n                    title={getName(installedCSV)}\n                  />\n                ) : (\n                  'None'\n                )}\n              </dd>\n              <dt>Starting Version</dt>\n              <dd>{obj.spec.startingCSV || 'None'}</dd>\n              <dt>Catalog Source</dt>\n              <dd>\n                {catalogSource ? (\n                  <ResourceLink\n                    kind={referenceForModel(CatalogSourceModel)}\n                    name={getName(catalogSource)}\n                    namespace={getNamespace(catalogSource)}\n                    title={getName(catalogSource)}\n                  />\n                ) : (\n                  'None'\n                )}\n              </dd>\n              <dt>Install Plan</dt>\n              <dd>\n                {installPlan ? (\n                  <ResourceLink\n                    kind={referenceForModel(InstallPlanModel)}\n                    name={getName(installPlan)}\n                    namespace={getNamespace(installPlan)}\n                    title={getName(installPlan)}\n                  />\n                ) : (\n                  'None'\n                )}\n              </dd>\n            </dl>\n          </div>\n        </div>\n      </div>\n    </div>\n  );\n};\n\nexport class SubscriptionUpdates extends React.Component<\n  SubscriptionUpdatesProps,\n  SubscriptionUpdatesState\n> {\n  constructor(props) {\n    super(props);\n    this.state = {\n      waitingForUpdate: false,\n      installPlanApproval: _.get(props.obj, 'spec.installPlanApproval'),\n      channel: _.get(props.obj, 'spec.channel'),\n    };\n  }\n\n  static getDerivedStateFromProps(nextProps, prevState) {\n    const stillWaiting =\n      prevState.waitingForUpdate &&\n      _.get(nextProps, 'obj.spec.channel') === prevState.channel &&\n      _.get(nextProps, 'obj.spec.installPlanApproval') === prevState.installPlanApproval;\n\n    return stillWaiting\n      ? null\n      : {\n          waitingForUpdate: false,\n          channel: _.get(nextProps, 'obj.spec.channel'),\n          installPlanApproval: _.get(nextProps, 'obj.spec.installPlanApproval'),\n        };\n  }\n\n  render() {\n    const { catalogSource, installedCSV, obj, pkg } = this.props;\n\n    const k8sUpdateAndWait = (...args) =>\n      k8sUpdate(...args).then(() => this.setState({ waitingForUpdate: true }));\n    const channelModal = () =>\n      createSubscriptionChannelModal({ subscription: obj, pkg, k8sUpdate: k8sUpdateAndWait });\n    const approvalModal = () =>\n      createInstallPlanApprovalModal({ obj, k8sUpdate: k8sUpdateAndWait });\n    const installPlanPhase = (installPlan: InstallPlanKind) => {\n      switch (_.get(installPlan, 'status.phase') as InstallPlanPhase) {\n        case InstallPlanPhase.InstallPlanPhaseRequiresApproval:\n          return '1 requires approval';\n        case InstallPlanPhase.InstallPlanPhaseFailed:\n          return '1 failed';\n        default:\n          return '1 installing';\n      }\n    };\n\n    return (\n      <div className=\"co-detail-table\">\n        <div className=\"co-detail-table__row row\">\n          <div className=\"co-detail-table__section col-sm-3\">\n            <dl className=\"co-m-pane__details\">\n              <dt className=\"co-detail-table__section-header\">Channel</dt>\n              <dd>\n                {this.state.waitingForUpdate ? (\n                  <LoadingInline />\n                ) : (\n                  <Button\n                    type=\"button\"\n                    isInline\n                    onClick={channelModal}\n                    variant=\"link\"\n                    isDisabled={!pkg}\n                  >\n                    {obj.spec.channel || 'default'}\n                    {pkg && <PencilAltIcon className=\"co-icon-space-l pf-c-button-icon--plain\" />}\n                  </Button>\n                )}\n              </dd>\n            </dl>\n          </div>\n          <div className=\"co-detail-table__section col-sm-3\">\n            <dl className=\"co-m-pane__details\">\n              <dt className=\"co-detail-table__section-header\">Approval</dt>\n              <dd>\n                {this.state.waitingForUpdate ? (\n                  <LoadingInline />\n                ) : (\n                  <Button type=\"button\" isInline onClick={approvalModal} variant=\"link\">\n                    {obj.spec.installPlanApproval || 'Automatic'}\n                    <PencilAltIcon className=\"co-icon-space-l pf-c-button-icon--plain\" />\n                  </Button>\n                )}\n              </dd>\n            </dl>\n          </div>\n          <div className=\"co-detail-table__section co-detail-table__section--last col-sm-6\">\n            <dl className=\"co-m-pane__details\">\n              <dt className=\"co-detail-table__section-header\">Upgrade Status</dt>\n              {catalogSource ? (\n                <dd>{subscriptionState(_.get(obj.status, 'state'))}</dd>\n              ) : (\n                <dd>\n                  <WarningStatus title=\"Cannot update\" />\n                  <span className=\"text-muted\">Catalog source was removed</span>\n                </dd>\n              )}\n            </dl>\n            {catalogSource && (\n              <>\n                <div className=\"co-detail-table__bracket\" />\n                <div className=\"co-detail-table__breakdown\">\n                  {_.get(obj.status, 'installedCSV') && installedCSV ? (\n                    <Link\n                      to={`/k8s/ns/${obj.metadata.namespace}/${referenceForModel(\n                        ClusterServiceVersionModel,\n                      )}/${_.get(obj.status, 'installedCSV')}`}\n                    >\n                      1 installed\n                    </Link>\n                  ) : (\n                    <span>0 installed</span>\n                  )}\n                  {_.get(obj.status, 'state') ===\n                    SubscriptionState.SubscriptionStateUpgradePending &&\n                  _.get(obj.status, 'installplan') &&\n                  this.props.installPlan ? (\n                    <Link\n                      to={`/k8s/ns/${obj.metadata.namespace}/${referenceForModel(\n                        InstallPlanModel,\n                      )}/${_.get(obj.status, 'installplan.name')}`}\n                    >\n                      <span>{installPlanPhase(this.props.installPlan)}</span>\n                    </Link>\n                  ) : (\n                    <span>0 installing</span>\n                  )}\n                </div>\n              </>\n            )}\n          </div>\n        </div>\n      </div>\n    );\n  }\n}\n\nexport const SubscriptionDetailsPage: React.SFC<SubscriptionDetailsPageProps> = (props) => (\n  <DetailsPage\n    {...props}\n    namespace={props.match.params.ns}\n    kind={referenceForModel(SubscriptionModel)}\n    name={props.match.params.name}\n    pages={[navFactory.details(SubscriptionDetails), navFactory.editYaml()]}\n    resources={[\n      {\n        kind: referenceForModel(PackageManifestModel),\n        isList: true,\n        namespace: props.namespace,\n        prop: 'packageManifests',\n      },\n      {\n        kind: referenceForModel(InstallPlanModel),\n        isList: true,\n        namespace: props.namespace,\n        prop: 'installPlans',\n      },\n      {\n        kind: referenceForModel(ClusterServiceVersionModel),\n        namespace: props.namespace,\n        isList: true,\n        prop: 'clusterServiceVersions',\n      },\n      {\n        kind: referenceForModel(CatalogSourceModel),\n        isList: true,\n        prop: 'catalogSources',\n      },\n    ]}\n    menuActions={menuActions}\n  />\n);\n\nexport type SubscriptionsPageProps = {\n  namespace?: string;\n  match?: match<{ ns?: string }>;\n};\n\nexport type SubscriptionsListProps = {\n  loaded: boolean;\n  loadError?: string;\n  data: SubscriptionKind[];\n  operatorGroup: { loaded: boolean; data?: OperatorGroupKind[] };\n};\n\nexport type SubscriptionUpdatesProps = {\n  catalogSource: CatalogSourceKind;\n  obj: SubscriptionKind;\n  pkg: PackageManifestKind;\n  installedCSV?: ClusterServiceVersionKind;\n  installPlan?: InstallPlanKind;\n};\n\nexport type SubscriptionUpdatesState = {\n  waitingForUpdate: boolean;\n  channel: string;\n  installPlanApproval: InstallPlanApproval;\n};\n\nexport type SubscriptionDetailsProps = {\n  catalogSources?: CatalogSourceKind[];\n  clusterServiceVersions?: ClusterServiceVersionKind[];\n  installPlans?: InstallPlanKind[];\n  obj: SubscriptionKind;\n  packageManifests: PackageManifestKind[];\n};\n\nexport type SubscriptionDetailsPageProps = {\n  match: match<{ ns: string; name: string }>;\n  namespace: string;\n};\n\nSubscriptionsList.displayName = 'SubscriptionsList';\nSubscriptionsPage.displayName = 'SubscriptionsPage';\nSubscriptionDetails.displayName = 'SubscriptionDetails';\nSubscriptionDetailsPage.displayName = 'SubscriptionDetailsPage';\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AAOA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAMA;AACA;AADA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAOA;AACA;AAMA;AACA;AAMA;AACA;AAQA;AASA;AACA;AAEA;;;;;;;;;;;;;ACzGA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AACA;AAEA;AAEA;AAGA;AAMA;AACA;AADA;AAGA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAGA;AAkBA;AASA;AACA;AAEA;;;;;;;;;;;;;AChFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AAMA;AACA;AAEA;AAEA;;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AAIA;AAGA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;AAKA;AAGA;AAGA;AAEA;AACA;AACA;AACA;;AACA;;AAAA;;AAIA;AAEA;AACA;AAIA;AASA;AAEA;AAmBA;;;;;;;;;;;;;ACvHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAGA;;AAMA;AACA;AAYA;AAOA;AACA;AACA;AAOA;AACA;AACA;AACA;AACA;AAIA;;AAGA;AAGA;AACA;AAGA;AACA;AACA;AARA;AAQA;AACA;AAIA;;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAGA;;;AAGA;AACA;AAGA;AACA;AACA;AAIA;AAGA;AAEA;AAGA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;AC1KA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAQA;AAUA;AACA;AAQA;AAOA;AAQA;AAWA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAGA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAOA;AACA;AAOA;AAGA;AAGA;AAGA;AACA;AAQA;AAEA;AAgBA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAUA;AAEA;;AAOA;AACA;AACA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAMA;AAUA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAYA;AACA;AACA;AACA;AAYA;AACA;AAkBA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAWA;AACA;AAMA;AACA;AACA;AACA;AAKA;AACA;AAMA;AACA;AACA;AACA;AAIA;AACA;AAIA;AAEA;AACA;AACA;AAWA;AACA;AACA;AACA;AAMA;AAYA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AA4CA;AACA;AACA;AACA;;;;;A","sourceRoot":""}