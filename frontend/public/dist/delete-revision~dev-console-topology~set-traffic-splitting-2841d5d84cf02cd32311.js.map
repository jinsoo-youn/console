{"version":3,"file":"delete-revision~dev-console-topology~set-traffic-splitting-2841d5d84cf02cd32311.js","sources":["webpack:///./packages/dev-console/src/actions/add-resources.tsx","webpack:///./packages/dev-console/src/components/import/render-utils.tsx","webpack:///./packages/dev-console/src/components/pipelineruns/status/TaskStatusTooltip.scss?a429","webpack:///./packages/dev-console/src/components/pipelineruns/status/TaskStatusTooltip.tsx","webpack:///./packages/dev-console/src/components/svg/SvgBoxedText.tsx","webpack:///./packages/dev-console/src/components/svg/SvgCircledIcon.tsx","webpack:///./packages/dev-console/src/components/svg/SvgDropShadowFilter.tsx","webpack:///./packages/dev-console/src/components/svg/SvgResourceIcon.scss?350b","webpack:///./packages/dev-console/src/components/svg/SvgResourceIcon.tsx","webpack:///./packages/dev-console/src/components/topology/actions/graphActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/groupActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/nodeActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/regroupActions.ts","webpack:///./packages/dev-console/src/components/topology/actions/workloadActions.ts","webpack:///./packages/dev-console/src/components/topology/components/AbstractSBRComponentFactory.ts","webpack:///./packages/dev-console/src/components/topology/components/ContextMenu.scss?29d3","webpack:///./packages/dev-console/src/components/topology/components/GraphComponent.scss?c6e3","webpack:///./packages/dev-console/src/components/topology/components/GraphComponent.tsx","webpack:///./packages/dev-console/src/components/topology/components/NodeShadows.tsx","webpack:///./packages/dev-console/src/components/topology/components/RegroupHint.scss?ed6e","webpack:///./packages/dev-console/src/components/topology/components/RegroupHint.tsx","webpack:///./packages/dev-console/src/components/topology/components/componentFactory.ts","webpack:///./packages/dev-console/src/components/topology/components/componentUtils.ts","webpack:///./packages/dev-console/src/components/topology/components/const.ts","webpack:///./packages/dev-console/src/components/topology/components/createConnection.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/AggregateEdge.scss?1c09","webpack:///./packages/dev-console/src/components/topology/components/edges/AggregateEdge.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/BaseEdge.scss?5801","webpack:///./packages/dev-console/src/components/topology/components/edges/BaseEdge.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/ConnectsTo.scss?1292","webpack:///./packages/dev-console/src/components/topology/components/edges/ConnectsTo.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/CreateConnector.scss?c25f","webpack:///./packages/dev-console/src/components/topology/components/edges/CreateConnector.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/ServiceBinding.scss?9b61","webpack:///./packages/dev-console/src/components/topology/components/edges/ServiceBinding.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/TrafficConnector.scss?63b6","webpack:///./packages/dev-console/src/components/topology/components/edges/TrafficConnector.tsx","webpack:///./packages/dev-console/src/components/topology/components/edges/index.ts","webpack:///./packages/dev-console/src/components/topology/components/groups/Application.scss?a31d","webpack:///./packages/dev-console/src/components/topology/components/groups/Application.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/ApplicationGroup.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/ApplicationNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/GroupNode.scss?0a5e","webpack:///./packages/dev-console/src/components/topology/components/groups/GroupNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/ResourceKindsInfo.scss?de36","webpack:///./packages/dev-console/src/components/topology/components/groups/ResourceKindsInfo.tsx","webpack:///./packages/dev-console/src/components/topology/components/groups/index.ts","webpack:///./packages/dev-console/src/components/topology/components/index.ts","webpack:///./packages/dev-console/src/components/topology/components/moveNodeToGroup.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodeContextMenu.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/BaseNode.scss?af32","webpack:///./packages/dev-console/src/components/topology/components/nodes/BaseNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/CheIcon.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/Decorator.scss?ede8","webpack:///./packages/dev-console/src/components/topology/components/nodes/Decorator.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/PodSet.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/WorkloadNode.scss?4778","webpack:///./packages/dev-console/src/components/topology/components/nodes/WorkloadNode.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/BuildDecorator.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/PipelineBuildDecoratorTooltip.scss?0c26","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/PipelineBuildDecoratorTooltip.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/build-decorators/build-decorator-utils.tsx","webpack:///./packages/dev-console/src/components/topology/components/nodes/index.ts","webpack:///./packages/dev-console/src/components/topology/components/removeConnection.tsx","webpack:///./packages/dev-console/src/components/topology/components/withEditReviewAccess.tsx","webpack:///./packages/dev-console/src/components/topology/data-transforms/data-transformer.ts","webpack:///./packages/dev-console/src/components/topology/data-transforms/index.ts","webpack:///./packages/dev-console/src/components/topology/data-transforms/topology-model.ts","webpack:///./packages/dev-console/src/components/topology/data-transforms/transform-utils.ts","webpack:///./packages/dev-console/src/components/topology/filters/filter-types.ts","webpack:///./packages/dev-console/src/components/topology/filters/filter-utils.ts","webpack:///./packages/dev-console/src/components/topology/filters/index.ts","webpack:///./packages/dev-console/src/components/topology/filters/useDisplayFilters.ts","webpack:///./packages/dev-console/src/components/topology/filters/useSearchFilter.ts","webpack:///./packages/dev-console/src/components/topology/helm/components/const.ts","webpack:///./packages/dev-console/src/components/topology/helm/helm-data-transformer.ts","webpack:///./packages/dev-console/src/components/topology/helm/helm-topology-model.ts","webpack:///./packages/dev-console/src/components/topology/index.ts","webpack:///./packages/dev-console/src/components/topology/operators/components/const.ts","webpack:///./packages/dev-console/src/components/topology/operators/operators-data-transformer.ts","webpack:///./packages/dev-console/src/components/topology/operators/operators-topology-model.ts","webpack:///./packages/dev-console/src/components/topology/topology-types.ts","webpack:///./packages/dev-console/src/components/topology/topology-utils.ts","webpack:///./packages/knative-plugin/src/topology/const.ts","webpack:///./packages/knative-plugin/src/topology/data-transformer.ts","webpack:///./packages/knative-plugin/src/topology/knative-topology-model.ts","webpack:///./packages/knative-plugin/src/topology/knative-topology-utils.ts","webpack:///./packages/kubevirt-plugin/src/topology/components/const.ts","webpack:///./packages/kubevirt-plugin/src/topology/kubevirt-data-transformer.ts","webpack:///./packages/kubevirt-plugin/src/topology/kubevirt-topology-model.ts","webpack:///./public/components/daemon-set.tsx","webpack:///./public/components/deployment.tsx","webpack:///./public/components/stateful-set.tsx"],"sourcesContent":["import * as React from 'react';\nimport {\n  GitAltIcon,\n  OsImageIcon,\n  CatalogIcon,\n  CubeIcon,\n  DatabaseIcon,\n} from '@patternfly/react-icons';\nimport { ImportOptions } from '../components/import/import-types';\nimport { KebabAction, createKebabAction } from '../utils/add-resources-menu-utils';\n\nexport const allImportResourceAccess = 'allImportResourceAccess';\nexport const allCatalogImageResourceAccess = 'allCatalogImageResourceAccess';\n\nexport const fromGit = createKebabAction(\n  'From Git',\n  <GitAltIcon />,\n  ImportOptions.GIT,\n  allImportResourceAccess,\n);\n\nexport const containerImage = createKebabAction(\n  'Container Image',\n  <OsImageIcon />,\n  ImportOptions.CONTAINER,\n  allCatalogImageResourceAccess,\n);\n\nexport const fromCatalog = createKebabAction(\n  'From Catalog',\n  <CatalogIcon />,\n  ImportOptions.CATALOG,\n);\n\nexport const fromDockerfile = createKebabAction(\n  'From Dockerfile',\n  <CubeIcon />,\n  ImportOptions.DOCKERFILE,\n  allImportResourceAccess,\n);\n\nexport const fromDatabaseCatalog = createKebabAction(\n  'Database',\n  <DatabaseIcon />,\n  ImportOptions.DATABASE,\n);\n\nexport const addResourceMenu: KebabAction[] = [\n  fromGit,\n  containerImage,\n  fromCatalog,\n  fromDockerfile,\n  fromDatabaseCatalog,\n];\n\nexport const addResourceMenuWithoutCatalog: KebabAction[] = [\n  fromGit,\n  containerImage,\n  fromDockerfile,\n];\n","import * as React from 'react';\nimport { BitbucketIcon, GitAltIcon, GithubIcon, GitlabIcon } from '@patternfly/react-icons';\nimport CheIcon from '../topology/components/nodes/CheIcon';\nimport { detectGitType } from './import-validation-utils';\nimport { GitTypes } from './import-types';\n\nexport const routeDecoratorIcon = (\n  routeURL: string,\n  radius: number,\n  cheEnabled?: boolean,\n): React.ReactElement => {\n  if (cheEnabled && routeURL) {\n    return <CheIcon style={{ fontSize: radius }} />;\n  }\n  switch (detectGitType(routeURL)) {\n    case GitTypes.invalid:\n      // Not a valid url and thus not safe to use\n      return null;\n    case GitTypes.github:\n      return <GithubIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n    case GitTypes.bitbucket:\n      return <BitbucketIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n    case GitTypes.gitlab:\n      return <GitlabIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n    default:\n      return <GitAltIcon style={{ fontSize: radius }} alt=\"Edit Source Code\" />;\n  }\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { TaskStatus, runStatus, getRunStatusColor } from '../../../utils/pipeline-augment';\nimport './TaskStatusTooltip.scss';\n\ninterface TaskStatusToolTipProps {\n  taskStatus: TaskStatus;\n}\n\nconst TaskStatusToolTip: React.FC<TaskStatusToolTipProps> = ({ taskStatus }) => {\n  return (\n    <div className=\"odc-task-status-tooltip\">\n      {Object.keys(runStatus).map((status) => {\n        const { message, pftoken } = getRunStatusColor(status);\n        return taskStatus[status] ? (\n          <React.Fragment key={status}>\n            <div\n              className=\"odc-task-status-tooltip__legend\"\n              style={{ background: pftoken.value }}\n            />\n            <div>\n              {status === runStatus.PipelineNotStarted || status === runStatus.FailedToStart\n                ? message\n                : `${taskStatus[status]} ${message}`}\n            </div>\n          </React.Fragment>\n        ) : null;\n      })}\n    </div>\n  );\n};\n\nexport default TaskStatusToolTip;\n","import * as React from 'react';\nimport {\n  useSize,\n  useHover,\n  WithDndDragProps,\n  useCombineRefs,\n  createSvgIdUrl,\n} from '@console/topology';\nimport { truncateMiddle } from '@console/internal/components/utils';\nimport { RESOURCE_NAME_TRUNCATE_LENGTH } from '../../const';\nimport { SvgResourceIcon } from './SvgResourceIcon';\nimport SvgCircledIcon from './SvgCircledIcon';\nimport SvgDropShadowFilter from './SvgDropShadowFilter';\n\nexport interface SvgBoxedTextProps {\n  children?: string;\n  className?: string;\n  paddingX?: number;\n  paddingY?: number;\n  x?: number;\n  y?: number;\n  cornerRadius?: number;\n  kind?: string;\n  typeIconClass?: string;\n  typeIconPadding?: number;\n  truncate?: number;\n  dragRef?: WithDndDragProps['dndDragRef'];\n  // TODO remove with 2.0\n  onMouseEnter?: React.MouseEventHandler<SVGGElement>;\n  onMouseLeave?: React.MouseEventHandler<SVGGElement>;\n}\n\nconst FILTER_ID = 'SvgBoxedTextDropShadowFilterId';\n\n/**\n * Renders a `<text>` component with a `<rect>` box behind.\n */\nconst SvgBoxedText: React.FC<SvgBoxedTextProps> = ({\n  children,\n  className,\n  paddingX = 0,\n  paddingY = 0,\n  cornerRadius = 4,\n  x = 0,\n  y = 0,\n  kind,\n  typeIconClass,\n  typeIconPadding = 4,\n  onMouseEnter,\n  onMouseLeave,\n  truncate = RESOURCE_NAME_TRUNCATE_LENGTH,\n  dragRef,\n  ...other\n}) => {\n  const [labelHover, labelHoverRef] = useHover();\n  const [textSize, textRef] = useSize([children, className, labelHover]);\n  const [iconSize, iconRef] = useSize([kind]);\n  const iconSpace = kind && iconSize ? iconSize.width + paddingX : 0;\n  const refs = useCombineRefs(dragRef, typeof truncate === 'number' ? labelHoverRef : undefined);\n  const typedIconWidth = typeIconClass && iconSize ? iconSize.height + typeIconPadding * 2 : 0;\n  const midX = typedIconWidth ? x + typedIconWidth / 2 : x;\n\n  return (\n    <g className={className} ref={refs}>\n      <SvgDropShadowFilter id={FILTER_ID} />\n      {textSize && (\n        <rect\n          filter={createSvgIdUrl(FILTER_ID)}\n          x={midX - paddingX - textSize.width / 2 - iconSpace / 2 - (typeIconClass ? 10 : 0)}\n          width={textSize.width + paddingX * 2 + iconSpace + (typeIconClass ? 10 : 0)}\n          y={y - paddingY - textSize.height / 2}\n          height={textSize.height + paddingY * 2}\n          rx={cornerRadius}\n          ry={cornerRadius}\n        />\n      )}\n      {textSize && kind && (\n        <SvgResourceIcon\n          ref={iconRef}\n          x={midX - textSize.width / 2 - paddingX / 2}\n          y={y}\n          kind={kind}\n        />\n      )}\n      {textSize && iconSize && typeIconClass && (\n        <SvgCircledIcon\n          x={midX - (textSize.width + iconSpace) / 2 - paddingX}\n          y={y - iconSize.height + paddingY * 1.5}\n          width={iconSize.height + paddingY}\n          height={iconSize.height + paddingY}\n          iconClass={typeIconClass}\n          padding={typeIconPadding}\n        />\n      )}\n      <text\n        {...other}\n        ref={textRef}\n        x={midX + iconSpace / 2}\n        y={y}\n        textAnchor=\"middle\"\n        dy=\"0.35em\"\n        onMouseEnter={onMouseEnter}\n        onMouseLeave={onMouseLeave}\n      >\n        {truncate > 0\n          ? labelHover\n            ? children\n            : truncateMiddle(children, { length: truncate })\n          : children}\n      </text>\n    </g>\n  );\n};\n\nexport default SvgBoxedText;\n","import * as React from 'react';\nimport { useSize, createSvgIdUrl } from '@console/topology';\nimport { isIconUrl } from '@console/shared/';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport SvgDropShadowFilter from './SvgDropShadowFilter';\n\ninterface SvgTypedIconProps {\n  className?: string;\n  x: number;\n  y: number;\n  width: number;\n  height: number;\n  padding?: number;\n  iconClass: string;\n}\n\nconst FILTER_ID = 'SvgTypedIconDropShadowFilterId';\n\nexport const CircledIcon: React.FC<SvgTypedIconProps> = (\n  { className, x, y, width, height, iconClass, padding = 4 },\n  circleRef,\n) => {\n  const [typedIconSize, typedIconRef] = useSize([]);\n\n  let iconWidth = 0;\n  let iconHeight = 0;\n\n  if (typedIconSize) {\n    ({ width: iconWidth, height: iconHeight } = typedIconSize);\n  }\n\n  return (\n    <g className={className}>\n      <SvgDropShadowFilter id={FILTER_ID} />\n      <circle\n        ref={circleRef}\n        filter={createSvgIdUrl(FILTER_ID)}\n        cx={x - iconWidth / 2}\n        cy={y + iconHeight / 2}\n        r={iconWidth / 2 + padding}\n      />\n      <g ref={typedIconRef}>\n        <image\n          x={x - iconWidth}\n          y={y}\n          width={width}\n          height={height}\n          xlinkHref={isIconUrl(iconClass) ? iconClass : getImageForIconClass(iconClass)}\n          filter={createSvgIdUrl(FILTER_ID)}\n        />\n      </g>\n    </g>\n  );\n};\n\nexport default React.forwardRef(CircledIcon);\n","import * as React from 'react';\nimport { SVGDefs } from '@console/topology';\n\nexport interface SvgDropShadowFilterProps {\n  // The unique ID that identifies the filter.\n  // It is also used to uniquely identify the def entry to prevent duplicates.\n  id: string;\n  dx?: number;\n  dy?: number;\n  stdDeviation?: number;\n  floodOpacity?: number;\n  floodColor?: string;\n}\n\nconst SvgDropShadowFilter: React.FC<SvgDropShadowFilterProps> = ({\n  id,\n  dx = 0,\n  dy = 1,\n  stdDeviation = 2,\n  floodColor = '#030303',\n  floodOpacity = 0.2,\n}) => {\n  if (window.navigator.userAgent.includes('Edge')) {\n    // feDropShadow is not supported by Edge\n    return (\n      <SVGDefs id={id}>\n        <filter\n          id={id}\n          x={`-${stdDeviation * 12.5}%`}\n          y={`-${stdDeviation * 12.5}%`}\n          width={`${100 + stdDeviation * 25}%`}\n          height={`${100 + stdDeviation * 25}%`}\n        >\n          <feGaussianBlur in=\"SourceAlpha\" stdDeviation={stdDeviation} />\n          <feOffset dx={dx} dy={dy} result=\"offsetblur\" />\n          <feFlood floodColor={floodColor} floodOpacity={floodOpacity} />\n          <feComposite in2=\"offsetblur\" operator=\"in\" />\n          <feMerge>\n            <feMergeNode />\n            <feMergeNode in=\"SourceGraphic\" />\n          </feMerge>\n        </filter>\n      </SVGDefs>\n    );\n  }\n\n  return (\n    <SVGDefs id={id}>\n      <filter\n        id={id}\n        x={`-${stdDeviation * 12.5}%`}\n        y={`-${stdDeviation * 12.5}%`}\n        width={`${100 + stdDeviation * 25}%`}\n        height={`${100 + stdDeviation * 25}%`}\n      >\n        <feDropShadow\n          dx={dx}\n          dy={dy}\n          stdDeviation={stdDeviation}\n          floodColor={floodColor}\n          floodOpacity={floodOpacity}\n        />\n      </filter>\n    </SVGDefs>\n  );\n};\n\nexport default SvgDropShadowFilter;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport cx from 'classnames';\nimport { get } from 'lodash';\nimport { useSize } from '@console/topology';\nimport { modelFor, kindToAbbr } from '@console/internal/module/k8s';\nimport './SvgResourceIcon.scss';\n\ninterface ResourceIconProps {\n  x: number;\n  y: number;\n  kind: string;\n  leftJustified?: boolean;\n}\n\nfunction getKindStringAndAbbreviation(kind: string) {\n  const kindObj = modelFor(kind);\n  const kindStr = get(kindObj, 'kind', kind);\n  const kindColor = get(kindObj, 'color', undefined);\n  const kindAbbr = (kindObj && kindObj.abbr) || kindToAbbr(kindStr);\n  return { kindStr, kindAbbr, kindColor };\n}\n\nconst ForwardSvgResourceIcon: React.FC<ResourceIconProps> = (\n  { kind, x, y, leftJustified },\n  iconRef,\n) => {\n  const { kindAbbr, kindStr, kindColor } = getKindStringAndAbbreviation(kind);\n  const [textSize, textRef] = useSize([]);\n\n  let rect = null;\n  let paddingX = 0;\n  let paddingY = 0;\n  let width = 0;\n  let height = 0;\n\n  if (textSize) {\n    ({ height, width } = textSize);\n    paddingX = height / 2;\n    paddingY = height / 14;\n    height += paddingY * 2;\n    rect = (\n      <rect\n        fill={kindColor}\n        ref={iconRef}\n        x={x - (leftJustified ? 0 : paddingX + width / 2)}\n        width={textSize.width + paddingX * 2}\n        y={y - (leftJustified ? 0 : paddingY + textSize.height / 2)}\n        height={height}\n        rx={height / 2}\n        ry={height / 2}\n      />\n    );\n  }\n\n  return (\n    <g\n      className={cx('odc-resource-icon', {\n        [`odc-resource-icon-${kindStr.toLowerCase()}`]: !kindColor,\n      })}\n    >\n      {rect}\n      <title>{kindStr}</title>\n      <text\n        ref={textRef}\n        x={x + (leftJustified ? paddingX + width / 2 : 0)}\n        y={y + (leftJustified ? (paddingY + height) / 2 : 0)}\n        textAnchor=\"middle\"\n        dy=\"0.35em\"\n      >\n        {kindAbbr}\n      </text>\n    </g>\n  );\n};\n\nconst SvgResourceIcon = React.forwardRef(ForwardSvgResourceIcon);\nexport { SvgResourceIcon, getKindStringAndAbbreviation };\n","import * as _ from 'lodash';\nimport { Node } from '@console/topology';\nimport { ServiceModel, addEventSource } from '@console/knative-plugin';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { addResourceMenu, addResourceMenuWithoutCatalog } from '../../../actions/add-resources';\nimport { GraphData } from '../topology-types';\n\nexport const graphActions = (graphData: GraphData, connectorSource?: Node) => {\n  let resourceMenu = connectorSource ? addResourceMenuWithoutCatalog : addResourceMenu;\n  const isKnativeService =\n    connectorSource?.getData()?.data?.kind === referenceForModel(ServiceModel);\n  if (isKnativeService && graphData.eventSourceEnabled) {\n    resourceMenu = [...addResourceMenuWithoutCatalog, addEventSource];\n  }\n  return _.reduce(\n    resourceMenu,\n    (menuItems, menuItem) => {\n      const item = menuItem(\n        null,\n        graphData.namespace,\n        false,\n        connectorSource?.getData()?.resources?.obj,\n        graphData.createResourceAccess,\n      );\n      if (item) {\n        menuItems.push(item);\n      }\n      return menuItems;\n    },\n    [],\n  );\n};\n","import * as _ from 'lodash';\nimport { KebabOption } from '@console/internal/components/utils/kebab';\nimport { modelFor, referenceFor, referenceForModel } from '@console/internal/module/k8s';\nimport { Node } from '@console/topology';\nimport { asAccessReview } from '@console/internal/components/utils';\nimport { ServiceModel, addEventSource } from '@console/knative-plugin';\nimport { addResourceMenuWithoutCatalog } from '../../../actions/add-resources';\nimport { TopologyDataMap, TopologyApplicationObject, GraphData } from '../topology-types';\nimport { getTopologyResourceObject } from '../topology-utils';\nimport { deleteResourceModal } from '../../modals';\nimport { cleanUpWorkload } from '../../../utils/application-utils';\n\nexport const getGroupComponents = (\n  groupId: string,\n  topology: TopologyDataMap,\n): TopologyApplicationObject => {\n  return _.values(topology).reduce(\n    (acc, val) => {\n      const dc = getTopologyResourceObject(val);\n      if (_.get(dc, ['metadata', 'labels', 'app.kubernetes.io/part-of']) === groupId) {\n        acc.resources.push(topology[dc.metadata.uid]);\n      }\n      return acc;\n    },\n    { id: groupId, name: groupId, resources: [] },\n  );\n};\n\nconst deleteGroup = (application: TopologyApplicationObject) => {\n  // accessReview needs a resource but group is not a k8s resource,\n  // so currently picking the first resource to do the rbac checks (might change in future)\n  const primaryResource = _.get(application.resources[0], ['resources', 'obj']);\n  const resourceModel = modelFor(primaryResource.kind)\n    ? modelFor(primaryResource.kind)\n    : modelFor(referenceFor(primaryResource));\n  return {\n    label: 'Delete Application',\n    callback: () => {\n      const reqs = [];\n      deleteResourceModal({\n        blocking: true,\n        resourceName: application.name,\n        resourceType: 'Application',\n        onSubmit: () => {\n          application.resources.forEach((workload) => {\n            const resource = _.get(workload, ['resources', 'obj']);\n            reqs.push(cleanUpWorkload(resource, workload));\n          });\n          return Promise.all(reqs);\n        },\n      });\n    },\n    accessReview: asAccessReview(resourceModel, primaryResource, 'delete'),\n  };\n};\n\nconst addResourcesMenu = (\n  graphData: GraphData,\n  application: TopologyApplicationObject,\n  connectorSource?: Node,\n) => {\n  const primaryResource = application.resources[0]?.resources?.obj;\n  const connectorSourceObj = connectorSource?.getData()?.resources?.obj || {};\n  const isKnativeService =\n    connectorSource?.getData()?.data?.kind === referenceForModel(ServiceModel);\n  let resourceMenu = addResourceMenuWithoutCatalog;\n  if (isKnativeService && graphData.eventSourceEnabled) {\n    resourceMenu = [...addResourceMenuWithoutCatalog, addEventSource];\n  }\n  return _.reduce(\n    resourceMenu,\n    (menuItems, menuItem) => {\n      const item = menuItem(\n        primaryResource,\n        application.resources[0]?.resources?.obj.metadata.namespace,\n        true,\n        connectorSourceObj,\n        graphData.createResourceAccess,\n      );\n      if (item) {\n        menuItems.push(item);\n      }\n      return menuItems;\n    },\n    [],\n  );\n};\n\nexport const groupActions = (\n  graphData: GraphData,\n  application: TopologyApplicationObject,\n  connectorSource?: Node,\n): KebabOption[] => {\n  const addItems = addResourcesMenu(graphData, application, connectorSource);\n  return !connectorSource ? [deleteGroup(application), ...addItems] : addItems;\n};\n","import * as _ from 'lodash';\nimport { Kebab, KebabOption } from '@console/internal/components/utils';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { TopologyDataObject } from '../topology-types';\nimport { getTopologyResourceObject } from '../topology-utils';\n\nexport const nodeActions = (node: TopologyDataObject): KebabOption[] => {\n  const contextMenuResource = getTopologyResourceObject(node);\n  if (!contextMenuResource) {\n    return null;\n  }\n  const resourceKind = modelFor(referenceFor(contextMenuResource));\n  const menuActions = [...Kebab.getExtensionsActionsForKind(resourceKind), ...Kebab.factory.common];\n\n  return _.map(menuActions, (a) => a(resourceKind, contextMenuResource));\n};\n","import { KebabOption } from '@console/internal/components/utils/kebab';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { Node } from '@console/topology';\nimport { editApplicationModal, groupEditApplicationModal } from '../../modals';\n\nexport const regroupActions = (obj: Node, regroupChildren: boolean = false): KebabOption[] => {\n  if (regroupChildren) {\n    return [\n      {\n        label: 'Edit Application Grouping',\n        callback: () =>\n          groupEditApplicationModal({\n            group: obj,\n            blocking: true,\n          }),\n      },\n    ];\n  }\n  const resource = obj.getData()?.resources?.obj;\n  if (!resource) {\n    return [];\n  }\n  const resourceKind = modelFor(referenceFor(resource));\n  return [\n    {\n      label: 'Edit Application Grouping',\n      callback: () =>\n        editApplicationModal({\n          resourceKind,\n          resource,\n          blocking: true,\n        }),\n    },\n  ];\n};\n","import * as _ from 'lodash';\nimport { KebabAction, KebabOption } from '@console/internal/components/utils';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { menuActions as deploymentConfigMenuActions } from '@console/internal/components/deployment-config';\nimport { menuActions as deploymentMenuActions } from '@console/internal/components/deployment';\nimport { menuActions as statefulSetMenuActions } from '@console/internal/components/stateful-set';\nimport { menuActions as daemonSetMenuActions } from '@console/internal/components/daemon-set';\nimport { ModifyApplication } from '../../../actions/modify-application';\nimport { TopologyDataObject } from '../topology-types';\nimport { getTopologyResourceObject } from '../topology-utils';\n\nexport const workloadActions = (\n  workload: TopologyDataObject,\n  allowRegroup: boolean = true,\n): KebabOption[] => {\n  const contextMenuResource = getTopologyResourceObject(workload);\n  if (!contextMenuResource) {\n    return null;\n  }\n\n  const menuActions: KebabAction[] = [];\n  if (allowRegroup) {\n    menuActions.push(ModifyApplication);\n  }\n  switch (contextMenuResource.kind) {\n    case 'DeploymentConfig':\n      menuActions.push(...deploymentConfigMenuActions);\n      break;\n    case 'Deployment':\n      menuActions.push(...deploymentMenuActions);\n      break;\n    case 'StatefulSet':\n      menuActions.push(...statefulSetMenuActions);\n      break;\n    case 'DaemonSet':\n      menuActions.push(...daemonSetMenuActions);\n      break;\n    default:\n      break;\n  }\n\n  return _.map(menuActions, (a) =>\n    a(modelFor(referenceFor(contextMenuResource)), contextMenuResource),\n  );\n};\n","import { createConnectorCallback } from './componentUtils';\nimport { CreateConnector } from './edges';\nimport {\n  ComponentFactory as TopologyComponentFactory,\n  withCreateConnector,\n} from '@console/topology';\n\nabstract class AbstractSBRComponentFactory {\n  protected hasServiceBinding: boolean;\n\n  constructor(serviceBinding: boolean) {\n    this.hasServiceBinding = serviceBinding;\n  }\n\n  set serviceBinding(value: boolean) {\n    this.hasServiceBinding = value;\n  }\n\n  public withAddResourceConnector = () =>\n    withCreateConnector(createConnectorCallback(this.hasServiceBinding), CreateConnector);\n\n  abstract getFactory(): TopologyComponentFactory;\n}\n\nexport { AbstractSBRComponentFactory };\n","// extracted by mini-css-extract-plugin","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { GraphComponent as BaseGraphComponent, WithContextMenuProps } from '@console/topology';\n\ntype GraphComponentProps = React.ComponentProps<typeof BaseGraphComponent> & {\n  dragEditInProgress?: boolean;\n  hasDropTarget?: boolean;\n  dragCreate?: boolean;\n} & WithContextMenuProps;\n\nconst DRAG_ACTIVE_CLASS = 'odc-m-drag-active';\nconst VALID_DROP_CLASS = 'odc-m-valid-drop-target';\n\nconst GraphComponent: React.FC<GraphComponentProps> = (props) => {\n  const { dragEditInProgress, hasDropTarget, dragCreate } = props;\n  const graphClasses = classNames('odc-graph', { 'odc-m-drag-create': dragCreate });\n\n  React.useEffect(() => {\n    const addClassList = [];\n    const removeClassList = [];\n\n    dragEditInProgress\n      ? addClassList.push(DRAG_ACTIVE_CLASS)\n      : removeClassList.push(DRAG_ACTIVE_CLASS);\n    hasDropTarget ? addClassList.push(VALID_DROP_CLASS) : removeClassList.push(VALID_DROP_CLASS);\n\n    if (addClassList.length) {\n      addClassList.forEach((className) => document.body.classList.add(className));\n    }\n    if (removeClassList.length) {\n      removeClassList.forEach((className) => document.body.classList.remove(className));\n    }\n  }, [dragEditInProgress, hasDropTarget]);\n  return (\n    <g className={graphClasses}>\n      <BaseGraphComponent {...props} />\n    </g>\n  );\n};\n\nexport default GraphComponent;\n","import * as React from 'react';\nimport SvgDropShadowFilter from '../../svg/SvgDropShadowFilter';\n\nexport const NODE_SHADOW_FILTER_ID = 'NodeShadowsFilterId';\nexport const NODE_SHADOW_FILTER_ID_HOVER = 'NodeShadowsFilterId--hover';\n\nconst NodeShadows: React.FC = () => (\n  <>\n    <SvgDropShadowFilter id={NODE_SHADOW_FILTER_ID} />\n    <SvgDropShadowFilter\n      id={NODE_SHADOW_FILTER_ID_HOVER}\n      dy={3}\n      stdDeviation={7}\n      floodOpacity={0.24}\n    />\n  </>\n);\n\nexport { NodeShadows };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { InfoCircleIcon } from '@patternfly/react-icons';\nimport { ShortcutTable, Shortcut } from '@console/shared';\n\nimport './RegroupHint.scss';\n\nconst RegroupHint: React.FC = () => (\n  <div className=\"odc-regroup-hint\">\n    <InfoCircleIcon className=\"odc-regroup-hint__icon\" />\n    <span className=\"odc-regroup-hint__text\">\n      <ShortcutTable>\n        <Shortcut shift drag>\n          Edit application grouping\n        </Shortcut>\n      </ShortcutTable>\n    </span>\n  </div>\n);\n\nexport { RegroupHint };\n","import * as React from 'react';\nimport {\n  GraphElement,\n  ModelKind,\n  ComponentFactory as TopologyComponentFactory,\n  withPanZoom,\n  withDragNode,\n  withTargetDrag,\n  withSelection,\n  withDndDrop,\n  withRemoveConnector,\n} from '@console/topology';\nimport { Application } from './groups';\nimport { WorkloadNode } from './nodes';\nimport GraphComponent from './GraphComponent';\nimport { workloadContextMenu, groupContextMenu, graphContextMenu } from './nodeContextMenu';\nimport {\n  NodeComponentProps,\n  graphDropTargetSpec,\n  nodeDragSourceSpec,\n  nodeDropTargetSpec,\n  applicationGroupDropTargetSpec,\n  edgeDragSourceSpec,\n  removeConnectorCallback,\n  MOVE_CONNECTOR_DROP_TYPE,\n  withContextMenu,\n} from './componentUtils';\nimport './ContextMenu.scss';\nimport {\n  TYPE_WORKLOAD,\n  TYPE_CONNECTS_TO,\n  TYPE_APPLICATION_GROUP,\n  TYPE_AGGREGATE_EDGE,\n  TYPE_SERVICE_BINDING,\n  TYPE_TRAFFIC_CONNECTOR,\n} from './const';\nimport { createConnection } from './createConnection';\nimport { withEditReviewAccess } from './withEditReviewAccess';\nimport { AggregateEdge, ConnectsTo, ServiceBinding, TrafficConnector } from './edges';\nimport { AbstractSBRComponentFactory } from './AbstractSBRComponentFactory';\n\nclass ComponentFactory extends AbstractSBRComponentFactory {\n  getFactory = (): TopologyComponentFactory => {\n    return (kind, type): React.ComponentType<{ element: GraphElement }> | undefined => {\n      switch (type) {\n        case TYPE_APPLICATION_GROUP:\n          return withDndDrop(applicationGroupDropTargetSpec)(\n            withSelection(false, true)(withContextMenu(groupContextMenu)(Application)),\n          );\n        case TYPE_WORKLOAD:\n          return this.withAddResourceConnector()(\n            withDndDrop<\n              any,\n              any,\n              { droppable?: boolean; hover?: boolean; canDrop?: boolean },\n              NodeComponentProps\n            >(nodeDropTargetSpec)(\n              withEditReviewAccess('patch')(\n                withDragNode(nodeDragSourceSpec(type))(\n                  withSelection(false, true)(withContextMenu(workloadContextMenu)(WorkloadNode)),\n                ),\n              ),\n            ),\n          );\n        case TYPE_CONNECTS_TO:\n          return withTargetDrag(\n            edgeDragSourceSpec(MOVE_CONNECTOR_DROP_TYPE, this.serviceBinding, createConnection),\n          )(withRemoveConnector(removeConnectorCallback)(ConnectsTo));\n        case TYPE_SERVICE_BINDING:\n          return withRemoveConnector(removeConnectorCallback)(ServiceBinding);\n        case TYPE_AGGREGATE_EDGE:\n          return AggregateEdge;\n        case TYPE_TRAFFIC_CONNECTOR:\n          return TrafficConnector;\n        default:\n          switch (kind) {\n            case ModelKind.graph:\n              return withDndDrop(graphDropTargetSpec)(\n                withPanZoom()(\n                  withSelection(false, true)(withContextMenu(graphContextMenu)(GraphComponent)),\n                ),\n              );\n            default:\n              return undefined;\n          }\n      }\n    };\n  };\n}\n\nexport { ComponentFactory };\n","import * as React from 'react';\nimport { action } from 'mobx';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { errorModal } from '@console/internal/components/modals';\nimport {\n  Modifiers,\n  Edge,\n  GraphElement,\n  isEdge,\n  isNode,\n  Node,\n  Graph,\n  DragSourceSpec,\n  DragObjectWithType,\n  DropTargetSpec,\n  DropTargetMonitor,\n  DragSpecOperationType,\n  CREATE_CONNECTOR_DROP_TYPE,\n  CREATE_CONNECTOR_OPERATION,\n  withContextMenu as withTopologyContextMenu,\n  isGraph,\n  withDndDrop,\n} from '@console/topology';\nimport { createConnection } from './createConnection';\nimport { removeConnection } from './removeConnection';\nimport { moveNodeToGroup } from './moveNodeToGroup';\nimport { graphContextMenu, groupContextMenu } from './nodeContextMenu';\n\nimport './GraphComponent.scss';\n\nconst MOVE_CONNECTOR_DROP_TYPE = '#moveConnector#';\n\nconst NODE_DRAG_TYPE = '#node#';\nconst EDGE_DRAG_TYPE = '#edge#';\n\nconst MOVE_CONNECTOR_OPERATION = 'moveconnector';\nconst REGROUP_OPERATION = 'regroup';\n\ntype GraphComponentProps = {\n  element: Graph;\n};\n\ntype NodeComponentProps = {\n  element: Node;\n};\n\ntype EdgeComponentProps = {\n  element: Edge;\n};\n\n/**\n * type: the drag operation type\n * edit: true if the operation performs an edit, used to dim invalid drop targets\n * canDropOnNode: true if the drag object can be dropped on node, used to highlight valid drop nodes\n */\ntype EditableDragOperationType = {\n  type: string;\n  edit?: boolean;\n  canDropOnNode?: (operationType: string, dragElement: GraphElement, node: Node) => boolean;\n};\n\ntype DragNodeObject = {\n  element: GraphElement;\n  allowRegroup: boolean;\n};\n\nconst canDropEdgeOnNode = (operation: string, edge: Edge, node: Node): boolean => {\n  if (edge.getSource() === node) {\n    return false;\n  }\n\n  if (edge.getTarget() === node) {\n    return true;\n  }\n\n  return !node.getTargetEdges().find((e) => e.getSource() === edge.getSource());\n};\n\nconst highlightNode = (monitor: DropTargetMonitor, element: Node): boolean => {\n  const operation = monitor.getOperation() as EditableDragOperationType;\n  if (!monitor.isDragging() || !operation) {\n    return false;\n  }\n\n  if (operation.type === CREATE_CONNECTOR_OPERATION) {\n    return (\n      monitor.getItem() !== element &&\n      !monitor\n        .getItem()\n        .getSourceEdges()\n        .find((e) => e.getTarget() === element)\n    );\n  }\n\n  return (\n    operation.canDropOnNode && operation.canDropOnNode(operation.type, monitor.getItem(), element)\n  );\n};\n\nconst nodeDragSourceSpec = (\n  type: string,\n  allowRegroup: boolean = true,\n  canEdit: boolean = false,\n): DragSourceSpec<\n  DragObjectWithType,\n  DragSpecOperationType<EditableDragOperationType>,\n  Node,\n  {\n    dragging?: boolean;\n    regrouping?: boolean;\n  },\n  NodeComponentProps & { canEdit?: boolean }\n> => ({\n  item: { type: NODE_DRAG_TYPE },\n  operation: (monitor, props) => {\n    return (canEdit || props.canEdit) && allowRegroup\n      ? {\n          [Modifiers.SHIFT]: { type: REGROUP_OPERATION, edit: true },\n        }\n      : undefined;\n  },\n  canCancel: (monitor) => monitor.getOperation()?.type === REGROUP_OPERATION,\n  begin: (monitor, props): DragNodeObject => {\n    return {\n      element: props.element,\n      allowRegroup: (canEdit || props.canEdit) && allowRegroup,\n    };\n  },\n  end: async (dropResult, monitor, props) => {\n    if (!monitor.isCancelled() && monitor.getOperation()?.type === REGROUP_OPERATION) {\n      if (monitor.didDrop() && dropResult && props && props.element.getParent() !== dropResult) {\n        const controller = props.element.getController();\n        await moveNodeToGroup(props.element, isNode(dropResult) ? dropResult : null);\n\n        // perform the optimistic update in an action so as not to render too soon\n        action(() => {\n          // FIXME: check shouldn't be necessary if we handled the async and backend data refresh correctly\n          if (controller.getNodeById(props.element.getId())) {\n            dropResult.appendChild(props.element);\n          }\n        })();\n      } else {\n        // cancel operation\n        return Promise.reject();\n      }\n    }\n    return undefined;\n  },\n  collect: (monitor) => ({\n    dragging: monitor.isDragging(),\n    regrouping: monitor.getOperation()?.type === REGROUP_OPERATION,\n  }),\n});\n\nconst nodesEdgeIsDragging = (monitor, props) => {\n  if (!monitor.isDragging()) {\n    return false;\n  }\n  if (monitor.getOperation() === MOVE_CONNECTOR_OPERATION) {\n    return monitor.getItem().getSource() === props.element;\n  }\n  if (monitor.getOperation() === CREATE_CONNECTOR_OPERATION) {\n    return monitor.getItem() === props.element;\n  }\n  return false;\n};\n\nconst nodeDropTargetSpec: DropTargetSpec<\n  GraphElement,\n  any,\n  { canDrop: boolean; dropTarget: boolean; edgeDragging: boolean },\n  NodeComponentProps\n> = {\n  accept: [EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: (item, monitor, props) => {\n    if (isEdge(item)) {\n      return canDropEdgeOnNode(monitor.getOperation()?.type, item, props.element);\n    }\n    if (item === props.element) {\n      return false;\n    }\n    return !props.element.getTargetEdges().find((e) => e.getSource() === item);\n  },\n  collect: (monitor, props) => ({\n    canDrop: highlightNode(monitor, props.element),\n    dropTarget: monitor.isOver({ shallow: true }),\n    edgeDragging: nodesEdgeIsDragging(monitor, props),\n  }),\n};\n\nconst graphDropTargetSpec: DropTargetSpec<\n  DragNodeObject,\n  any,\n  { dragEditInProgress: boolean },\n  GraphComponentProps\n> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  hitTest: () => true,\n  canDrop: (item, monitor, props) => {\n    return (\n      monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) &&\n      ((monitor.getOperation()?.type === REGROUP_OPERATION &&\n        // FIXME: the hasParent check is necessary due to model updates during async actions\n        item.element.hasParent() &&\n        item.element.getParent() !== props.element) ||\n        monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE)\n    );\n  },\n  collect: (monitor) => {\n    const operation = monitor.getOperation() as EditableDragOperationType;\n    const dragEditInProgress =\n      monitor.isDragging() && (operation?.type === CREATE_CONNECTOR_OPERATION || operation?.edit);\n    const dragCreate =\n      dragEditInProgress &&\n      (monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE ||\n        monitor.getItemType() === MOVE_CONNECTOR_DROP_TYPE);\n    return {\n      dragEditInProgress,\n      dragCreate,\n      hasDropTarget: dragEditInProgress && monitor.hasDropTarget(),\n    };\n  },\n  dropHint: 'create',\n};\n\nconst applicationGroupDropTargetSpec: DropTargetSpec<\n  any,\n  any,\n  { droppable: boolean; dropTarget: boolean; canDrop: boolean },\n  any\n> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: (item, monitor) =>\n    monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) &&\n    (monitor.getOperation()?.type === REGROUP_OPERATION ||\n      monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n  collect: (monitor) => {\n    return {\n      droppable: monitor.isDragging() && monitor.getOperation()?.type === REGROUP_OPERATION,\n      dropTarget: monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }),\n      canDrop:\n        monitor.isDragging() &&\n        (monitor.getOperation()?.type === REGROUP_OPERATION ||\n          monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n      dragRegroupable: monitor.isDragging() && monitor.getItem()?.allowRegroup,\n    };\n  },\n  dropHint: 'create',\n};\n\nconst edgeDragSourceSpec = (\n  type: string,\n  serviceBinding: boolean,\n  callback: (\n    sourceNode: Node,\n    targetNode: Node,\n    replaceTargetNode?: Node,\n    serviceBindingFlag?: boolean,\n  ) => Promise<K8sResourceKind[] | K8sResourceKind>,\n  failureTitle: string = 'Error moving connection',\n): DragSourceSpec<\n  DragObjectWithType,\n  DragSpecOperationType<EditableDragOperationType>,\n  Node,\n  { dragging: boolean },\n  EdgeComponentProps\n> => ({\n  item: { type: EDGE_DRAG_TYPE },\n  operation: { type: MOVE_CONNECTOR_OPERATION, edit: true, canDropOnNode: canDropEdgeOnNode },\n  begin: (monitor, props) => {\n    props.element.raise();\n    return props.element;\n  },\n  drag: (event, monitor, props) => {\n    props.element.setEndPoint(event.x, event.y);\n  },\n  end: (dropResult, monitor, props) => {\n    props.element.setEndPoint();\n    if (\n      monitor.didDrop() &&\n      dropResult &&\n      canDropEdgeOnNode(monitor.getOperation()?.type, props.element, dropResult)\n    ) {\n      callback(\n        props.element.getSource(),\n        dropResult,\n        props.element.getTarget(),\n        serviceBinding,\n      ).catch((error) => {\n        errorModal({ title: failureTitle, error: error.message, showIcon: true });\n      });\n    }\n  },\n  collect: (monitor) => ({\n    dragging: monitor.isDragging(),\n  }),\n});\n\nconst noDropTargetSpec: DropTargetSpec<GraphElement, any, {}, { element: GraphElement }> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: () => {\n    return false;\n  },\n};\n\nconst withNoDrop = () => {\n  return withDndDrop<any, any, {}, NodeComponentProps>(noDropTargetSpec);\n};\n\nconst withContextMenu = <E extends GraphElement>(actions: (element: E) => React.ReactElement[]) => {\n  return withTopologyContextMenu(\n    actions,\n    document.getElementById('popper-container'),\n    'odc-topology-context-menu',\n  );\n};\n\nconst createConnectorCallback = (serviceBinding: boolean) => (\n  source: Node,\n  target: Node | Graph,\n): React.ReactElement[] | null => {\n  if (source === target) {\n    return null;\n  }\n\n  if (isGraph(target)) {\n    return graphContextMenu(target, source);\n  }\n  if (target.isGroup()) {\n    return groupContextMenu(target, source);\n  }\n  createConnection(source, target, null, serviceBinding).catch((error) => {\n    errorModal({ title: 'Error creating connection', error: error.message });\n  });\n  return null;\n};\n\nconst removeConnectorCallback = (edge: Edge): void => {\n  removeConnection(edge).catch((error) => {\n    errorModal({ title: 'Error removing connection', error: error.message });\n  });\n  return null;\n};\n\nexport {\n  GraphComponentProps,\n  NodeComponentProps,\n  EdgeComponentProps,\n  EditableDragOperationType,\n  DragNodeObject,\n  nodesEdgeIsDragging,\n  nodeDragSourceSpec,\n  nodeDropTargetSpec,\n  graphDropTargetSpec,\n  applicationGroupDropTargetSpec,\n  edgeDragSourceSpec,\n  noDropTargetSpec,\n  createConnectorCallback,\n  removeConnectorCallback,\n  REGROUP_OPERATION,\n  MOVE_CONNECTOR_DROP_TYPE,\n  NODE_DRAG_TYPE,\n  EDGE_DRAG_TYPE,\n  withNoDrop,\n  withContextMenu,\n};\n","import { STORAGE_PREFIX } from '@console/shared';\n\nexport const TYPE_WORKLOAD = 'workload';\nexport const TYPE_CONNECTS_TO = 'connects-to';\nexport const TYPE_AGGREGATE_EDGE = 'aggregate-edge';\nexport const TYPE_SERVICE_BINDING = 'service-binding';\nexport const TYPE_APPLICATION_GROUP = 'part-of';\nexport const TYPE_TRAFFIC_CONNECTOR = 'traffic-connector';\nexport const LAST_TOPOLOGY_VIEW_LOCAL_STORAGE_KEY = `${STORAGE_PREFIX}/last-topology-view`;\n\nexport const DEFAULT_NODE_PAD = 20;\nexport const DEFAULT_GROUP_PAD = 40;\n\nexport const NODE_WIDTH = 104;\nexport const NODE_HEIGHT = 104;\nexport const NODE_PADDING = [0, DEFAULT_NODE_PAD];\n\nexport const GROUP_WIDTH = 300;\nexport const GROUP_HEIGHT = 180;\nexport const GROUP_PADDING = [DEFAULT_GROUP_PAD];\n","import { Node } from '@console/topology';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { createTopologyResourceConnection } from '../topology-utils';\n\nexport const createConnection = (\n  sourceNode: Node,\n  targetNode: Node,\n  replaceTargetNode: Node = null,\n  serviceBindingFlag: boolean = false,\n): Promise<K8sResourceKind[] | K8sResourceKind> => {\n  return createTopologyResourceConnection(\n    sourceNode.getData(),\n    targetNode.getData(),\n    replaceTargetNode ? replaceTargetNode.getData() : null,\n    serviceBindingFlag,\n  );\n};\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { Edge, Layer, useHover, EdgeConnectorArrow, observer } from '@console/topology';\n\nimport './AggregateEdge.scss';\n\ntype AggregateEdgeProps = {\n  element: Edge;\n};\n\nconst ObservedAggregateEdge: React.FC<AggregateEdgeProps> = ({ element }) => {\n  const [hover, hoverRef] = useHover();\n  const startPoint = element.getStartPoint();\n  const endPoint = element.getEndPoint();\n  const { bidirectional } = element.getData();\n\n  return (\n    <Layer id={hover ? 'top' : undefined}>\n      <g\n        ref={hoverRef}\n        data-test-id=\"edge-handler\"\n        className={classNames('odc-base-edge odc-aggregate-edge', {\n          'is-hover': hover,\n        })}\n      >\n        <line\n          x1={startPoint.x}\n          y1={startPoint.y}\n          x2={endPoint.x}\n          y2={endPoint.y}\n          strokeWidth={10}\n          stroke=\"transparent\"\n        />\n        <line\n          className=\"odc-base-edge__link\"\n          x1={startPoint.x}\n          y1={startPoint.y}\n          x2={endPoint.x}\n          y2={endPoint.y}\n        />\n        {!bidirectional &&\n          (!element.getSource().isCollapsed() || !element.getTarget().isCollapsed()) && (\n            <EdgeConnectorArrow edge={element} />\n          )}\n      </g>\n    </Layer>\n  );\n};\n\nconst AggregateEdge = observer(ObservedAggregateEdge);\nexport { AggregateEdge };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { referenceFor, modelFor } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport {\n  Layer,\n  Edge,\n  WithRemoveConnectorProps,\n  observer,\n  useHover,\n  useSelection,\n} from '@console/topology';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport './BaseEdge.scss';\n\ntype BaseEdgeProps = {\n  element: Edge;\n  dragging?: boolean;\n  className?: string;\n} & WithRemoveConnectorProps;\n\nconst ObservedBaseEdge: React.FC<BaseEdgeProps> = ({\n  element,\n  dragging,\n  onShowRemoveConnector,\n  onHideRemoveConnector,\n  children,\n  className,\n}) => {\n  const [hover, hoverRef] = useHover();\n  const [selected, onSelect] = useSelection(false, true);\n  const startPoint = element.getStartPoint();\n  const endPoint = element.getEndPoint();\n  const resourceObj = getTopologyResourceObject(element.getSource().getData());\n  const resourceModel = resourceObj && modelFor(referenceFor(resourceObj));\n\n  const editAccess = useAccessReview({\n    group: resourceModel?.apiGroup,\n    verb: 'patch',\n    resource: resourceModel?.plural,\n    name: resourceObj?.metadata.name,\n    namespace: resourceObj?.metadata.namespace,\n  });\n\n  React.useLayoutEffect(() => {\n    if (editAccess) {\n      if (hover && !dragging) {\n        onShowRemoveConnector && onShowRemoveConnector();\n      } else {\n        onHideRemoveConnector && onHideRemoveConnector();\n      }\n    }\n  }, [hover, dragging, onShowRemoveConnector, onHideRemoveConnector, editAccess]);\n\n  return (\n    <Layer id={dragging || hover ? 'top' : undefined}>\n      <g\n        ref={hoverRef}\n        data-test-id=\"edge-handler\"\n        className={classNames(className, 'odc-base-edge', {\n          'is-dragging': dragging,\n          'is-hover': hover,\n          'is-selected': selected,\n        })}\n        onClick={onSelect}\n      >\n        <line\n          x1={startPoint.x}\n          y1={startPoint.y}\n          x2={endPoint.x}\n          y2={endPoint.y}\n          strokeWidth={10}\n          stroke=\"transparent\"\n        />\n        <line\n          className=\"odc-base-edge__link\"\n          x1={startPoint.x}\n          y1={startPoint.y}\n          x2={endPoint.x}\n          y2={endPoint.y}\n        />\n        {children}\n      </g>\n    </Layer>\n  );\n};\n\nconst BaseEdge = observer(ObservedBaseEdge);\nexport { BaseEdge };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport {\n  WithSourceDragProps,\n  WithTargetDragProps,\n  WithRemoveConnectorProps,\n  Edge,\n  observer,\n  EdgeConnectorArrow,\n} from '@console/topology';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { BaseEdge } from './BaseEdge';\nimport './ConnectsTo.scss';\n\ntype ConnectsToProps = {\n  element: Edge;\n  dragging?: boolean;\n} & WithSourceDragProps &\n  WithTargetDragProps &\n  WithRemoveConnectorProps;\n\nconst ObservedConnectsTo: React.FC<ConnectsToProps> = ({\n  element,\n  targetDragRef,\n  children,\n  ...others\n}) => {\n  const childEdges = element.getChildren();\n  const sourceData =\n    childEdges?.length > 0\n      ? (childEdges[0] as Edge).getSource().getData()\n      : element.getSource().getData();\n  const resourceObj = getTopologyResourceObject(sourceData);\n  const resourceModel = modelFor(referenceFor(resourceObj));\n  const editAccess = useAccessReview({\n    group: resourceModel.apiGroup,\n    verb: 'patch',\n    resource: resourceModel.plural,\n    name: resourceObj.metadata.name,\n    namespace: resourceObj.metadata.namespace,\n  });\n  const edgeClasses = classNames('odc-connects-to', { 'odc-m-editable': editAccess });\n\n  return (\n    <BaseEdge className={edgeClasses} element={element} {...others}>\n      <EdgeConnectorArrow dragRef={editAccess ? targetDragRef : undefined} edge={element} />\n      {children}\n    </BaseEdge>\n  );\n};\n\nconst ConnectsTo = observer(ObservedConnectsTo);\nexport { ConnectsTo };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport { DefaultCreateConnector, Point } from '@console/topology';\n\nimport './CreateConnector.scss';\n\ntype CreateConnectorProps = {\n  startPoint: Point;\n  endPoint: Point;\n  hints: string[];\n  dragging?: boolean;\n};\n\nconst CreateConnector: React.FC<CreateConnectorProps> = ({\n  startPoint,\n  endPoint,\n  dragging,\n  hints,\n}) => {\n  const [hover, setHover] = React.useState(false);\n  const unsetHandle = React.useRef<number>();\n\n  React.useEffect(() => {\n    setHover(false);\n    clearTimeout(unsetHandle.current);\n    unsetHandle.current = window.setTimeout(() => {\n      setHover(dragging);\n    }, 2000);\n    return () => {\n      clearTimeout(unsetHandle.current);\n    };\n  }, [endPoint.x, endPoint.y, dragging]);\n\n  const classes = classNames('odc-create-connector', { 'is-dragging': dragging });\n  return (\n    <DefaultCreateConnector\n      className={classes}\n      startPoint={startPoint}\n      endPoint={endPoint}\n      dragging={dragging}\n      hints={hints}\n      tipContents={hover && dragging ? 'Add Resources' : null}\n    />\n  );\n};\n\nexport { CreateConnector };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport {\n  WithSourceDragProps,\n  WithTargetDragProps,\n  WithRemoveConnectorProps,\n  Edge,\n  observer,\n  EdgeConnectorArrow,\n} from '@console/topology';\nimport { BaseEdge } from './BaseEdge';\nimport './ServiceBinding.scss';\n\ntype ServiceBindingProps = {\n  element: Edge;\n  dragging?: boolean;\n} & WithSourceDragProps &\n  WithTargetDragProps &\n  WithRemoveConnectorProps;\n\nconst ObservedServiceBinding: React.FC<ServiceBindingProps> = ({\n  element,\n  targetDragRef,\n  children,\n  ...others\n}) => (\n  <BaseEdge element={element} {...others} className=\"odc-service-binding\">\n    <EdgeConnectorArrow dragRef={targetDragRef} edge={element} />\n    {children}\n  </BaseEdge>\n);\n\nconst ServiceBinding = observer(ObservedServiceBinding);\nexport { ServiceBinding };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Edge, EdgeConnectorArrow } from '@console/topology';\nimport { BaseEdge } from './BaseEdge';\nimport './TrafficConnector.scss';\n\ntype TrafficConnectorProps = {\n  element: Edge;\n};\n\nconst TrafficConnector: React.FC<TrafficConnectorProps> = ({ element }) => (\n  <BaseEdge element={element} className=\"odc-traffic-connector\">\n    <EdgeConnectorArrow edge={element} />\n  </BaseEdge>\n);\n\nexport { TrafficConnector };\n","export * from './BaseEdge';\nexport * from './AggregateEdge';\nexport * from './ConnectsTo';\nexport * from './CreateConnector';\nexport * from './ServiceBinding';\nexport * from './TrafficConnector';\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport {\n  Node,\n  observer,\n  WithDndDropProps,\n  WithSelectionProps,\n  WithContextMenuProps,\n} from '@console/topology';\nimport { SHOW_GROUPING_HINT_EVENT } from '../../topology-types';\nimport { RegroupHint } from '../RegroupHint';\nimport ApplicationNode from './ApplicationNode';\nimport ApplicationGroup from './ApplicationGroup';\n\nimport './Application.scss';\n\ntype ApplicationProps = {\n  element: Node;\n  droppable?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n  dragRegroupable?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\nconst ObservedApplication: React.FC<ApplicationProps> = ({\n  element,\n  selected,\n  onSelect,\n  dndDropRef,\n  droppable,\n  canDrop,\n  dropTarget,\n  dragRegroupable,\n  onContextMenu,\n  contextMenuOpen,\n  dragging,\n}) => {\n  const needsHintRef = React.useRef<boolean>(false);\n  React.useEffect(() => {\n    const needsHint = dropTarget && !canDrop && dragRegroupable;\n    if (needsHint !== needsHintRef.current) {\n      needsHintRef.current = needsHint;\n      element\n        .getController()\n        .fireEvent(SHOW_GROUPING_HINT_EVENT, element, needsHint ? <RegroupHint /> : null);\n    }\n  }, [dropTarget, canDrop, element, dragRegroupable]);\n\n  if (element.isCollapsed()) {\n    return (\n      <ApplicationNode\n        element={element}\n        selected={selected}\n        onSelect={onSelect}\n        dndDropRef={dndDropRef}\n        canDrop={canDrop}\n        dropTarget={dropTarget}\n        onContextMenu={onContextMenu}\n        contextMenuOpen={contextMenuOpen}\n        dragging={dragging}\n      />\n    );\n  }\n\n  return (\n    <ApplicationGroup\n      element={element}\n      selected={selected}\n      onSelect={onSelect}\n      dndDropRef={dndDropRef}\n      canDrop={canDrop}\n      dropTarget={dropTarget}\n      droppable={droppable}\n      onContextMenu={onContextMenu}\n      contextMenuOpen={contextMenuOpen}\n      dragging={dragging}\n    />\n  );\n};\n\nconst Application = observer(ObservedApplication);\nexport { Application };\n","import * as React from 'react';\nimport { polygonHull } from 'd3-polygon';\nimport * as _ from 'lodash';\nimport {\n  Layer,\n  Node,\n  PointTuple,\n  NodeShape,\n  NodeStyle,\n  maxPadding,\n  observer,\n  useCombineRefs,\n  useHover,\n  useDragNode,\n  WithDndDropProps,\n  WithSelectionProps,\n  WithContextMenuProps,\n  createSvgIdUrl,\n  hullPath,\n} from '@console/topology';\nimport * as classNames from 'classnames';\nimport { useDisplayFilters, useSearchFilter } from '../../filters';\nimport SvgBoxedText from '../../../svg/SvgBoxedText';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID, NODE_SHADOW_FILTER_ID_HOVER } from '../NodeShadows';\n\ntype ApplicationGroupProps = {\n  element: Node;\n  droppable?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\ntype PointWithSize = [number, number, number];\n\n// Return the point whose Y is the largest value.\n// If multiple points are found, compute the center X between them\n// export for testing only\nexport function computeLabelLocation(points: PointWithSize[]): PointWithSize {\n  let lowPoints: PointWithSize[];\n  const threshold = 5;\n\n  _.forEach(points, (p) => {\n    const delta = !lowPoints ? Infinity : Math.round(p[1]) - Math.round(lowPoints[0][1]);\n    if (delta > threshold) {\n      lowPoints = [p];\n    } else if (Math.abs(delta) <= threshold) {\n      lowPoints.push(p);\n    }\n  });\n  return [\n    (_.minBy(lowPoints, (p) => p[0])[0] + _.maxBy(lowPoints, (p) => p[0])[0]) / 2,\n    lowPoints[0][1],\n    // use the max size value\n    _.maxBy(lowPoints, (p) => p[2])[2],\n  ];\n}\n\nconst ApplicationGroup: React.FC<ApplicationGroupProps> = ({\n  element,\n  selected,\n  onSelect,\n  dndDropRef,\n  droppable,\n  canDrop,\n  dropTarget,\n  onContextMenu,\n  contextMenuOpen,\n  dragging,\n}) => {\n  const [hover, hoverRef] = useHover();\n  const [labelHover, labelHoverRef] = useHover();\n  const labelLocation = React.useRef<PointWithSize>();\n  const pathRef = React.useRef<string>();\n  const dragNodeRef = useDragNode()[1];\n  const dragLabelRef = useDragNode()[1];\n  const refs = useCombineRefs<SVGPathElement>(hoverRef, dragNodeRef);\n  const [filtered] = useSearchFilter(element.getLabel());\n  const displayFilters = useDisplayFilters();\n  const showLabels = displayFilters.showLabels || hover;\n\n  // cast to number and coerce\n  const padding = maxPadding(element.getStyle<NodeStyle>().padding);\n  const hullPadding = (point: PointWithSize | PointTuple) => (point[2] || 0) + padding;\n\n  if (!droppable || !pathRef.current || !labelLocation.current) {\n    const children = element.getNodes().filter((c) => c.isVisible());\n    if (children.length === 0) {\n      return null;\n    }\n    const points: (PointWithSize | PointTuple)[] = [];\n    _.forEach(children, (c) => {\n      if (c.getNodeShape() === NodeShape.circle) {\n        const bounds = c.getBounds();\n        const { width, height } = bounds;\n        const { x, y } = bounds.getCenter();\n        const radius = Math.max(width, height) / 2;\n        points.push([x, y, radius] as PointWithSize);\n      } else {\n        // add all 4 corners\n        const { width, height, x, y } = c.getBounds();\n        points.push([x, y, 0] as PointWithSize);\n        points.push([x + width, y, 0] as PointWithSize);\n        points.push([x, y + height, 0] as PointWithSize);\n        points.push([x + width, y + height, 0] as PointWithSize);\n      }\n    });\n    const hullPoints: (PointWithSize | PointTuple)[] =\n      points.length > 2 ? polygonHull(points as PointTuple[]) : (points as PointTuple[]);\n    if (!hullPoints) {\n      return null;\n    }\n\n    // change the box only when not dragging\n    pathRef.current = hullPath(hullPoints as PointTuple[], hullPadding);\n\n    // Compute the location of the group label.\n    labelLocation.current = computeLabelLocation(hullPoints as PointWithSize[]);\n  }\n\n  return (\n    <g\n      ref={labelHoverRef}\n      onContextMenu={onContextMenu}\n      onClick={onSelect}\n      className={classNames('odc-application-group', {\n        'is-dragging': dragging,\n        'is-highlight': canDrop,\n        'is-filtered': filtered,\n      })}\n    >\n      <NodeShadows />\n      <Layer id=\"groups\">\n        <g\n          ref={refs}\n          onContextMenu={onContextMenu}\n          onClick={onSelect}\n          className={classNames('odc-application-group', {\n            'is-dragging': dragging,\n            'is-highlight': canDrop,\n            'is-selected': selected,\n            'is-dropTarget': canDrop && dropTarget,\n            'is-filtered': filtered,\n          })}\n        >\n          <path\n            ref={dndDropRef}\n            className=\"odc-application-group__bg\"\n            filter={createSvgIdUrl(\n              hover || labelHover || dragging || contextMenuOpen || dropTarget\n                ? NODE_SHADOW_FILTER_ID_HOVER\n                : NODE_SHADOW_FILTER_ID,\n            )}\n            d={pathRef.current}\n          />\n        </g>\n      </Layer>\n      {showLabels && (\n        <SvgBoxedText\n          className=\"odc-application-group__label\"\n          kind=\"application\"\n          x={labelLocation.current[0]}\n          y={labelLocation.current[1] + hullPadding(labelLocation.current) + 24}\n          paddingX={8}\n          paddingY={5}\n          dragRef={dragLabelRef}\n        >\n          {element.getLabel()}\n        </SvgBoxedText>\n      )}\n    </g>\n  );\n};\n\nexport default observer(ApplicationGroup);\n","import * as React from 'react';\nimport * as _ from 'lodash';\nimport * as classNames from 'classnames';\nimport {\n  observer,\n  Node,\n  useAnchor,\n  RectAnchor,\n  useCombineRefs,\n  useHover,\n  useDragNode,\n  WithDndDropProps,\n  WithSelectionProps,\n  WithContextMenuProps,\n  createSvgIdUrl,\n} from '@console/topology';\nimport { useSearchFilter } from '../../filters/useSearchFilter';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID, NODE_SHADOW_FILTER_ID_HOVER } from '../NodeShadows';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { GroupNode } from './GroupNode';\nimport { ApplicationModel } from '../../../../models';\n\ntype ApplicationGroupProps = {\n  element: Node;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\nconst ApplicationNode: React.FC<ApplicationGroupProps> = ({\n  element,\n  selected,\n  onSelect,\n  dndDropRef,\n  canDrop,\n  dropTarget,\n  onContextMenu,\n  contextMenuOpen,\n  dragging,\n}) => {\n  useAnchor(React.useCallback((node: Node) => new RectAnchor(node, 1.5), []));\n  const [hover, hoverRef] = useHover();\n  const dragNodeRef = useDragNode()[1];\n  const refs = useCombineRefs<SVGRectElement>(dragNodeRef, hoverRef);\n  const [filtered] = useSearchFilter(element.getLabel());\n  const { width, height } = element.getDimensions();\n\n  const resourcesData = {};\n  _.forEach(element.getData().groupResources, (res) => {\n    const a = getTopologyResourceObject(res);\n    resourcesData[a.kind] = [...(resourcesData[a.kind] ? resourcesData[a.kind] : []), a];\n  });\n\n  return (\n    <g\n      ref={refs}\n      onContextMenu={onContextMenu}\n      onClick={onSelect}\n      className={classNames('odc-application-group', {\n        'is-highlight': canDrop,\n        'is-dragging': dragging,\n        'is-selected': selected,\n        'is-dropTarget': canDrop && dropTarget,\n        'is-filtered': filtered,\n      })}\n    >\n      <NodeShadows />\n      <rect\n        ref={dndDropRef}\n        filter={createSvgIdUrl(\n          hover || dragging || contextMenuOpen || dropTarget\n            ? NODE_SHADOW_FILTER_ID_HOVER\n            : NODE_SHADOW_FILTER_ID,\n        )}\n        className=\"odc-application-group__bg\"\n        x={0}\n        y={0}\n        width={width}\n        height={height}\n        rx=\"5\"\n        ry=\"5\"\n      />\n      <GroupNode\n        element={element}\n        kind={ApplicationModel.kind}\n        groupResources={element.getData().groupResources}\n      />\n    </g>\n  );\n};\n\nexport default observer(ApplicationNode);\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport {\n  truncateMiddle,\n  shouldTruncate,\n  TruncateOptions,\n} from '@console/internal/components/utils';\nimport { Node, useSize, useHover } from '@console/topology';\nimport { RESOURCE_NAME_TRUNCATE_LENGTH } from '../../../../const';\nimport SvgCircledIcon from '../../../svg/SvgCircledIcon';\nimport { TopologyDataObject } from '../../topology-types';\nimport { SvgResourceIcon } from '../../../svg/SvgResourceIcon';\nimport { ResourceKindsInfo } from './ResourceKindsInfo';\n\nimport './GroupNode.scss';\n\nconst TOP_MARGIN = 20;\nconst LEFT_MARGIN = 20;\nconst TEXT_MARGIN = 10;\n\nconst truncateOptions: TruncateOptions = {\n  length: RESOURCE_NAME_TRUNCATE_LENGTH,\n};\n\ntype GroupNodeProps = {\n  element: Node;\n  kind?: string;\n  emptyValue?: React.ReactNode;\n  groupResources?: TopologyDataObject;\n  children?: React.ReactNode;\n  typeIconClass?: string;\n};\n\nconst GroupNode: React.FC<GroupNodeProps> = ({\n  element,\n  groupResources,\n  children,\n  kind,\n  emptyValue,\n  typeIconClass,\n}) => {\n  const [textHover, textHoverRef] = useHover();\n  const [iconSize, iconRef] = useSize([kind]);\n  const iconWidth = iconSize ? iconSize.width : 0;\n  const iconHeight = iconSize ? iconSize.height : 0;\n  const title = element.getLabel();\n  const { width, height } = element.getDimensions();\n  return (\n    <>\n      {typeIconClass && (\n        <SvgCircledIcon\n          className=\"odc-group-node__type-icon\"\n          x={10}\n          y={-10}\n          width={20}\n          height={20}\n          iconClass={typeIconClass}\n        />\n      )}\n      <SvgResourceIcon ref={iconRef} x={LEFT_MARGIN} y={TOP_MARGIN - 2} kind={kind} leftJustified />\n      {title && (\n        <Tooltip\n          content={title}\n          position={TooltipPosition.top}\n          trigger=\"manual\"\n          isVisible={textHover && shouldTruncate(title)}\n        >\n          <text\n            ref={textHoverRef}\n            className=\"odc-group-node__title\"\n            x={LEFT_MARGIN + iconWidth + TEXT_MARGIN}\n            y={TOP_MARGIN + iconHeight}\n            textAnchor=\"start\"\n            dy=\"-0.25em\"\n          >\n            {truncateMiddle(title, truncateOptions)}\n          </text>\n        </Tooltip>\n      )}\n      {(children || groupResources || emptyValue) && (\n        <g transform={`translate(${LEFT_MARGIN}, ${TOP_MARGIN + iconHeight})`}>\n          {(groupResources || emptyValue) && (\n            <ResourceKindsInfo\n              groupResources={groupResources}\n              emptyValue={emptyValue}\n              width={width - LEFT_MARGIN}\n              height={height - TOP_MARGIN - iconHeight}\n            />\n          )}\n          {children}\n        </g>\n      )}\n    </>\n  );\n};\n\nexport { GroupNode };\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { modelFor, referenceFor, referenceForModel } from '@console/internal/module/k8s';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { TopologyDataObject } from '../../topology-types';\nimport { ResourceIcon } from '@console/internal/components/utils';\n\nimport './ResourceKindsInfo.scss';\n\ntype ResourceKindsInfoProps = {\n  groupResources: TopologyDataObject;\n  emptyValue?: React.ReactNode;\n  width: number;\n  height: number;\n};\n\nconst ResourceKindsInfo: React.FC<ResourceKindsInfoProps> = ({\n  groupResources,\n  emptyValue,\n  width,\n  height,\n}) => {\n  const resourcesData = {};\n  _.forEach(groupResources, (res: TopologyDataObject) => {\n    const a = getTopologyResourceObject(res);\n    const kindObj = modelFor(referenceFor(a));\n    const key = kindObj.abbr || a.kind;\n    resourcesData[key] = [...(resourcesData[key] ? resourcesData[key] : []), a];\n  });\n  const resourceTypes = _.keys(resourcesData);\n\n  if (!resourceTypes.length) {\n    return (\n      <foreignObject width={width} height={height}>\n        <div className=\"odc-resource-kinds-info\">{emptyValue}</div>\n      </foreignObject>\n    );\n  }\n\n  return (\n    <foreignObject width={width} height={height}>\n      <div className=\"odc-resource-kinds-info\">\n        <table className=\"odc-resource-kinds-info__table\">\n          <tbody className=\"odc-resource-kinds-info__body\">\n            {resourceTypes.map((key) => {\n              const kindObj = modelFor(referenceFor(resourcesData[key][0]));\n              return (\n                <tr key={key} className=\"odc-resource-kinds-info__row\">\n                  <td className=\"odc-resource-kinds-info__count\">{resourcesData[key].length}</td>\n                  <td className=\"odc-resource-kinds-info__resource-icon\">\n                    <ResourceIcon kind={kindObj.crd ? referenceForModel(kindObj) : kindObj.kind} />\n                  </td>\n                  <td className=\"odc-resource-kinds-info__kind\">\n                    {resourcesData[key].length > 1 ? kindObj.labelPlural : kindObj.label}\n                  </td>\n                </tr>\n              );\n            })}\n          </tbody>\n        </table>\n      </div>\n    </foreignObject>\n  );\n};\n\nexport { ResourceKindsInfo };\n","export * from './GroupNode';\nexport * from './Application';\nexport * from './ResourceKindsInfo';\n","export * from './const';\nexport * from './AbstractSBRComponentFactory';\nexport * from './componentUtils';\nexport * from './componentFactory';\nexport * from './NodeShadows';\nexport * from './nodeContextMenu';\nexport * from './withEditReviewAccess';\nexport * from './moveNodeToGroup';\nexport * from './createConnection';\nexport * from './removeConnection';\nexport * from './nodes';\nexport * from './edges';\nexport * from './groups';\n","import * as React from 'react';\nimport { confirmModal, errorModal } from '@console/internal/components/modals';\nimport { Node } from '@console/topology';\nimport { updateTopologyResourceApplication } from '../topology-utils';\n\nexport const moveNodeToGroup = (node: Node, targetGroup: Node): Promise<void> => {\n  const sourceGroup = node.getParent() !== node.getGraph() ? (node.getParent() as Node) : undefined;\n  if (sourceGroup === targetGroup) {\n    return Promise.reject();\n  }\n\n  if (sourceGroup) {\n    const title = targetGroup ? 'Move Component Node' : 'Remove Component Node from Application';\n    const message = (\n      <>\n        Are you sure you want to {targetGroup ? 'move' : 'remove'}{' '}\n        <strong>{node.getLabel()}</strong> from {sourceGroup.getLabel()}\n        {targetGroup ? ` to ${targetGroup.getLabel()}` : ''}?\n      </>\n    );\n    const btnText = targetGroup ? 'Move' : 'Remove';\n\n    return new Promise((resolve, reject) => {\n      confirmModal({\n        title,\n        message,\n        btnText,\n        close: () => {\n          reject();\n        },\n        cancel: () => {\n          reject();\n        },\n        executeFn: () => {\n          return updateTopologyResourceApplication(\n            node.getData(),\n            targetGroup ? targetGroup.getLabel() : null,\n          )\n            .then(resolve)\n            .catch((err) => {\n              const error = err.message;\n              errorModal({ error });\n              reject(err);\n            });\n        },\n      });\n    });\n  }\n\n  return updateTopologyResourceApplication(node.getData(), targetGroup.getLabel()).catch((err) => {\n    const error = err.message;\n    errorModal({ error });\n  });\n};\n","import * as React from 'react';\nimport { ContextMenuItem, ContextSubMenuItem, Node, Graph } from '@console/topology';\nimport {\n  history,\n  KebabItem,\n  KebabOption,\n  KebabMenuOption,\n  kebabOptionsToMenu,\n  isKebabSubMenu,\n} from '@console/internal/components/utils';\nimport { workloadActions } from '../actions/workloadActions';\nimport { groupActions } from '../actions/groupActions';\nimport { nodeActions } from '../actions/nodeActions';\nimport { graphActions } from '../actions/graphActions';\nimport { TopologyApplicationObject } from '../topology-types';\nimport { regroupActions } from '../actions/regroupActions';\n\nconst onKebabOptionClick = (option: KebabOption) => {\n  if (option.callback) {\n    option.callback();\n  }\n  if (option.href) {\n    history.push(option.href);\n  }\n};\n\nexport const createMenuItems = (actions: KebabMenuOption[]) =>\n  actions.map((option) =>\n    isKebabSubMenu(option) ? (\n      <ContextSubMenuItem label={option.label} key={option.label}>\n        {createMenuItems(option.children)}\n      </ContextSubMenuItem>\n    ) : (\n      <ContextMenuItem\n        key={option.label}\n        component={<KebabItem option={option} onClick={() => onKebabOptionClick(option)} />}\n      />\n    ),\n  );\n\nexport const workloadContextMenu = (element: Node) =>\n  createMenuItems(kebabOptionsToMenu(workloadActions(element.getData())));\n\nexport const noRegroupWorkloadContextMenu = (element: Node) =>\n  createMenuItems(kebabOptionsToMenu(workloadActions(element.getData(), false)));\n\nexport const groupContextMenu = (element: Node, connectorSource?: Node) => {\n  const applicationData: TopologyApplicationObject = {\n    id: element.getId(),\n    name: element.getLabel(),\n    resources: element.getData().groupResources,\n  };\n\n  const graphData = element.getGraph().getData();\n  return createMenuItems(\n    kebabOptionsToMenu(groupActions(graphData, applicationData, connectorSource)),\n  );\n};\nexport const nodeContextMenu = (element: Node) =>\n  createMenuItems(kebabOptionsToMenu(nodeActions(element.getData())));\n\nexport const graphContextMenu = (graph: Graph, connectorSource?: Node) =>\n  createMenuItems(kebabOptionsToMenu(graphActions(graph.getData(), connectorSource)));\n\nexport const regroupContextMenu = (element: Node) =>\n  createMenuItems(kebabOptionsToMenu(regroupActions(element)));\n\nexport const regroupGroupContextMenu = (element: Node) =>\n  createMenuItems(kebabOptionsToMenu(regroupActions(element, true)));\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as classNames from 'classnames';\nimport {\n  Node,\n  useAnchor,\n  EllipseAnchor,\n  WithCreateConnectorProps,\n  WithDndDropProps,\n  WithDragNodeProps,\n  WithSelectionProps,\n  WithContextMenuProps,\n  useCombineRefs,\n  useHover,\n  observer,\n  createSvgIdUrl,\n} from '@console/topology';\nimport { modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport SvgBoxedText from '../../../svg/SvgBoxedText';\nimport { getTopologyResourceObject } from '../../topology-utils';\nimport { useDisplayFilters, useSearchFilter } from '../../filters';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID_HOVER, NODE_SHADOW_FILTER_ID } from '../NodeShadows';\n\nimport './BaseNode.scss';\n\nexport type BaseNodeProps = {\n  className: string;\n  outerRadius: number;\n  innerRadius?: number;\n  icon?: string;\n  kind?: string;\n  children?: React.ReactNode;\n  attachments?: React.ReactNode;\n  element: Node;\n  dragging?: boolean;\n  edgeDragging?: boolean;\n  dropTarget?: boolean;\n  canDrop?: boolean;\n} & WithSelectionProps &\n  WithDragNodeProps &\n  WithDndDropProps &\n  WithContextMenuProps &\n  WithCreateConnectorProps;\n\nconst ObservedBaseNode: React.FC<BaseNodeProps> = ({\n  className,\n  outerRadius,\n  innerRadius,\n  icon,\n  kind,\n  element,\n  selected,\n  onSelect,\n  children,\n  attachments,\n  dragNodeRef,\n  dndDropRef,\n  canDrop,\n  dragging,\n  edgeDragging,\n  dropTarget,\n  onHideCreateConnector,\n  onShowCreateConnector,\n  onContextMenu,\n  contextMenuOpen,\n}) => {\n  const [hover, hoverRef] = useHover();\n  useAnchor(EllipseAnchor);\n  const { width, height } = element.getDimensions();\n  const cx = width / 2;\n  const cy = height / 2;\n  const resourceObj = getTopologyResourceObject(element.getData());\n  const resourceModel = modelFor(referenceFor(resourceObj));\n  const iconRadius = innerRadius * 0.9;\n  const editAccess = useAccessReview({\n    group: resourceModel.apiGroup,\n    verb: 'patch',\n    resource: resourceModel.plural,\n    name: resourceObj.metadata.name,\n    namespace: resourceObj.metadata.namespace,\n  });\n  const [filtered] = useSearchFilter(element.getLabel());\n  const displayFilters = useDisplayFilters();\n  const showLabels = displayFilters.showLabels || hover;\n  const refs = useCombineRefs<SVGEllipseElement>(hoverRef, dragNodeRef);\n\n  React.useLayoutEffect(() => {\n    if (editAccess) {\n      if (hover) {\n        onShowCreateConnector && onShowCreateConnector();\n      } else {\n        onHideCreateConnector && onHideCreateConnector();\n      }\n    }\n  }, [hover, onShowCreateConnector, onHideCreateConnector, editAccess]);\n\n  return (\n    <g\n      className={classNames('odc-base-node', className, {\n        'is-hover': hover || contextMenuOpen,\n        'is-highlight': canDrop,\n        'is-dragging': dragging || edgeDragging,\n        'is-dropTarget': canDrop && dropTarget,\n        'is-filtered': filtered,\n        'is-selected': selected,\n      })}\n    >\n      <NodeShadows />\n      <g\n        data-test-id=\"base-node-handler\"\n        onClick={onSelect}\n        onContextMenu={editAccess ? onContextMenu : null}\n        ref={refs}\n      >\n        <circle\n          className=\"odc-base-node__bg\"\n          ref={dndDropRef}\n          cx={cx}\n          cy={cy}\n          r={outerRadius}\n          filter={createSvgIdUrl(\n            hover || dragging || edgeDragging || dropTarget || contextMenuOpen\n              ? NODE_SHADOW_FILTER_ID_HOVER\n              : NODE_SHADOW_FILTER_ID,\n          )}\n        />\n        {icon && (\n          <image\n            x={cx - iconRadius}\n            y={cy - iconRadius}\n            width={iconRadius * 2}\n            height={iconRadius * 2}\n            xlinkHref={icon}\n          />\n        )}\n        {showLabels && (kind || element.getLabel()) && (\n          <SvgBoxedText\n            className=\"odc-base-node__label\"\n            x={cx}\n            y={cy + outerRadius + 24}\n            paddingX={8}\n            paddingY={4}\n            kind={kind}\n          >\n            {element.getLabel()}\n          </SvgBoxedText>\n        )}\n        {children}\n      </g>\n      {attachments}\n    </g>\n  );\n};\n\nconst BaseNode = observer(ObservedBaseNode);\nexport { BaseNode };\n","import * as React from 'react';\n\nconst CheIcon: React.FC<React.HTMLProps<SVGElement>> = ({ style }): React.ReactElement => {\n  return (\n    <svg height=\"1em\" width=\"1em\" version=\"1.1\" viewBox=\"0 0 47 57\" style={style}>\n      <g fillRule=\"evenodd\" stroke=\"none\" strokeWidth=\"1\" fill=\"none\">\n        <path\n          d=\"M0.032227,30.88l-0.032227-17.087,23.853-13.793,23.796,13.784-14.691,8.51-9.062-5.109-23.864,13.695z\"\n          fill=\"#fdb940\"\n        />\n        <path\n          d=\"M0,43.355l23.876,13.622,23.974-13.937v-16.902l-23.974,13.506-23.876-13.506v17.217z\"\n          fill=\"#525c86\"\n        />\n      </g>\n    </svg>\n  );\n};\n\nexport default CheIcon;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { createSvgIdUrl, useHover } from '@console/topology';\nimport SvgDropShadowFilter from '../../../svg/SvgDropShadowFilter';\n\nimport './Decorator.scss';\n\ntype DecoratorTypes = {\n  x: number;\n  y: number;\n  radius: number;\n  onClick?(event: React.MouseEvent<SVGGElement, MouseEvent>): void;\n  href?: string;\n  external?: boolean;\n  circleRef?: React.Ref<SVGCircleElement>;\n};\n\nconst FILTER_ID = 'DecoratorDropShadowFilterId';\nconst HOVER_FILTER_ID = 'DecoratorDropShadowHoverFilterId';\n\nconst Decorator: React.FunctionComponent<DecoratorTypes> = ({\n  x,\n  y,\n  radius,\n  onClick,\n  children,\n  href,\n  external,\n  circleRef,\n}) => {\n  const [hover, hoverRef] = useHover();\n  const decorator = (\n    <g\n      className=\"odc-decorator\"\n      onClick={(e) => {\n        e.stopPropagation();\n        onClick && onClick(e);\n      }}\n      ref={hoverRef}\n    >\n      <SvgDropShadowFilter id={FILTER_ID} stdDeviation={1} floodOpacity={0.5} />\n      <SvgDropShadowFilter id={HOVER_FILTER_ID} dy={3} stdDeviation={5} floodOpacity={0.5} />\n      <circle\n        ref={circleRef}\n        className=\"odc-decorator__bg\"\n        cx={x}\n        cy={y}\n        r={radius}\n        filter={createSvgIdUrl(hover ? HOVER_FILTER_ID : FILTER_ID)}\n      />\n      <g transform={`translate(${x}, ${y})`}>{children}</g>\n    </g>\n  );\n  if (href) {\n    return (\n      /*\n      // @ts-ignore */\n      // eslint-disable-next-line jsx-a11y/anchor-is-valid\n      <a className=\"odc-decorator__link\" xlinkHref={href} target={external ? '_blank' : null}>\n        {decorator}\n      </a>\n    );\n  }\n  return decorator;\n};\n\nexport { Decorator };\n","import * as React from 'react';\nimport { get } from 'lodash';\nimport {\n  PodStatus,\n  calculateRadius,\n  getPodData,\n  podRingLabel,\n  podDataInProgress,\n} from '@console/shared';\nimport { DonutStatusData } from '../../topology-types';\n\ninterface PodSetProps {\n  size: number;\n  data: DonutStatusData;\n  showPodCount?: boolean;\n  x?: number;\n  y?: number;\n}\n\ninterface InnerPodStatusRadius {\n  innerPodStatusOuterRadius: number;\n  innerPodStatusInnerRadius: number;\n}\n\nconst calculateInnerPodStatusRadius = (\n  outerPodStatusInnerRadius: number,\n  outerPodStatusWidth: number,\n): InnerPodStatusRadius => {\n  const innerPodStatusWidth = outerPodStatusWidth * 0.6;\n  const spaceBwOuterAndInnerPodStatus = 3;\n  const innerPodStatusOuterRadius = outerPodStatusInnerRadius - spaceBwOuterAndInnerPodStatus;\n  const innerPodStatusInnerRadius = innerPodStatusOuterRadius - innerPodStatusWidth;\n\n  return { innerPodStatusOuterRadius, innerPodStatusInnerRadius };\n};\n\nexport const podSetInnerRadius = (size: number, data: DonutStatusData) => {\n  const { podStatusInnerRadius, podStatusStrokeWidth } = calculateRadius(size);\n  let radius = podStatusInnerRadius;\n\n  if (podDataInProgress(data.dc, data.current, data.isRollingOut)) {\n    const { innerPodStatusInnerRadius } = calculateInnerPodStatusRadius(\n      radius,\n      podStatusStrokeWidth,\n    );\n    radius = innerPodStatusInnerRadius;\n  }\n\n  const { podStatusStrokeWidth: innerStrokeWidth, podStatusInset } = calculateRadius(radius * 2);\n\n  return radius - innerStrokeWidth - podStatusInset;\n};\n\nconst PodSet: React.FC<PodSetProps> = ({ size, data, x = 0, y = 0, showPodCount }) => {\n  const { podStatusOuterRadius, podStatusInnerRadius, podStatusStrokeWidth } = calculateRadius(\n    size,\n  );\n  const { innerPodStatusOuterRadius, innerPodStatusInnerRadius } = calculateInnerPodStatusRadius(\n    podStatusInnerRadius,\n    podStatusStrokeWidth,\n  );\n  const { inProgressDeploymentData, completedDeploymentData } = getPodData(\n    data.dc,\n    data.pods,\n    data.current,\n    data.previous,\n    data.isRollingOut,\n  );\n\n  const obj = get(data, ['current', 'obj'], null) || data.dc;\n  const { title, subTitle, titleComponent } = podRingLabel(obj, data.dc.kind, data?.pods);\n  return (\n    <>\n      <PodStatus\n        key={inProgressDeploymentData ? 'deploy' : 'notDeploy'}\n        x={x - size / 2}\n        y={y - size / 2}\n        innerRadius={podStatusInnerRadius}\n        outerRadius={podStatusOuterRadius}\n        data={completedDeploymentData}\n        size={size}\n        subTitle={showPodCount && subTitle}\n        title={showPodCount && title}\n        titleComponent={showPodCount && titleComponent}\n      />\n      {inProgressDeploymentData && (\n        <PodStatus\n          x={x - size / 2}\n          y={y - size / 2}\n          innerRadius={innerPodStatusInnerRadius}\n          outerRadius={innerPodStatusOuterRadius}\n          data={inProgressDeploymentData}\n          size={size}\n        />\n      )}\n    </>\n  );\n};\n\nexport default PodSet;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { connect } from 'react-redux';\nimport { calculateRadius } from '@console/shared';\nimport {\n  Node,\n  observer,\n  WithCreateConnectorProps,\n  WithDragNodeProps,\n  WithSelectionProps,\n  WithDndDropProps,\n  WithContextMenuProps,\n} from '@console/topology';\nimport { RootState } from '@console/internal/redux';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { ExternalLinkAltIcon } from '@patternfly/react-icons';\nimport { routeDecoratorIcon } from '../../../import/render-utils';\nimport { Decorator } from './Decorator';\nimport PodSet, { podSetInnerRadius } from './PodSet';\nimport BuildDecorator from './build-decorators/BuildDecorator';\nimport { BaseNode } from './BaseNode';\nimport { getCheURL, getEditURL, getServiceBindingStatus } from '../../topology-utils';\nimport { useDisplayFilters } from '../../filters/useDisplayFilters';\n\nimport './WorkloadNode.scss';\n\ninterface StateProps {\n  serviceBinding: boolean;\n  cheURL: string;\n}\n\nexport type WorkloadNodeProps = {\n  element: Node;\n  hover?: boolean;\n  dragging?: boolean;\n  highlight?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  urlAnchorRef?: React.Ref<SVGCircleElement>;\n} & WithSelectionProps &\n  WithDragNodeProps &\n  WithDndDropProps &\n  WithContextMenuProps &\n  WithCreateConnectorProps &\n  StateProps;\n\nconst ObservedWorkloadNode: React.FC<WorkloadNodeProps> = ({\n  element,\n  urlAnchorRef,\n  canDrop,\n  dropTarget,\n  serviceBinding,\n  cheURL,\n  ...rest\n}) => {\n  const { width, height } = element.getDimensions();\n  const workloadData = element.getData().data;\n  const filters = useDisplayFilters();\n  const size = Math.min(width, height);\n  const { donutStatus, editURL, vcsURI } = workloadData;\n  const { radius, decoratorRadius } = calculateRadius(size);\n  const cheEnabled = !!cheURL;\n  const cx = width / 2;\n  const cy = height / 2;\n  const editUrl = editURL || getEditURL(vcsURI, cheURL);\n  const repoIcon = routeDecoratorIcon(editUrl, decoratorRadius, cheEnabled);\n  const tipContent = `Create a ${\n    serviceBinding && element.getData().operatorBackedService ? 'binding' : 'visual'\n  } connector`;\n\n  return (\n    <g>\n      <Tooltip\n        content={tipContent}\n        trigger=\"manual\"\n        isVisible={dropTarget && canDrop}\n        tippyProps={{ duration: 0, delay: 0 }}\n      >\n        <BaseNode\n          className=\"odc-workload-node\"\n          outerRadius={radius}\n          innerRadius={podSetInnerRadius(size, donutStatus)}\n          icon={!filters.podCount ? workloadData.builderImage : undefined}\n          kind={workloadData.kind}\n          element={element}\n          dropTarget={dropTarget}\n          canDrop={canDrop}\n          {...rest}\n          attachments={[\n            repoIcon && (\n              <Tooltip key=\"edit\" content=\"Edit Source Code\" position={TooltipPosition.right}>\n                <Decorator\n                  x={cx + radius - decoratorRadius * 0.7}\n                  y={cy + radius - decoratorRadius * 0.7}\n                  radius={decoratorRadius}\n                  href={editUrl}\n                  external\n                >\n                  <g transform={`translate(-${decoratorRadius / 2}, -${decoratorRadius / 2})`}>\n                    {repoIcon}\n                  </g>\n                </Decorator>\n              </Tooltip>\n            ),\n            workloadData.url && (\n              <Tooltip key=\"route\" content=\"Open URL\" position={TooltipPosition.right}>\n                <Decorator\n                  x={cx + radius - decoratorRadius * 0.7}\n                  y={cy + -radius + decoratorRadius * 0.7}\n                  radius={decoratorRadius}\n                  href={workloadData.url}\n                  external\n                  circleRef={urlAnchorRef}\n                >\n                  <g transform={`translate(-${decoratorRadius / 2}, -${decoratorRadius / 2})`}>\n                    <ExternalLinkAltIcon style={{ fontSize: decoratorRadius }} alt=\"Open URL\" />\n                  </g>\n                </Decorator>\n              </Tooltip>\n            ),\n            <BuildDecorator\n              key=\"build\"\n              workloadData={workloadData}\n              x={cx - radius + decoratorRadius * 0.7}\n              y={cy + radius - decoratorRadius * 0.7}\n              radius={decoratorRadius}\n            />,\n          ]}\n        >\n          <PodSet size={size} x={cx} y={cy} data={donutStatus} showPodCount={filters.podCount} />\n        </BaseNode>\n      </Tooltip>\n    </g>\n  );\n};\n\nconst mapStateToProps = (state: RootState): StateProps => {\n  const consoleLinks = state.UI.get('consoleLinks');\n  return {\n    cheURL: getCheURL(consoleLinks),\n    serviceBinding: getServiceBindingStatus(state),\n  };\n};\n\nconst WorkloadNode = connect(mapStateToProps)(observer(ObservedWorkloadNode));\nexport { WorkloadNode };\n","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport { Tooltip, TooltipPosition } from '@patternfly/react-core';\nimport { WorkloadData } from '../../../topology-types';\nimport { Decorator } from '../Decorator';\nimport { getBuildDecoratorParts } from './build-decorator-utils';\n\nexport interface BuildDecoratorProps {\n  workloadData: WorkloadData;\n  radius: number;\n  x: number;\n  y: number;\n}\n\nconst BuildDecorator: React.FC<BuildDecoratorProps> = ({ workloadData, radius, x, y }) => {\n  const { decoratorIcon, linkRef, tooltipContent } = getBuildDecoratorParts(workloadData);\n\n  if (!decoratorIcon && !tooltipContent) {\n    return null;\n  }\n\n  let decoratorContent = (\n    <Decorator x={x} y={y} radius={radius}>\n      <g transform={`translate(-${radius / 2}, -${radius / 2})`}>\n        <foreignObject width={radius} height={radius} style={{ fontSize: radius }}>\n          {decoratorIcon}\n        </foreignObject>\n      </g>\n    </Decorator>\n  );\n\n  if (linkRef) {\n    decoratorContent = (\n      <Link to={linkRef} className=\"odc-decorator__link\">\n        {decoratorContent}\n      </Link>\n    );\n  }\n\n  return (\n    <Tooltip key=\"build\" content={tooltipContent} position={TooltipPosition.left}>\n      {decoratorContent}\n    </Tooltip>\n  );\n};\n\nexport default BuildDecorator;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport {\n  getRunStatusColor,\n  getTaskStatus,\n  Pipeline,\n  runStatus,\n} from '../../../../../utils/pipeline-augment';\nimport HorizontalStackedBars from '../../../../charts/HorizontalStackedBars';\nimport TaskStatusToolTip from '../../../../pipelineruns/status/TaskStatusTooltip';\nimport './PipelineBuildDecoratorTooltip.scss';\n\nexport interface PipelineBuildDecoratorTooltipProps {\n  pipeline: Pipeline;\n  status: string;\n}\n\nconst PipelineBuildDecoratorTooltip: React.FC<PipelineBuildDecoratorTooltipProps> = ({\n  pipeline,\n  status,\n}) => {\n  if (!pipeline || !status) {\n    return null;\n  }\n\n  const taskStatus = getTaskStatus(pipeline.latestRun, pipeline);\n  const pipelineBars = (\n    <HorizontalStackedBars\n      height=\"1em\"\n      inline\n      values={Object.keys(runStatus).map((rStatus) => ({\n        color: getRunStatusColor(runStatus[rStatus]).pftoken.value,\n        name: rStatus,\n        size: taskStatus[runStatus[rStatus]],\n      }))}\n    />\n  );\n  const breakdownInfo = <TaskStatusToolTip taskStatus={taskStatus} />;\n\n  return (\n    <div className=\"odc-pipeline-build-decorator-tooltip\">\n      <div className=\"odc-pipeline-build-decorator-tooltip__title\">Pipeline {status}</div>\n      <div className=\"odc-pipeline-build-decorator-tooltip__status-bars-wrapper\">\n        <div className=\"odc-pipeline-build-decorator-tooltip__status-bars-title\">Task Status</div>\n        <div className=\"odc-pipeline-build-decorator-tooltip__status-bars\">{pipelineBars}</div>\n      </div>\n      <div className=\"odc-pipeline-build-decorator-tooltip__status-breakdown\">{breakdownInfo}</div>\n    </div>\n  );\n};\n\nexport default PipelineBuildDecoratorTooltip;\n","import * as React from 'react';\nimport { Status } from '@console/shared';\nimport { resourcePathFromModel } from '@console/internal/components/utils';\nimport { BuildModel } from '@console/internal/models';\nimport { PipelineRunModel } from '../../../../../models';\nimport { constructCurrentPipeline } from '../../../../../utils/pipeline-utils';\nimport { WorkloadData } from '../../../topology-types';\nimport PipelineBuildDecoratorTooltip from './PipelineBuildDecoratorTooltip';\n\ntype BuildDecoratorData = {\n  decoratorIcon: React.ReactElement;\n  linkRef?: string;\n  tooltipContent: React.ReactElement;\n};\n\nexport const getBuildDecoratorParts = (workloadData: WorkloadData): BuildDecoratorData => {\n  const { build, connectedPipeline } = workloadData;\n\n  let tooltipContent = null;\n  let decoratorIcon = null;\n  let linkRef = null;\n\n  let currentPipelineStatus = null;\n  if (connectedPipeline) {\n    const { pipelineRuns, pipeline } = connectedPipeline;\n    currentPipelineStatus = constructCurrentPipeline(pipeline, pipelineRuns);\n  }\n\n  if (currentPipelineStatus) {\n    const { currentPipeline, status } = currentPipelineStatus;\n    tooltipContent = <PipelineBuildDecoratorTooltip pipeline={currentPipeline} status={status} />;\n    decoratorIcon = <Status status={status} iconOnly noTooltip />;\n    linkRef = `${resourcePathFromModel(\n      PipelineRunModel,\n      currentPipeline.latestRun.metadata.name,\n      currentPipeline.latestRun.metadata.namespace,\n    )}/logs`;\n  } else if (build) {\n    tooltipContent = `Build ${build.status && build.status.phase}`;\n    decoratorIcon = <Status status={build.status.phase} iconOnly noTooltip />;\n    linkRef = `${resourcePathFromModel(\n      BuildModel,\n      build.metadata.name,\n      build.metadata.namespace,\n    )}/logs`;\n  }\n\n  return {\n    tooltipContent,\n    decoratorIcon,\n    linkRef,\n  };\n};\n","export * from './BaseNode';\nexport * from './WorkloadNode';\nexport * from './Decorator';\n","import * as React from 'react';\nimport { Edge } from '@console/topology';\nimport { YellowExclamationTriangleIcon } from '@console/shared/src';\nimport { confirmModal, errorModal } from '@console/internal/components/modals';\nimport { removeTopologyResourceConnection } from '../topology-utils';\n\nexport const removeConnection = (edge: Edge): Promise<any> => {\n  const message =\n    edge.getType() === 'service-binding' ? (\n      <p>\n        Deleting the binding connector deletes the config details of the source and removes the\n        binding resources. Are you sure you want to delete the binding connector?\n      </p>\n    ) : (\n      <p>\n        Deleting the visual connector removes the `connects-to` annotation from the resources. Are\n        you sure you want to delete the visual connector?\n      </p>\n    );\n\n  return confirmModal({\n    title: (\n      <>\n        <YellowExclamationTriangleIcon className=\"co-icon-space-r\" /> Delete Connector?\n      </>\n    ),\n    message,\n    btnText: 'Delete',\n    submitDanger: true,\n    executeFn: () => {\n      return removeTopologyResourceConnection(\n        edge.getSource().getData(),\n        edge.getTarget().getData(),\n        edge.getData().data && edge.getData().data.sbr,\n        edge.getType(),\n      ).catch((err) => {\n        err && errorModal({ error: err.message });\n      });\n    },\n  });\n};\n","import * as React from 'react';\nimport { observer } from 'mobx-react';\nimport { modelFor, referenceFor, K8sVerb } from '@console/internal/module/k8s';\nimport { useAccessReview } from '@console/internal/components/utils';\nimport { Node } from '@console/topology';\nimport { getTopologyResourceObject } from '../topology-utils';\n\ntype ComponentProps = {\n  element: Node;\n};\n\nexport const withEditReviewAccess = (verb: K8sVerb) => (WrappedComponent: React.ComponentType) => {\n  const Component: React.FC<ComponentProps> = (props) => {\n    const resourceObj = getTopologyResourceObject(props.element.getData());\n    const resourceModel = modelFor(referenceFor(resourceObj));\n    const editAccess = useAccessReview({\n      group: resourceModel.apiGroup,\n      verb,\n      resource: resourceModel.plural,\n      name: resourceObj.metadata.name,\n      namespace: resourceObj.metadata.namespace,\n    });\n    return <WrappedComponent {...(props as any)} canEdit={editAccess} />;\n  };\n  return observer(Component);\n};\n","import * as _ from 'lodash';\nimport {\n  K8sResourceKind,\n  isGroupVersionKind,\n  kindForReference,\n  apiVersionForReference,\n} from '@console/internal/module/k8s';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { getKnativeTopologyDataModel } from '@console/knative-plugin/src/topology/data-transformer';\nimport {\n  getKubevirtTopologyDataModel,\n  kubevirtAllowedResources,\n} from '@console/kubevirt-plugin/src/topology/kubevirt-data-transformer';\nimport {\n  TopologyDataModel,\n  TopologyDataResources,\n  Edge,\n  TrafficData,\n  KialiNode,\n} from '../topology-types';\nimport { TYPE_TRAFFIC_CONNECTOR, TYPE_WORKLOAD } from '../components/const';\nimport { HelmReleaseResourcesMap } from '../../helm/helm-types';\nimport { allowedResources } from '../topology-utils';\nimport {\n  addToTopologyDataModel,\n  createInstanceForResource,\n  createTopologyNodeData,\n  getTopologyEdgeItems,\n  getTopologyGroupItems,\n  getTopologyNodeItem,\n  mergeGroup,\n} from './transform-utils';\nimport { getOperatorTopologyDataModel } from '../operators/operators-data-transformer';\nimport { getHelmTopologyDataModel } from '../helm/helm-data-transformer';\n\nexport const getFilteredTrafficWorkload = (nodes: KialiNode[]): KialiNode[] =>\n  nodes.filter(({ data }) => data.nodeType === TYPE_WORKLOAD);\n\nexport const getTrafficConnectors = (\n  trafficData: TrafficData,\n  resources: K8sResourceKind[],\n): Edge[] => {\n  const filteredWorkload = getFilteredTrafficWorkload(trafficData.nodes);\n  return trafficData.edges.reduce((acc, { data }) => {\n    const { data: sourceTrafficNode } = filteredWorkload.find(\n      (wrkld) => wrkld.data.id === data.source,\n    );\n    const { data: targetTrafficNode } = filteredWorkload.find(\n      (wrkld) => wrkld.data.id === data.target,\n    );\n    const sourceResourceNode = resources.find((res) => {\n      return res.metadata.name === sourceTrafficNode[sourceTrafficNode.nodeType];\n    });\n    const targetResourceNode = resources.find(\n      (res) => res.metadata.name === targetTrafficNode[targetTrafficNode.nodeType],\n    );\n    return sourceResourceNode && targetResourceNode\n      ? [\n          ...acc,\n          {\n            id: `${sourceResourceNode.metadata.uid}_${targetResourceNode.metadata.uid}`,\n            type: TYPE_TRAFFIC_CONNECTOR,\n            source: sourceResourceNode.metadata.uid,\n            target: targetResourceNode.metadata.uid,\n            data: data.traffic,\n          },\n        ]\n      : acc;\n  }, []);\n};\n\nconst getBaseTopologyDataModel = (\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  installedOperators,\n  utils: Function[],\n  transformBy: string[],\n  serviceBindingRequests: K8sResourceKind[],\n): TopologyDataModel => {\n  const baseDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  _.forEach(transformBy, (key) => {\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data).forEach((item) => {\n        const { obj: deploymentConfig } = item;\n        const uid = _.get(deploymentConfig, ['metadata', 'uid']);\n        typedDataModel.topology[uid] = createTopologyNodeData(\n          item,\n          TYPE_WORKLOAD,\n          getImageForIconClass(`icon-openshift`),\n        );\n        typedDataModel.graph.nodes.push(getTopologyNodeItem(deploymentConfig, TYPE_WORKLOAD));\n        typedDataModel.graph.edges.push(\n          ...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests),\n        );\n        mergeGroup(getTopologyGroupItems(deploymentConfig), typedDataModel.graph.groups);\n      });\n      addToTopologyDataModel(typedDataModel, baseDataModel);\n    }\n  });\n  return baseDataModel;\n};\n\n/**\n * Tranforms the k8s resources objects into topology data\n */\nexport const transformTopologyData = (\n  resources: TopologyDataResources,\n  transformBy: string[],\n  utils?: Function[],\n  trafficData?: TrafficData,\n  helmResourcesMap?: HelmReleaseResourcesMap,\n): TopologyDataModel => {\n  const installedOperators = _.get(resources, 'clusterServiceVersions.data');\n  const serviceBindingRequests = _.get(resources, 'serviceBindingRequests.data');\n  const topologyGraphAndNodeData: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  // TODO: plugin\n  const allResourceTypes = [...allowedResources, ...kubevirtAllowedResources];\n  const allResourcesList = _.flatten(\n    allResourceTypes.map((resourceKind) => {\n      return resources[resourceKind]\n        ? resources[resourceKind].data.map((res) => {\n            const resKind = resources[resourceKind].kind;\n            let kind = resKind;\n            let apiVersion;\n            if (resKind && isGroupVersionKind(resKind)) {\n              kind = kindForReference(resKind);\n              apiVersion = apiVersionForReference(resKind);\n            }\n            return {\n              kind,\n              apiVersion,\n              ...res,\n            };\n          })\n        : [];\n    }),\n  );\n  if (trafficData) {\n    topologyGraphAndNodeData.graph.edges = getTrafficConnectors(trafficData, allResourcesList);\n  }\n\n  // Copy the resources into a mutable list of resources, we don't want to effect the incoming lists\n  const dataResources: TopologyDataResources = Object.keys(resources).reduce((obj, key) => {\n    obj[key] = {\n      ...resources[key],\n      data: [...resources[key].data],\n    };\n    return obj;\n  }, {} as TopologyDataResources);\n\n  // TODO: plugins\n  const knativeModel = getKnativeTopologyDataModel(\n    dataResources,\n    allResourcesList,\n    installedOperators,\n    utils,\n  );\n  addToTopologyDataModel(knativeModel, topologyGraphAndNodeData);\n\n  const operatorsModel = getOperatorTopologyDataModel(\n    dataResources,\n    allResourcesList,\n    installedOperators,\n    utils,\n    transformBy,\n    serviceBindingRequests,\n  );\n  addToTopologyDataModel(operatorsModel, topologyGraphAndNodeData);\n\n  const helmModel = getHelmTopologyDataModel(\n    dataResources,\n    allResourcesList,\n    installedOperators,\n    utils,\n    transformBy,\n    serviceBindingRequests,\n    helmResourcesMap,\n  );\n  addToTopologyDataModel(helmModel, topologyGraphAndNodeData);\n\n  const vmsModel = getKubevirtTopologyDataModel(\n    dataResources,\n    allResourcesList,\n    installedOperators,\n    utils,\n    transformBy,\n    serviceBindingRequests,\n  );\n  addToTopologyDataModel(vmsModel, topologyGraphAndNodeData);\n\n  const baseModel = getBaseTopologyDataModel(\n    dataResources,\n    allResourcesList,\n    installedOperators,\n    utils,\n    transformBy,\n    serviceBindingRequests,\n  );\n  addToTopologyDataModel(baseModel, topologyGraphAndNodeData);\n\n  return topologyGraphAndNodeData;\n};\n","export * from './data-transformer';\nexport * from './transform-utils';\nexport * from './topology-model';\n","import { EdgeModel, Model, NodeModel, createAggregateEdges } from '@console/topology';\nimport { ALL_APPLICATIONS_KEY } from '@console/shared/src';\nimport {\n  getKnativeNodeModel,\n  getKnativeGroupModel,\n  getKnativeEdgeModel,\n} from '@console/knative-plugin/src/topology/knative-topology-model';\nimport {\n  getKubevirtGroupModel,\n  getKubevirtNodeModel,\n  getKubevirtEdgeModel,\n} from '@console/kubevirt-plugin/src/topology/kubevirt-topology-model';\nimport { getHelmEdgeModel, getHelmGroupModel, getHelmNodeModel } from '../helm/helm-topology-model';\nimport {\n  getOperatorEdgeModel,\n  getOperatorGroupModel,\n  getOperatorNodeModel,\n} from '../operators/operators-topology-model';\nimport { TopologyFilters } from '../filters';\nimport { TopologyDataModel, TopologyDataObject, Node } from '../topology-types';\nimport {\n  TYPE_APPLICATION_GROUP,\n  TYPE_AGGREGATE_EDGE,\n  NODE_WIDTH,\n  NODE_HEIGHT,\n  NODE_PADDING,\n  GROUP_WIDTH,\n  GROUP_HEIGHT,\n  GROUP_PADDING,\n} from '../components/const';\nimport { dataObjectFromModel } from './transform-utils';\n\nconst getApplicationGroupForNode = (node: Node, groups: NodeModel[]): NodeModel => {\n  const group = groups.find((g) => g.children.includes(node.id));\n  if (!group) {\n    return null;\n  }\n  if (group.type === TYPE_APPLICATION_GROUP) {\n    return group;\n  }\n  return getApplicationGroupForNode(group, groups);\n};\n\nexport const topologyModelFromDataModel = (\n  dataModel: TopologyDataModel,\n  application: string = ALL_APPLICATIONS_KEY,\n  filters?: TopologyFilters,\n): Model => {\n  const groupNodes: NodeModel[] = dataModel.graph.groups.map((d) => {\n    // TODO: Change to use plugins\n    let node = getKnativeGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getKubevirtGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getHelmGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getOperatorGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    const data: TopologyDataObject = dataModel.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.nodes.map((id) => dataModel.topology[id]);\n\n    return {\n      width: GROUP_WIDTH,\n      height: GROUP_HEIGHT,\n      id: d.id,\n      group: true,\n      type: d.type,\n      visible:\n        d.type !== TYPE_APPLICATION_GROUP ||\n        application === ALL_APPLICATIONS_KEY ||\n        d.name === application,\n      collapsed: filters && d.type === TYPE_APPLICATION_GROUP && !filters.display.appGrouping,\n      data,\n      children: d.nodes,\n      label: d.name,\n      style: {\n        padding: GROUP_PADDING,\n      },\n    };\n  });\n\n  const nodes: NodeModel[] = dataModel.graph.nodes.map((d) => {\n    // TODO: Change to use plugins\n    let node = getKnativeNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getKubevirtNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getHelmNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getOperatorNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: dataModel.topology[d.id].name,\n      data: dataModel.topology[d.id],\n      visible: true,\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  });\n\n  const allNodes = [...nodes, ...groupNodes];\n\n  // Flag any hidden nodes\n  if (application !== ALL_APPLICATIONS_KEY) {\n    const allGroups = [...groupNodes, ...nodes.filter((n) => n.group)];\n    allNodes\n      .filter((g) => g.type !== TYPE_APPLICATION_GROUP)\n      .forEach((g) => {\n        const group = getApplicationGroupForNode(g, allGroups);\n        const hidden =\n          application !== ALL_APPLICATIONS_KEY && (!group || application !== group.label);\n        g.visible = !hidden;\n      });\n  }\n\n  // create links from data, only include those which have a valid source and target\n  const edges = dataModel.graph.edges\n    .filter((d) => {\n      return allNodes.find((n) => n.id === d.source) && allNodes.find((n) => n.id === d.target);\n    })\n    .map(\n      (d): EdgeModel => {\n        // TODO: Change to use plugins\n        let edge = getKnativeEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getKubevirtEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getHelmEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getOperatorEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n\n        return {\n          data: d,\n          source: d.source,\n          target: d.target,\n          id: `${d.source}_${d.target}`,\n          type: d.type,\n        };\n      },\n    );\n\n  // create topology model\n  const model: Model = {\n    nodes: allNodes,\n    edges: createAggregateEdges(TYPE_AGGREGATE_EDGE, edges, allNodes),\n  };\n\n  return model;\n};\n","import * as _ from 'lodash';\nimport { K8sResourceKind, referenceFor } from '@console/internal/module/k8s';\nimport { TransformResourceData, isKnativeServing } from '@console/shared';\nimport { ClusterServiceVersionKind } from '@console/operator-lifecycle-manager';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport {\n  TYPE_EVENT_SOURCE,\n  TYPE_KNATIVE_REVISION,\n} from '@console/knative-plugin/src/topology/const';\nimport { edgesFromAnnotations, edgesFromServiceBinding } from '../../../utils/application-utils';\nimport {\n  TopologyDataModel,\n  TopologyDataResources,\n  TopologyDataObject,\n  Node,\n  Edge,\n  Group,\n  TopologyOverviewItem,\n  ConnectsToData,\n} from '../topology-types';\nimport {\n  TYPE_APPLICATION_GROUP,\n  TYPE_WORKLOAD,\n  TYPE_CONNECTS_TO,\n  TYPE_SERVICE_BINDING,\n} from '../components/const';\nimport { getRoutesURL } from '../topology-utils';\n\nexport const dataObjectFromModel = (node: Node | Group): TopologyDataObject => {\n  return {\n    id: node.id,\n    name: node.name,\n    type: node.type,\n    resources: null,\n    operatorBackedService: false,\n    data: null,\n  };\n};\n\n/**\n * create instance of TransformResourceData, return object containing all methods\n */\nexport const createInstanceForResource = (\n  resources: TopologyDataResources,\n  utils?: Function[],\n  installedOperators?: ClusterServiceVersionKind[],\n) => {\n  const transformResourceData = new TransformResourceData(resources, utils, installedOperators);\n\n  return {\n    deployments: transformResourceData.createDeploymentItems,\n    deploymentConfigs: transformResourceData.createDeploymentConfigItems,\n    daemonSets: transformResourceData.createDaemonSetItems,\n    statefulSets: transformResourceData.createStatefulSetItems,\n  };\n};\n\n/**\n * create all data that need to be shown on a topology data\n */\nexport const createTopologyNodeData = (\n  dc: TopologyOverviewItem,\n  type: string,\n  defaultIcon: string,\n  operatorBackedService: boolean = false,\n): TopologyDataObject => {\n  const {\n    obj: deploymentConfig,\n    current,\n    previous,\n    isRollingOut,\n    buildConfigs,\n    pipelines = [],\n    pipelineRuns = [],\n  } = dc;\n  const dcUID = _.get(deploymentConfig, 'metadata.uid');\n  const deploymentsLabels = _.get(deploymentConfig, 'metadata.labels', {});\n  const deploymentsAnnotations = _.get(deploymentConfig, 'metadata.annotations', {});\n\n  const builderImageIcon =\n    getImageForIconClass(`icon-${deploymentsLabels['app.openshift.io/runtime']}`) ||\n    getImageForIconClass(`icon-${deploymentsLabels['app.kubernetes.io/name']}`);\n  return {\n    id: dcUID,\n    name:\n      _.get(deploymentConfig, 'metadata.name') || deploymentsLabels['app.kubernetes.io/instance'],\n    type,\n    resources: { ...dc, isOperatorBackedService: operatorBackedService },\n    pods: dc.pods,\n    operatorBackedService,\n    data: {\n      url: getRoutesURL(dc),\n      kind: referenceFor(deploymentConfig),\n      editURL: deploymentsAnnotations['app.openshift.io/edit-url'],\n      vcsURI: deploymentsAnnotations['app.openshift.io/vcs-uri'],\n      builderImage: builderImageIcon || defaultIcon,\n      isKnativeResource:\n        type && (type === TYPE_EVENT_SOURCE || type === TYPE_KNATIVE_REVISION)\n          ? true\n          : isKnativeServing(deploymentConfig, 'metadata.labels'),\n      build: buildConfigs?.[0]?.builds?.[0],\n      connectedPipeline: {\n        pipeline: pipelines[0],\n        pipelineRuns,\n      },\n      donutStatus: {\n        pods: dc.pods,\n        current,\n        previous,\n        isRollingOut,\n        dc: deploymentConfig,\n      },\n    },\n  };\n};\n\n/**\n * create node data for graphs\n */\nexport const getTopologyNodeItem = (\n  dc: K8sResourceKind,\n  type?: string,\n  children?: string[],\n): Node => {\n  const uid = _.get(dc, ['metadata', 'uid']);\n  const name = _.get(dc, ['metadata', 'name']);\n  const label = _.get(dc, ['metadata', 'labels', 'app.openshift.io/instance']);\n\n  return {\n    id: uid,\n    type: type || TYPE_WORKLOAD,\n    name: label || name,\n    ...(children && children.length && { children }),\n  };\n};\n\n/**\n * create edge data for graph\n */\nexport const getTopologyEdgeItems = (\n  dc: K8sResourceKind,\n  resources: K8sResourceKind[],\n  sbrs: K8sResourceKind[],\n): Edge[] => {\n  const annotations = _.get(dc, 'metadata.annotations');\n  const edges = [];\n\n  _.forEach(edgesFromAnnotations(annotations), (edge: string | ConnectsToData) => {\n    // handles multiple edges\n    const targetNode = _.get(\n      _.find(resources, (deployment) => {\n        let name;\n        if (typeof edge === 'string') {\n          name =\n            deployment.metadata?.labels?.['app.kubernetes.io/instance'] ??\n            deployment.metadata?.name;\n          return name === edge;\n        }\n        name = deployment.metadata?.name;\n        const { apiVersion: edgeApiVersion, kind: edgeKind, name: edgeName } = edge;\n        const { kind, apiVersion } = deployment;\n        let edgeExists = name === edgeName && kind === edgeKind;\n        if (apiVersion) {\n          edgeExists = edgeExists && apiVersion === edgeApiVersion;\n        }\n        return edgeExists;\n      }),\n      ['metadata', 'uid'],\n    );\n    const uid = _.get(dc, ['metadata', 'uid']);\n    if (targetNode) {\n      edges.push({\n        id: `${uid}_${targetNode}`,\n        type: TYPE_CONNECTS_TO,\n        source: uid,\n        target: targetNode,\n      });\n    }\n  });\n\n  _.forEach(edgesFromServiceBinding(dc, sbrs), (sbr) => {\n    // look for multiple backing services first in `backingServiceSelectors`\n    // followed by a fallback to the single reference in `backingServiceSelector`\n    _.forEach(sbr.spec.backingServiceSelectors || [sbr.spec.backingServiceSelector], (bss) => {\n      if (bss) {\n        // handles multiple edges\n        const targetResource = resources.find(\n          (deployment) =>\n            deployment?.metadata?.ownerReferences?.[0]?.kind === bss.kind &&\n            deployment?.metadata?.ownerReferences?.[0]?.name === bss.resourceRef,\n        );\n        const target = targetResource?.metadata?.uid;\n        const source = dc?.metadata?.uid;\n        if (source && target) {\n          edges.push({\n            id: `${source}_${target}`,\n            type: TYPE_SERVICE_BINDING,\n            source,\n            target,\n            data: { sbr },\n          });\n        }\n      }\n    });\n  });\n\n  return edges;\n};\n\n/**\n * create groups data for graph\n */\nexport const getTopologyGroupItems = (dc: K8sResourceKind): Group => {\n  const groupName = _.get(dc, ['metadata', 'labels', 'app.kubernetes.io/part-of']);\n  if (!groupName) {\n    return null;\n  }\n\n  return {\n    id: `group:${groupName}`,\n    type: TYPE_APPLICATION_GROUP,\n    name: groupName,\n    nodes: [_.get(dc, ['metadata', 'uid'])],\n  };\n};\n\nexport const mergeGroup = (newGroup: Group, existingGroups: Group[]): void => {\n  if (!newGroup) {\n    return;\n  }\n\n  // find and add the groups\n  const existingGroup = existingGroups.find((g) => g.id === newGroup.id);\n  if (!existingGroup) {\n    existingGroups.push(newGroup);\n  } else {\n    newGroup.nodes.forEach((id) => {\n      if (!existingGroup.nodes.includes(id)) {\n        existingGroup.nodes.push(id);\n      }\n    });\n  }\n};\n\nexport const mergeGroups = (newGroups: Group[], existingGroups: Group[]): void => {\n  if (!newGroups || !newGroups.length) {\n    return;\n  }\n  newGroups.forEach((newGroup) => {\n    mergeGroup(newGroup, existingGroups);\n  });\n};\n\nexport const addToTopologyDataModel = (\n  newModel: TopologyDataModel,\n  graphModel: TopologyDataModel,\n) => {\n  graphModel.graph.nodes.push(...newModel.graph.nodes);\n  graphModel.graph.edges.push(...newModel.graph.edges);\n  mergeGroups(newModel.graph.groups, graphModel.graph.groups);\n  graphModel.topology = {\n    ...graphModel.topology,\n    ...newModel.topology,\n  };\n};\n","export const TOPOLOGY_SEARCH_FILTER_KEY = 'searchQuery';\nexport const FILTER_ACTIVE_CLASS = 'odc-m-filter-active';\n\nexport enum ShowFiltersKeyValue {\n  podCount = 'Pod Count',\n  eventSources = 'Event Sources',\n  virtualMachines = 'Virtual Machines',\n  showLabels = 'Show Labels',\n}\n\nexport enum ExpandFiltersKeyValue {\n  appGrouping = 'Application Groupings',\n  helmGrouping = 'Helm Releases',\n  knativeServices = 'Knative Services',\n  operatorGrouping = 'Operator Groupings',\n}\n\nexport type TopologyFilters = {\n  display: DisplayFilters;\n};\n\nexport type DisplayFilters = {\n  podCount: boolean;\n  eventSources: boolean;\n  virtualMachines: boolean;\n  showLabels: boolean;\n  knativeServices: boolean;\n  appGrouping: boolean;\n  operatorGrouping: boolean;\n  helmGrouping: boolean;\n};\n","import { RootState } from '@console/internal/redux';\nimport { getQueryArgument } from '@console/internal/components/utils';\nimport { getDefaultTopologyFilters } from '../redux/reducer';\nimport { TOPOLOGY_SEARCH_FILTER_KEY, TopologyFilters } from './filter-types';\n\nexport const getTopologyFilters = (state: RootState): TopologyFilters => {\n  const topology = state?.plugins?.devconsole?.topology;\n  return topology ? topology.get('filters') : getDefaultTopologyFilters();\n};\n\nexport const getTopologySearchQuery = () => getQueryArgument(TOPOLOGY_SEARCH_FILTER_KEY) ?? '';\n","export * from './filter-types';\nexport * from './filter-utils';\nexport * from './useSearchFilter';\nexport * from './useDisplayFilters';\n","// FIXME upgrading redux types is causing many errors at this time\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { useSelector } from 'react-redux';\nimport { RootState } from '@console/internal/redux';\nimport { DisplayFilters } from './filter-types';\nimport { getTopologyFilters } from './filter-utils';\n\nconst useDisplayFilters = (): DisplayFilters => {\n  return useSelector((state: RootState) => getTopologyFilters(state).display);\n};\n\nexport { useDisplayFilters };\n","import * as React from 'react';\nimport * as fuzzy from 'fuzzysearch';\nimport { toLower } from 'lodash';\nimport { getTopologySearchQuery } from './filter-utils';\n\nconst fuzzyCaseInsensitive = (a: string, b: string): boolean => fuzzy(toLower(a), toLower(b));\n\nconst useSearchFilter = (text: string): [boolean, string] => {\n  const searchQuery = getTopologySearchQuery();\n  const filtered = React.useMemo(() => fuzzyCaseInsensitive(searchQuery, text), [\n    searchQuery,\n    text,\n  ]);\n  return [filtered && !!searchQuery, searchQuery];\n};\n\nexport { useSearchFilter };\n","import { GROUP_HEIGHT, GROUP_PADDING, GROUP_WIDTH } from '../../components/const';\n\nexport const TYPE_HELM_RELEASE = 'helm-release';\nexport const TYPE_HELM_WORKLOAD = 'helm-workload';\n\nexport const HELM_GROUP_WIDTH = GROUP_WIDTH;\nexport const HELM_GROUP_HEIGHT = GROUP_HEIGHT;\nexport const HELM_GROUP_PADDING = GROUP_PADDING;\n","import * as _ from 'lodash';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { SecretModel } from '@console/internal/models';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport {\n  TopologyDataModel,\n  TopologyDataResources,\n  TopologyDataMap,\n  Group,\n} from '../topology-types';\nimport { TYPE_HELM_RELEASE, TYPE_HELM_WORKLOAD } from './components/const';\nimport { HelmReleaseResourcesMap } from '../../helm/helm-types';\nimport { getHelmReleaseKey } from '../topology-utils';\nimport {\n  dataObjectFromModel,\n  addToTopologyDataModel,\n  createInstanceForResource,\n  createTopologyNodeData,\n  getTopologyEdgeItems,\n  getTopologyGroupItems,\n  getTopologyNodeItem,\n  mergeGroup,\n  mergeGroups,\n} from '../data-transforms/transform-utils';\n\nexport const isHelmReleaseNode = (\n  obj: K8sResourceKind,\n  helmResourcesMap: HelmReleaseResourcesMap,\n): boolean => {\n  if (helmResourcesMap) {\n    return helmResourcesMap.hasOwnProperty(getHelmReleaseKey(obj));\n  }\n  return false;\n};\n\nexport const getTopologyHelmReleaseGroupItem = (\n  obj: K8sResourceKind,\n  helmResourcesMap: HelmReleaseResourcesMap,\n  secrets: K8sResourceKind[],\n): { groups: Group[]; dataModel: TopologyDataMap } => {\n  const resourceKindName = getHelmReleaseKey(obj);\n  const helmResources = helmResourcesMap[resourceKindName];\n  const releaseName = helmResources?.releaseName;\n  const releaseVersion = helmResources?.releaseVersion;\n  const releaseNotes = helmResources?.releaseNotes;\n  const uid = _.get(obj, ['metadata', 'uid'], null);\n  const returnData = { groups: [], dataModel: {} };\n\n  if (!releaseName) {\n    return returnData;\n  }\n\n  const secret = secrets.find((nextSecret) => {\n    const { labels } = nextSecret.metadata;\n    return labels?.name?.includes(releaseName) && labels?.version === releaseVersion.toString();\n  });\n\n  if (secret) {\n    const appGroup = getTopologyGroupItems(secret);\n    if (appGroup) {\n      mergeGroup(appGroup, returnData.groups);\n    }\n  }\n\n  const helmGroup = {\n    id: secret ? secret.metadata.uid : `${TYPE_HELM_RELEASE}:${releaseName}`,\n    type: TYPE_HELM_RELEASE,\n    name: releaseName,\n    nodes: [uid],\n  };\n\n  const dataModel = dataObjectFromModel(helmGroup);\n  const { kind, apiVersion } = SecretModel;\n  dataModel.resources = {\n    obj: secret ? { ...secret, kind, apiVersion } : null,\n    buildConfigs: null,\n    services: null,\n    routes: null,\n  };\n  dataModel.data = {\n    chartIcon: helmResources?.chartIcon,\n    manifestResources: helmResources?.manifestResources || [],\n    releaseNotes,\n  };\n  returnData.dataModel[helmGroup.id] = dataModel;\n  returnData.groups.push(helmGroup);\n\n  return returnData;\n};\n\nexport const getHelmTopologyDataModel = (\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  installedOperators,\n  utils: Function[],\n  transformBy: string[],\n  serviceBindingRequests: K8sResourceKind[],\n  helmResourcesMap?: HelmReleaseResourcesMap,\n): TopologyDataModel => {\n  const helmDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const helmResources = {};\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  const secrets = _.get(resources, 'secrets.data', []);\n  _.forEach(transformBy, (key) => {\n    helmResources[key] = [];\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data).forEach((item) => {\n        const { obj: deploymentConfig } = item;\n        const uid = _.get(deploymentConfig, ['metadata', 'uid']);\n        if (isHelmReleaseNode(deploymentConfig, helmResourcesMap)) {\n          helmResources[key].push(uid);\n          typedDataModel.topology[uid] = createTopologyNodeData(\n            item,\n            TYPE_HELM_WORKLOAD,\n            getImageForIconClass(`icon-openshift`),\n          );\n          typedDataModel.graph.nodes.push(\n            getTopologyNodeItem(deploymentConfig, TYPE_HELM_WORKLOAD),\n          );\n          typedDataModel.graph.edges.push(\n            ...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests),\n          );\n          const { groups, dataModel } = getTopologyHelmReleaseGroupItem(\n            deploymentConfig,\n            helmResourcesMap,\n            secrets,\n          );\n          mergeGroups(groups, typedDataModel.graph.groups);\n          typedDataModel.topology = _.merge(typedDataModel.topology, dataModel);\n        }\n      });\n      addToTopologyDataModel(typedDataModel, helmDataModel);\n    }\n  });\n\n  _.forEach(transformBy, (key) => {\n    if (!_.isEmpty(resources[key].data) && !_.isEmpty(helmResources[key])) {\n      resources[key].data = resources[key].data.filter(\n        (resource) => !helmResources[key].find((uid) => uid === resource.metadata.uid),\n      );\n    }\n  });\n  return helmDataModel;\n};\n","import { NodeModel, EdgeModel } from '@console/topology';\nimport { TopologyFilters as Filters } from '../filters';\nimport {\n  TopologyDataModel as DataModel,\n  TopologyDataObject,\n  Node,\n  Group,\n  Edge,\n} from '../topology-types';\nimport {\n  TYPE_HELM_RELEASE,\n  HELM_GROUP_WIDTH,\n  HELM_GROUP_HEIGHT,\n  HELM_GROUP_PADDING,\n} from './components/const';\nimport { dataObjectFromModel } from '../data-transforms/transform-utils';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getHelmGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_HELM_RELEASE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.nodes.map((id) => model.topology[id]);\n\n    return {\n      width: HELM_GROUP_WIDTH,\n      height: HELM_GROUP_HEIGHT,\n      id: d.id,\n      group: true,\n      type: d.type,\n      visible: true,\n      collapsed: filters && !filters.display.helmGrouping,\n      data,\n      children: d.nodes,\n      label: d.name,\n      style: {\n        padding: HELM_GROUP_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getHelmNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getHelmEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","export * from './topology-types';\nexport * from './topology-utils';\nexport * from './data-transforms';\nexport * from './components';\nexport * from './filters';\n","import { GROUP_HEIGHT, GROUP_PADDING, GROUP_WIDTH } from '../../components/const';\n\nexport const TYPE_OPERATOR_BACKED_SERVICE = 'operator-backed-service';\nexport const TYPE_OPERATOR_WORKLOAD = 'operator-workload';\n\nexport const OPERATOR_GROUP_WIDTH = GROUP_WIDTH;\nexport const OPERATOR_GROUP_HEIGHT = GROUP_HEIGHT;\nexport const OPERATOR_GROUP_PADDING = GROUP_PADDING;\n","import * as _ from 'lodash';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport {\n  getDefaultOperatorIcon,\n  getImageForCSVIcon,\n  getOperatorBackedServiceKindMap,\n} from '@console/shared/src';\nimport { ClusterServiceVersionKind } from '@console/operator-lifecycle-manager/src';\nimport { TopologyDataModel, TopologyDataResources } from '../topology-types';\nimport { TYPE_OPERATOR_BACKED_SERVICE, TYPE_OPERATOR_WORKLOAD } from './components/const';\nimport {\n  addToTopologyDataModel,\n  createInstanceForResource,\n  createTopologyNodeData,\n  getTopologyEdgeItems,\n  getTopologyGroupItems,\n  getTopologyNodeItem,\n  mergeGroup,\n} from '../data-transforms/transform-utils';\n\nexport const getOperatorTopologyDataModel = (\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  installedOperators: ClusterServiceVersionKind[],\n  utils: Function[],\n  transformBy: string[],\n  serviceBindingRequests: K8sResourceKind[],\n): TopologyDataModel => {\n  const operatorsDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(installedOperators);\n  const operatorMap = {};\n  const obsGroups = {};\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  _.forEach(transformBy, (key) => {\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data, true).forEach((item) => {\n        const { obj: deploymentConfig } = item;\n        const uid = deploymentConfig?.metadata?.uid;\n        const ownerReference = deploymentConfig?.metadata?.ownerReferences?.[0];\n        const ownerUid = ownerReference?.uid;\n        const nodeResourceKind = ownerReference?.kind;\n        const operatorBackedServiceKind = operatorBackedServiceKindMap?.[nodeResourceKind];\n        const appGroup = deploymentConfig?.metadata?.labels?.['app.kubernetes.io/part-of'];\n        let operator: K8sResourceKind = _.find(installedOperators, {\n          metadata: { uid: ownerUid },\n        }) as K8sResourceKind;\n\n        if (_.isEmpty(operator)) {\n          operator = operatorBackedServiceKind;\n        }\n\n        const csvIcon = operatorBackedServiceKind?.spec?.icon?.[0] || operator?.spec?.icon?.[0];\n\n        const operatorName = appGroup\n          ? `${appGroup}:${operator.metadata.name}`\n          : operator.metadata.name;\n        typedDataModel.topology[uid] = createTopologyNodeData(\n          item,\n          TYPE_OPERATOR_BACKED_SERVICE,\n          getImageForCSVIcon(csvIcon) || getDefaultOperatorIcon(),\n          true,\n        );\n        typedDataModel.graph.nodes.push(\n          getTopologyNodeItem(deploymentConfig, TYPE_OPERATOR_WORKLOAD),\n        );\n        typedDataModel.graph.edges.push(\n          ...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests),\n        );\n        operatorMap[operatorName] = _.merge({}, operator, {\n          metadata: {\n            uid: `${operatorName}:${operator.metadata.uid}`,\n          },\n        });\n        if (!(operatorName in obsGroups)) {\n          obsGroups[operatorName] = [];\n        }\n        obsGroups[operatorName].push(deploymentConfig.metadata.uid);\n        if (appGroup) {\n          const newGroup = getTopologyGroupItems(\n            _.merge({}, deploymentConfig, {\n              metadata: {\n                uid: `${operatorName}:${operator.metadata.uid}`,\n              },\n            }),\n          );\n          mergeGroup(newGroup, typedDataModel.graph.groups);\n        }\n      });\n      addToTopologyDataModel(typedDataModel, operatorsDataModel);\n    }\n  });\n\n  _.forIn(obsGroups, (children, grp) => {\n    const groupDataModel: TopologyDataModel = {\n      graph: { nodes: [], edges: [], groups: [] },\n      topology: {},\n    };\n    groupDataModel.graph.nodes.push(\n      getTopologyNodeItem(operatorMap[grp], TYPE_OPERATOR_BACKED_SERVICE, children),\n    );\n\n    groupDataModel.topology[operatorMap[grp].metadata.uid] = {\n      id: operatorMap[grp].metadata.uid,\n      name: operatorMap[grp].metadata.name,\n      type: TYPE_OPERATOR_BACKED_SERVICE,\n      resources: {\n        obj: operatorMap[grp],\n        buildConfigs: [],\n        routes: [],\n        services: [],\n        isOperatorBackedService: true,\n      },\n      operatorBackedService: true,\n      data: {\n        builderImage:\n          getImageForCSVIcon(operatorMap?.[grp]?.spec?.icon?.[0]) || getDefaultOperatorIcon(),\n      },\n    };\n    addToTopologyDataModel(groupDataModel, operatorsDataModel);\n  });\n\n  _.forEach(transformBy, (key) => {\n    const operatorResources = transformResourceData[key](resources[key].data, true);\n    if (!_.isEmpty(resources[key].data) && !_.isEmpty(operatorResources)) {\n      resources[key].data = resources[key].data.filter(\n        (resource) =>\n          !operatorResources.find(\n            (operatorResource) => operatorResource.obj.metadata.uid === resource.metadata.uid,\n          ),\n      );\n    }\n  });\n\n  return operatorsDataModel;\n};\n","import { NodeModel, EdgeModel } from '@console/topology';\nimport { TopologyFilters as Filters } from '../filters';\nimport {\n  TopologyDataModel as DataModel,\n  TopologyDataObject,\n  Node,\n  Group,\n  Edge,\n} from '../topology-types';\nimport {\n  TYPE_OPERATOR_BACKED_SERVICE,\n  OPERATOR_GROUP_WIDTH,\n  OPERATOR_GROUP_HEIGHT,\n  OPERATOR_GROUP_PADDING,\n} from './components/const';\nimport { dataObjectFromModel } from '../data-transforms/transform-utils';\nimport { NodeShape } from '@console/topology/src/types';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getOperatorGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getOperatorNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_OPERATOR_BACKED_SERVICE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.children && d.children.map((id) => model.topology[id]);\n    return {\n      width: OPERATOR_GROUP_WIDTH,\n      height: OPERATOR_GROUP_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: model.topology[d.id].name,\n      data,\n      visible: true,\n      collapsed:\n        filters && d.type === TYPE_OPERATOR_BACKED_SERVICE && !filters.display.operatorGrouping,\n      children: d.children,\n      group: true,\n      shape: NodeShape.rect,\n      style: {\n        padding: OPERATOR_GROUP_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getOperatorEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","import { ComponentType } from 'react';\nimport { FirehoseResult, KebabOption } from '@console/internal/components/utils';\nimport { ExtPodKind, OverviewItem, PodControllerOverviewItem } from '@console/shared';\nimport { DeploymentKind, K8sResourceKind, PodKind, EventKind } from '@console/internal/module/k8s';\nimport { Pipeline, PipelineRun } from '../../utils/pipeline-augment';\nimport { Node as TopologyNode, EventListener } from '@console/topology/src/types';\n\nexport type Point = [number, number];\n\nexport interface TopologyDataResources {\n  replicationControllers: FirehoseResult;\n  pods: FirehoseResult<PodKind[]>;\n  deploymentConfigs: FirehoseResult;\n  services: FirehoseResult;\n  routes: FirehoseResult;\n  deployments: FirehoseResult<DeploymentKind[]>;\n  replicaSets: FirehoseResult;\n  buildConfigs: FirehoseResult;\n  builds: FirehoseResult;\n  daemonSets?: FirehoseResult;\n  secrets?: FirehoseResult;\n  ksroutes?: FirehoseResult;\n  configurations?: FirehoseResult;\n  revisions?: FirehoseResult;\n  ksservices?: FirehoseResult;\n  statefulSets?: FirehoseResult;\n  pipelines?: FirehoseResult;\n  pipelineRuns?: FirehoseResult;\n  eventSourceCronjob?: FirehoseResult;\n  eventSourceContainers?: FirehoseResult;\n  eventSourceApiserver?: FirehoseResult;\n  eventSourceCamel?: FirehoseResult;\n  eventSourceKafka?: FirehoseResult;\n  eventSourceSinkbinding?: FirehoseResult;\n  clusterServiceVersions?: FirehoseResult;\n  events?: FirehoseResult<EventKind[]>;\n  // TODO: Plugin?\n  serviceBindingRequests?: FirehoseResult;\n  virtualmachines?: FirehoseResult;\n  virtualmachineinstances?: FirehoseResult;\n  virtualmachinetemplates?: FirehoseResult;\n  migrations?: FirehoseResult;\n  dataVolumes?: FirehoseResult;\n  vmImports?: FirehoseResult;\n}\n\nexport interface Node {\n  id: string;\n  type?: string;\n  name?: string;\n  children?: string[];\n  data?: {};\n}\n\nexport interface Edge {\n  id?: string;\n  type?: string;\n  source: string;\n  target: string;\n  data?: { [key: string]: any };\n}\n\nexport interface Group {\n  id?: string;\n  type?: string;\n  name: string;\n  nodes: string[];\n}\n\nexport interface GraphModel {\n  nodes: Node[];\n  edges: Edge[];\n  groups: Group[];\n}\n\nexport interface TopologyDataMap {\n  [id: string]: TopologyDataObject;\n}\n\nexport interface TopologyDataModel {\n  graph: GraphModel;\n  topology: TopologyDataMap;\n}\n\nexport type TopologyOverviewItem = OverviewItem & {\n  pipelines?: Pipeline[];\n  pipelineRuns?: PipelineRun[];\n};\n\nexport interface TopologyDataObject<D = {}> {\n  id: string;\n  name: string;\n  type: string;\n  resources: OverviewItem;\n  pods?: ExtPodKind[];\n  data: D;\n  operatorBackedService: boolean;\n  groupResources?: TopologyDataObject[];\n}\n\nexport interface TopologyApplicationObject {\n  id: string;\n  name: string;\n  resources: TopologyDataObject[];\n}\n\nexport interface ConnectedWorkloadPipeline {\n  pipeline: Pipeline;\n  pipelineRuns: PipelineRun[];\n}\n\nexport interface WorkloadData {\n  url?: string;\n  editURL?: string;\n  vcsURI?: string;\n  builderImage?: string;\n  kind?: string;\n  isKnativeResource?: boolean;\n  build: K8sResourceKind;\n  donutStatus: DonutStatusData;\n  connectedPipeline: ConnectedWorkloadPipeline;\n}\n\nexport interface DonutStatusData {\n  pods: ExtPodKind[];\n  current: PodControllerOverviewItem;\n  previous: PodControllerOverviewItem;\n  dc: K8sResourceKind;\n  isRollingOut: boolean;\n}\n\nexport interface GraphApi {\n  zoomIn(): void;\n  zoomOut(): void;\n  zoomReset(): void;\n  zoomFit(): void;\n  resetLayout(): void;\n}\n\nexport enum GraphElementType {\n  node = 'node',\n  edge = 'edge',\n  group = 'group',\n}\n\nexport interface Selectable {\n  selected?: boolean;\n  onSelect?(): void;\n}\n\nexport interface GroupElementInterface {\n  isPointInGroup: (p: Point) => boolean;\n}\n\nexport type ViewNode = {\n  id: string;\n  type?: string;\n  x: number;\n  y: number;\n  size: number;\n  name: string;\n  fx?: number;\n  fy?: number;\n};\n\nexport type ViewEdge = {\n  id: string;\n  type?: string;\n  nodeSize: number;\n  source: ViewNode;\n  target: ViewNode;\n};\n\nexport type ViewGroup = {\n  id: string;\n  type?: string;\n  name: string;\n  nodes: ViewNode[];\n  element?: GroupElementInterface;\n};\n\nexport type NodeProps<D = {}> = ViewNode &\n  Selectable & {\n    data?: TopologyDataObject<D>;\n    dragActive?: boolean;\n    isDragging?: boolean;\n    isTarget?: boolean;\n    onHover?(hovered: boolean): void;\n  };\n\nexport type DragConnectionProps = NodeProps & {\n  dragX: number;\n  dragY: number;\n  isDragging?: boolean;\n  onHover?(hovered: boolean): void;\n};\n\nexport type EdgeProps<D = {}> = ViewEdge & {\n  data?: TopologyDataObject<D>;\n  dragActive?: boolean;\n  isDragging?: boolean;\n  targetArrowRef?(ref: SVGPathElement): void;\n  onRemove?: () => void;\n};\n\nexport type GroupProps = ViewGroup &\n  Selectable & {\n    dragActive?: boolean;\n    dropSource?: boolean;\n    dropTarget?: boolean;\n    groupRef(element: GroupElementInterface): void;\n  };\n\nexport type TrafficData = {\n  nodes: KialiNode[];\n  edges: KialiEdge[];\n};\n\nexport type KialiNode = {\n  data: {\n    id: string;\n    nodeType: string;\n    namespace: string;\n    workload: string;\n    app: string;\n    version?: string;\n    destServices?: { [key: string]: any }[];\n    traffic?: { [key: string]: any }[];\n  };\n};\n\nexport type KialiEdge = {\n  data: {\n    id: string;\n    source: string;\n    target: string;\n    traffic: { [key: string]: any };\n  };\n};\n\nexport type ConnectsToData = { apiVersion: string; kind: string; name: string };\n\nexport type NodeProvider = (type: string) => ComponentType<NodeProps>;\n\nexport type EdgeProvider = (type: string) => ComponentType<EdgeProps>;\n\nexport type GroupProvider = (type: string) => ComponentType<GroupProps>;\n\nexport type ActionProvider = (type: GraphElementType, id: string) => KebabOption[];\n\nexport type ContextMenuProvider = {\n  open: (type: GraphElementType, id: string, eventX: number, eventY: number) => boolean;\n};\n\nexport type GraphData = {\n  namespace: string;\n  createResourceAccess: string[];\n  eventSourceEnabled: boolean;\n};\n\nexport const SHOW_GROUPING_HINT_EVENT = 'show-regroup-hint';\nexport type ShowGroupingHintEventListener = EventListener<[TopologyNode, string]>;\n","import * as _ from 'lodash';\nimport { K8sResourceKind, modelFor, referenceFor } from '@console/internal/module/k8s';\nimport { RootState } from '@console/internal/redux';\nimport { getRouteWebURL } from '@console/internal/components/routes';\nimport { OverviewItem } from '@console/shared';\nimport {\n  createResourceConnection,\n  updateResourceApplication,\n  removeResourceConnection,\n  createServiceBinding,\n  removeServiceBinding,\n} from '../../utils/application-utils';\nimport { TopologyDataObject } from './topology-types';\nimport { TYPE_OPERATOR_BACKED_SERVICE } from './operators/components/const';\nimport { HelmReleaseResourcesMap } from '../helm/helm-types';\nimport { ALLOW_SERVICE_BINDING } from '../../const';\n\nexport const allowedResources = ['deployments', 'deploymentConfigs', 'daemonSets', 'statefulSets'];\n\nexport const getServiceBindingStatus = ({ FLAGS }: RootState): boolean =>\n  FLAGS.get(ALLOW_SERVICE_BINDING);\n\nexport const getCheURL = (consoleLinks: K8sResourceKind[]) =>\n  _.get(_.find(consoleLinks, ['metadata.name', 'che']), 'spec.href', '');\n\nexport const getEditURL = (gitURL: string, cheURL: string) => {\n  return gitURL && cheURL ? `${cheURL}/f?url=${gitURL}&policies.create=peruser` : gitURL;\n};\n\nexport const getHelmReleaseKey = (resource) => `${resource.kind}---${resource.metadata.name}`;\n\nexport const isHelmReleaseNode = (\n  obj: K8sResourceKind,\n  helmResourcesMap: HelmReleaseResourcesMap,\n): boolean => {\n  if (helmResourcesMap) {\n    return helmResourcesMap.hasOwnProperty(getHelmReleaseKey(obj));\n  }\n  return false;\n};\n\nexport const getKialiLink = (consoleLinks: K8sResourceKind[], namespace: string): string => {\n  const kialiLink = _.find(consoleLinks, ['metadata.name', `kiali-namespace-${namespace}`])?.spec\n    ?.href;\n  return kialiLink || '';\n};\n\n/**\n * filter data based on the active application\n */\nexport const filterBasedOnActiveApplication = (\n  data: K8sResourceKind[],\n  application: string,\n): K8sResourceKind[] => {\n  const PART_OF = 'app.kubernetes.io/part-of';\n  if (!application) {\n    return data;\n  }\n  return data.filter((dc) => {\n    return _.get(dc, ['metadata', 'labels', PART_OF]) === application;\n  });\n};\n\n/**\n * get the route data\n */\nconst getRouteData = (ksroutes: K8sResourceKind[], resource: OverviewItem): string => {\n  if (ksroutes && ksroutes.length > 0 && !_.isEmpty(ksroutes[0].status)) {\n    const trafficData = _.find(ksroutes[0].status.traffic, {\n      revisionName: resource.obj.metadata.name,\n    });\n    return _.get(trafficData, 'url', ksroutes[0].status.url);\n  }\n  return null;\n};\n\n/**\n * get routes url\n */\nexport const getRoutesURL = (resource: OverviewItem): string => {\n  const { routes, ksroutes } = resource;\n  if (routes.length > 0 && !_.isEmpty(routes[0].spec)) {\n    return getRouteWebURL(routes[0]);\n  }\n  return getRouteData(ksroutes, resource);\n};\n\nexport const getTopologyResourceObject = (topologyObject: TopologyDataObject): K8sResourceKind => {\n  if (!topologyObject) {\n    return null;\n  }\n  return _.get(topologyObject, ['resources', 'obj']);\n};\n\nexport const updateTopologyResourceApplication = (\n  item: TopologyDataObject,\n  application: string,\n): Promise<any> => {\n  if (!item || !_.size(item.resources)) {\n    return Promise.reject();\n  }\n\n  const resources: K8sResourceKind[] = [];\n  const updates: Promise<any>[] = [];\n\n  resources.push(getTopologyResourceObject(item));\n\n  if (item.type === TYPE_OPERATOR_BACKED_SERVICE) {\n    _.forEach(item.groupResources, (groupResource) => {\n      resources.push(getTopologyResourceObject(groupResource));\n    });\n  }\n\n  for (const resource of resources) {\n    const resourceKind = modelFor(referenceFor(resource));\n    if (!resourceKind) {\n      return Promise.reject(\n        new Error(`Unable to update application, invalid resource type: ${resource.kind}`),\n      );\n    }\n    updates.push(updateResourceApplication(resourceKind, resource, application));\n  }\n\n  return Promise.all(updates);\n};\n\nexport const createTopologyResourceConnection = (\n  source: TopologyDataObject,\n  target: TopologyDataObject,\n  replaceTarget: TopologyDataObject = null,\n  serviceBindingFlag: boolean,\n): Promise<K8sResourceKind[] | K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject(new Error('Can not create a connection from a node to itself.'));\n  }\n\n  const sourceObj = getTopologyResourceObject(source);\n  const targetObj = getTopologyResourceObject(target);\n  const replaceTargetObj = replaceTarget && getTopologyResourceObject(replaceTarget);\n\n  if (serviceBindingFlag && target.operatorBackedService) {\n    if (replaceTarget) {\n      return new Promise<K8sResourceKind[] | K8sResourceKind>((resolve, reject) => {\n        createServiceBinding(sourceObj, targetObj)\n          .then(() => {\n            // eslint-disable-next-line promise/no-nesting\n            removeResourceConnection(sourceObj, replaceTargetObj)\n              .then(resolve)\n              .catch(reject);\n          })\n          .catch(reject);\n      });\n    }\n\n    return createServiceBinding(sourceObj, targetObj);\n  }\n\n  return createResourceConnection(sourceObj, targetObj, replaceTargetObj);\n};\n\nexport const removeTopologyResourceConnection = (\n  source: TopologyDataObject,\n  target: TopologyDataObject,\n  sbr: K8sResourceKind,\n  edgeType: string,\n): Promise<any> => {\n  if (!source || !target) {\n    return Promise.reject();\n  }\n\n  const sourceObj = getTopologyResourceObject(source);\n  const targetObj = getTopologyResourceObject(target);\n\n  if (edgeType === 'service-binding') {\n    return removeServiceBinding(sbr);\n  }\n\n  return removeResourceConnection(sourceObj, targetObj);\n};\n","import {\n  DEFAULT_GROUP_PAD,\n  GROUP_WIDTH,\n} from '@console/dev-console/src/components/topology/components/const';\n\nexport const TYPE_EVENT_SOURCE = 'event-source';\nexport const TYPE_EVENT_SOURCE_LINK = 'event-source-link';\nexport const TYPE_KNATIVE_SERVICE = 'knative-service';\nexport const TYPE_REVISION_TRAFFIC = 'revision-traffic';\nexport const TYPE_KNATIVE_REVISION = 'knative-revision';\n\nexport const KNATIVE_GROUP_NODE_WIDTH = GROUP_WIDTH;\nexport const KNATIVE_GROUP_NODE_HEIGHT = 100;\nexport const KNATIVE_GROUP_NODE_PADDING = [\n  DEFAULT_GROUP_PAD,\n  DEFAULT_GROUP_PAD,\n  DEFAULT_GROUP_PAD + 10,\n  DEFAULT_GROUP_PAD,\n];\n","import * as _ from 'lodash';\nimport { getOperatorBackedServiceKindMap, OperatorBackedServiceKindMap } from '@console/shared';\nimport { DeploymentKind, K8sResourceKind } from '@console/internal/module/k8s';\nimport { ClusterServiceVersionKind } from '@console/operator-lifecycle-manager';\nimport {\n  TopologyDataModel,\n  TopologyDataResources,\n  addToTopologyDataModel,\n} from '@console/dev-console/src/components/topology';\nimport { getDynamicEventSourcesModelRefs } from '../utils/fetch-dynamic-eventsources-utils';\nimport { NodeType, transformKnNodeData } from './knative-topology-utils';\n\n/**\n * Filter out deployments not created via revisions/eventsources\n */\nexport const filterNonKnativeDeployments = (\n  resources: DeploymentKind[],\n  eventSources?: K8sResourceKind[],\n): DeploymentKind[] => {\n  const KNATIVE_CONFIGURATION = 'serving.knative.dev/configuration';\n  const isEventSourceKind = (uid: string): boolean =>\n    uid && !!eventSources?.find((eventSource) => eventSource.metadata?.uid === uid);\n  return _.filter(resources, (d) => {\n    return (\n      !_.get(d, ['metadata', 'labels', KNATIVE_CONFIGURATION], false) &&\n      !isEventSourceKind(d.metadata?.ownerReferences?.[0].uid)\n    );\n  });\n};\n\nconst addKnativeTopologyData = (\n  topologyDataModel: TopologyDataModel,\n  knativeResources: K8sResourceKind[],\n  allResources: K8sResourceKind[],\n  type: string,\n  resources: TopologyDataResources,\n  operatorBackedServiceKindMap: OperatorBackedServiceKindMap,\n  utils: Function[],\n) => {\n  if (!knativeResources?.length) {\n    return;\n  }\n\n  const knativeResourceDataModel = transformKnNodeData(\n    knativeResources,\n    type,\n    resources,\n    allResources,\n    operatorBackedServiceKindMap,\n    utils,\n  );\n\n  addToTopologyDataModel(knativeResourceDataModel, topologyDataModel);\n};\n\nconst getKnativeEventSources = (resources: TopologyDataResources): K8sResourceKind[] => {\n  const evenSourceProps = getDynamicEventSourcesModelRefs();\n  return evenSourceProps.reduce((acc, currProp) => {\n    const currPropResource = resources[currProp]?.data ?? [];\n    return [...acc, ...currPropResource];\n  }, []);\n};\n\nexport const getKnativeTopologyDataModel = (\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  installedOperators: ClusterServiceVersionKind[],\n  utils?: Function[],\n): TopologyDataModel => {\n  const knativeTopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(installedOperators);\n  const knSvcResources: K8sResourceKind[] = _.get(resources, ['ksservices', 'data'], []);\n  const knEventSources: K8sResourceKind[] = getKnativeEventSources(resources);\n  const knRevResources: K8sResourceKind[] = _.get(resources, ['revisions', 'data'], []);\n\n  addKnativeTopologyData(\n    knativeTopologyDataModel,\n    knSvcResources,\n    allResources,\n    NodeType.KnService,\n    resources,\n    operatorBackedServiceKindMap,\n    utils,\n  );\n  addKnativeTopologyData(\n    knativeTopologyDataModel,\n    knEventSources,\n    allResources,\n    NodeType.EventSource,\n    resources,\n    operatorBackedServiceKindMap,\n    utils,\n  );\n  addKnativeTopologyData(\n    knativeTopologyDataModel,\n    knRevResources,\n    allResources,\n    NodeType.Revision,\n    resources,\n    operatorBackedServiceKindMap,\n    utils,\n  );\n\n  const deploymentResources: DeploymentKind[] = _.get(resources, ['deployments', 'data'], []);\n  resources.deployments.data = filterNonKnativeDeployments(deploymentResources, knEventSources);\n\n  return knativeTopologyDataModel;\n};\n","import { EdgeModel, NodeModel, NodeShape } from '@console/topology';\nimport {\n  TopologyDataModel as DataModel,\n  TopologyDataObject,\n  dataObjectFromModel,\n  Group,\n  Node,\n  Edge,\n  NODE_HEIGHT,\n  NODE_PADDING,\n  NODE_WIDTH,\n  TopologyFilters as Filters,\n} from '@console/dev-console/src/components/topology';\nimport {\n  KNATIVE_GROUP_NODE_HEIGHT,\n  KNATIVE_GROUP_NODE_PADDING,\n  KNATIVE_GROUP_NODE_WIDTH,\n  TYPE_EVENT_SOURCE,\n  TYPE_KNATIVE_SERVICE,\n} from './const';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKnativeGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\nexport const getKnativeNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_EVENT_SOURCE) {\n    const hidden = filters && !filters.display.eventSources;\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      visible: !hidden,\n      label: model.topology[d.id].name,\n      data: model.topology[d.id],\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  }\n  if (d.type === TYPE_KNATIVE_SERVICE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.children && d.children.map((id) => model.topology[id]);\n    return {\n      width: KNATIVE_GROUP_NODE_WIDTH,\n      height: KNATIVE_GROUP_NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      visible: true,\n      label: model.topology[d.id].name,\n      data,\n      collapsed: filters && !filters.display.knativeServices,\n      children: d.children,\n      group: true,\n      shape: NodeShape.rect,\n      style: {\n        padding: KNATIVE_GROUP_NODE_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKnativeEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","import * as _ from 'lodash';\nimport { Node as TopologyNode } from '@console/topology';\nimport {\n  K8sResourceKind,\n  apiVersionForModel,\n  referenceFor,\n  modelFor,\n  k8sUpdate,\n  PodKind,\n} from '@console/internal/module/k8s';\nimport {\n  TransformResourceData,\n  getResourcePausedAlert,\n  getBuildAlerts,\n  getOwnedResources,\n  OperatorBackedServiceKindMap,\n  getBuildConfigsForResource,\n} from '@console/shared';\nimport {\n  Node,\n  Edge,\n  TopologyDataResources,\n  TopologyDataModel,\n  TopologyDataObject,\n  getTopologyGroupItems,\n  createTopologyNodeData,\n  getTopologyNodeItem,\n  getTopologyEdgeItems,\n  mergeGroup,\n  filterBasedOnActiveApplication,\n  getTopologyResourceObject,\n  TopologyOverviewItem,\n} from '@console/dev-console/src/components/topology';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { DeploymentModel } from '@console/internal/models';\nimport { RootState } from '@console/internal/redux';\nimport { FLAG_KNATIVE_EVENTING } from '../const';\nimport { ServiceModel as knServiceModel } from '../models';\nimport { KnativeItem } from '../utils/get-knative-resources';\n\nexport enum NodeType {\n  EventSource = 'event-source',\n  KnService = 'knative-service',\n  Revision = 'knative-revision',\n}\n\nexport enum EdgeType {\n  Traffic = 'revision-traffic',\n  EventSource = 'event-source-link',\n}\n\ntype RevK8sResourceKind = K8sResourceKind & {\n  resources?: { [key: string]: any };\n};\n/**\n * returns if event source is enabled or not\n * @param Flags\n */\nexport const getEventSourceStatus = ({ FLAGS }: RootState): boolean =>\n  FLAGS.get(FLAG_KNATIVE_EVENTING);\n\n/**\n * fetch the parent resource from a resource\n * @param resource\n * @param resources\n */\nexport const getParentResource = (\n  resource: K8sResourceKind,\n  resources: K8sResourceKind[],\n): K8sResourceKind => {\n  const parentUids = _.map(\n    _.get(resource, ['metadata', 'ownerReferences'], []),\n    (owner) => owner.uid,\n  );\n  const [resourcesParent] = _.filter(resources, ({ metadata: { uid } }) =>\n    parentUids.includes(uid),\n  );\n  return resourcesParent;\n};\n\n/**\n * Filters revision based on active application\n * @param revisions\n * @param resources\n * @param application\n */\nexport const filterRevisionsByActiveApplication = (\n  revisions: K8sResourceKind[],\n  resources: TopologyDataResources,\n  application: string,\n) => {\n  const filteredRevisions = [];\n  _.forEach(revisions, (revision) => {\n    const configuration = getParentResource(revision, resources.configurations.data);\n    const service = getParentResource(configuration, resources.ksservices.data);\n    const hasTraffic =\n      service &&\n      service.status &&\n      _.find(service.status.traffic, { revisionName: revision.metadata.name });\n    const isServicePartofGroup = filterBasedOnActiveApplication([service], application).length > 0;\n    if (hasTraffic && isServicePartofGroup) {\n      filteredRevisions.push(revision);\n    }\n  });\n  return filteredRevisions;\n};\n\n/**\n * Forms data with respective revisions, configurations, routes based on kntaive service\n */\nexport const getKnativeServiceData = (\n  resource: K8sResourceKind,\n  resources: TopologyDataResources,\n  utils?: Function[],\n): KnativeItem => {\n  const configurations = getOwnedResources(resource, resources.configurations.data);\n  const revisions =\n    configurations && configurations.length\n      ? getOwnedResources(configurations[0], resources.revisions.data)\n      : undefined;\n  const revisionsDeploymentData = _.reduce(\n    revisions,\n    (acc, revision) => {\n      let revisionDep: RevK8sResourceKind = revision;\n      let pods: PodKind[];\n      if (resources.deployments) {\n        const transformResourceData = new TransformResourceData(resources);\n        const associatedDeployment = getOwnedResources(revision, resources.deployments.data);\n        if (!_.isEmpty(associatedDeployment)) {\n          const depObj: K8sResourceKind = {\n            ...associatedDeployment[0],\n            apiVersion: apiVersionForModel(DeploymentModel),\n            kind: DeploymentModel.kind,\n          };\n          const replicaSets = transformResourceData.getReplicaSetsForResource(depObj);\n          const [current, previous] = replicaSets;\n          pods = [..._.get(current, 'pods', []), ..._.get(previous, 'pods', [])];\n          revisionDep = { ...revisionDep, resources: { pods, current } };\n        }\n      }\n      acc.revisionsDep.push(revisionDep);\n      pods && acc.allPods.push(...pods);\n      return acc;\n    },\n    { revisionsDep: [], allPods: [] },\n  );\n  const ksroutes = resources.ksroutes\n    ? getOwnedResources(resource, resources.ksroutes.data)\n    : undefined;\n  const buildConfigs = getBuildConfigsForResource(resource, resources);\n  const overviewItem = {\n    configurations,\n    revisions: revisionsDeploymentData.revisionsDep,\n    ksroutes,\n    buildConfigs,\n    pods: revisionsDeploymentData.allPods,\n  };\n  if (utils) {\n    return utils.reduce((acc, element) => {\n      return { ...acc, ...element(resource, resources) };\n    }, overviewItem);\n  }\n  return overviewItem;\n};\n\n/**\n * Rollup data for deployments for revisions/ event sources\n */\nconst createKnativeDeploymentItems = (\n  resource: K8sResourceKind,\n  resources: TopologyDataResources,\n  utils?: Function[],\n): TopologyOverviewItem => {\n  const transformResourceData = new TransformResourceData(resources, utils);\n  const associatedDeployment = getOwnedResources(resource, resources.deployments.data);\n  if (!_.isEmpty(associatedDeployment)) {\n    const depObj: K8sResourceKind = {\n      ...associatedDeployment[0],\n      apiVersion: apiVersionForModel(DeploymentModel),\n      kind: DeploymentModel.kind,\n    };\n    const replicaSets = transformResourceData.getReplicaSetsForResource(depObj);\n    const [current, previous] = replicaSets;\n    const isRollingOut = !!current && !!previous;\n    const buildConfigs = transformResourceData.getBuildConfigsForResource(depObj);\n    const services = transformResourceData.getServicesForResource(depObj);\n    const routes = transformResourceData.getRoutesForServices(services);\n    const alerts = {\n      ...getResourcePausedAlert(depObj),\n      ...getBuildAlerts(buildConfigs),\n    };\n    const overviewItems = {\n      obj: resource,\n      alerts,\n      buildConfigs,\n      current,\n      isRollingOut,\n      previous,\n      pods: [..._.get(current, 'pods', []), ..._.get(previous, 'pods', [])],\n      routes,\n      services,\n    };\n\n    if (utils) {\n      return utils.reduce((acc, element) => {\n        return { ...acc, ...element(depObj, resources) };\n      }, overviewItems);\n    }\n    return overviewItems;\n  }\n  const knResources = getKnativeServiceData(resource, resources, utils);\n  return {\n    obj: resource,\n    buildConfigs: [],\n    routes: [],\n    services: [],\n    ...knResources,\n  };\n};\n\n/**\n * only get revision which are included in traffic data\n */\nexport const filterRevisionsBaseOnTrafficStatus = (\n  resource: K8sResourceKind,\n  revisions: K8sResourceKind[],\n): K8sResourceKind[] => {\n  if (!_.get(resource, 'status.traffic', null)) return undefined;\n  return resource.status.traffic.reduce((acc, curr) => {\n    const el = revisions.find((rev) => curr.revisionName === rev.metadata.name);\n    return el ? [...acc, el] : acc;\n  }, []);\n};\n\n/**\n * Form Node data for revisions/event/service sources\n */\nexport const getKnativeTopologyNodeItems = (\n  resource: K8sResourceKind,\n  type: string,\n  resources?: TopologyDataResources,\n): Node[] => {\n  const nodes = [];\n  const children: string[] = [];\n  if (type === NodeType.KnService && resources && resources.configurations) {\n    const configurations = getOwnedResources(resource, resources.configurations.data);\n    const configUidData = _.get(configurations[0], ['metadata', 'uid']);\n    const ChildData = _.filter(resources.revisions.data, {\n      metadata: {\n        ownerReferences: [{ uid: configUidData }],\n      },\n    });\n    _.forEach(filterRevisionsBaseOnTrafficStatus(resource, ChildData), (c) => {\n      const uidRev = c.metadata.uid;\n      children.push(uidRev);\n      nodes.push(getTopologyNodeItem(c, NodeType.Revision));\n    });\n  }\n  nodes.push(getTopologyNodeItem(resource, type, children));\n  return nodes;\n};\n\n/**\n * Form Edge data for event sources\n */\nexport const getEventTopologyEdgeItems = (resource: K8sResourceKind, { data }): Edge[] => {\n  const uid = _.get(resource, ['metadata', 'uid']);\n  const sinkSvc = _.get(resource, 'spec.sink.ref', null) || _.get(resource, 'spec.sink', null);\n  const edges = [];\n  if (sinkSvc && sinkSvc.kind === knServiceModel.kind) {\n    _.forEach(data, (res) => {\n      const resname = _.get(res, ['metadata', 'name']);\n      const resUid = _.get(res, ['metadata', 'uid']);\n      if (resname === sinkSvc.name) {\n        edges.push({\n          id: `${uid}_${resUid}`,\n          type: EdgeType.EventSource,\n          source: uid,\n          target: resUid,\n        });\n      }\n    });\n  }\n  return edges;\n};\n\n/**\n * Form Edge data for service sources with traffic data\n */\nexport const getTrafficTopologyEdgeItems = (resource: K8sResourceKind, { data }): Edge[] => {\n  const uid = _.get(resource, ['metadata', 'uid']);\n  const trafficSvc = _.get(resource, ['status', 'traffic'], []);\n  const edges = [];\n  _.forEach(trafficSvc, (res) => {\n    const resname = _.get(res, ['revisionName']);\n    const trafficPercent = _.get(res, ['percent']);\n    const revisionObj = _.find(data, (rev) => {\n      const revname = _.get(rev, ['metadata', 'name']);\n      return revname === resname;\n    });\n    const resUid = _.get(revisionObj, ['metadata', 'uid'], null);\n    if (resUid) {\n      const revisionIndex = _.findIndex(edges, (edge) => edge.id === `${uid}_${resUid}`);\n      if (revisionIndex >= 0) {\n        edges[revisionIndex].data.percent += trafficPercent;\n      } else {\n        edges.push({\n          id: `${uid}_${resUid}`,\n          type: EdgeType.Traffic,\n          source: uid,\n          target: resUid,\n          data: { percent: trafficPercent },\n        });\n      }\n    }\n  });\n  return edges;\n};\n\n/**\n * create all data that need to be shown on a topology data for knative service\n */\nexport const createTopologyServiceNodeData = (\n  svcRes: TopologyOverviewItem,\n  operatorBackedServiceKindMap: OperatorBackedServiceKindMap,\n  type: string,\n): TopologyDataObject => {\n  const { pipelines = [], pipelineRuns = [] } = svcRes;\n  const { obj: knativeSvc } = svcRes;\n  const uid = _.get(knativeSvc, 'metadata.uid');\n  const labels = _.get(knativeSvc, 'metadata.labels', {});\n  const annotations = _.get(knativeSvc, 'metadata.annotations', {});\n  const nodeResourceKind = _.get(knativeSvc, 'metadata.ownerReferences[0].kind');\n  return {\n    id: uid,\n    name: _.get(knativeSvc, 'metadata.name') || labels['app.kubernetes.io/instance'],\n    type,\n    resources: { ...svcRes },\n    operatorBackedService: nodeResourceKind in operatorBackedServiceKindMap,\n    data: {\n      url: knativeSvc.status?.url || '',\n      kind: referenceFor(knativeSvc),\n      editURL: annotations['app.openshift.io/edit-url'],\n      vcsURI: annotations['app.openshift.io/vcs-uri'],\n      isKnativeResource: true,\n      connectedPipeline: {\n        pipeline: pipelines[0],\n        pipelineRuns,\n      },\n      build: svcRes.buildConfigs?.[0]?.builds?.[0],\n    },\n  };\n};\n\nexport const transformKnNodeData = (\n  knResourcesData: K8sResourceKind[],\n  type: string,\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  operatorBackedServiceKindMap: OperatorBackedServiceKindMap,\n  utils?: Function[],\n): TopologyDataModel => {\n  const knDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const serviceBindingRequests = _.get(resources, 'serviceBindingRequests.data');\n  _.forEach(knResourcesData, (res) => {\n    const { uid } = res.metadata;\n    const item = createKnativeDeploymentItems(res, resources, utils);\n    switch (type) {\n      case NodeType.EventSource: {\n        knDataModel.topology[uid] = createTopologyNodeData(\n          item,\n          type,\n          getImageForIconClass(`icon-openshift`),\n        );\n        knDataModel.graph.nodes.push(...getKnativeTopologyNodeItems(res, type, resources));\n        knDataModel.graph.edges.push(...getEventTopologyEdgeItems(res, resources.ksservices));\n        const newGroup = getTopologyGroupItems(res);\n        mergeGroup(newGroup, knDataModel.graph.groups);\n        break;\n      }\n      case NodeType.Revision: {\n        const revisionItem = _.omit(item, ['pipelines', 'pipelineRuns', 'buildConfigs']);\n        knDataModel.topology[uid] = createTopologyNodeData(\n          revisionItem,\n          type,\n          getImageForIconClass(`icon-openshift`),\n        );\n        break;\n      }\n      case NodeType.KnService: {\n        knDataModel.topology[uid] = createTopologyServiceNodeData(\n          item,\n          operatorBackedServiceKindMap,\n          type,\n        );\n        knDataModel.graph.nodes.push(...getKnativeTopologyNodeItems(res, type, resources));\n        knDataModel.graph.edges.push(\n          ...getTrafficTopologyEdgeItems(res, resources.revisions),\n          ...getTopologyEdgeItems(res, allResources, serviceBindingRequests),\n        );\n        const newGroup = getTopologyGroupItems(res);\n        mergeGroup(newGroup, knDataModel.graph.groups);\n        break;\n      }\n      default:\n        break;\n    }\n  });\n\n  return knDataModel;\n};\n\nexport const createKnativeEventSourceSink = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n  const targetName = _.get(target, 'metadata.name');\n  const eventSourceObj = _.omit(source, 'status');\n  const sink = {\n    ref: {\n      apiVersion: target.apiVersion,\n      kind: target.kind,\n      name: targetName,\n    },\n  };\n  const updatePayload = {\n    ...eventSourceObj,\n    spec: { ...eventSourceObj.spec, sink },\n  };\n  return k8sUpdate(modelFor(referenceFor(source)), updatePayload);\n};\n\nexport const createTopologySinkConnection = (\n  source: TopologyDataObject,\n  target: TopologyDataObject,\n): Promise<K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n  const sourceObj = getTopologyResourceObject(source);\n  const targetObj = getTopologyResourceObject(target);\n\n  return createKnativeEventSourceSink(sourceObj, targetObj);\n};\n\nexport const createSinkConnection = (\n  sourceNode: TopologyNode,\n  targetNode: TopologyNode,\n): Promise<K8sResourceKind> => {\n  return createTopologySinkConnection(sourceNode.getData(), targetNode.getData());\n};\n","export const TYPE_VIRTUAL_MACHINE = 'virtual-machine';\n","import { apiVersionForModel, K8sResourceKind, referenceFor } from '@console/internal/module/k8s';\nimport {\n  OverviewItem,\n  getRoutesForServices,\n  getBuildConfigsForResource,\n  getReplicationControllersForResource,\n  getServicesForResource,\n} from '@console/shared';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport {\n  TopologyDataModel,\n  TopologyDataObject,\n  TopologyDataResources,\n  getRoutesURL,\n  addToTopologyDataModel,\n  getTopologyEdgeItems,\n  getTopologyGroupItems,\n  getTopologyNodeItem,\n  mergeGroup,\n} from '@console/dev-console/src/components/topology';\nimport { VMIKind, VMKind } from '../types';\nimport { VirtualMachineModel } from '../models';\nimport { TYPE_VIRTUAL_MACHINE } from './components/const';\nimport { findVMIPod } from '../selectors/pod/selectors';\nimport { getVMStatus } from '../statuses/vm/vm-status';\nimport { V1alpha1DataVolume } from '../types/vm/disk/V1alpha1DataVolume';\nimport { VMImportKind } from '../types/vm-import/ovirt/vm-import';\nimport { VMNodeData } from './types';\n\nexport const kubevirtAllowedResources = ['virtualmachines'];\n\nexport const getOperatingSystemImage = (vm: VMKind, templates: K8sResourceKind[]): string => {\n  const templateName = vm.metadata?.labels?.['vm.kubevirt.io/template'];\n  const template = templateName && templates.find((t) => t.metadata.name === templateName);\n  if (!template) {\n    return '';\n  }\n\n  return getImageForIconClass(template.metadata.annotations.iconClass);\n};\n\nexport const createVMOverviewItem = (vm: VMKind, vmi: VMIKind, resources: any): OverviewItem => {\n  const obj: K8sResourceKind = {\n    ...vm,\n    apiVersion: apiVersionForModel(VirtualMachineModel),\n    kind: VirtualMachineModel.kind,\n  };\n  const { visibleReplicationControllers } = getReplicationControllersForResource(obj, resources);\n  const [current, previous] = visibleReplicationControllers;\n  const buildConfigs = getBuildConfigsForResource(obj, resources);\n  const services = getServicesForResource(obj, resources);\n  const routes = getRoutesForServices(services, resources);\n  const laucherPod = findVMIPod(vmi, resources.pods.data);\n  const pods = laucherPod ? [laucherPod] : [];\n  return {\n    buildConfigs,\n    current,\n    obj,\n    previous,\n    pods,\n    routes,\n    services,\n    isMonitorable: false,\n    isOperatorBackedService: false,\n  };\n};\n\nexport const createVMOverviewItems = (resources: any): OverviewItem[] => {\n  if (!resources.virtualmachines?.data.length) {\n    return [];\n  }\n\n  return resources.virtualmachines.data.map((vm: any) => {\n    const { name } = vm.metadata;\n    const vmis = resources.virtualmachineinstances.data;\n    const vmi = vmis.find((instance) => instance.metadata.name === name) as VMIKind;\n\n    return createVMOverviewItem(vm, vmi, resources);\n  });\n};\n\nconst createTopologyVMNodeData = (\n  vmOverview: OverviewItem,\n  resources: TopologyDataResources,\n): TopologyDataObject<VMNodeData> => {\n  const vm = vmOverview.obj as VMKind;\n  const { uid, name, labels } = vm.metadata;\n  const vmis = resources.virtualmachineinstances?.data;\n  const vmi = vmis.find((instance) => instance.metadata.name === name) as VMIKind;\n  const pods = resources.pods?.data;\n  const migrations = resources.migrations?.data;\n  const dataVolumes = resources.dataVolumes?.data as V1alpha1DataVolume[];\n  const vmImports = resources.vmImports?.data as VMImportKind[];\n\n  const vmStatusBundle = getVMStatus({\n    vm,\n    vmi,\n    pods,\n    migrations,\n    dataVolumes,\n    vmImports,\n  });\n\n  return {\n    id: uid,\n    name: name || labels['app.kubernetes.io/instance'],\n    type: TYPE_VIRTUAL_MACHINE,\n    resources: vmOverview,\n    operatorBackedService: false,\n    data: {\n      url: getRoutesURL(vmOverview),\n      kind: referenceFor(vm),\n      vmi,\n      vmStatusBundle,\n      osImage: getOperatingSystemImage(vm as VMKind, resources.virtualmachinetemplates.data),\n    },\n  };\n};\n\nexport const getKubevirtTopologyDataModel = (\n  resources: TopologyDataResources,\n  allResources: K8sResourceKind[],\n  installedOperators,\n  utils: Function[],\n  transformBy: string[],\n  serviceBindingRequests: K8sResourceKind[],\n): TopologyDataModel => {\n  const vmsDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const vmsResources = [];\n\n  if (resources.virtualmachines?.data.length) {\n    const typedDataModel: TopologyDataModel = {\n      graph: { nodes: [], edges: [], groups: [] },\n      topology: {},\n    };\n\n    const vmOverviewItems = createVMOverviewItems(resources);\n    vmOverviewItems.forEach((vmOverview: OverviewItem) => {\n      const vm = vmOverview.obj;\n      const { uid } = vm.metadata;\n      vmsResources.push(uid);\n      typedDataModel.topology[uid] = createTopologyVMNodeData(vmOverview, resources);\n      typedDataModel.graph.nodes.push(getTopologyNodeItem(vm, TYPE_VIRTUAL_MACHINE));\n      typedDataModel.graph.edges.push(\n        ...getTopologyEdgeItems(vm, allResources, serviceBindingRequests),\n      );\n      mergeGroup(getTopologyGroupItems(vm), typedDataModel.graph.groups);\n    });\n\n    addToTopologyDataModel(typedDataModel, vmsDataModel);\n  }\n\n  return vmsDataModel;\n};\n","import { NodeModel, EdgeModel } from '@console/topology';\nimport {\n  TopologyFilters as Filters,\n  TopologyDataModel as DataModel,\n  TopologyDataObject,\n  Node,\n  Group,\n  Edge,\n  dataObjectFromModel,\n  NODE_HEIGHT,\n  NODE_PADDING,\n  NODE_WIDTH,\n} from '@console/dev-console/src/components/topology';\nimport { TYPE_VIRTUAL_MACHINE } from './components/const';\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKubevirtGroupModel = (d: Group, model: DataModel, filters: Filters): NodeModel => {\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKubevirtNodeModel = (d: Node, model: DataModel, filters: Filters): NodeModel => {\n  if (d.type === TYPE_VIRTUAL_MACHINE) {\n    const data: TopologyDataObject = model.topology[d.id] || dataObjectFromModel(d);\n    const hidden = filters && !filters.display.virtualMachines;\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: model.topology[d.id].name,\n      data,\n      visible: !hidden,\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  }\n  return null;\n};\n\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nexport const getKubevirtEdgeModel = (d: Edge, model: DataModel, filters: Filters): EdgeModel => {\n  return null;\n};\n","import * as React from 'react';\nimport { Link } from 'react-router-dom';\nimport * as classNames from 'classnames';\nimport { sortable } from '@patternfly/react-table';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { AddHealthChecks, EditHealthChecks } from '@console/app/src/actions/modify-health-checks';\nimport { K8sResourceKind } from '../module/k8s';\nimport { DetailsPage, ListPage, Table, TableRow, TableData, RowFunction } from './factory';\nimport { AsyncComponent, DetailsItem, Kebab, KebabAction, ContainerTable, detailsPage, LabelList, navFactory, PodsComponent, ResourceKebab, ResourceLink, ResourceSummary, SectionHeading, Selector, LoadingInline } from './utils';\nimport { ResourceEventStream } from './events';\nimport { VolumesTable } from './volumes-table';\nimport { DaemonSetModel } from '../models';\nimport { PodRingController, PodRing } from '@console/shared';\nimport { ResourceLabel } from '../models/hypercloud/resource-plural';\n\nexport const menuActions: KebabAction[] = [AddHealthChecks, Kebab.factory.AddStorage, ...Kebab.getExtensionsActionsForKind(DaemonSetModel), EditHealthChecks, ...Kebab.factory.common];\n\nconst kind = 'DaemonSet';\n\nconst tableColumnClasses = ['', '', classNames('pf-m-hidden', 'pf-m-visible-on-sm', 'pf-u-w-16-on-lg'), classNames('pf-m-hidden', 'pf-m-visible-on-lg'), classNames('pf-m-hidden', 'pf-m-visible-on-lg'), Kebab.columnClass];\n\nconst DaemonSetTableHeader = (t?: TFunction) => {\n  return [\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_1'),\n      sortField: 'metadata.name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_2'),\n      sortField: 'metadata.namespace',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_3'),\n      sortFunc: 'daemonsetNumScheduled',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_15'),\n      sortField: 'metadata.labels',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: t('COMMON:MSG_MAIN_TABLEHEADER_16'),\n      sortField: 'spec.selector',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[4] },\n    },\n    {\n      title: '',\n      props: { className: tableColumnClasses[5] },\n    },\n  ];\n};\nDaemonSetTableHeader.displayName = 'DaemonSetTableHeader';\n\nconst DaemonSetTableRow: RowFunction<K8sResourceKind> = ({ obj: daemonset, index, key, style }) => {\n  return (\n    <TableRow id={daemonset.metadata.uid} index={index} trKey={key} style={style}>\n      <TableData className={tableColumnClasses[0]}>\n        <ResourceLink kind={kind} name={daemonset.metadata.name} namespace={daemonset.metadata.namespace} title={daemonset.metadata.uid} />\n      </TableData>\n      <TableData className={classNames(tableColumnClasses[1], 'co-break-word')}>\n        <ResourceLink kind=\"Namespace\" name={daemonset.metadata.namespace} title={daemonset.metadata.namespace} />\n      </TableData>\n      <TableData className={tableColumnClasses[2]}>\n        <Link to={`/k8s/ns/${daemonset.metadata.namespace}/daemonsets/${daemonset.metadata.name}/pods`} title=\"pods\">\n          {daemonset.status.currentNumberScheduled} of {daemonset.status.desiredNumberScheduled} pods\n        </Link>\n      </TableData>\n      <TableData className={tableColumnClasses[3]}>\n        <LabelList kind={kind} labels={daemonset.metadata.labels} />\n      </TableData>\n      <TableData className={tableColumnClasses[4]}>\n        <Selector selector={daemonset.spec.selector} namespace={daemonset.metadata.namespace} />\n      </TableData>\n      <TableData className={tableColumnClasses[5]}>\n        <ResourceKebab actions={menuActions} kind={kind} resource={daemonset} />\n      </TableData>\n    </TableRow>\n  );\n};\n\nexport const DaemonSetDetailsList: React.FC<DaemonSetDetailsListProps> = ({ ds }) => {\n  const { t } = useTranslation();\n  return (\n    <dl className=\"co-m-pane__details\">\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_38')} obj={ds} path=\"status.currentNumberScheduled\" />\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_39')} obj={ds} path=\"status.desiredNumberScheduled\" />\n    </dl>\n  );\n};\n\nconst DaemonSetDetails: React.FC<DaemonSetDetailsProps> = ({ obj: daemonset }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', { 0: ResourceLabel(daemonset, t) })} />\n        <PodRingController\n          namespace={daemonset.metadata.namespace}\n          kind={daemonset.kind}\n          render={d => {\n            return d.loaded ? <PodRing key={daemonset.metadata.uid} pods={d.data[daemonset.metadata.uid].pods} obj={daemonset} resourceKind={DaemonSetModel} enableScaling={false} /> : <LoadingInline />;\n          }}\n        />\n        <div className=\"row\">\n          <div className=\"col-lg-6\">\n            <ResourceSummary resource={daemonset} showPodSelector showNodeSelector showTolerations />\n          </div>\n          <div className=\"col-lg-6\">\n            <DaemonSetDetailsList ds={daemonset} />\n          </div>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_1')} />\n        <ContainerTable containers={daemonset.spec.template.spec.containers} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <VolumesTable resource={daemonset} heading={t('COMMON:MSG_DETAILS_TABDETAILS_VOLUMES_TABLEHEADER_1')} />\n      </div>\n    </>\n  );\n};\n\nconst EnvironmentPage: React.FC<EnvironmentPageProps> = props => <AsyncComponent loader={() => import('./environment.jsx').then(c => c.EnvironmentPage)} {...props} />;\n\nconst envPath = ['spec', 'template', 'spec', 'containers'];\nconst EnvironmentTab: React.FC<EnvironmentTabProps> = props => <EnvironmentPage obj={props.obj} rawEnvData={props.obj.spec.template.spec} envPath={envPath} readOnly={false} />;\nconst { details, pods, editYaml, envEditor, events } = navFactory;\nexport const DaemonSets: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Daemon Sets\" Header={DaemonSetTableHeader.bind(null, t)} Row={DaemonSetTableRow} virtualize />;\n};\n\nexport const DaemonSetsPage: React.FC<DaemonSetsPageProps> = props => {\n  const { t } = useTranslation();\n  return <ListPage title={t('COMMON:MSG_LNB_MENU_30')} createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_30') })} canCreate={true} ListComponent={DaemonSets} kind={kind} {...props} />;\n};\n\nconst DaemonSetPods: React.FC<DaemonSetPodsProps> = props => <PodsComponent {...props} customData={{ showNodes: true }} />;\n\nexport const DaemonSetsDetailsPage: React.FC<DaemonSetsDetailsPageProps> = props => <DetailsPage {...props} kind={kind} menuActions={menuActions} pages={[details(detailsPage(DaemonSetDetails)), editYaml(), pods(DaemonSetPods), envEditor(EnvironmentTab), events(ResourceEventStream)]} />;\n\ntype DaemonSetDetailsListProps = {\n  ds: K8sResourceKind;\n};\n\ntype EnvironmentPageProps = {\n  obj: K8sResourceKind;\n  rawEnvData: any;\n  envPath: string[];\n  readOnly: boolean;\n};\n\ntype EnvironmentTabProps = {\n  obj: K8sResourceKind;\n};\n\ntype DaemonSetDetailsProps = {\n  obj: K8sResourceKind;\n};\n\ntype DaemonSetsPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype DaemonSetPodsProps = {\n  obj: K8sResourceKind;\n};\n\ntype DaemonSetsDetailsPageProps = {\n  match: any;\n};\n","import * as React from 'react';\n\nimport { Status, PodRingController } from '@console/shared';\nimport PodRingSet from '@console/shared/src/components/pod/PodRingSet';\nimport { AddHealthChecks, EditHealthChecks } from '@console/app/src/actions/modify-health-checks';\nimport { DeploymentModel } from '../models';\nimport { DeploymentKind, K8sKind, K8sResourceKindReference } from '../module/k8s';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { configureUpdateStrategyModal, errorModal } from './modals';\nimport { Conditions } from './conditions';\nimport { ResourceEventStream } from './events';\nimport { VolumesTable } from './volumes-table';\nimport { DetailsPage, ListPage, Table, RowFunction } from './factory';\nimport { AsyncComponent, DetailsItem, Kebab, KebabAction, ContainerTable, navFactory, pluralize, ResourceSummary, SectionHeading, togglePaused, WorkloadPausedAlert, LoadingInline } from './utils';\nimport { ReplicaSetsPage } from './replicaset';\nimport { WorkloadTableRow, WorkloadTableHeader } from './workload-table';\nimport { ResourceLabel } from '../models/hypercloud/resource-plural';\n\nconst deploymentsReference: K8sResourceKindReference = 'Deployment';\nconst { ModifyCount, AddStorage, common } = Kebab.factory;\n\nconst UpdateStrategy: KebabAction = (kind: K8sKind, deployment: DeploymentKind) => {\n  const { t } = useTranslation();\n  return {\n    label: t('COMMON:MSG_MAIN_ACTIONBUTTON_8'),\n    callback: () => configureUpdateStrategyModal({ deployment }),\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: deployment.metadata.name,\n      namespace: deployment.metadata.namespace,\n      verb: 'patch',\n    },\n  };\n};\n\nconst PauseAction: KebabAction = (kind: K8sKind, obj: DeploymentKind) => {\n  const { t } = useTranslation();\n  return {\n    label: obj.spec.paused ? t('COMMON:MSG_MAIN_ACTIONBUTTON_37') : t('COMMON:MSG_MAIN_ACTIONBUTTON_12'),\n    callback: () => togglePaused(kind, obj).catch(err => errorModal({ error: err.message })),\n    accessReview: {\n      group: kind.apiGroup,\n      resource: kind.plural,\n      name: obj.metadata.name,\n      namespace: obj.metadata.namespace,\n      verb: 'patch',\n    },\n  };\n};\n\nexport const menuActions = [ModifyCount, PauseAction, AddHealthChecks, AddStorage, UpdateStrategy, ...Kebab.getExtensionsActionsForKind(DeploymentModel), EditHealthChecks, ...common];\n\nexport const DeploymentDetailsList: React.FC<DeploymentDetailsListProps> = ({ deployment }) => {\n  const { t } = useTranslation();\n  return (\n    <dl className=\"co-m-pane__details\">\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_25')} obj={deployment} path=\"spec.strategy.type\" />\n      {deployment.spec.strategy.type === 'RollingUpdate' && (\n        <>\n          <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_26')} obj={deployment} path=\"spec.strategy.rollingUpdate.maxUnavailable\">\n            {deployment.spec.strategy.rollingUpdate.maxUnavailable || 1} of {pluralize(deployment.spec.replicas, 'pod')}\n          </DetailsItem>\n          <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_27')} obj={deployment} path=\"spec.strategy.rollingUpdate.maxSurge\">\n            {deployment.spec.strategy.rollingUpdate.maxSurge || 1} greater than {pluralize(deployment.spec.replicas, 'pod')}\n          </DetailsItem>\n        </>\n      )}\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_28')} obj={deployment} path=\"spec.progressDeadlineSeconds\">\n        {deployment.spec.progressDeadlineSeconds ? pluralize(deployment.spec.progressDeadlineSeconds, 'second') : 'Not Configured'}\n      </DetailsItem>\n      <DetailsItem label={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_29')} obj={deployment} path=\"spec.minReadySeconds\">\n        {deployment.spec.minReadySeconds ? pluralize(deployment.spec.minReadySeconds, 'second') : 'Not Configured'}\n      </DetailsItem>\n    </dl>\n  );\n};\nDeploymentDetailsList.displayName = 'DeploymentDetailsList';\n\nconst DeploymentDetails: React.FC<DeploymentDetailsProps> = ({ obj: deployment }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', { 0: ResourceLabel(deployment, t) })} />\n        {deployment.spec.paused && <WorkloadPausedAlert obj={deployment} model={DeploymentModel} />}\n        <PodRingController\n          namespace={deployment.metadata.namespace}\n          kind={deployment.kind}\n          render={d => {\n            return d.loaded ? <PodRingSet key={deployment.metadata.uid} podData={d.data[deployment.metadata.uid]} obj={deployment} resourceKind={DeploymentModel} path=\"/spec/replicas\" /> : <LoadingInline />;\n          }}\n        />\n        <div className=\"co-m-pane__body-group\">\n          <div className=\"row\">\n            <div className=\"col-sm-6\">\n              <ResourceSummary resource={deployment} showPodSelector showNodeSelector showTolerations>\n                <dt>{t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_13')}</dt>\n                <dd>{deployment.status.availableReplicas === deployment.status.updatedReplicas && deployment.spec.replicas === deployment.status.availableReplicas ? <Status status=\"Up to date\" /> : <Status status=\"Updating\" />}</dd>\n              </ResourceSummary>\n            </div>\n            <div className=\"col-sm-6\">\n              <DeploymentDetailsList deployment={deployment} />\n            </div>\n          </div>\n        </div>\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_1')} />\n        <ContainerTable containers={deployment.spec.template.spec.containers} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <VolumesTable resource={deployment} heading={t('COMMON:MSG_DETAILS_TABDETAILS_VOLUMES_TABLEHEADER_1')} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONDITIONS_1')} />\n        <Conditions conditions={deployment.status.conditions} />\n      </div>\n    </>\n  );\n};\nDeploymentDetails.displayName = 'DeploymentDetails';\n\nconst EnvironmentPage = props => <AsyncComponent loader={() => import('./environment.jsx').then(c => c.EnvironmentPage)} {...props} />;\n\nconst envPath = ['spec', 'template', 'spec', 'containers'];\nconst environmentComponent = props => <EnvironmentPage obj={props.obj} rawEnvData={props.obj.spec.template.spec} envPath={envPath} readOnly={false} />;\n\nconst ReplicaSetsTab: React.FC<ReplicaSetsTabProps> = ({ obj }) => {\n  const {\n    metadata: { namespace },\n    spec: { selector },\n  } = obj;\n\n  // Hide the create button to avoid confusion when showing replica sets for an object.\n  return <ReplicaSetsPage showTitle={false} namespace={namespace} selector={selector} canCreate={false} />;\n};\n\nconst { details, editYaml, pods, envEditor, events } = navFactory;\nexport const DeploymentsDetailsPage: React.FC<DeploymentsDetailsPageProps> = props => {\n  const { t } = useTranslation();\n  return (\n    <DetailsPage\n      {...props}\n      kind={deploymentsReference}\n      menuActions={menuActions}\n      pages={[\n        details(DeploymentDetails),\n        editYaml(),\n        {\n          href: 'replicasets',\n          name: t('COMMON:MSG_LNB_MENU_31'),\n          component: ReplicaSetsTab,\n        },\n        pods(),\n        envEditor(environmentComponent),\n        events(ResourceEventStream),\n      ]}\n    />\n  );\n};\nDeploymentsDetailsPage.displayName = 'DeploymentsDetailsPage';\n\ntype DeploymentDetailsListProps = {\n  deployment: DeploymentKind;\n};\n\ntype DeploymentDetailsProps = {\n  obj: DeploymentKind;\n};\n\nconst kind = 'Deployment';\n\nconst DeploymentTableRow: RowFunction<DeploymentKind> = ({ obj, index, key, style }) => {\n  return <WorkloadTableRow obj={obj} index={index} rowKey={key} style={style} menuActions={menuActions} kind={kind} />;\n};\n\nconst DeploymentTableHeader = (t?: TFunction) => {\n  return WorkloadTableHeader(t);\n};\nDeploymentTableHeader.displayName = 'DeploymentTableHeader';\n\nexport const DeploymentsList: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Deployments\" Header={DeploymentTableHeader.bind(null, t)} Row={DeploymentTableRow} virtualize />;\n};\nDeploymentsList.displayName = 'DeploymentsList';\n\nexport const DeploymentsPage: React.FC<DeploymentsPageProps> = props => {\n  const { t } = useTranslation();\n  return <ListPage title={t('COMMON:MSG_LNB_MENU_24')} createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_24') })} kind={deploymentsReference} canCreate={true} ListComponent={DeploymentsList} {...props} />;\n};\nDeploymentsPage.displayName = 'DeploymentsPage';\n\ntype ReplicaSetsTabProps = {\n  obj: DeploymentKind;\n};\n\ntype DeploymentsPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype DeploymentsDetailsPageProps = {\n  match: any;\n};\n","import * as React from 'react';\n\nimport PodRingSet from '@console/shared/src/components/pod/PodRingSet';\nimport { PodRingController } from '@console/shared';\nimport { AddHealthChecks, EditHealthChecks } from '@console/app/src/actions/modify-health-checks';\nimport { K8sResourceKind } from '../module/k8s';\nimport { ResourceEventStream } from './events';\nimport { DetailsPage, ListPage, Table, RowFunction } from './factory';\nimport { useTranslation } from 'react-i18next';\nimport { TFunction } from 'i18next';\nimport { WorkloadTableRow, WorkloadTableHeader } from './workload-table';\n\nimport { AsyncComponent, Kebab, KebabAction, ContainerTable, ResourceSummary, SectionHeading, navFactory, LoadingInline, PodsComponent } from './utils';\nimport { VolumesTable } from './volumes-table';\nimport { StatefulSetModel } from '../models';\nimport { ResourceLabel } from '../models/hypercloud/resource-plural';\n\nconst { AddStorage, common, ModifyCount } = Kebab.factory;\nexport const menuActions: KebabAction[] = [AddHealthChecks, ModifyCount, AddStorage, ...Kebab.getExtensionsActionsForKind(StatefulSetModel), EditHealthChecks, ...common];\n\nconst kind = 'StatefulSet';\n\nconst StatefulSetTableRow: RowFunction<K8sResourceKind> = ({ obj, index, key, style }) => {\n  return <WorkloadTableRow obj={obj} index={index} rowKey={key} style={style} menuActions={menuActions} kind={kind} />;\n};\n\nconst StatefulSetTableHeader = (t?: TFunction) => {\n  return WorkloadTableHeader(t);\n};\nStatefulSetTableHeader.displayName = 'StatefulSetTableHeader';\n\nconst StatefulSetDetails: React.FC<StatefulSetDetailsProps> = ({ obj: ss }) => {\n  const { t } = useTranslation();\n  return (\n    <>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_DETAILS_1', {0: ResourceLabel(ss, t)})} />\n        <PodRingController\n          namespace={ss.metadata.namespace}\n          kind={ss.kind}\n          render={d => {\n            return d.loaded ? <PodRingSet key={ss.metadata.uid} podData={d.data[ss.metadata.uid]} obj={ss} resourceKind={StatefulSetModel} path=\"/spec/replicas\" /> : <LoadingInline />;\n          }}\n        />\n        <ResourceSummary resource={ss} showPodSelector showNodeSelector showTolerations />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <SectionHeading text={t('COMMON:MSG_DETAILS_TABDETAILS_CONTAINERS_TABLEHEADER_1')} />\n        <ContainerTable containers={ss.spec.template.spec.containers} />\n      </div>\n      <div className=\"co-m-pane__body\">\n        <VolumesTable resource={ss} heading={t('COMMON:MSG_DETAILS_TABDETAILS_VOLUMES_TABLEHEADER_1')} />\n      </div>\n    </>\n  );\n};\n\nconst EnvironmentPage: React.FC<EnvironmentPageProps> = props => <AsyncComponent loader={() => import('./environment.jsx').then(c => c.EnvironmentPage)} {...props} />;\n\nconst envPath = ['spec', 'template', 'spec', 'containers'];\nconst EnvironmentTab: React.FC<EnvironmentTabProps> = props => <EnvironmentPage obj={props.obj} rawEnvData={props.obj.spec.template.spec} envPath={envPath} readOnly={false} />;\n\nexport const StatefulSetsList: React.FC = props => {\n  const { t } = useTranslation();\n  return <Table {...props} aria-label=\"Stateful Sets\" Header={StatefulSetTableHeader.bind(null, t)} Row={StatefulSetTableRow} virtualize />;\n};\nexport const StatefulSetsPage: React.FC<StatefulSetsPageProps> = props => {\n  const { t } = useTranslation();\n  return <ListPage {...props} title={t('COMMON:MSG_LNB_MENU_25')} createButtonText={t('COMMON:MSG_MAIN_CREATEBUTTON_1', { 0: t('COMMON:MSG_LNB_MENU_25') })} ListComponent={StatefulSetsList} kind={kind} canCreate={true} />;\n};\n\nconst StatefulSetPods: React.FC<StatefulSetPodsProps> = props => <PodsComponent {...props} customData={{ showNodes: true }} />;\n\nconst pages = [navFactory.details(StatefulSetDetails), navFactory.editYaml(), navFactory.pods(StatefulSetPods), navFactory.envEditor(EnvironmentTab), navFactory.events(ResourceEventStream)];\n\nexport const StatefulSetsDetailsPage: React.FC<StatefulSetsDetailsPageProps> = props => <DetailsPage {...props} kind={kind} menuActions={menuActions} pages={pages} />;\n\ntype EnvironmentPageProps = {\n  obj: K8sResourceKind;\n  rawEnvData: any;\n  envPath: string[];\n  readOnly: boolean;\n};\n\ntype EnvironmentTabProps = {\n  obj: K8sResourceKind;\n};\n\ntype StatefulSetDetailsProps = {\n  obj: K8sResourceKind;\n};\n\ntype StatefulSetsPageProps = {\n  showTitle?: boolean;\n  namespace?: string;\n  selector?: any;\n};\n\ntype StatefulSetPodsProps = {\n  obj: K8sResourceKind;\n};\n\ntype StatefulSetsDetailsPageProps = {\n  match: any;\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAEA;AACA;AAEA;AAOA;AAOA;AAMA;AAOA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AC3DA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;AC3BA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAMA;AACA;AAGA;AACA;AAEA;AAIA;AAEA;AACA;AAIA;AAGA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC/BA;AACA;AAOA;AACA;AACA;AACA;AACA;AAoBA;AAEA;;AAEA;AACA;AAAA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAWA;AAQA;AAUA;AAWA;AACA;AACA;AACA;AAIA;AAEA;;;;;;;;;;;;;AClHA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAYA;AAEA;AAIA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AAWA;AAEA;;;;;;;;;;;;;ACvDA;AAAA;AAAA;AAAA;AAAA;AACA;AAaA;AAQA;AACA;AACA;AAEA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AAEA;AAEA;AAOA;AAUA;AAEA;;;;;;;;;;;;ACnEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAYA;AAEA;AAGA;AACA;AAEA;AACA;AACA;AAWA;AAEA;AACA;;;;;;;;;;;;;AC5EA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAGA;;AACA;AACA;AAEA;AACA;AACA;AACA;;AAGA;AAOA;AACA;AACA;AACA;AACA;AAGA;;;;;;;;;;;;;AC/BA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAIA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;AAGA;AAOA;AACA;AACA;AACA;AACA;AAGA;AAEA;AAKA;AACA;AACA;;;;;;;;;;;;;AC/FA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAEA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AAGA;AAQA;AAPA;AACA;AAEA;AACA;AACA;AAMA;AAEA;;;;;;;;;;;;ACxBA;;;;;;;;;;;ACAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AASA;;;;;;;;;;;;AClBA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AAQA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAWA;AACA;AACA;AACA;AACA;AAWA;AACA;AAQA;AACA;AACA;AACA;AAEA;AAAA;;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAcA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACzFA;AAEA;AACA;AAmBA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AACA;AA8BA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AAGA;AAEA;AAcA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAAA;AACA;AACA;AACA;AAAA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;;AACA;AACA;AACA;AAAA;AACA;;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAiBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAKA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACxVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACjBA;AAAA;AAAA;AAAA;AAEA;AAMA;AAMA;;;;;;;;;;;;AChBA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AAEA;AAQA;AAOA;AACA;AAMA;AAEA;AACA;;;;;;;;;;;;AClDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAQA;AACA;AAQA;AAQA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AAGA;AAQA;AAOA;AAIA;AAEA;AACA;;;;;;;;;;;;ACxFA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AAQA;AACA;AACA;AACA;AACA;AASA;AAAA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAGA;AAEA;AACA;;;;;;;;;;;;ACtDA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AASA;AAMA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAUA;AAEA;;;;;;;;;;;;AC9CA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AAQA;AACA;AASA;AAAA;AAKA;AAEA;AACA;AAEA;AAEA;AACA;;;;;;;;;;;;AChCA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAMA;AAEA;AAIA;;;;;;;;;;;;;ACfA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;ACLA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AACA;AACA;AAEA;AAaA;AAaA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAaA;AAEA;AAcA;AAEA;AACA;;;;;;;;;;;;;ACnFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAiBA;AACA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AAMA;AAeA;AAEA;;;;;;;;;;;;;AChLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAaA;AACA;AACA;AACA;AACA;AAWA;AAWA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAUA;AAOA;AAEA;;;;;;;;;;;;AC7FA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAWA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAUA;AACA;AAOA;AAYA;AAEA;AAQA;AAKA;AAEA;;;;;;;;;;;;AChGA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AASA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAGA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AAKA;AAMA;AAEA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;;AAEA;AAAA;AACA;;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACrDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAQA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAcA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AAGA;AAGA;AAGA;;;;;;;;;;;;ACnEA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAcA;AACA;AACA;AACA;AACA;AACA;AAEA;AAqBA;AAsBA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAMA;AAQA;AACA;AAGA;AASA;AAYA;AAEA;AAGA;AAEA;AACA;;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AAIA;AAOA;AAEA;;;;;;;;;;;;ACnBA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AAYA;AACA;AAEA;AAUA;AACA;AAIA;AACA;AACA;AAGA;AACA;AACA;AAQA;AAGA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AAEA;;;;;;;;;;;;;ACjEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAsBA;AAIA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAGA;AAIA;AAQA;AACA;AACA;AAEA;AAYA;AAYA;AAEA;;;;;;;;;;;;ACnGA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACAA;AACA;AACA;AACA;AAUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAsBA;AAAA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AAEA;AAMA;AAWA;AAEA;AAOA;AAMA;AAEA;AAQA;AACA;AAKA;AAOA;AAEA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;AChJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AASA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AAOA;AACA;AAKA;AAEA;AAKA;AAEA;;;;;;;;;;;;AC9CA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AAOA;AAIA;AACA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AAGA;AAEA;AAEA;;AAAA;AACA;AACA;AACA;AAEA;AAGA;AAEA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAKA;AAAA;AACA;AACA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACpDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AAaA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACxCA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACzBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAMA;AACA;AACA;AAWA;AAEA;AACA;AASA;AACA;AAEA;AAGA;AAIA;AACA;AACA;AAGA;AAGA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAKA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAGA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AAMA;AAEA;AAQA;AAEA;AASA;AAEA;AAQA;AAEA;AAQA;AAEA;AACA;;;;;;;;;;;;;ACtNA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;;;;;;;;;;;;;ACFA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAKA;AAKA;AACA;AAOA;AAUA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;ACnLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;AACA;AAIA;AAWA;AAMA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAMA;AASA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AAEA;AAMA;AAEA;;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;AACA;AACA;AACA;;AAEA;AACA;AAAA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AACA;AAIA;;;;;;;;;;;;;ACxQA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACdA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;ACVA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;ACHA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAGA;AAEA;AACA;AACA;AAEA;;;;;;;;;;;;;ACZA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;;AChBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAOA;AAEA;AACA;AAYA;AAIA;AACA;AACA;AACA;AACA;AAEA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AASA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAKA;AAGA;AAGA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;;;;;;;;;;;;;AC/IA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AClDA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AAEA;AACA;AACA;;;;;;;;;;;;;ACPA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAOA;AACA;AAUA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAMA;AAGA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AAEA;AACA;;;;;;;;;;;;;ACtIA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAMA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACuFA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAqHA;;;;;;;;;;;;;ACpQA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAEA;AAEA;AAQA;AAEA;AAEA;AAEA;AAGA;AAGA;AACA;AACA;AAEA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;;AACA;AAEA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAIA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAGA;AACA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AAMA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;;;;;;;;;;;;;AClLA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;AClBA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAGA;AAKA;AACA;AAEA;;AAEA;AACA;AAIA;AACA;AAEA;;AACA;AAEA;AAEA;AACA;AAEA;AASA;AACA;AACA;AAEA;AASA;AACA;AAEA;AACA;AACA;;AACA;AACA;AACA;AACA;AAEA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AASA;AASA;AAUA;AACA;AAEA;AACA;;;;;;;;;;;;;AC9GA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAYA;AAQA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;ACpEA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAQA;AAQA;AAeA;AACA;AAEA;AACA;AAGA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAKA;;;AAGA;AACA;AAGA;;;;AAIA;AACA;AAIA;AAIA;AAGA;AACA;AAEA;;;;;AAKA;AACA;AAKA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AAEA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AAEA;;AAEA;AACA;AAIA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAEA;AACA;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAKA;AACA;AACA;AACA;AAKA;AACA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAIA;AACA;AAEA;AAIA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAIA;AACA;;;;;;;;;;;;;ACxcA;AAAA;AAAA;;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AAOA;AACA;AAYA;AACA;AACA;AACA;AAKA;AAEA;;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AAQA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAEA;AACA;AAEA;AACA;;;;;;;;;;;;;AC3JA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAYA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;;;;;;;;;;;;;AC5CA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AACA;;AAAA;AACA;AAEA;AACA;AAEA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AAEA;AACA;AAGA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AAEA;;;;;;;;;;;;;ACrJA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;;AAAA;AAEA;AACA;;AAAA;AAIA;AAGA;AAKA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAIA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAKA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AAKA;AACA;AACA;AAEA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;AAUA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;ACjMA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAIA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;;;;;A","sourceRoot":""}