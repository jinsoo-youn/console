{"version":3,"file":"10-2a682ec0694ec9212dbd.js","sources":["webpack:///./public/components/environment.jsx"],"sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash-es';\nimport * as PropTypes from 'prop-types';\nimport { connect } from 'react-redux';\nimport { Alert, Button, ActionGroup, AlertActionCloseButton } from '@patternfly/react-core';\nimport * as classNames from 'classnames';\nimport { withTranslation } from 'react-i18next';\nimport { k8sPatch, k8sGet, referenceFor, referenceForOwnerRef } from '../module/k8s';\nimport { AsyncComponent, checkAccess, ContainerDropdown, EnvFromPair, EnvType, FieldLevelHelp, LoadingBox, LoadingInline, NameValueEditorPair, PromiseComponent, ResourceLink } from './utils';\nimport { ConfigMapModel, SecretModel } from '../models';\n\n/**\n * Set up an AsyncComponent to wrap the name-value-editor to allow on demand loading to reduce the\n * vendor footprint size.\n */\nconst NameValueEditorComponent = props => <AsyncComponent loader={() => import('./utils/name-value-editor').then(c => c.NameValueEditor)} {...props} />;\nconst EnvFromEditorComponent = props => <AsyncComponent loader={() => import('./utils/name-value-editor').then(c => c.EnvFromEditor)} {...props} />;\n\n/**\n * Set up initial value for the environment vars state. Use this in constructor or cancelChanges.\n *\n * Our return value here is an object in the form of:\n * {\n *   env: [[envname, value, id],[...]]\n *   envFrom: [[envFromprefix, resourceObject, id], [...]]\n * }\n *\n *\n * @param initialPairObjects\n * @returns {*}\n * @private\n */\nconst getPairsFromObject = (element = {}) => {\n  const returnedPairs = {};\n  if (_.isEmpty(element.env)) {\n    returnedPairs.env = [['', '', 0]];\n  } else {\n    returnedPairs.env = _.map(element.env, (leafNode, i) => {\n      if (!_.has(leafNode, 'value') && !_.has(leafNode, 'valueFrom')) {\n        leafNode.value = '';\n      }\n      leafNode.ID = i;\n      return Object.values(leafNode);\n    });\n  }\n  if (_.isEmpty(element.envFrom)) {\n    const configMapSecretRef = { name: '', key: '' };\n    returnedPairs.envFrom = [['', { configMapSecretRef }, 0]];\n  } else {\n    returnedPairs.envFrom = _.map(element.envFrom, (leafNode, i) => {\n      if (!_.has(leafNode, 'prefix')) {\n        leafNode.prefix = '';\n      }\n      leafNode.ID = i;\n      return [leafNode.prefix, _.pick(leafNode, ['configMapRef', 'secretRef']), leafNode.ID];\n    });\n  }\n  return returnedPairs;\n};\n\n/**\n * Get name/value pairs from an array or object source\n *\n * @param initialPairObjects\n * @returns {Array}\n */\nconst envVarsToArray = initialPairObjects => {\n  const cpOfInitialPairs = _.cloneDeep(initialPairObjects);\n  if (_.isArray(cpOfInitialPairs)) {\n    return _.map(cpOfInitialPairs, element => {\n      const { env, envFrom } = getPairsFromObject(element);\n      return [env, envFrom];\n    });\n  }\n  const { env, envFrom } = getPairsFromObject(cpOfInitialPairs);\n  return [[env, envFrom]];\n};\n\nconst getContainersObjectForDropdown = containerArray => {\n  return _.reduce(\n    containerArray,\n    (result, elem, order) => {\n      result[elem.name] = { ...elem, order };\n      return result;\n    },\n    {},\n  );\n};\n\nclass CurrentEnvVars {\n  constructor(data, isContainerArray, path) {\n    this.currentEnvVars = {};\n    this.state = { allowed: true };\n    if (!_.isEmpty(data) && arguments.length > 1) {\n      this.setResultObject(data, isContainerArray, path);\n    } else {\n      this.setRawData(data);\n    }\n  }\n\n  setRawData(rawEnvData) {\n    this.rawEnvData = rawEnvData;\n    this.isContainerArray = _.isArray(rawEnvData.containers);\n    this.isCreate = _.isEmpty(rawEnvData);\n    this.hasInitContainers = !_.isUndefined(rawEnvData.initContainers);\n\n    if (this.isContainerArray || this.isCreate) {\n      this.currentEnvVars.containers = envVarsToArray(rawEnvData.containers);\n      this.currentEnvVars.initContainers = envVarsToArray(rawEnvData.initContainers);\n    } else {\n      this.currentEnvVars.buildObject = envVarsToArray(rawEnvData);\n    }\n    return this;\n  }\n\n  /**\n   * Initialize CurrentEnvVars with result object after patch operation.\n   *\n   * If this is a containerArray its possible to have initContainers at a level above\n   * the current envPath, so when we setRawData, we want to drop right such that\n   * not only the containers can be initialized, but also initContainers. A build object\n   * only has env data in the base path.\n   *\n   * @param resultObject\n   * @param isContainerArray\n   * @param path\n   * @returns CurrentEnvVars\n   */\n  setResultObject(resultObject, isContainerArray, path) {\n    if (isContainerArray) {\n      return this.setRawData(_.get(resultObject, _.dropRight(path)));\n    }\n    return this.setRawData(_.get(resultObject, path));\n  }\n\n  getEnvVarByTypeAndIndex(type, index) {\n    return this.currentEnvVars[type][index];\n  }\n\n  setFormattedVars(containerType, index, environmentType, formattedPairs) {\n    this.currentEnvVars[containerType][index][environmentType] = formattedPairs;\n    return this;\n  }\n\n  /**\n   * Return array of patches for the save operation.\n   *\n   *\n   * @param envPath\n   * @returns {Array}\n   * @public\n   */\n  getPatches(envPath) {\n    if (this.isContainerArray) {\n      const envPathForIC = _.dropRight(envPath).concat('initContainers');\n      const op = 'add';\n\n      const containerEnvPatch = this.currentEnvVars.containers.map((finalPairsForContainer, i) => {\n        const path = `/${envPath.join('/')}/${i}/env`;\n        const value = this._envVarsToNameVal(finalPairsForContainer[EnvType.ENV]);\n        return { path, op, value };\n      });\n\n      const containerEnvFromPatch = this.currentEnvVars.containers.map((finalPairsForContainer, i) => {\n        const path = `/${envPath.join('/')}/${i}/envFrom`;\n        const value = this._envFromVarsToResourcePrefix(finalPairsForContainer[EnvType.ENV_FROM]);\n        return { path, op, value };\n      });\n\n      let patches = _.concat(containerEnvPatch, containerEnvFromPatch);\n\n      if (this.hasInitContainers) {\n        const envPatchForIC = this.currentEnvVars.initContainers.map((finalPairsForContainer, i) => {\n          const path = `/${envPathForIC.join('/')}/${i}/env`;\n          const value = this._envVarsToNameVal(finalPairsForContainer[EnvType.ENV]);\n          return { path, op, value };\n        });\n\n        const envFromPatchForIC = this.currentEnvVars.initContainers.map((finalPairsForContainer, i) => {\n          const path = `/${envPathForIC.join('/')}/${i}/envFrom`;\n          const value = this._envFromVarsToResourcePrefix(finalPairsForContainer[EnvType.ENV_FROM]);\n          return { path, op, value };\n        });\n\n        patches = _.concat(patches, envPatchForIC, envFromPatchForIC);\n      }\n      return patches;\n    }\n    return this.currentEnvVars.buildObject.map(finalPairsForContainer => {\n      const op = 'add';\n      const path = `/${envPath.join('/')}/env`;\n      const value = this._envVarsToNameVal(finalPairsForContainer[EnvType.ENV]);\n      return { path, op, value };\n    });\n  }\n\n  /**\n   * Return array of variables for the create operation.\n   *\n   * @returns {Array}\n   * @public\n   */\n  dispatchNewEnvironmentVariables() {\n    return this.isCreate ? this._envVarsToNameVal(this.currentEnvVars.containers[0][EnvType.ENV]) : null;\n  }\n\n  /**\n   * Return env var pairs in name value notation, and strip out any pairs that have empty NAME values.\n   *\n   *\n   * @param finalEnvPairs\n   * @returns {Array}\n   * @private\n   */\n  _envVarsToNameVal(finalEnvPairs) {\n    return _.filter(finalEnvPairs, finalEnvPair => finalEnvPair[NameValueEditorPair.Name]).map(finalPairForContainer => {\n      const name = finalPairForContainer[NameValueEditorPair.Name];\n      const value = finalPairForContainer[NameValueEditorPair.Value];\n      return _.isObject(value) ? { name, valueFrom: value } : { name, value };\n    });\n  }\n\n  /**\n   * Return env var pairs in envFrom (resource/prefix) notation, and strip out any pairs that have empty resource values.\n   *\n   *\n   * @param finalEnvPairs\n   * @returns {Array}\n   * @private\n   */\n  _envFromVarsToResourcePrefix(finalEnvPairs) {\n    return _.filter(finalEnvPairs, finalEnvPair => !_.isEmpty(finalEnvPair[EnvFromPair.Resource]) && !finalEnvPair[EnvFromPair.Resource].configMapSecretRef).map(finalPairForContainer => {\n      return _.assign({ prefix: finalPairForContainer[EnvFromPair.Prefix] }, finalPairForContainer[EnvFromPair.Resource]);\n    });\n  }\n}\n\n/** @type {(state: any, props: {obj?: object, rawEnvData?: any, readOnly: boolean, envPath: any, onChange?: (env: any) => void, addConfigMapSecret?: boolean, useLoadingInline?: boolean}) => {model: K8sKind}} */\nconst stateToProps = ({ k8s, UI }, { obj }) => ({\n  model: k8s.getIn(['RESOURCES', 'models', referenceFor(obj)]) || k8s.getIn(['RESOURCES', 'models', obj.kind]),\n  impersonate: UI.get('impersonate'),\n});\n\nclass EnvironmentPage_ extends PromiseComponent {\n  /**\n   * Set initial state and decide which kind of env we are setting up\n   *\n   * @param props\n   */\n  constructor(props) {\n    super(props);\n\n    this.reload = this._reload.bind(this);\n    this.saveChanges = this._saveChanges.bind(this);\n    this.updateEnvVars = this._updateEnvVars.bind(this);\n    this.selectContainer = this._selectContainer.bind(this);\n    const currentEnvVars = new CurrentEnvVars(this.props.rawEnvData);\n    this.state = {\n      currentEnvVars,\n      success: null,\n      containerIndex: 0,\n      containerType: currentEnvVars.isContainerArray || currentEnvVars.isCreate ? 'containers' : 'buildObject',\n    };\n  }\n\n  componentDidMount() {\n    this._checkEditAccess();\n    const { addConfigMapSecret, readOnly } = this.props;\n    if (!addConfigMapSecret || readOnly) {\n      const configMaps = {},\n        secrets = {};\n      this.setState({ configMaps, secrets });\n      return;\n    }\n    const envNamespace = _.get(this.props, 'obj.metadata.namespace');\n\n    Promise.all([\n      k8sGet(ConfigMapModel, null, envNamespace).catch(err => {\n        if (err.response.status !== 403) {\n          const errorMessage = err.message || 'Could not load config maps.';\n          this.setState({ errorMessage });\n        }\n        return {\n          configMaps: {},\n        };\n      }),\n      k8sGet(SecretModel, null, envNamespace).catch(err => {\n        if (err.response.status !== 403) {\n          const errorMessage = err.message || 'Could not load secrets.';\n          this.setState({ errorMessage });\n        }\n        return {\n          secrets: {},\n        };\n      }),\n    ]).then(([configMaps, secrets]) => this.setState({ configMaps, secrets }));\n  }\n\n  componentDidUpdate(prevProps) {\n    const { obj, model, impersonate, readOnly, rawEnvData } = this.props;\n    const { dirty } = this.state;\n\n    if (!_.isEqual(rawEnvData, prevProps.rawEnvData)) {\n      this.setState({\n        ...(!dirty && { currentEnvVars: new CurrentEnvVars(rawEnvData) }),\n        stale: dirty,\n      });\n    }\n\n    if (_.get(prevProps.obj, 'metadata.uid') !== _.get(obj, 'metadata.uid') || _.get(prevProps.model, 'apiGroup') !== _.get(model, 'apiGroup') || _.get(prevProps.model, 'path') !== _.get(model, 'path') || prevProps.impersonate !== impersonate || prevProps.readOnly !== readOnly) {\n      this._checkEditAccess();\n    }\n  }\n\n  _checkEditAccess() {\n    const { obj, model, impersonate, readOnly } = this.props;\n    if (readOnly) {\n      return;\n    }\n\n    // Only check RBAC if editing an existing resource. The form will always\n    // be enabled when creating a new application (git import / deploy image).\n    if (_.isEmpty(obj) || !model) {\n      this.setState({ allowed: true });\n      return;\n    }\n\n    const { name, namespace } = obj.metadata;\n    const resourceAttributes = {\n      group: model.apiGroup,\n      resource: model.plural,\n      verb: 'patch',\n      name,\n      namespace,\n    };\n    checkAccess(resourceAttributes, impersonate).then(resp => this.setState({ allowed: resp.status.allowed }));\n  }\n\n  /**\n   * Callback for NVEditor update our state with new values\n   * @param env\n   * @param i\n   */\n  _updateEnvVars(env, i = 0, type = EnvType.ENV) {\n    const { onChange } = this.props;\n    const { currentEnvVars, containerType } = this.state;\n    const currentEnv = _.cloneDeep(currentEnvVars);\n    currentEnv.setFormattedVars(containerType, i, type, env.nameValuePairs);\n    this.setState({\n      currentEnvVars: currentEnv,\n      dirty: true,\n      success: null,\n    });\n    _.isFunction(onChange) && onChange(currentEnv.dispatchNewEnvironmentVariables());\n  }\n\n  /**\n   * Reset the page to initial state\n   * @private\n   */\n  _reload() {\n    const { rawEnvData } = this.props;\n    this.setState({\n      currentEnvVars: new CurrentEnvVars(rawEnvData),\n      dirty: false,\n      errorMessage: null,\n      stale: false,\n      success: null,\n    });\n  }\n\n  _selectContainer(containerName) {\n    const { rawEnvData } = this.props;\n    let containerIndex = _.findIndex(rawEnvData.containers, { name: containerName });\n    if (containerIndex !== -1) {\n      return this.setState({\n        containerIndex,\n        containerType: 'containers',\n      });\n    }\n    containerIndex = _.findIndex(rawEnvData.initContainers, { name: containerName });\n    if (containerIndex !== -1) {\n      return this.setState({\n        containerIndex,\n        containerType: 'initContainers',\n      });\n    }\n  }\n\n  /**\n   * Make it so. Patch the values for the env var changes made on the page.\n   * 1. Validate for dup keys\n   * 2. Throw out empty rows\n   * 3. Use add command if we are adding new env vars, and replace if we are modifying\n   * 4. Send the patch command down to REST, and update with response\n   *\n   * @param e\n   */\n  _saveChanges(e) {\n    const { envPath, obj, model } = this.props;\n    const { currentEnvVars } = this.state;\n\n    e.preventDefault();\n\n    const patches = currentEnvVars.getPatches(envPath);\n    const promise = k8sPatch(model, obj, patches);\n    this.handlePromise(promise).then(res => {\n      this.setState({\n        currentEnvVars: new CurrentEnvVars(res, currentEnvVars.isContainerArray, envPath),\n        dirty: false,\n        errorMessage: null,\n        stale: false,\n        success: 'Successfully updated the environment variables.',\n      });\n    });\n  }\n\n  dismissSuccess = () => {\n    this.setState({ success: null });\n  };\n\n  render() {\n    const { errorMessage, success, inProgress, currentEnvVars, stale, configMaps, secrets, containerIndex, containerType, allowed } = this.state;\n    const { rawEnvData, obj, addConfigMapSecret, useLoadingInline, t } = this.props;\n    const readOnly = this.props.readOnly || !allowed;\n\n    if (!configMaps || !currentEnvVars || !secrets) {\n      if (useLoadingInline) {\n        return <LoadingInline />;\n      }\n      return <LoadingBox />;\n    }\n\n    const envVar = currentEnvVars.getEnvVarByTypeAndIndex(containerType, containerIndex);\n\n    const containerDropdown = currentEnvVars.isContainerArray ? <ContainerDropdown currentKey={rawEnvData[containerType][containerIndex].name} containers={getContainersObjectForDropdown(rawEnvData.containers)} initContainers={getContainersObjectForDropdown(rawEnvData.initContainers)} onChange={this.selectContainer} /> : null;\n\n    const owners = _.get(obj.metadata, 'ownerReferences', []).map((o, i) => <ResourceLink key={i} kind={referenceForOwnerRef(o)} name={o.name} namespace={obj.metadata.namespace} title={o.uid} inline />);\n    const containerVars = (\n      <>\n        {readOnly && !_.isEmpty(owners) && (\n          <div className=\"co-toolbar__group co-toolbar__group--left\">\n            <Alert isInline className=\"co-alert col-md-11 col-xs-10\" variant=\"info\" title={t('COMMON:MSG_DETAILS_TABENVIRONMENT_1')}>\n              {t('COMMON:MSG_DETAILS_TABENVIRONMENT_2')} {owners.length > 1 ? <>owners: {owners}</> : owners}\n            </Alert>\n          </div>\n        )}\n        {currentEnvVars.isContainerArray && (\n          <div className=\"co-toolbar__group co-toolbar__group--left\">\n            <div className=\"co-toolbar__item\">{containerType === 'containers' ? t('COMMON:MSG_DETAILS_TABENVIRONMENT_3') : t('COMMON:MSG_DETAILS_TABENVIRONMENT_10')}</div>\n            <div className=\"co-toolbar__item\">{containerDropdown}</div>\n          </div>\n        )}\n        <div className={classNames({ 'co-m-pane__body-group': !currentEnvVars.isCreate })}>\n          {!currentEnvVars.isCreate && (\n            <h3 className=\"co-section-heading-tertiary\">\n              {t('COMMON:MSG_DETAILS_TABENVIRONMENT_4')}\n              {!readOnly && (\n                <FieldLevelHelp>\n                  Define environment variables as key-value pairs to store configuration settings. You can enter text or add values from a ConfigMap or Secret. Drag and drop environment variables to change the order in which they are run. A variable can reference any other variables that come before it in the list, for example <code>FULLDOMAIN = $(SUBDOMAIN).example.com</code>.\n                </FieldLevelHelp>\n              )}\n            </h3>\n          )}\n          <NameValueEditorComponent nameValueId={containerIndex} nameValuePairs={envVar[EnvType.ENV]} updateParentData={this.updateEnvVars} addString={t('COMMON:MSG_DETAILS_TABENVIRONMENT_11')} addSecondString={t('COMMON:MSG_DETAILS_TABENVIRONMENT_12')} nameString=\"Name\" readOnly={readOnly} allowSorting={true} configMaps={configMaps} secrets={secrets} addConfigMapSecret={addConfigMapSecret} />\n        </div>\n        {currentEnvVars.isContainerArray && (\n          <div className=\"co-m-pane__body-group environment-buttons\">\n            <h3 className=\"co-section-heading-tertiary\">\n              {t('COMMON:MSG_DETAILS_TABENVIRONMENT_7')}\n              {!readOnly && (\n                <FieldLevelHelp>\n                  Add new values by referencing an existing config map or secret. Drag and drop environment variables within this section to change the order in which they are run.\n                  <br />\n                  <strong>Note: </strong>If identical values exist in both lists, the single value in the list above will take precedence.\n                </FieldLevelHelp>\n              )}\n            </h3>\n            <EnvFromEditorComponent nameValueId={containerIndex} nameValuePairs={envVar[EnvType.ENV_FROM]} updateParentData={this.updateEnvVars} readOnly={readOnly} configMaps={configMaps} secrets={secrets} addButtonLabel={t('COMMON:MSG_DETAILS_TABENVIRONMENT_13')} />\n          </div>\n        )}\n      </>\n    );\n\n    return (\n      <div className={classNames({ 'co-m-pane__body': !currentEnvVars.isCreate })}>\n        {containerVars}\n        {!currentEnvVars.isCreate && (\n          <div className=\"co-m-pane__body-group\">\n            <div className=\"pf-c-form environment-buttons\">\n              {errorMessage && <Alert isInline className=\"co-alert\" variant=\"danger\" title={errorMessage} />}\n              {stale && (\n                <Alert isInline className=\"co-alert\" variant=\"info\" title=\"The information on this page is no longer current.\">\n                  Click Reload to update and lose edits, or Save Changes to overwrite.\n                </Alert>\n              )}\n              {success && <Alert isInline className=\"co-alert\" variant=\"success\" title={success} action={<AlertActionCloseButton onClose={this.dismissSuccess} />} />}\n              {!readOnly && (\n                <ActionGroup>\n                  <Button isDisabled={inProgress} type=\"submit\" variant=\"primary\" onClick={this.saveChanges}>\n                    {t('COMMON:MSG_COMMON_BUTTON_COMMIT_3')}\n                  </Button>\n                  <Button isDisabled={inProgress} type=\"button\" variant=\"secondary\" onClick={this.reload}>\n                    {t('COMMON:MSG_COMMON_BUTTON_ETC_13')}\n                  </Button>\n                </ActionGroup>\n              )}\n            </div>\n          </div>\n        )}\n      </div>\n    );\n  }\n}\n\nexport const EnvironmentPage = connect(stateToProps)(withTranslation()(EnvironmentPage_));\n\nEnvironmentPage_.propTypes = {\n  obj: PropTypes.object,\n  rawEnvData: PropTypes.oneOfType([PropTypes.object, PropTypes.array]),\n  envPath: PropTypes.array.isRequired,\n  readOnly: PropTypes.bool.isRequired,\n  onChange: PropTypes.func,\n  addConfigMapSecret: PropTypes.bool,\n  useLoadingInline: PropTypes.bool,\n};\nEnvironmentPage_.defaultProps = {\n  obj: {},\n  rawEnvData: {},\n  addConfigMapSecret: true,\n};\n"],"mappings":";;;;;;;;;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AAEA;;;;;;;;;;;;;AAaA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAGA;AACA;AACA;AAGA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;;;;;AAYA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;AAKA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;;;;AAIA;AACA;AACA;AAuKA;AACA;AACA;AAvKA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAIA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;AAIA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;;;;;;;AAQA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AAEA;AACA;AAEA;AAEA;AACA;;AAAA;;AAAA;AAIA;AAEA;AACA;AAGA;AACA;AAEA;AACA;;AAEA;AACA;AAIA;AAEA;AAEA;AACA;AACA;;AAGA;AACA;AACA;AAGA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AAKA;AACA;AAEA;AAGA;AAUA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;A","sourceRoot":""}