{"version":3,"file":"create-local-volume-set-a76dc11f2aea82e93236.js","sources":["webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-set/create-local-volume-set.scss?810b","webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-set/create-local-volume-set.tsx","webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-set/node-selection-list.scss?b0d3","webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-set/nodes-selection-list.tsx","webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-set/types.ts","webpack:///./packages/local-storage-operator-plugin/src/components/local-volume-set/utils.ts"],"sourcesContent":["// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport { match as RouterMatch } from 'react-router';\nimport {\n  ActionGroup,\n  Button,\n  Form,\n  FormGroup,\n  TextInput,\n  Radio,\n  Expandable,\n  TextInputTypes,\n  Text,\n  TextVariants,\n} from '@patternfly/react-core';\nimport {\n  resourcePathFromModel,\n  BreadCrumbs,\n  Dropdown,\n  resourceObjPath,\n  withHandlePromise,\n  HandlePromiseProps,\n  ButtonBar,\n} from '@console/internal/components/utils';\nimport { history } from '@console/internal/components/utils/router';\nimport { ListPage } from '@console/internal/components/factory';\nimport { k8sCreate, referenceFor } from '@console/internal/module/k8s';\nimport { NodeModel } from '@console/internal/models';\nimport { ClusterServiceVersionModel } from '@console/operator-lifecycle-manager';\nimport { LocalVolumeSetModel } from '../../models';\nimport { NodesSelectionList } from './nodes-selection-list';\nimport {\n  RowUIDMap,\n  LocalVolumeSetKind,\n  DeviceType,\n  DiskType,\n  DeviceMechanicalProperty,\n} from './types';\nimport { getSelectedNodeUIDs } from './utils';\nimport './create-local-volume-set.scss';\n\nconst volumeModeDropdownItems = {\n  Block: 'Block',\n  Filesystem: 'Filesystem',\n};\n\nconst volumeTypeDropdownItems = {\n  [DiskType.SSD]: 'SSD / NVMe',\n  [DiskType.HDD]: 'HDD',\n};\n\nconst CreateLocalVolumeSet: React.FC = withHandlePromise<CreateLocalVolumeSetProps>((props) => {\n  const { match, handlePromise, inProgress, errorMessage } = props;\n  const [volumeSetName, setVolumeSetName] = React.useState('');\n  const [storageClassName, setStorageClassName] = React.useState('');\n  const [showNodesList, setShowNodesList] = React.useState(false);\n  const [volumeType, setVolumeType] = React.useState<DiskType>(DiskType.SSD);\n  const [volumeMode, setVolumeMode] = React.useState(volumeModeDropdownItems.Block);\n  const [maxVolumeLimit, setMaxVolumeLimit] = React.useState('');\n  const [rows, setRows] = React.useState<RowUIDMap>({});\n  const [allSelected, setAllSelected] = React.useState<boolean>(null);\n\n  const { ns, appName } = match.params;\n  const modelName = LocalVolumeSetModel.label;\n\n  const toggleShowNodesList = () => {\n    setShowNodesList(!showNodesList);\n  };\n\n  const onSubmit = (event: React.FormEvent<EventTarget>) => {\n    event.preventDefault();\n\n    const requestData: LocalVolumeSetKind = {\n      apiVersion: LocalVolumeSetModel.apiVersion,\n      kind: LocalVolumeSetModel.kind,\n      metadata: { name: volumeSetName },\n      spec: {\n        storageClassName,\n        volumeMode,\n        deviceInclusionSpec: {\n          // Only Raw disk supported for 4.5\n          deviceTypes: [DeviceType.RawDisk],\n          deviceMechanicalProperty: [DeviceMechanicalProperty[volumeType]],\n        },\n      },\n    };\n\n    if (showNodesList) {\n      const selectedNodesUID = getSelectedNodeUIDs(rows);\n      const selectedNodes = selectedNodesUID.map((uid) => rows[uid].props.data.metadata.name);\n      requestData.spec.nodeSelector = {\n        nodeSelectorTerms: [\n          {\n            matchExpressions: [\n              { key: 'kubernetes.io/hostname', operator: 'In', values: [...selectedNodes] },\n            ],\n          },\n        ],\n      };\n    }\n    if (maxVolumeLimit) requestData.spec.maxDeviceCount = +maxVolumeLimit;\n\n    handlePromise(k8sCreate(LocalVolumeSetModel, requestData))\n      .then((resource) => history.push(resourceObjPath(resource, referenceFor(resource))))\n      .catch(() => null);\n  };\n\n  return (\n    <>\n      <div className=\"co-create-operand__header\">\n        <div className=\"co-create-operand__header-buttons\">\n          <BreadCrumbs\n            breadcrumbs={[\n              {\n                name: 'Local Storage',\n                path: resourcePathFromModel(ClusterServiceVersionModel, appName, ns),\n              },\n              { name: `Create ${modelName}`, path: '' },\n            ]}\n          />\n        </div>\n        <h1 className=\"co-create-operand__header-text\">{`Create ${modelName}`}</h1>\n        <p className=\"help-block\">\n          A {modelName} allows you to filter a set of storage volumes, group them and create a\n          dedicated storage class to consume storage for them.\n        </p>\n      </div>\n      <Form noValidate={false} className=\"co-m-pane__body co-m-pane__form\" onSubmit={onSubmit}>\n        <FormGroup label=\"Volume Set Name\" isRequired fieldId=\"create-lvs--volume-set-name\">\n          <TextInput\n            type={TextInputTypes.text}\n            id=\"create-lvs--volume-set-name\"\n            value={volumeSetName}\n            onChange={(name) => setVolumeSetName(name)}\n            isRequired\n          />\n        </FormGroup>\n        <FormGroup label=\"Storage Class Name\" fieldId=\"create-lvs--storage-class-name\">\n          <TextInput\n            type={TextInputTypes.text}\n            id=\"create-lvs--storage-class-name\"\n            value={storageClassName}\n            onChange={(name) => setStorageClassName(name)}\n            isRequired\n          />\n        </FormGroup>\n        <Text component={TextVariants.h3} className=\"lso-create-lvs__filter-volumes-text--margin\">\n          Filter Volumes\n        </Text>\n        <FormGroup label=\"Node Selector\" fieldId=\"create-lvs--radio-group-node-selector\">\n          <div id=\"create-lvs--radio-group-node-selector\">\n            <Radio\n              label=\"All nodes\"\n              name=\"nodes-selection\"\n              id=\"create-lvs--radio-all-nodes\"\n              className=\"lso-create-lvs__all-nodes-radio--padding\"\n              value=\"allNodes\"\n              onChange={toggleShowNodesList}\n              description=\"Selecting all nodes will search for available volume storage on all nodes.\"\n              defaultChecked\n            />\n            <Radio\n              label=\"Select nodes\"\n              name=\"nodes-selection\"\n              id=\"create-lvs--radio-select-nodes\"\n              value=\"selectedNodes\"\n              onChange={toggleShowNodesList}\n              description=\"Selecting nodes allow you to limit the search for available volumes to specific nodes.\"\n            />\n          </div>\n        </FormGroup>\n        {showNodesList && (\n          <ListPage\n            customData={{ rows, setRows, allSelected, setAllSelected }}\n            showTitle={false}\n            kind={NodeModel.kind}\n            ListComponent={NodesSelectionList}\n          />\n        )}\n        <FormGroup label=\"Volume Type\" fieldId=\"create-lvs--volume-type-dropdown\">\n          <Dropdown\n            id=\"create-lvs--volume-type-dropdown\"\n            dropDownClassName=\"dropdown--full-width\"\n            items={volumeTypeDropdownItems}\n            title={volumeTypeDropdownItems[volumeType]}\n            selectedKey={volumeType}\n            onChange={(type: DiskType) => setVolumeType(type)}\n          />\n        </FormGroup>\n        <Expandable toggleText=\"Advanced\" data-test-id=\"create-lvs-form-advanced\">\n          <FormGroup\n            label=\"Volume Mode\"\n            fieldId=\"create-lso--volume-mode-dropdown\"\n            className=\"lso-create-lvs__volume-mode-dropdown--margin\"\n          >\n            <Dropdown\n              id=\"create-lso--volume-mode-dropdown\"\n              dropDownClassName=\"dropdown--full-width\"\n              items={volumeModeDropdownItems}\n              title={volumeModeDropdownItems[volumeMode]}\n              selectedKey={volumeMode}\n              onChange={(mode: string) => setVolumeMode(mode)}\n            />\n          </FormGroup>\n          <FormGroup label=\"Max Volume Limit\" fieldId=\"create-lvs--max-volume-limit\">\n            <p className=\"help-block lso-create-lvs__max-volume-limit-help-text--margin\">\n              Volume limit will set the maximum number of PVs to create on a node. If the field is\n              empty, will create PVs for all available volumes on the matching nodes.\n            </p>\n            <TextInput\n              type={TextInputTypes.number}\n              id=\"create-lvs--max-volume-limit\"\n              value={maxVolumeLimit}\n              onChange={(maxLimit) => setMaxVolumeLimit(maxLimit)}\n            />\n          </FormGroup>\n        </Expandable>\n        <ButtonBar errorMessage={errorMessage} inProgress={inProgress}>\n          <ActionGroup>\n            <Button type=\"submit\" variant=\"primary\">\n              Create\n            </Button>\n            <Button type=\"button\" variant=\"secondary\" onClick={history.goBack}>\n              Cancel\n            </Button>\n          </ActionGroup>\n        </ButtonBar>\n      </Form>\n    </>\n  );\n});\n\ntype CreateLocalVolumeSetProps = {\n  match: RouterMatch<{ appName: string; ns: string }>;\n} & HandlePromiseProps;\n\nexport default CreateLocalVolumeSet;\n","// extracted by mini-css-extract-plugin","import * as React from 'react';\nimport * as _ from 'lodash';\nimport { Text, pluralize } from '@patternfly/react-core';\nimport * as classNames from 'classnames';\nimport { sortable, OnSelect } from '@patternfly/react-table';\nimport { Table } from '@console/internal/components/factory';\nimport {\n  ResourceLink,\n  humanizeBinaryBytes,\n  convertToBaseValue,\n} from '@console/internal/components/utils';\nimport { NodeKind } from '@console/internal/module/k8s';\nimport { getUID, getName, getNodeCPUCapacity, getNodeAllocatableMemory } from '@console/shared';\nimport { NodeTableRow, RowUIDMap } from './types';\nimport { getSelectedNodeUIDs } from './utils';\nimport './node-selection-list.scss';\n\nconst tableColumnClasses = [\n  classNames('pf-u-w-30-on-sm'),\n  classNames('pf-m-hidden', 'pf-m-visible-on-sm', 'pf-u-w-10-on-sm'),\n  classNames('pf-m-hidden', 'pf-m-visible-on-sm', 'pf-u-w-20-on-sm'),\n  classNames('pf-m-hidden', 'pf-m-visible-on-sm', 'pf-u-w-20-on-sm'),\n  classNames('pf-m-hidden', 'pf-m-visible-on-sm', 'pf-u-w-20-on-sm'),\n];\n\nconst setTableHeader = () => {\n  return [\n    {\n      title: 'Name',\n      sortField: 'metadata.name',\n      transforms: [sortable],\n      props: { className: tableColumnClasses[0] },\n    },\n    {\n      title: 'CPU',\n      props: { className: tableColumnClasses[1] },\n    },\n    {\n      title: 'Memory',\n      props: { className: tableColumnClasses[2] },\n    },\n    {\n      title: 'Location',\n      props: { className: tableColumnClasses[3] },\n    },\n    {\n      title: 'Taints',\n      props: { className: tableColumnClasses[3] },\n    },\n  ];\n};\n\nconst stateShouldUpdate = (rowUIDMap: RowUIDMap, rows: RowUIDMap): boolean => {\n  /* On initial render rows will be empty */\n  if (_.isEmpty(rows)) return true;\n  return Object.keys(rowUIDMap).some((uid) => rows?.[uid]?.selected !== rowUIDMap?.[uid]?.selected);\n};\n\nconst createNodeUIDMap = (nodes: NodeKind[]): NodeUIDMap =>\n  nodes.reduce((nodeUIDMap: NodeUIDMap, node: NodeKind) => {\n    const uid = getUID(node);\n    nodeUIDMap[uid] = node;\n    return nodeUIDMap;\n  }, {});\n\nconst createRowUIDMap = (nodeUIDMap: NodeUIDMap, rows: RowUIDMap): RowUIDMap =>\n  Object.keys(nodeUIDMap).reduce((rowUIDMap, uid: string) => {\n    const node = nodeUIDMap[uid];\n    const nodeName = getName(node);\n    const nodeLocation = node.metadata.labels?.['failure-domain.beta.kubernetes.io/zone'] ?? '-';\n    const nodeCpuCapacity = getNodeCPUCapacity(node);\n    const nodeAllocatableMemory = getNodeAllocatableMemory(node);\n    const nodeTaints = node.spec?.taints?.length ?? 0;\n    const cells = [\n      {\n        title: <ResourceLink kind=\"Node\" name={nodeName} title={uid} />,\n      },\n      {\n        title: nodeCpuCapacity || '-',\n      },\n      {\n        title: humanizeBinaryBytes(convertToBaseValue(nodeAllocatableMemory)).string || '-',\n      },\n      {\n        title: nodeLocation || '-',\n      },\n      {\n        title: pluralize(nodeTaints, 'taint'),\n      },\n    ];\n    rowUIDMap[uid] = {\n      cells,\n      selected: rows?.[uid]?.selected ?? false,\n      props: {\n        data: nodeUIDMap[uid],\n        uid,\n      },\n    };\n    return rowUIDMap;\n  }, {});\n\nconst setTableRows: SetTableRows = ({ componentProps, customData }) => {\n  const { data: filteredData } = componentProps;\n  const { rows, setRows, allSelected, setAllSelected } = customData;\n\n  const nodeUIDMap = createNodeUIDMap(filteredData);\n  const rowUIDMap = createRowUIDMap(nodeUIDMap, rows);\n  const tableRows = Object.values(rowUIDMap);\n\n  if (allSelected !== null) {\n    /* Selecting and deselecting visible table rows */\n    Object.keys(rowUIDMap).forEach((uid) => (rowUIDMap[uid].selected = allSelected));\n    setRows({ ...rows, ...rowUIDMap });\n    setAllSelected(null);\n  } else if (!_.isEmpty(rowUIDMap) && stateShouldUpdate(rowUIDMap, rows)) {\n    setRows({ ...rows, ...rowUIDMap });\n  }\n  return tableRows;\n};\n\nexport const NodesSelectionList: React.FC<NodesSelectionListProps> = (props) => {\n  const { rows, setRows, setAllSelected } = props.customData;\n\n  const onSelectTableRows: OnSelect = (_event, isSelected, rowId, rowData) => {\n    const updatedRows: RowUIDMap = { ...rows };\n    if (rowId === -1) {\n      setAllSelected(isSelected);\n    } else {\n      const { uid } = rowData.props;\n      updatedRows[uid].selected = isSelected;\n      setRows({ ...updatedRows });\n    }\n  };\n\n  return (\n    <>\n      <div className=\"lso-node-selection-table__table--scroll\">\n        <Table\n          {...props}\n          aria-label=\"Select nodes for creating volume filter\"\n          data-test-id=\"create-lvs-form-node-selection-table\"\n          Header={setTableHeader}\n          Rows={setTableRows}\n          onSelect={onSelectTableRows}\n          customData={props.customData}\n          virtualize={false}\n        />\n      </div>\n      <Text data-test-id=\"create-lvs-form-selected-nodes\" component=\"h6\">\n        {pluralize(getSelectedNodeUIDs(rows).length, 'node')} selected\n      </Text>\n    </>\n  );\n};\n\ntype NodesSelectionListProps = {\n  data: NodeKind[];\n  customData: {\n    allSelected: boolean;\n    rows: RowUIDMap;\n    setAllSelected: React.Dispatch<React.SetStateAction<boolean>>;\n    setRows: React.Dispatch<React.SetStateAction<RowUIDMap>>;\n  };\n};\n\ntype SetTableRows = (props: {\n  componentProps: { data: NodeKind[] };\n  customData: NodesSelectionListProps['customData'];\n}) => NodeTableRow[];\n\ntype NodeUIDMap = {\n  [key: string]: NodeKind;\n};\n","import { IRow } from '@patternfly/react-table';\nimport { NodeKind, K8sResourceCommon } from '@console/internal/module/k8s';\n\nexport type NodeTableRow = {\n  cells: IRow['cells'];\n  selected: IRow['selected'];\n  props: {\n    data: NodeKind;\n    uid: string;\n  };\n};\n\nexport type RowUIDMap = {\n  [key: string]: NodeTableRow;\n};\n\nexport enum DiskType {\n  SSD = 'SSD',\n  HDD = 'HDD',\n}\n\nexport enum DeviceType {\n  RawDisk = 'RawDisk',\n  Partition = 'Partition',\n}\n\nexport enum DeviceMechanicalProperty {\n  SSD = 'Rotational',\n  HDD = 'NonRotational',\n}\n\nexport type LocalVolumeSetKind = K8sResourceCommon & {\n  spec: {\n    storageClassName: string;\n    volumeMode: string;\n    deviceInclusionSpec: {\n      deviceTypes: DeviceType[];\n      deviceMechanicalProperty: DeviceMechanicalProperty[];\n      minSize?: number;\n      maxSize?: number;\n    };\n    nodeSelector?: {\n      nodeSelectorTerms: [\n        {\n          matchExpressions: [{ key: string; operator: string; values: string[] }];\n        },\n      ];\n    };\n    maxDeviceCount?: number;\n  };\n};\n","import { RowUIDMap } from './types';\n\nexport const getSelectedNodeUIDs = (rows: RowUIDMap) =>\n  Object.keys(rows).filter((uid) => rows[uid].selected);\n"],"mappings":";;;;;;;;;AAAA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAEA;AAYA;AASA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAOA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAAA;AAEA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAGA;AACA;;AACA;AAEA;AAEA;AACA;AACA;AAQA;AACA;AAQA;AAGA;AACA;AACA;AAUA;AAUA;AAQA;AACA;AASA;AACA;AAKA;AASA;AACA;AAIA;AAQA;AACA;AACA;AAGA;AAQA;AAMA;;;;;;;;;;;;AC3OA;;;;;;;;;;;;ACAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AAMA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAAA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AAEA;AACA;AAEA;AACA;AACA;AACA;AACA;AAAA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AAWA;AACA;AACA;AAGA;;;;;;;;;;;;;ACzIA;AAAA;AAAA;AAAA;AAAA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;AAEA;AAAA;AACA;AACA;AACA;;;;;;;;;;;;;AC3BA;AAAA;AAAA;;;;;A","sourceRoot":""}