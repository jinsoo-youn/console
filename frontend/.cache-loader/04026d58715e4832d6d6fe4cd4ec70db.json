{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/layouts/BaseLayout.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/layouts/BaseLayout.ts","mtime":1615298458710},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport * as _ from 'lodash';\nimport { action } from 'mobx';\nimport { ADD_CHILD_EVENT, REMOVE_CHILD_EVENT, GRAPH_LAYOUT_END_EVENT, NODE_COLLAPSE_CHANGE_EVENT, ELEMENT_VISIBILITY_CHANGE_EVENT, } from '../types';\nimport { leafNodeElements, groupNodeElements, getClosestVisibleParent, } from '../utils/element-utils';\nimport { DRAG_MOVE_OPERATION, DRAG_NODE_END_EVENT, DRAG_NODE_START_EVENT, } from '../behavior';\nimport { BaseEdge } from '../elements';\nimport { ForceSimulation } from './ForceSimulation';\nclass LayoutNode {\n    constructor(node, distance, index = -1) {\n        // isFixed is used locally for Force simulation during drag events\n        this.isFixed = false;\n        this.node = node;\n        this.distance = distance;\n        this.index = index;\n        // Currently we support only fixed node sizes, this will need to change if/when dynamic node sizes are supported\n        const bounds = this.nodeBounds;\n        this.nodeWidth = bounds.width + this.distance * 2;\n        this.nodeHeight = bounds.height + this.distance * 2;\n        this.nodeRadius = Math.max(bounds.width, bounds.height) / 2;\n    }\n    get element() {\n        return this.node;\n    }\n    get id() {\n        return this.node.getId();\n    }\n    get x() {\n        return this.xx || this.node.getBounds().getCenter().x;\n    }\n    set x(x) {\n        if (!Number.isNaN(x)) {\n            this.xx = x;\n        }\n    }\n    get y() {\n        return this.yy || this.node.getBounds().getCenter().y;\n    }\n    set y(y) {\n        if (!Number.isNaN(y)) {\n            this.yy = y;\n        }\n    }\n    get fx() {\n        return this.isFixed ? this.node.getBounds().getCenter().x : undefined;\n    }\n    get fy() {\n        return this.isFixed ? this.node.getBounds().getCenter().y : undefined;\n    }\n    setPosition(x, y) {\n        this.node.setBounds(this.node\n            .getBounds()\n            .clone()\n            .setCenter(x, y));\n    }\n    get nodeBounds() {\n        const { padding } = this.node.getStyle();\n        // Currently non-group nodes do not include their padding in the bounds\n        if (!this.node.isGroup() && padding) {\n            return this.node\n                .getBounds()\n                .clone()\n                .padding(padding);\n        }\n        return this.node.getBounds();\n    }\n    get width() {\n        return this.nodeWidth;\n    }\n    get height() {\n        return this.nodeHeight;\n    }\n    update() {\n        if (this.xx != null && this.yy != null) {\n            this.node.setBounds(this.node\n                .getBounds()\n                .clone()\n                .setCenter(this.xx, this.yy));\n        }\n        this.xx = undefined;\n        this.yy = undefined;\n    }\n    get radius() {\n        return this.nodeRadius;\n    }\n    get collisionRadius() {\n        return this.radius + this.distance;\n    }\n}\nclass LayoutGroup {\n    constructor(node, padding, index) {\n        this.node = node;\n        this.padding = padding;\n        this.index = index;\n    }\n    get element() {\n        return this.node;\n    }\n    get id() {\n        return this.node.getId();\n    }\n}\nclass LayoutLink {\n    constructor(edge, source, target, isFalse = false) {\n        this.edge = edge;\n        this.sourceNode = source;\n        this.targetNode = target;\n        this.isFalse = isFalse;\n    }\n    get element() {\n        return this.edge;\n    }\n    get id() {\n        return this.edge.getId();\n    }\n    get source() {\n        return this.sourceNode;\n    }\n    get target() {\n        return this.targetNode;\n    }\n}\nconst LAYOUT_DEFAULTS = {\n    linkDistance: 60,\n    nodeDistance: 35,\n    groupDistance: 35,\n    collideDistance: 0,\n    simulationSpeed: 10,\n    chargeStrength: 0,\n    allowDrag: true,\n    layoutOnDrag: true,\n};\nclass BaseLayout {\n    constructor(graph, options) {\n        this.scheduleRestart = false;\n        this.nodes = [];\n        this.edges = [];\n        this.groups = [];\n        this.nodesMap = {};\n        this.handleDragStart = (element, event, operation) => {\n            this.initDrag(element, event, operation);\n            if (!this.options.layoutOnDrag) {\n                return;\n            }\n            if (operation.type !== DRAG_MOVE_OPERATION) {\n                this.forceSimulation.stopSimulation();\n                return;\n            }\n            const id = element.getId();\n            let found = false;\n            const dragNode = this.nodes.find((node) => node.id === id);\n            if (dragNode) {\n                dragNode.isFixed = true;\n                found = true;\n            }\n            if (!found) {\n                const dragGroup = this.groups.find((group) => group.id === id);\n                if (dragGroup) {\n                    const groupNodes = dragGroup.leaves;\n                    groupNodes.forEach((node) => {\n                        node.isFixed = true;\n                    });\n                    found = true;\n                }\n            }\n            if (found) {\n                this.forceSimulation.alphaTarget(0.1);\n                this.forceSimulation.restart();\n            }\n        };\n        this.handleDragEnd = (element, event, operation) => {\n            this.endDrag(element, event, operation);\n            if (!this.options.layoutOnDrag) {\n                return;\n            }\n            if (operation.type !== DRAG_MOVE_OPERATION) {\n                this.forceSimulation.restart();\n                return;\n            }\n            const id = element.getId();\n            const dragNode = this.nodes.find((node) => node.id === id);\n            if (dragNode) {\n                dragNode.isFixed = false;\n            }\n            else {\n                const dragGroup = this.groups.find((group) => group.id === id);\n                if (dragGroup) {\n                    const groupNodes = dragGroup.leaves;\n                    groupNodes.forEach((node) => {\n                        node.isFixed = false;\n                    });\n                }\n            }\n            this.forceSimulation.alphaTarget(0);\n        };\n        this.layout = () => {\n            this.stopListening();\n            this.runLayout(true);\n            this.startListening();\n        };\n        this.handleChildAdded = ({ child }) => {\n            if (!this.nodesMap[child.getId()]) {\n                this.scheduleRestart = true;\n                this.scheduleLayout();\n            }\n        };\n        this.handleChildRemoved = ({ child }) => {\n            if (this.nodesMap[child.getId()]) {\n                this.scheduleRestart = true;\n                this.scheduleLayout();\n            }\n        };\n        this.handleElementVisibilityChange = (event) => {\n            if (event.visible === (this.nodesMap[event.target.getId()] === undefined)) {\n                this.scheduleRestart = true;\n                this.scheduleLayout();\n            }\n        };\n        this.handleNodeCollapse = ({ node }) => {\n            if (!node.isCollapsed()) {\n                this.scheduleRestart = true;\n                this.scheduleLayout();\n            }\n        };\n        this.scheduleLayout = () => {\n            if (!this.scheduleHandle) {\n                this.scheduleHandle = window.requestAnimationFrame(() => {\n                    delete this.scheduleHandle;\n                    this.runLayout(false, this.scheduleRestart);\n                    this.scheduleRestart = false;\n                });\n            }\n        };\n        this.getFixedNodeDistance = (link) => {\n            return Math.sqrt((link.sourceNode.x - link.targetNode.x) ** 2 + (link.sourceNode.y - link.targetNode.y) ** 2);\n        };\n        // Default is to clear any initial bend points\n        this.initializeEdgeBendpoints = (edge) => {\n            // remove any bendpoints\n            if (edge.getBendpoints().length > 0) {\n                edge.setBendpoints([]);\n            }\n        };\n        this.graph = graph;\n        this.options = Object.assign(Object.assign({}, LAYOUT_DEFAULTS), options);\n        if (this.options.allowDrag) {\n            graph\n                .getController()\n                .addEventListener(DRAG_NODE_START_EVENT, this.handleDragStart)\n                .addEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);\n        }\n        this.forceSimulation = new ForceSimulation(this.options);\n    }\n    destroy() {\n        if (this.options.allowDrag) {\n            this.graph\n                .getController()\n                .removeEventListener(DRAG_NODE_START_EVENT, this.handleDragStart)\n                .removeEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);\n        }\n        this.stopListening();\n        this.forceSimulation.destroy();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    initDrag(element, event, operation) { }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    endDrag(element, event, operation) { }\n    startListening() {\n        const controller = this.graph.getController();\n        if (controller) {\n            controller.addEventListener(ADD_CHILD_EVENT, this.handleChildAdded);\n            controller.addEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);\n            controller.addEventListener(ELEMENT_VISIBILITY_CHANGE_EVENT, this.handleElementVisibilityChange);\n            controller.addEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);\n        }\n    }\n    stopListening() {\n        const controller = this.graph.getController();\n        if (this.scheduleHandle) {\n            window.cancelAnimationFrame(this.scheduleHandle);\n        }\n        if (controller) {\n            controller.removeEventListener(ADD_CHILD_EVENT, this.handleChildAdded);\n            controller.removeEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);\n            controller.removeEventListener(ELEMENT_VISIBILITY_CHANGE_EVENT, this.handleElementVisibilityChange);\n            controller.removeEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);\n        }\n    }\n    getLayoutNode(nodes, node) {\n        if (!node) {\n            return undefined;\n        }\n        let layoutNode = _.find(nodes, { id: node.getId() });\n        if (!layoutNode && _.size(node.getChildren())) {\n            layoutNode = _.find(nodes, { id: node.getChildren()[0].getId() });\n        }\n        if (!layoutNode) {\n            layoutNode = this.getLayoutNode(nodes, getClosestVisibleParent(node));\n        }\n        return layoutNode;\n    }\n    getFauxEdges(groups, nodes) {\n        const fauxEdges = [];\n        groups.forEach((group) => {\n            const groupNodes = group.element.getNodes();\n            for (let i = 0; i < groupNodes.length; i++) {\n                for (let j = i + 1; j < groupNodes.length; j++) {\n                    const fauxEdge = new BaseEdge();\n                    const source = this.getLayoutNode(nodes, groupNodes[i]);\n                    const target = this.getLayoutNode(nodes, groupNodes[j]);\n                    if (source && target) {\n                        const link = this.createLayoutLink(fauxEdge, source, target, true);\n                        fauxEdge.setController(target.element.getController());\n                        fauxEdges.push(link);\n                    }\n                }\n            }\n        });\n        return fauxEdges;\n    }\n    createLayoutNode(node, nodeDistance, index) {\n        return new LayoutNode(node, nodeDistance, index);\n    }\n    createLayoutLink(edge, source, target, isFalse = false) {\n        return new LayoutLink(edge, source, target, isFalse);\n    }\n    createLayoutGroup(node, padding, index) {\n        return new LayoutGroup(node, padding, index);\n    }\n    getNodes(leafNodes, nodeDistance) {\n        return leafNodes.map((n, index) => this.createLayoutNode(n, nodeDistance, index));\n    }\n    getLinks(edges) {\n        const links = [];\n        edges.forEach((e) => {\n            const source = this.getLayoutNode(this.nodes, e.getSource());\n            const target = this.getLayoutNode(this.nodes, e.getTarget());\n            if (source && target) {\n                this.initializeEdgeBendpoints(e);\n                links.push(this.createLayoutLink(e, source, target));\n            }\n        });\n        return links;\n    }\n    // Turn empty groups into nodes\n    getNodesFromGroups(groups, nodeDistance, nodeCount) {\n        let count = 0;\n        const groupNodes = [];\n        groups.forEach((group) => {\n            if (group.getChildren().filter((c) => c.isVisible()).length === 0) {\n                groupNodes.push(this.createLayoutNode(group, nodeDistance, nodeCount + count++));\n            }\n        });\n        return groupNodes;\n    }\n    getGroups(groups, nodes, padding) {\n        let nodeIndex = nodes.length;\n        // Create groups only for those with children\n        const layoutGroups = groups\n            .filter((g) => g.getChildren().filter((c) => c.isVisible()).length > 0)\n            .map((group) => this.createLayoutGroup(group, padding, nodeIndex++));\n        layoutGroups.forEach((groupNode) => {\n            const leaves = [];\n            const leafElements = groupNode.element\n                .getChildren()\n                .filter((node) => !node.isGroup() || node.getChildren().length === 0);\n            leafElements.forEach((leaf) => {\n                const layoutLeaf = nodes.find((n) => n.id === leaf.getId());\n                if (layoutLeaf) {\n                    leaves.push(layoutLeaf);\n                    layoutLeaf.parent = groupNode;\n                }\n            });\n            groupNode.leaves = leaves;\n            const childGroups = [];\n            const groupElements = groupNode.element\n                .getChildren()\n                .filter((node) => node.isGroup() && !node.isCollapsed());\n            groupElements.forEach((group) => {\n                const layoutGroup = layoutGroups.find((g) => g.id === group.getId());\n                if (layoutGroup) {\n                    childGroups.push(layoutGroup);\n                    layoutGroup.parent = groupNode;\n                }\n            });\n            groupNode.groups = childGroups;\n        });\n        return layoutGroups;\n    }\n    initializeNodePositions(newNodes, graph, force = false) {\n        const { width, height } = graph.getBounds();\n        const cx = width / 2;\n        const cy = height / 2;\n        newNodes.forEach((node) => {\n            // only init position for nodes that are still at 0, 0\n            const { x, y } = node.element.getPosition();\n            if (force || (x === 0 && y === 0)) {\n                node.setPosition(cx, cy);\n            }\n        });\n    }\n    setupLayout(graph, // eslint-disable-line @typescript-eslint/no-unused-vars\n    nodes, // eslint-disable-line @typescript-eslint/no-unused-vars\n    edges, // eslint-disable-line @typescript-eslint/no-unused-vars\n    groups) { }\n    updateExistingNodes(existingNodes) {\n        existingNodes.forEach((n) => {\n            n.isFixed = true;\n        });\n    }\n    stopSimulation() {\n        this.forceSimulation.haltForceSimulation();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLayout(graph, initialRun, addingNodes) { }\n    updateLayout() {\n        this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);\n        this.forceSimulation.alpha(0.2);\n    }\n    runLayout(initialRun, restart = true) {\n        const prevGroups = this.groups;\n        // create datum\n        const leafNodes = leafNodeElements(this.graph.getNodes()).filter((n) => n.isVisible());\n        const groups = groupNodeElements(this.graph.getNodes()).filter((g) => g.isVisible());\n        this.nodes = this.getNodes(leafNodes, this.options.nodeDistance);\n        const groupNodes = this.getNodesFromGroups(groups, this.options.nodeDistance, this.nodes.length);\n        if (groupNodes) {\n            this.nodes.push(...groupNodes);\n        }\n        this.groups = this.getGroups(groups, this.nodes, this.options.groupDistance);\n        const newNodes = initialRun\n            ? this.nodes\n            : this.nodes.filter((node) => !this.nodesMap[node.element.getId()]);\n        let addingNodes = restart && newNodes.length > 0;\n        if (!initialRun && restart && !addingNodes) {\n            this.groups.forEach((group) => {\n                const prevGroup = prevGroups.find((g) => g.element.getId() === group.element.getId());\n                if (!prevGroup) {\n                    addingNodes = true;\n                    newNodes.push(...group.leaves);\n                }\n                else {\n                    group.leaves.forEach((node) => {\n                        if (!prevGroup.leaves.find((l) => l.element.getId() === node.element.getId())) {\n                            newNodes.push(node);\n                        }\n                    });\n                }\n            });\n            addingNodes = newNodes.length > 0;\n        }\n        this.edges = this.getLinks(this.graph.getEdges());\n        // initialize new node positions\n        this.initializeNodePositions(newNodes, this.graph, initialRun);\n        // re-create the nodes map\n        this.nodesMap = this.nodes.reduce((acc, n) => {\n            acc[n.id] = n;\n            return acc;\n        }, {});\n        // Add faux edges to keep grouped items together\n        this.edges.push(...this.getFauxEdges(this.groups, this.nodes));\n        this.setupLayout(this.graph, this.nodes, this.edges, this.groups);\n        this.updateExistingNodes(this.nodes.filter((n) => !newNodes.includes(n)));\n        if (initialRun || addingNodes) {\n            // Reset the force simulation\n            this.stopSimulation();\n            this.startLayout(this.graph, initialRun, addingNodes);\n        }\n        else if (restart && this.options.layoutOnDrag) {\n            this.updateLayout();\n        }\n        this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });\n    }\n}\n__decorate([\n    action\n], BaseLayout.prototype, \"runLayout\", null);\nexport { BaseLayout, LayoutNode, LayoutGroup, LayoutLink, LAYOUT_DEFAULTS };\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/layouts/BaseLayout.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/layouts/BaseLayout.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { action } from 'mobx';\nimport {\n  Edge,\n  Graph,\n  Layout,\n  Node,\n  ADD_CHILD_EVENT,\n  REMOVE_CHILD_EVENT,\n  GRAPH_LAYOUT_END_EVENT,\n  ElementChildEventListener,\n  NODE_COLLAPSE_CHANGE_EVENT,\n  NodeCollapseChangeEventListener,\n  NodeStyle,\n  ElementVisibilityChangeEventListener,\n  ELEMENT_VISIBILITY_CHANGE_EVENT,\n  ElementVisibilityChangeEvent,\n} from '../types';\nimport {\n  leafNodeElements,\n  groupNodeElements,\n  getClosestVisibleParent,\n} from '../utils/element-utils';\nimport {\n  DRAG_MOVE_OPERATION,\n  DRAG_NODE_END_EVENT,\n  DRAG_NODE_START_EVENT,\n  DragEvent,\n  DragNodeEventListener,\n  DragOperationWithType,\n} from '../behavior';\nimport { BaseEdge } from '../elements';\nimport { ForceSimulation } from './ForceSimulation';\nimport { Rect } from '../geom';\n\nclass LayoutNode {\n  protected readonly node: Node;\n\n  protected xx?: number;\n\n  protected yy?: number;\n\n  protected nodeWidth: number;\n\n  protected nodeHeight: number;\n\n  protected nodeRadius: number;\n\n  public readonly distance: number;\n\n  public parent: LayoutGroup;\n\n  public index: number;\n\n  // isFixed is used locally for Force simulation during drag events\n  public isFixed: boolean = false;\n\n  constructor(node: Node, distance: number, index: number = -1) {\n    this.node = node;\n    this.distance = distance;\n    this.index = index;\n\n    // Currently we support only fixed node sizes, this will need to change if/when dynamic node sizes are supported\n    const bounds = this.nodeBounds;\n    this.nodeWidth = bounds.width + this.distance * 2;\n    this.nodeHeight = bounds.height + this.distance * 2;\n    this.nodeRadius = Math.max(bounds.width, bounds.height) / 2;\n  }\n\n  get element(): Node {\n    return this.node;\n  }\n\n  get id(): string {\n    return this.node.getId();\n  }\n\n  get x(): number {\n    return this.xx || this.node.getBounds().getCenter().x;\n  }\n\n  set x(x: number) {\n    if (!Number.isNaN(x)) {\n      this.xx = x;\n    }\n  }\n\n  get y(): number {\n    return this.yy || this.node.getBounds().getCenter().y;\n  }\n\n  set y(y: number) {\n    if (!Number.isNaN(y)) {\n      this.yy = y;\n    }\n  }\n\n  get fx(): number | undefined {\n    return this.isFixed ? this.node.getBounds().getCenter().x : undefined;\n  }\n\n  get fy(): number | undefined {\n    return this.isFixed ? this.node.getBounds().getCenter().y : undefined;\n  }\n\n  setPosition(x: number, y: number) {\n    this.node.setBounds(\n      this.node\n        .getBounds()\n        .clone()\n        .setCenter(x, y),\n    );\n  }\n\n  get nodeBounds(): Rect {\n    const { padding } = this.node.getStyle<NodeStyle>();\n    // Currently non-group nodes do not include their padding in the bounds\n    if (!this.node.isGroup() && padding) {\n      return this.node\n        .getBounds()\n        .clone()\n        .padding(padding);\n    }\n    return this.node.getBounds();\n  }\n\n  get width(): number {\n    return this.nodeWidth;\n  }\n\n  get height(): number {\n    return this.nodeHeight;\n  }\n\n  update() {\n    if (this.xx != null && this.yy != null) {\n      this.node.setBounds(\n        this.node\n          .getBounds()\n          .clone()\n          .setCenter(this.xx, this.yy),\n      );\n    }\n    this.xx = undefined;\n    this.yy = undefined;\n  }\n\n  get radius(): number {\n    return this.nodeRadius;\n  }\n\n  get collisionRadius(): number {\n    return this.radius + this.distance;\n  }\n}\n\nclass LayoutGroup {\n  protected readonly node: Node;\n\n  public leaves: LayoutNode[];\n\n  public groups: LayoutGroup[];\n\n  public parent: LayoutGroup;\n\n  public padding: number;\n\n  public index: number;\n\n  constructor(node: Node, padding: number, index: number) {\n    this.node = node;\n    this.padding = padding;\n    this.index = index;\n  }\n\n  get element(): Node {\n    return this.node;\n  }\n\n  get id(): string {\n    return this.node.getId();\n  }\n}\n\nclass LayoutLink {\n  private readonly edge: Edge;\n\n  public sourceNode: LayoutNode;\n\n  public targetNode: LayoutNode;\n\n  public isFalse: boolean;\n\n  constructor(edge: Edge, source: LayoutNode, target: LayoutNode, isFalse: boolean = false) {\n    this.edge = edge;\n    this.sourceNode = source;\n    this.targetNode = target;\n    this.isFalse = isFalse;\n  }\n\n  get element(): Edge {\n    return this.edge;\n  }\n\n  get id(): string {\n    return this.edge.getId();\n  }\n\n  get source(): any {\n    return this.sourceNode;\n  }\n\n  get target(): any {\n    return this.targetNode;\n  }\n}\n\ntype LayoutOptions = {\n  linkDistance: number;\n  nodeDistance: number;\n  groupDistance: number;\n  collideDistance: number;\n  simulationSpeed: number;\n  chargeStrength: number;\n  allowDrag: boolean;\n  layoutOnDrag: boolean;\n};\n\nconst LAYOUT_DEFAULTS: LayoutOptions = {\n  linkDistance: 60,\n  nodeDistance: 35,\n  groupDistance: 35,\n  collideDistance: 0,\n  simulationSpeed: 10,\n  chargeStrength: 0,\n  allowDrag: true,\n  layoutOnDrag: true,\n};\n\nclass BaseLayout implements Layout {\n  private graph: Graph;\n\n  protected forceSimulation: ForceSimulation;\n\n  protected options: LayoutOptions;\n\n  protected scheduleHandle?: number;\n\n  private scheduleRestart = false;\n\n  protected nodes: LayoutNode[] = [];\n\n  protected edges: LayoutLink[] = [];\n\n  protected groups: LayoutGroup[] = [];\n\n  protected nodesMap: { [id: string]: LayoutNode } = {};\n\n  constructor(graph: Graph, options?: Partial<LayoutOptions>) {\n    this.graph = graph;\n    this.options = {\n      ...LAYOUT_DEFAULTS,\n      ...options,\n    };\n\n    if (this.options.allowDrag) {\n      graph\n        .getController()\n        .addEventListener<DragNodeEventListener>(DRAG_NODE_START_EVENT, this.handleDragStart)\n        .addEventListener<DragNodeEventListener>(DRAG_NODE_END_EVENT, this.handleDragEnd);\n    }\n\n    this.forceSimulation = new ForceSimulation(this.options);\n  }\n\n  destroy(): void {\n    if (this.options.allowDrag) {\n      this.graph\n        .getController()\n        .removeEventListener(DRAG_NODE_START_EVENT, this.handleDragStart)\n        .removeEventListener(DRAG_NODE_END_EVENT, this.handleDragEnd);\n    }\n\n    this.stopListening();\n\n    this.forceSimulation.destroy();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected initDrag(element: Node, event: DragEvent, operation: DragOperationWithType): void {}\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected endDrag(element: Node, event: DragEvent, operation: DragOperationWithType): void {}\n\n  handleDragStart = (element: Node, event: DragEvent, operation: DragOperationWithType) => {\n    this.initDrag(element, event, operation);\n\n    if (!this.options.layoutOnDrag) {\n      return;\n    }\n\n    if (operation.type !== DRAG_MOVE_OPERATION) {\n      this.forceSimulation.stopSimulation();\n      return;\n    }\n\n    const id = element.getId();\n    let found = false;\n    const dragNode: LayoutNode | undefined = this.nodes.find((node: LayoutNode) => node.id === id);\n    if (dragNode) {\n      dragNode.isFixed = true;\n      found = true;\n    }\n    if (!found) {\n      const dragGroup: LayoutGroup | undefined = this.groups.find(\n        (group: LayoutGroup) => group.id === id,\n      );\n      if (dragGroup) {\n        const groupNodes = dragGroup.leaves;\n        groupNodes.forEach((node: LayoutNode) => {\n          node.isFixed = true;\n        });\n        found = true;\n      }\n    }\n\n    if (found) {\n      this.forceSimulation.alphaTarget(0.1);\n      this.forceSimulation.restart();\n    }\n  };\n\n  handleDragEnd = (element: Node, event: DragEvent, operation: DragOperationWithType) => {\n    this.endDrag(element, event, operation);\n\n    if (!this.options.layoutOnDrag) {\n      return;\n    }\n\n    if (operation.type !== DRAG_MOVE_OPERATION) {\n      this.forceSimulation.restart();\n      return;\n    }\n\n    const id = element.getId();\n    const dragNode: LayoutNode | undefined = this.nodes.find((node: LayoutNode) => node.id === id);\n    if (dragNode) {\n      dragNode.isFixed = false;\n    } else {\n      const dragGroup: LayoutGroup | undefined = this.groups.find(\n        (group: LayoutGroup) => group.id === id,\n      );\n      if (dragGroup) {\n        const groupNodes = dragGroup.leaves;\n        groupNodes.forEach((node: LayoutNode) => {\n          node.isFixed = false;\n        });\n      }\n    }\n    this.forceSimulation.alphaTarget(0);\n  };\n\n  layout = () => {\n    this.stopListening();\n\n    this.runLayout(true);\n\n    this.startListening();\n  };\n\n  private startListening(): void {\n    const controller = this.graph.getController();\n    if (controller) {\n      controller.addEventListener(ADD_CHILD_EVENT, this.handleChildAdded);\n      controller.addEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);\n      controller.addEventListener(\n        ELEMENT_VISIBILITY_CHANGE_EVENT,\n        this.handleElementVisibilityChange,\n      );\n      controller.addEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);\n    }\n  }\n\n  private stopListening(): void {\n    const controller = this.graph.getController();\n    if (this.scheduleHandle) {\n      window.cancelAnimationFrame(this.scheduleHandle);\n    }\n    if (controller) {\n      controller.removeEventListener(ADD_CHILD_EVENT, this.handleChildAdded);\n      controller.removeEventListener(REMOVE_CHILD_EVENT, this.handleChildRemoved);\n      controller.removeEventListener(\n        ELEMENT_VISIBILITY_CHANGE_EVENT,\n        this.handleElementVisibilityChange,\n      );\n      controller.removeEventListener(NODE_COLLAPSE_CHANGE_EVENT, this.handleNodeCollapse);\n    }\n  }\n\n  protected handleChildAdded: ElementChildEventListener = ({ child }): void => {\n    if (!this.nodesMap[child.getId()]) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  protected handleChildRemoved: ElementChildEventListener = ({ child }): void => {\n    if (this.nodesMap[child.getId()]) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  protected handleElementVisibilityChange: ElementVisibilityChangeEventListener = (\n    event: ElementVisibilityChangeEvent,\n  ): void => {\n    if (event.visible === (this.nodesMap[event.target.getId()] === undefined)) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  private handleNodeCollapse: NodeCollapseChangeEventListener = ({ node }): void => {\n    if (!node.isCollapsed()) {\n      this.scheduleRestart = true;\n      this.scheduleLayout();\n    }\n  };\n\n  private scheduleLayout = (): void => {\n    if (!this.scheduleHandle) {\n      this.scheduleHandle = window.requestAnimationFrame(() => {\n        delete this.scheduleHandle;\n        this.runLayout(false, this.scheduleRestart);\n        this.scheduleRestart = false;\n      });\n    }\n  };\n\n  protected getFixedNodeDistance = (link: LayoutLink): number => {\n    return Math.sqrt(\n      (link.sourceNode.x - link.targetNode.x) ** 2 + (link.sourceNode.y - link.targetNode.y) ** 2,\n    );\n  };\n\n  protected getLayoutNode(nodes: LayoutNode[], node: Node | null): LayoutNode | undefined {\n    if (!node) {\n      return undefined;\n    }\n\n    let layoutNode = _.find(nodes, { id: node.getId() });\n    if (!layoutNode && _.size(node.getChildren())) {\n      layoutNode = _.find(nodes, { id: node.getChildren()[0].getId() });\n    }\n    if (!layoutNode) {\n      layoutNode = this.getLayoutNode(nodes, getClosestVisibleParent(node));\n    }\n\n    return layoutNode;\n  }\n\n  protected getFauxEdges(groups: LayoutGroup[], nodes: LayoutNode[]): LayoutLink[] {\n    const fauxEdges: LayoutLink[] = [];\n    groups.forEach((group: LayoutGroup) => {\n      const groupNodes = group.element.getNodes();\n      for (let i = 0; i < groupNodes.length; i++) {\n        for (let j = i + 1; j < groupNodes.length; j++) {\n          const fauxEdge = new BaseEdge();\n          const source = this.getLayoutNode(nodes, groupNodes[i]);\n          const target = this.getLayoutNode(nodes, groupNodes[j]);\n          if (source && target) {\n            const link = this.createLayoutLink(fauxEdge, source, target, true);\n            fauxEdge.setController(target.element.getController());\n            fauxEdges.push(link);\n          }\n        }\n      }\n    });\n\n    return fauxEdges;\n  }\n\n  protected createLayoutNode(node: Node, nodeDistance: number, index: number) {\n    return new LayoutNode(node, nodeDistance, index);\n  }\n\n  protected createLayoutLink(\n    edge: Edge,\n    source: LayoutNode,\n    target: LayoutNode,\n    isFalse: boolean = false,\n  ): LayoutLink {\n    return new LayoutLink(edge, source, target, isFalse);\n  }\n\n  protected createLayoutGroup(node: Node, padding: number, index: number) {\n    return new LayoutGroup(node, padding, index);\n  }\n\n  protected getNodes(leafNodes: Node[], nodeDistance: number): LayoutNode[] {\n    return leafNodes.map((n, index) => this.createLayoutNode(n, nodeDistance, index));\n  }\n\n  // Default is to clear any initial bend points\n  protected initializeEdgeBendpoints = (edge: Edge): void => {\n    // remove any bendpoints\n    if (edge.getBendpoints().length > 0) {\n      edge.setBendpoints([]);\n    }\n  };\n\n  protected getLinks(edges: Edge[]): LayoutLink[] {\n    const links: LayoutLink[] = [];\n    edges.forEach((e) => {\n      const source = this.getLayoutNode(this.nodes, e.getSource());\n      const target = this.getLayoutNode(this.nodes, e.getTarget());\n      if (source && target) {\n        this.initializeEdgeBendpoints(e);\n        links.push(this.createLayoutLink(e, source, target));\n      }\n    });\n\n    return links;\n  }\n\n  // Turn empty groups into nodes\n  protected getNodesFromGroups(\n    groups: Node[],\n    nodeDistance: number,\n    nodeCount: number,\n  ): LayoutNode[] {\n    let count = 0;\n    const groupNodes: LayoutNode[] = [];\n    groups.forEach((group: Node) => {\n      if (group.getChildren().filter((c) => c.isVisible()).length === 0) {\n        groupNodes.push(this.createLayoutNode(group, nodeDistance, nodeCount + count++));\n      }\n    });\n\n    return groupNodes;\n  }\n\n  protected getGroups(groups: Node[], nodes: LayoutNode[], padding: number): LayoutGroup[] {\n    let nodeIndex = nodes.length;\n    // Create groups only for those with children\n    const layoutGroups: LayoutGroup[] = groups\n      .filter((g) => g.getChildren().filter((c) => c.isVisible()).length > 0)\n      .map((group: Node) => this.createLayoutGroup(group, padding, nodeIndex++));\n\n    layoutGroups.forEach((groupNode: LayoutGroup) => {\n      const leaves: LayoutNode[] = [];\n      const leafElements = groupNode.element\n        .getChildren()\n        .filter((node: Node) => !node.isGroup() || node.getChildren().length === 0);\n      leafElements.forEach((leaf: Node) => {\n        const layoutLeaf = nodes.find((n) => n.id === leaf.getId());\n        if (layoutLeaf) {\n          leaves.push(layoutLeaf);\n          layoutLeaf.parent = groupNode;\n        }\n      });\n      groupNode.leaves = leaves;\n      const childGroups: LayoutGroup[] = [];\n      const groupElements = groupNode.element\n        .getChildren()\n        .filter((node: Node) => node.isGroup() && !node.isCollapsed());\n      groupElements.forEach((group: Node) => {\n        const layoutGroup = layoutGroups.find((g) => g.id === group.getId());\n        if (layoutGroup) {\n          childGroups.push(layoutGroup);\n          layoutGroup.parent = groupNode;\n        }\n      });\n      groupNode.groups = childGroups;\n    });\n\n    return layoutGroups;\n  }\n\n  protected initializeNodePositions(\n    newNodes: LayoutNode[],\n    graph: Graph,\n    force: boolean = false,\n  ): void {\n    const { width, height } = graph.getBounds();\n    const cx = width / 2;\n    const cy = height / 2;\n    newNodes.forEach((node: LayoutNode) => {\n      // only init position for nodes that are still at 0, 0\n      const { x, y } = node.element.getPosition();\n      if (force || (x === 0 && y === 0)) {\n        node.setPosition(cx, cy);\n      }\n    });\n  }\n\n  protected setupLayout(\n    graph: Graph, // eslint-disable-line @typescript-eslint/no-unused-vars\n    nodes: LayoutNode[], // eslint-disable-line @typescript-eslint/no-unused-vars\n    edges: LayoutLink[], // eslint-disable-line @typescript-eslint/no-unused-vars\n    groups: LayoutGroup[], // eslint-disable-line @typescript-eslint/no-unused-vars\n  ): void {}\n\n  protected updateExistingNodes(existingNodes: LayoutNode[]): void {\n    existingNodes.forEach((n) => {\n      (n as LayoutNode).isFixed = true;\n    });\n  }\n\n  protected stopSimulation(): void {\n    this.forceSimulation.haltForceSimulation();\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  protected startLayout(graph: Graph, initialRun: boolean, addingNodes: boolean): void {}\n\n  protected updateLayout(): void {\n    this.forceSimulation.useForceSimulation(this.nodes, this.edges, this.getFixedNodeDistance);\n    this.forceSimulation.alpha(0.2);\n  }\n\n  @action\n  private runLayout(initialRun: boolean, restart = true): void {\n    const prevGroups = this.groups;\n\n    // create datum\n    const leafNodes = leafNodeElements(this.graph.getNodes()).filter((n) => n.isVisible());\n    const groups = groupNodeElements(this.graph.getNodes()).filter((g) => g.isVisible());\n\n    this.nodes = this.getNodes(leafNodes, this.options.nodeDistance);\n\n    const groupNodes: LayoutNode[] = this.getNodesFromGroups(\n      groups,\n      this.options.nodeDistance,\n      this.nodes.length,\n    );\n    if (groupNodes) {\n      this.nodes.push(...groupNodes);\n    }\n\n    this.groups = this.getGroups(groups, this.nodes, this.options.groupDistance);\n\n    const newNodes: LayoutNode[] = initialRun\n      ? this.nodes\n      : this.nodes.filter((node) => !this.nodesMap[node.element.getId()]);\n    let addingNodes = restart && newNodes.length > 0;\n\n    if (!initialRun && restart && !addingNodes) {\n      this.groups.forEach((group) => {\n        const prevGroup = prevGroups.find((g) => g.element.getId() === group.element.getId());\n        if (!prevGroup) {\n          addingNodes = true;\n          newNodes.push(...group.leaves);\n        } else {\n          group.leaves.forEach((node) => {\n            if (!prevGroup.leaves.find((l) => l.element.getId() === node.element.getId())) {\n              newNodes.push(node);\n            }\n          });\n        }\n      });\n      addingNodes = newNodes.length > 0;\n    }\n\n    this.edges = this.getLinks(this.graph.getEdges());\n\n    // initialize new node positions\n    this.initializeNodePositions(newNodes, this.graph, initialRun);\n\n    // re-create the nodes map\n    this.nodesMap = this.nodes.reduce((acc, n) => {\n      acc[n.id] = n;\n      return acc;\n    }, {});\n\n    // Add faux edges to keep grouped items together\n    this.edges.push(...this.getFauxEdges(this.groups, this.nodes));\n\n    this.setupLayout(this.graph, this.nodes, this.edges, this.groups);\n\n    this.updateExistingNodes(this.nodes.filter((n) => !newNodes.includes(n)));\n\n    if (initialRun || addingNodes) {\n      // Reset the force simulation\n      this.stopSimulation();\n\n      this.startLayout(this.graph, initialRun, addingNodes);\n    } else if (restart && this.options.layoutOnDrag) {\n      this.updateLayout();\n    }\n    this.graph.getController().fireEvent(GRAPH_LAYOUT_END_EVENT, { graph: this.graph });\n  }\n}\n\nexport { BaseLayout, LayoutNode, LayoutGroup, LayoutLink, LayoutOptions, LAYOUT_DEFAULTS };\n"]}]}