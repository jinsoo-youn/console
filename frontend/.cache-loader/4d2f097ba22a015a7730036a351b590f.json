{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/constants/vm/provision-source.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/constants/vm/provision-source.ts","mtime":1616735742420},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["/* eslint-disable lines-between-class-members */\nimport { getName, getNamespace } from '@console/shared/src';\nimport { ObjectEnum } from '../object-enum';\nimport { asVM, getDataVolumeTemplates, getDisks, getInterfaces, getVolumeDataVolumeName, getVolumes, } from '../../selectors/vm';\nimport { StorageUISource } from '../../components/modals/disk-modal/storage-ui-source';\nimport { VolumeWrapper } from '../../k8s/wrapper/vm/volume-wrapper';\nimport { DataVolumeWrapper } from '../../k8s/wrapper/vm/data-volume-wrapper';\nimport { VolumeType } from './storage';\nexport class ProvisionSource extends ObjectEnum {\n}\nProvisionSource.PXE = new ProvisionSource('PXE');\nProvisionSource.CONTAINER = new ProvisionSource('Container');\nProvisionSource.URL = new ProvisionSource('URL');\nProvisionSource.DISK = new ProvisionSource('Disk');\nProvisionSource.ALL = Object.freeze(ObjectEnum.getAllClassEnumProperties(ProvisionSource));\nProvisionSource.stringMapper = ProvisionSource.ALL.reduce((accumulator, provisionSource) => (Object.assign(Object.assign({}, accumulator), { [provisionSource.value]: provisionSource })), {});\nProvisionSource.getAll = () => ProvisionSource.ALL;\nProvisionSource.fromString = (source) => ProvisionSource.stringMapper[source];\nProvisionSource.getProvisionSourceDetails = (vmLikeEntity, { convertTemplateDataVolumesToAttachClonedDisk, dataVolumes, dataVolumeLookup, } = {}) => {\n    const vm = asVM(vmLikeEntity);\n    if (getInterfaces(vm).some((i) => i.bootOrder === 1)) {\n        return {\n            type: ProvisionSource.PXE,\n        };\n    }\n    const bootDisk = getDisks(vm).find((disk) => disk.bootOrder === 1);\n    if (bootDisk) {\n        const volume = getVolumes(vm).find((vol) => vol.name === bootDisk.name);\n        if (!volume) {\n            return {\n                error: 'No Volume has been found.',\n            };\n        }\n        const volumeWrapper = new VolumeWrapper(volume);\n        let dataVolumeWrapper;\n        if (volumeWrapper.getType() === VolumeType.DATA_VOLUME) {\n            if (convertTemplateDataVolumesToAttachClonedDisk) {\n                return {\n                    type: ProvisionSource.DISK,\n                    source: `${getNamespace(vmLikeEntity)}/${volumeWrapper.getDataVolumeName()}`,\n                };\n            }\n            let dataVolume;\n            if (dataVolumeLookup) {\n                dataVolume = dataVolumeLookup[getVolumeDataVolumeName(volume)];\n            }\n            if (!dataVolume) {\n                const allDataVolumes = [...getDataVolumeTemplates(vm)];\n                if (dataVolumes) {\n                    allDataVolumes.push(...dataVolumes);\n                }\n                dataVolume = allDataVolumes.find((dv) => getName(dv) === getVolumeDataVolumeName(volume));\n            }\n            if (!dataVolume) {\n                return {\n                    error: `Datavolume ${volumeWrapper.getDataVolumeName()} does not exist.`,\n                };\n            }\n            dataVolumeWrapper = new DataVolumeWrapper(dataVolume);\n        }\n        const type = StorageUISource.fromTypes(volumeWrapper.getType(), dataVolumeWrapper && dataVolumeWrapper.getType());\n        switch (type) {\n            case StorageUISource.CONTAINER:\n                return {\n                    type: ProvisionSource.CONTAINER,\n                    source: volumeWrapper.getContainerImage(),\n                };\n            case StorageUISource.URL:\n                return {\n                    type: ProvisionSource.URL,\n                    source: dataVolumeWrapper.getURL(),\n                };\n            case StorageUISource.ATTACH_CLONED_DISK:\n                return {\n                    type: ProvisionSource.DISK,\n                    source: `${dataVolumeWrapper.getPesistentVolumeClaimNamespace()}/${dataVolumeWrapper.getPesistentVolumeClaimName()}`,\n                };\n            case StorageUISource.ATTACH_DISK:\n                return {\n                    type: ProvisionSource.DISK,\n                    source: `${getNamespace(vmLikeEntity)}/${volumeWrapper.getPersistentVolumeClaimName()}`,\n                };\n            case StorageUISource.BLANK:\n                return {\n                    error: `Datavolume ${volumeWrapper.getDataVolumeName()} does not have a supported source (${type}).`,\n                };\n            default:\n                return {\n                    error: `Volume ${volumeWrapper.getName()} does not have a supported source.`,\n                };\n        }\n    }\n    return {\n        error: 'No bootable device found.',\n    };\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/constants/vm/provision-source.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/constants/vm/provision-source.ts"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable lines-between-class-members */\nimport { getName, getNamespace, K8sEntityMap } from '@console/shared/src';\nimport { ObjectEnum } from '../object-enum';\nimport {\n  asVM,\n  getDataVolumeTemplates,\n  getDisks,\n  getInterfaces,\n  getVolumeDataVolumeName,\n  getVolumes,\n} from '../../selectors/vm';\nimport { VMLikeEntityKind } from '../../types/vmLike';\nimport { StorageUISource } from '../../components/modals/disk-modal/storage-ui-source';\nimport { VolumeWrapper } from '../../k8s/wrapper/vm/volume-wrapper';\nimport { DataVolumeWrapper } from '../../k8s/wrapper/vm/data-volume-wrapper';\nimport { V1alpha1DataVolume } from '../../types/vm/disk/V1alpha1DataVolume';\nimport { VolumeType } from './storage';\n\ntype ProvisionSourceDetails = {\n  type?: ProvisionSource;\n  source?: string;\n  error?: string;\n};\n\nexport class ProvisionSource extends ObjectEnum<string> {\n  static readonly PXE = new ProvisionSource('PXE');\n  static readonly CONTAINER = new ProvisionSource('Container');\n  static readonly URL = new ProvisionSource('URL');\n  static readonly DISK = new ProvisionSource('Disk');\n\n  private static readonly ALL = Object.freeze(\n    ObjectEnum.getAllClassEnumProperties<ProvisionSource>(ProvisionSource),\n  );\n\n  private static readonly stringMapper = ProvisionSource.ALL.reduce(\n    (accumulator, provisionSource: ProvisionSource) => ({\n      ...accumulator,\n      [provisionSource.value]: provisionSource,\n    }),\n    {},\n  );\n\n  static getAll = () => ProvisionSource.ALL;\n\n  static fromString = (source: string): ProvisionSource => ProvisionSource.stringMapper[source];\n\n  static getProvisionSourceDetails = (\n    vmLikeEntity: VMLikeEntityKind,\n    {\n      convertTemplateDataVolumesToAttachClonedDisk,\n      dataVolumes,\n      dataVolumeLookup,\n    }: {\n      convertTemplateDataVolumesToAttachClonedDisk?: boolean;\n      dataVolumes?: V1alpha1DataVolume[];\n      dataVolumeLookup?: K8sEntityMap<V1alpha1DataVolume>;\n    } = {},\n  ): ProvisionSourceDetails => {\n    const vm = asVM(vmLikeEntity);\n    if (getInterfaces(vm).some((i) => i.bootOrder === 1)) {\n      return {\n        type: ProvisionSource.PXE,\n      };\n    }\n\n    const bootDisk = getDisks(vm).find((disk) => disk.bootOrder === 1);\n    if (bootDisk) {\n      const volume = getVolumes(vm).find((vol) => vol.name === bootDisk.name);\n      if (!volume) {\n        return {\n          error: 'No Volume has been found.',\n        };\n      }\n      const volumeWrapper = new VolumeWrapper(volume);\n      let dataVolumeWrapper;\n\n      if (volumeWrapper.getType() === VolumeType.DATA_VOLUME) {\n        if (convertTemplateDataVolumesToAttachClonedDisk) {\n          return {\n            type: ProvisionSource.DISK,\n            source: `${getNamespace(vmLikeEntity)}/${volumeWrapper.getDataVolumeName()}`,\n          };\n        }\n        let dataVolume;\n\n        if (dataVolumeLookup) {\n          dataVolume = dataVolumeLookup[getVolumeDataVolumeName(volume)];\n        }\n        if (!dataVolume) {\n          const allDataVolumes = [...getDataVolumeTemplates(vm)];\n          if (dataVolumes) {\n            allDataVolumes.push(...dataVolumes);\n          }\n          dataVolume = allDataVolumes.find((dv) => getName(dv) === getVolumeDataVolumeName(volume));\n        }\n        if (!dataVolume) {\n          return {\n            error: `Datavolume ${volumeWrapper.getDataVolumeName()} does not exist.`,\n          };\n        }\n        dataVolumeWrapper = new DataVolumeWrapper(dataVolume);\n      }\n\n      const type = StorageUISource.fromTypes(\n        volumeWrapper.getType(),\n        dataVolumeWrapper && dataVolumeWrapper.getType(),\n      );\n\n      switch (type) {\n        case StorageUISource.CONTAINER:\n          return {\n            type: ProvisionSource.CONTAINER,\n            source: volumeWrapper.getContainerImage(),\n          };\n        case StorageUISource.URL:\n          return {\n            type: ProvisionSource.URL,\n            source: dataVolumeWrapper.getURL(),\n          };\n        case StorageUISource.ATTACH_CLONED_DISK:\n          return {\n            type: ProvisionSource.DISK,\n            source: `${dataVolumeWrapper.getPesistentVolumeClaimNamespace()}/${dataVolumeWrapper.getPesistentVolumeClaimName()}`,\n          };\n        case StorageUISource.ATTACH_DISK:\n          return {\n            type: ProvisionSource.DISK,\n            source: `${getNamespace(vmLikeEntity)}/${volumeWrapper.getPersistentVolumeClaimName()}`,\n          };\n        case StorageUISource.BLANK:\n          return {\n            error: `Datavolume ${volumeWrapper.getDataVolumeName()} does not have a supported source (${type}).`,\n          };\n        default:\n          return {\n            error: `Volume ${volumeWrapper.getName()} does not have a supported source.`,\n          };\n      }\n    }\n\n    return {\n      error: 'No bootable device found.',\n    };\n  };\n}\n"]}]}