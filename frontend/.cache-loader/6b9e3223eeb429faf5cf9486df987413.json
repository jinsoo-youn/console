{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/co-fetch.js","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/co-fetch.js","mtime":1615298458720},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash-es';\nimport 'whatwg-fetch';\nimport { getAccessToken } from './hypercloud/auth';\nimport store from './redux';\nconst initDefaults = {\n    headers: {},\n    credentials: 'same-origin',\n};\n// TODO: url can be url or path, but shouldLogout only handles paths\nexport const shouldLogout = url => {\n    const k8sRegex = new RegExp(`^${window.SERVER_FLAGS.basePath}api/kubernetes/`);\n    // 401 from k8s. show logout screen\n    if (k8sRegex.test(url)) {\n        // Don't let 401s from proxied services log out users\n        const proxyRegex = new RegExp(`^${window.SERVER_FLAGS.basePath}api/kubernetes/api/v1/proxy/`);\n        if (proxyRegex.test(url)) {\n            return false;\n        }\n        const serviceRegex = new RegExp(`^${window.SERVER_FLAGS.basePath}api/kubernetes/api/v1/namespaces/\\\\w+/services/\\\\w+/proxy/`);\n        if (serviceRegex.test(url)) {\n            return false;\n        }\n        return true;\n    }\n    return false;\n};\nconst validateStatus = (response, url) => {\n    if (response.ok) {\n        return response;\n    }\n    if (response.status === 401) {\n        //authSvc.logout(window.location.pathname);\n        //keycloak.logout();\n        // return response.json().then(json => {\n        //   const error = new Error(json.message || 'Authorization failed.');\n        //   error.response = response;\n        //   error.json = json;\n        //   throw error;\n        // });\n    }\n    const contentType = response.headers.get('content-type');\n    if (!contentType || contentType.indexOf('json') === -1) {\n        const error = new Error(response.statusText);\n        error.response = response;\n        throw error;\n    }\n    if (response.status === 403) {\n        return response.json().then(json => {\n            const error = new Error(json.message || 'Access denied due to cluster policy.');\n            error.response = response;\n            error.json = json;\n            throw error;\n        });\n    }\n    return response.json().then(json => {\n        const cause = _.get(json, 'details.causes[0]');\n        let reason;\n        if (cause) {\n            reason = `Error \"${cause.message}\" for field \"${cause.field}\".`;\n        }\n        if (!reason) {\n            reason = json.message;\n        }\n        if (!reason) {\n            reason = json.error;\n        }\n        if (!reason) {\n            reason = response.statusText;\n        }\n        const error = new Error(reason);\n        error.response = response;\n        error.json = json;\n        throw error;\n    });\n};\nexport class TimeoutError extends Error {\n    constructor(url, ms, ...params) {\n        super(`Call to ${url} timed out after ${ms}ms.`, ...params);\n        // Dumb hack to fix `instanceof TimeoutError`\n        Object.setPrototypeOf(this, TimeoutError.prototype);\n    }\n}\nconst cookiePrefix = 'csrf-token=';\nconst getCSRFToken = () => document &&\n    document.cookie &&\n    document.cookie\n        .split(';')\n        .map(c => _.trim(c))\n        .filter(c => c.startsWith(cookiePrefix))\n        .map(c => c.slice(cookiePrefix.length))\n        .pop();\nexport const coFetch = (url, options = {}, timeout = 60000) => {\n    const allOptions = _.defaultsDeep({}, initDefaults, options);\n    if (allOptions.method !== 'GET') {\n        allOptions.headers['X-CSRFToken'] = getCSRFToken();\n    }\n    // If the URL being requested is absolute (and therefore, not a local request),\n    // remove the authorization header to prevent credentials from leaking.\n    if (url.indexOf('://') >= 0) {\n        delete allOptions.headers.Authorization;\n        delete allOptions.headers['X-CSRFToken'];\n    }\n    if (window.SERVER_FLAGS.releaseModeFlag) {\n        if (!!getAccessToken()) {\n            allOptions.headers.Authorization = 'Bearer ' + getAccessToken();\n            const fetchPromise = fetch(url, allOptions).then(response => validateStatus(response, url));\n            // return fetch promise directly if timeout <= 0\n            if (timeout < 1) {\n                return fetchPromise;\n            }\n            const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n            // Initiate both the fetch promise and a timeout promise\n            return Promise.race([fetchPromise, timeoutPromise]);\n        }\n        else {\n            // return fetch promise directly if timeout <= 0\n            if (timeout < 1) {\n                return fetchPromise;\n            }\n            const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n            // Initiate both the fetch promise and a timeout promise\n            return Promise.race([timeoutPromise]);\n        }\n    }\n    else {\n        const fetchPromise = fetch(url, allOptions).then(response => validateStatus(response, url));\n        // return fetch promise directly if timeout <= 0\n        if (timeout < 1) {\n            return fetchPromise;\n        }\n        const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n        // Initiate both the fetch promise and a timeout promise\n        return Promise.race([fetchPromise, timeoutPromise]);\n    }\n};\nconst parseJson = response => response.json();\nexport const coFetchUtils = {\n    parseJson,\n};\nexport const coFetchCommon = (url, method = 'GET', options = {}, timeout) => {\n    const headers = {};\n    const { kind, name } = store.getState().UI.get('impersonate', {});\n    if ((kind === 'User' || kind === 'Group') && name) {\n        // Even if we are impersonating a group, we still need to set Impersonate-User to something or k8s will complain\n        headers['Impersonate-User'] = name;\n        if (kind === 'Group') {\n            headers['Impersonate-Group'] = name;\n        }\n    }\n    // Pass headers last to let callers to override Accept.\n    const allOptions = _.defaultsDeep({ method }, options, { headers });\n    return coFetch(url, allOptions, timeout).then(response => {\n        if (!response.ok) {\n            return response.text();\n        }\n        // If the response has no body, return promise that resolves with an empty object\n        if (response.headers.get('Content-Length') === '0') {\n            return Promise.resolve(response.headers.get('Content-Type') === 'text/plain' ? '' : {});\n        }\n        if (response.headers.get('Content-Type') === 'text/plain') {\n            return response.text();\n        }\n        return response.json();\n    });\n};\nexport const coFetchJSON = (url, method = 'GET', options = {}, timeout) => {\n    const allOptions = _.defaultsDeep({}, options, { headers: { Accept: 'application/json' } });\n    return coFetchCommon(url, method, allOptions, timeout);\n};\nexport const coFetchText = (url, options = {}, timeout) => {\n    return coFetchCommon(url, 'GET', options, timeout);\n};\nconst coFetchSendJSON = (url, method, json = null, options = {}, timeout) => {\n    const allOptions = {\n        headers: {\n            Accept: 'application/json',\n            'Content-Type': `application/${method === 'PATCH' ? 'json-patch+json' : 'json'};charset=UTF-8`,\n        },\n    };\n    if (json) {\n        allOptions.body = JSON.stringify(json);\n    }\n    return coFetchJSON(url, method, _.defaultsDeep(allOptions, options), timeout);\n};\ncoFetchJSON.delete = (url, options = {}, json = null, timeout) => {\n    return json ? coFetchSendJSON(url, 'DELETE', json, options, timeout) : coFetchJSON(url, 'DELETE', options, timeout);\n};\ncoFetchJSON.post = (url, json, options = {}, timeout) => coFetchSendJSON(url, 'POST', json, options, timeout);\ncoFetchJSON.put = (url, json, options = {}, timeout) => coFetchSendJSON(url, 'PUT', json, options, timeout);\ncoFetchJSON.patch = (url, json, options = {}, timeout) => coFetchSendJSON(url, 'PATCH', json, options, timeout);\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/co-fetch.js","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/co-fetch.js"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash-es';\nimport 'whatwg-fetch';\nimport { getAccessToken } from './hypercloud/auth';\nimport { authSvc } from './module/auth';\nimport store from './redux';\nimport keycloak from './hypercloud/keycloak';\n\nconst initDefaults = {\n  headers: {},\n  credentials: 'same-origin',\n};\n\n// TODO: url can be url or path, but shouldLogout only handles paths\nexport const shouldLogout = url => {\n  const k8sRegex = new RegExp(`^${window.SERVER_FLAGS.basePath}api/kubernetes/`);\n  // 401 from k8s. show logout screen\n  if (k8sRegex.test(url)) {\n    // Don't let 401s from proxied services log out users\n    const proxyRegex = new RegExp(`^${window.SERVER_FLAGS.basePath}api/kubernetes/api/v1/proxy/`);\n    if (proxyRegex.test(url)) {\n      return false;\n    }\n    const serviceRegex = new RegExp(`^${window.SERVER_FLAGS.basePath}api/kubernetes/api/v1/namespaces/\\\\w+/services/\\\\w+/proxy/`);\n    if (serviceRegex.test(url)) {\n      return false;\n    }\n    return true;\n  }\n  return false;\n};\n\nconst validateStatus = (response, url) => {\n  if (response.ok) {\n    return response;\n  }\n\n  if (response.status === 401) {\n    //authSvc.logout(window.location.pathname);\n    \n    //keycloak.logout();\n    \n    // return response.json().then(json => {\n    //   const error = new Error(json.message || 'Authorization failed.');\n    //   error.response = response;\n    //   error.json = json;\n    //   throw error;\n    // });\n  }\n\n  const contentType = response.headers.get('content-type');\n  if (!contentType || contentType.indexOf('json') === -1) {\n    const error = new Error(response.statusText);\n    error.response = response;\n    throw error;\n  }\n\n  if (response.status === 403) {\n    return response.json().then(json => {\n      const error = new Error(json.message || 'Access denied due to cluster policy.');\n      error.response = response;\n      error.json = json;\n      throw error;\n    });\n  }\n\n  return response.json().then(json => {\n    const cause = _.get(json, 'details.causes[0]');\n    let reason;\n    if (cause) {\n      reason = `Error \"${cause.message}\" for field \"${cause.field}\".`;\n    }\n    if (!reason) {\n      reason = json.message;\n    }\n    if (!reason) {\n      reason = json.error;\n    }\n    if (!reason) {\n      reason = response.statusText;\n    }\n    const error = new Error(reason);\n    error.response = response;\n    error.json = json;\n    throw error;\n  });\n};\n\nexport class TimeoutError extends Error {\n  constructor(url, ms, ...params) {\n    super(`Call to ${url} timed out after ${ms}ms.`, ...params);\n    // Dumb hack to fix `instanceof TimeoutError`\n    Object.setPrototypeOf(this, TimeoutError.prototype);\n  }\n}\n\nconst cookiePrefix = 'csrf-token=';\nconst getCSRFToken = () =>\n  document &&\n  document.cookie &&\n  document.cookie\n    .split(';')\n    .map(c => _.trim(c))\n    .filter(c => c.startsWith(cookiePrefix))\n    .map(c => c.slice(cookiePrefix.length))\n    .pop();\n\nexport const coFetch = (url, options = {}, timeout = 60000) => {\n  const allOptions = _.defaultsDeep({}, initDefaults, options);\n  if (allOptions.method !== 'GET') {\n    allOptions.headers['X-CSRFToken'] = getCSRFToken();\n  }\n\n  // If the URL being requested is absolute (and therefore, not a local request),\n  // remove the authorization header to prevent credentials from leaking.\n  if (url.indexOf('://') >= 0) {\n    delete allOptions.headers.Authorization;\n    delete allOptions.headers['X-CSRFToken'];\n  }\n\n  if (window.SERVER_FLAGS.releaseModeFlag) {\n    if (!!getAccessToken()) {\n      allOptions.headers.Authorization = 'Bearer ' + getAccessToken();\n      const fetchPromise = fetch(url, allOptions).then(response => validateStatus(response, url));\n\n      // return fetch promise directly if timeout <= 0\n      if (timeout < 1) {\n        return fetchPromise;\n      }\n\n      const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n\n      // Initiate both the fetch promise and a timeout promise\n      return Promise.race([fetchPromise, timeoutPromise]);\n    } else {\n      // return fetch promise directly if timeout <= 0\n      if (timeout < 1) {\n        return fetchPromise;\n      }\n\n      const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n\n      // Initiate both the fetch promise and a timeout promise\n      return Promise.race([timeoutPromise]);\n    }\n  } else {\n    const fetchPromise = fetch(url, allOptions).then(response => validateStatus(response, url));\n\n    // return fetch promise directly if timeout <= 0\n    if (timeout < 1) {\n      return fetchPromise;\n    }\n\n    const timeoutPromise = new Promise((unused, reject) => setTimeout(() => reject(new TimeoutError(url, timeout)), timeout));\n\n    // Initiate both the fetch promise and a timeout promise\n    return Promise.race([fetchPromise, timeoutPromise]);\n  }\n};\n\nconst parseJson = response => response.json();\n\nexport const coFetchUtils = {\n  parseJson,\n};\n\nexport const coFetchCommon = (url, method = 'GET', options = {}, timeout) => {\n  const headers = {};\n  const { kind, name } = store.getState().UI.get('impersonate', {});\n  if ((kind === 'User' || kind === 'Group') && name) {\n    // Even if we are impersonating a group, we still need to set Impersonate-User to something or k8s will complain\n    headers['Impersonate-User'] = name;\n    if (kind === 'Group') {\n      headers['Impersonate-Group'] = name;\n    }\n  }\n  // Pass headers last to let callers to override Accept.\n  const allOptions = _.defaultsDeep({ method }, options, { headers });\n  return coFetch(url, allOptions, timeout).then(response => {\n    if (!response.ok) {\n      return response.text();\n    }\n\n    // If the response has no body, return promise that resolves with an empty object\n    if (response.headers.get('Content-Length') === '0') {\n      return Promise.resolve(response.headers.get('Content-Type') === 'text/plain' ? '' : {});\n    }\n    if (response.headers.get('Content-Type') === 'text/plain') {\n      return response.text();\n    }\n    return response.json();\n  });\n};\n\nexport const coFetchJSON = (url, method = 'GET', options = {}, timeout) => {\n  const allOptions = _.defaultsDeep({}, options, { headers: { Accept: 'application/json' } });\n  return coFetchCommon(url, method, allOptions, timeout);\n};\n\nexport const coFetchText = (url, options = {}, timeout) => {\n  return coFetchCommon(url, 'GET', options, timeout);\n};\n\nconst coFetchSendJSON = (url, method, json = null, options = {}, timeout) => {\n  const allOptions = {\n    headers: {\n      Accept: 'application/json',\n      'Content-Type': `application/${method === 'PATCH' ? 'json-patch+json' : 'json'};charset=UTF-8`,\n    },\n  };\n  if (json) {\n    allOptions.body = JSON.stringify(json);\n  }\n  return coFetchJSON(url, method, _.defaultsDeep(allOptions, options), timeout);\n};\n\ncoFetchJSON.delete = (url, options = {}, json = null, timeout) => {\n  return json ? coFetchSendJSON(url, 'DELETE', json, options, timeout) : coFetchJSON(url, 'DELETE', options, timeout);\n};\ncoFetchJSON.post = (url, json, options = {}, timeout) => coFetchSendJSON(url, 'POST', json, options, timeout);\ncoFetchJSON.put = (url, json, options = {}, timeout) => coFetchSendJSON(url, 'PUT', json, options, timeout);\ncoFetchJSON.patch = (url, json, options = {}, timeout) => coFetchSendJSON(url, 'PATCH', json, options, timeout);\n"]}]}