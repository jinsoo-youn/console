{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/shared-submit-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/shared-submit-utils.ts","mtime":1616735742400},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nimport { getAppLabels, getPodLabels, getGitAnnotations, getCommonAnnotations, mergeData, } from './resource-label-utils';\nimport { makePortName } from './imagestream-utils';\nexport const dryRunOpt = { queryParams: { dryRun: 'All' } };\nconst isDeployImageFormData = (formData) => {\n    return 'isi' in formData;\n};\nexport const createService = (formData, imageStreamData, originalService) => {\n    const { project: { name: namespace }, application: { name: application }, name, labels: userLabels, image: { ports: imagePorts, tag: imageTag }, } = formData;\n    const imageStreamName = _.get(imageStreamData, 'metadata.name') || _.get(formData, 'image.name');\n    const git = _.get(formData, 'git');\n    const defaultLabels = getAppLabels(name, application, imageStreamName, imageTag);\n    const podLabels = getPodLabels(name);\n    const defaultAnnotations = git\n        ? Object.assign(Object.assign({}, getGitAnnotations(git.url, git.ref)), getCommonAnnotations()) : getCommonAnnotations();\n    let ports = imagePorts;\n    if (_.get(formData, 'build.strategy') === 'Docker') {\n        const port = { containerPort: _.get(formData, 'docker.containerPort'), protocol: 'TCP' };\n        ports = [port];\n    }\n    else if (isDeployImageFormData(formData)) {\n        const { isi: { ports: isiPorts }, } = formData;\n        ports = isiPorts;\n    }\n    const newService = {\n        kind: 'Service',\n        apiVersion: 'v1',\n        metadata: {\n            name,\n            namespace,\n            labels: Object.assign(Object.assign({}, defaultLabels), userLabels),\n            annotations: Object.assign({}, defaultAnnotations),\n        },\n        spec: {\n            selector: podLabels,\n            ports: _.map(ports, (port) => ({\n                port: port.containerPort,\n                targetPort: port.containerPort,\n                protocol: port.protocol,\n                // Use the same naming convention as CLI new-app.\n                name: makePortName(port),\n            })),\n        },\n    };\n    const service = mergeData(originalService, newService);\n    return service;\n};\nexport const createRoute = (formData, imageStreamData, originalRoute) => {\n    const { project: { name: namespace }, application: { name: application }, name, labels: userLabels, route: { hostname, secure, path, tls, targetPort: routeTargetPort }, image: { ports: imagePorts, tag: imageTag }, } = formData;\n    const imageStreamName = _.get(imageStreamData, 'metadata.name') || _.get(formData, 'image.name');\n    const git = _.get(formData, 'git');\n    const defaultLabels = getAppLabels(name, application, imageStreamName, imageTag);\n    const defaultAnnotations = git\n        ? Object.assign(Object.assign({}, getGitAnnotations(git.url, git.ref)), getCommonAnnotations()) : getCommonAnnotations();\n    let ports = imagePorts;\n    if (isDeployImageFormData(formData)) {\n        const { isi: { ports: isiPorts }, } = formData;\n        ports = isiPorts;\n    }\n    let targetPort;\n    if (_.get(formData, 'build.strategy') === 'Docker') {\n        const port = _.get(formData, 'docker.containerPort');\n        targetPort = makePortName({\n            containerPort: _.toInteger(port),\n            protocol: 'TCP',\n        });\n    }\n    else {\n        targetPort = routeTargetPort || makePortName(_.head(ports));\n    }\n    const newRoute = {\n        kind: 'Route',\n        apiVersion: 'route.openshift.io/v1',\n        metadata: {\n            name,\n            namespace,\n            labels: Object.assign(Object.assign({}, defaultLabels), userLabels),\n            defaultAnnotations,\n        },\n        spec: Object.assign(Object.assign({ to: {\n                kind: 'Service',\n                name,\n            } }, (secure ? { tls } : {})), { host: hostname, path, \n            // The service created by `createService` uses the same port as the container port.\n            port: {\n                // Use the port name, not the number for targetPort. The router looks\n                // at endpoints, not services, when resolving ports, so port numbers\n                // will not resolve correctly if the service port and container port\n                // numbers don't match.\n                targetPort,\n            }, wildcardPolicy: 'None' }),\n    };\n    const route = mergeData(originalRoute, newRoute);\n    return route;\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/shared-submit-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/shared-submit-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { GitImportFormData, DeployImageFormData } from '../components/import/import-types';\nimport {\n  getAppLabels,\n  getPodLabels,\n  getGitAnnotations,\n  getCommonAnnotations,\n  mergeData,\n} from './resource-label-utils';\nimport { makePortName } from './imagestream-utils';\n\nexport const dryRunOpt = { queryParams: { dryRun: 'All' } };\n\nconst isDeployImageFormData = (\n  formData: DeployImageFormData | GitImportFormData,\n): formData is DeployImageFormData => {\n  return 'isi' in (formData as DeployImageFormData);\n};\n\nexport const createService = (\n  formData: DeployImageFormData | GitImportFormData,\n  imageStreamData?: K8sResourceKind,\n  originalService?: K8sResourceKind,\n): K8sResourceKind => {\n  const {\n    project: { name: namespace },\n    application: { name: application },\n    name,\n    labels: userLabels,\n    image: { ports: imagePorts, tag: imageTag },\n  } = formData;\n\n  const imageStreamName = _.get(imageStreamData, 'metadata.name') || _.get(formData, 'image.name');\n  const git = _.get(formData, 'git');\n\n  const defaultLabels = getAppLabels(name, application, imageStreamName, imageTag);\n  const podLabels = getPodLabels(name);\n  const defaultAnnotations = git\n    ? { ...getGitAnnotations(git.url, git.ref), ...getCommonAnnotations() }\n    : getCommonAnnotations();\n\n  let ports = imagePorts;\n  if (_.get(formData, 'build.strategy') === 'Docker') {\n    const port = { containerPort: _.get(formData, 'docker.containerPort'), protocol: 'TCP' };\n    ports = [port];\n  } else if (isDeployImageFormData(formData)) {\n    const {\n      isi: { ports: isiPorts },\n    } = formData;\n    ports = isiPorts;\n  }\n\n  const newService: any = {\n    kind: 'Service',\n    apiVersion: 'v1',\n    metadata: {\n      name,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n      annotations: { ...defaultAnnotations },\n    },\n    spec: {\n      selector: podLabels,\n      ports: _.map(ports, (port) => ({\n        port: port.containerPort,\n        targetPort: port.containerPort,\n        protocol: port.protocol,\n        // Use the same naming convention as CLI new-app.\n        name: makePortName(port),\n      })),\n    },\n  };\n\n  const service = mergeData(originalService, newService);\n\n  return service;\n};\n\nexport const createRoute = (\n  formData: GitImportFormData | DeployImageFormData,\n  imageStreamData?: K8sResourceKind,\n  originalRoute?: K8sResourceKind,\n): K8sResourceKind => {\n  const {\n    project: { name: namespace },\n    application: { name: application },\n    name,\n    labels: userLabels,\n    route: { hostname, secure, path, tls, targetPort: routeTargetPort },\n    image: { ports: imagePorts, tag: imageTag },\n  } = formData;\n\n  const imageStreamName = _.get(imageStreamData, 'metadata.name') || _.get(formData, 'image.name');\n  const git = _.get(formData, 'git');\n\n  const defaultLabels = getAppLabels(name, application, imageStreamName, imageTag);\n  const defaultAnnotations = git\n    ? { ...getGitAnnotations(git.url, git.ref), ...getCommonAnnotations() }\n    : getCommonAnnotations();\n\n  let ports = imagePorts;\n  if (isDeployImageFormData(formData)) {\n    const {\n      isi: { ports: isiPorts },\n    } = formData;\n    ports = isiPorts;\n  }\n\n  let targetPort;\n  if (_.get(formData, 'build.strategy') === 'Docker') {\n    const port = _.get(formData, 'docker.containerPort');\n    targetPort = makePortName({\n      containerPort: _.toInteger(port),\n      protocol: 'TCP',\n    });\n  } else {\n    targetPort = routeTargetPort || makePortName(_.head(ports));\n  }\n\n  const newRoute: any = {\n    kind: 'Route',\n    apiVersion: 'route.openshift.io/v1',\n    metadata: {\n      name,\n      namespace,\n      labels: { ...defaultLabels, ...userLabels },\n      defaultAnnotations,\n    },\n    spec: {\n      to: {\n        kind: 'Service',\n        name,\n      },\n      ...(secure ? { tls } : {}),\n      host: hostname,\n      path,\n      // The service created by `createService` uses the same port as the container port.\n      port: {\n        // Use the port name, not the number for targetPort. The router looks\n        // at endpoints, not services, when resolving ports, so port numbers\n        // will not resolve correctly if the service port and container port\n        // numbers don't match.\n        targetPort,\n      },\n      wildcardPolicy: 'None',\n    },\n  };\n\n  const route = mergeData(originalRoute, newRoute);\n\n  return route;\n};\n"]}]}