{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelineruns/logs/logs-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelineruns/logs/logs-utils.ts","mtime":1616735742390},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { saveAs } from 'file-saver';\nimport { resourceURL, k8sGet, } from '@console/internal/module/k8s';\nimport { LOG_SOURCE_TERMINATED, LOG_SOURCE_WAITING, LineBuffer, } from '@console/internal/components/utils';\nimport { PodModel } from '@console/internal/models';\nimport { coFetchText } from '@console/internal/co-fetch';\nimport { errorModal } from '@console/internal/components/modals';\nimport { containerToLogSourceStatus } from '../../../utils/pipeline-utils';\nconst getSortedContainerStatus = (containers, containerStatuses) => {\n    const containerNames = containers.map((c) => c.name);\n    const sortedContainerStatus = [];\n    containerStatuses.forEach((cs) => {\n        const containerIndex = containerNames.indexOf(cs.name);\n        sortedContainerStatus[containerIndex] = cs;\n    });\n    return sortedContainerStatus;\n};\nexport const getRenderContainers = (pod) => {\n    var _a, _b, _c, _d;\n    const containers = (_b = (_a = pod.spec) === null || _a === void 0 ? void 0 : _a.containers) !== null && _b !== void 0 ? _b : [];\n    const containerStatuses = (_d = (_c = pod.status) === null || _c === void 0 ? void 0 : _c.containerStatuses) !== null && _d !== void 0 ? _d : [];\n    const sortedContainerStatuses = getSortedContainerStatus(containers, containerStatuses);\n    const firstRunningCont = sortedContainerStatuses.findIndex((container) => containerToLogSourceStatus(container) !== LOG_SOURCE_TERMINATED);\n    return {\n        containers: containers.slice(0, firstRunningCont === -1 ? containers.length : firstRunningCont + 1),\n        stillFetching: firstRunningCont !== -1,\n    };\n};\nconst getOrderedStepsFromPod = (name, ns) => {\n    return k8sGet(PodModel, name, ns)\n        .then((pod) => {\n        var _a, _b, _c;\n        return getSortedContainerStatus((_a = pod.spec.containers) !== null && _a !== void 0 ? _a : [], (_c = (_b = pod.status) === null || _b === void 0 ? void 0 : _b.containerStatuses) !== null && _c !== void 0 ? _c : []);\n    })\n        .catch((err) => {\n        errorModal({ error: err.message || 'Error downloading logs.' });\n        return [];\n    });\n};\nexport const getDownloadAllLogsCallback = (sortedTaskRuns, taskRunFromYaml, namespace, pipelineRunName) => {\n    const getWatchUrls = () => __awaiter(void 0, void 0, void 0, function* () {\n        const stepsList = yield Promise.all(sortedTaskRuns.map((currTask) => {\n            const { status = {} } = taskRunFromYaml[currTask];\n            const { podName } = status;\n            return getOrderedStepsFromPod(podName, namespace);\n        }));\n        return sortedTaskRuns.reduce((acc, currTask, i) => {\n            const { pipelineTaskName, status = {} } = taskRunFromYaml[currTask];\n            const { podName } = status;\n            const steps = stepsList[i];\n            const allStepUrls = steps.reduce((stepUrls, currentStep) => {\n                const { name } = currentStep;\n                const currentStatus = containerToLogSourceStatus(currentStep);\n                if (currentStatus === LOG_SOURCE_WAITING)\n                    return stepUrls;\n                const urlOpts = {\n                    ns: namespace,\n                    name: podName,\n                    path: 'log',\n                    queryParams: {\n                        container: name,\n                        follow: 'true',\n                    },\n                };\n                return Object.assign(Object.assign({}, stepUrls), { [name]: {\n                        status: currentStatus,\n                        url: resourceURL(PodModel, urlOpts),\n                    } });\n            }, {});\n            acc[currTask] = {\n                name: pipelineTaskName,\n                steps: Object.assign({}, allStepUrls),\n            };\n            return acc;\n        }, {});\n    });\n    const fetchLogs = (tasksPromise) => __awaiter(void 0, void 0, void 0, function* () {\n        const tasks = yield tasksPromise;\n        const allRequests = sortedTaskRuns.reduce((acc, currTask) => {\n            const task = tasks[currTask];\n            const promises = Object.keys(task.steps).map((step, i) => {\n                let heading = '';\n                if (i === 0) {\n                    heading += `${task.name}\\n\\n`;\n                }\n                heading += `${step}\\n\\n`;\n                const { url, status } = task.steps[step];\n                const getContentPromise = coFetchText(url).then((logs) => {\n                    return `${heading}${logs}\\n\\n`;\n                });\n                if (status === LOG_SOURCE_TERMINATED) {\n                    // If we are done, we want this log content\n                    return getContentPromise;\n                }\n                // If we are not done, let's not wait indefinitely\n                return Promise.race([\n                    getContentPromise,\n                    new Promise((resolve) => {\n                        setTimeout(() => resolve(''), 1000);\n                    }),\n                ]);\n            });\n            return [...acc, ...promises];\n        }, []);\n        const buffer = new LineBuffer(null);\n        return Promise.all(allRequests).then((allLogs) => {\n            buffer.ingest(allLogs.join(''));\n            const blob = buffer.getBlob({\n                type: 'text/plain;charset=utf-8',\n            });\n            saveAs(blob, `${pipelineRunName}.log`);\n            return null;\n        });\n    });\n    return () => {\n        return fetchLogs(getWatchUrls());\n    };\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelineruns/logs/logs-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelineruns/logs/logs-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { saveAs } from 'file-saver';\nimport {\n  PodKind,\n  ContainerSpec,\n  ContainerStatus,\n  resourceURL,\n  k8sGet,\n} from '@console/internal/module/k8s';\nimport {\n  LOG_SOURCE_TERMINATED,\n  LOG_SOURCE_WAITING,\n  LineBuffer,\n} from '@console/internal/components/utils';\nimport { PodModel } from '@console/internal/models';\nimport { coFetchText } from '@console/internal/co-fetch';\nimport { errorModal } from '@console/internal/components/modals';\nimport { containerToLogSourceStatus } from '../../../utils/pipeline-utils';\nimport { TaskRuns } from '../../../utils/pipeline-augment';\n\nconst getSortedContainerStatus = (\n  containers: ContainerSpec[],\n  containerStatuses: ContainerStatus[],\n): ContainerStatus[] => {\n  const containerNames = containers.map((c) => c.name);\n  const sortedContainerStatus = [];\n  containerStatuses.forEach((cs) => {\n    const containerIndex = containerNames.indexOf(cs.name);\n    sortedContainerStatus[containerIndex] = cs;\n  });\n  return sortedContainerStatus;\n};\n\nexport const getRenderContainers = (\n  pod: PodKind,\n): { containers: ContainerSpec[]; stillFetching: boolean } => {\n  const containers: ContainerSpec[] = pod.spec?.containers ?? [];\n  const containerStatuses: ContainerStatus[] = pod.status?.containerStatuses ?? [];\n\n  const sortedContainerStatuses = getSortedContainerStatus(containers, containerStatuses);\n\n  const firstRunningCont = sortedContainerStatuses.findIndex(\n    (container) => containerToLogSourceStatus(container) !== LOG_SOURCE_TERMINATED,\n  );\n  return {\n    containers: containers.slice(\n      0,\n      firstRunningCont === -1 ? containers.length : firstRunningCont + 1,\n    ),\n    stillFetching: firstRunningCont !== -1,\n  };\n};\n\nconst getOrderedStepsFromPod = (name: string, ns: string): Promise<ContainerStatus[]> => {\n  return k8sGet(PodModel, name, ns)\n    .then((pod: PodKind) => {\n      return getSortedContainerStatus(\n        pod.spec.containers ?? [],\n        pod.status?.containerStatuses ?? [],\n      );\n    })\n    .catch((err) => {\n      errorModal({ error: err.message || 'Error downloading logs.' });\n      return [];\n    });\n};\n\ntype StepsWatchUrl = {\n  [key: string]: {\n    name: string;\n    steps: { [step: string]: WatchURLStatus };\n  };\n};\n\ntype WatchURLStatus = {\n  status: string;\n  url: string;\n};\n\nexport const getDownloadAllLogsCallback = (\n  sortedTaskRuns: string[],\n  taskRunFromYaml: TaskRuns,\n  namespace: string,\n  pipelineRunName: string,\n): (() => Promise<Error>) => {\n  const getWatchUrls = async (): Promise<StepsWatchUrl> => {\n    const stepsList: ContainerStatus[][] = await Promise.all(\n      sortedTaskRuns.map((currTask) => {\n        const { status = {} } = taskRunFromYaml[currTask];\n        const { podName } = status;\n        return getOrderedStepsFromPod(podName, namespace);\n      }),\n    );\n    return sortedTaskRuns.reduce((acc, currTask, i) => {\n      const { pipelineTaskName, status = {} } = taskRunFromYaml[currTask];\n      const { podName } = status;\n      const steps = stepsList[i];\n      const allStepUrls = steps.reduce((stepUrls, currentStep) => {\n        const { name } = currentStep;\n        const currentStatus = containerToLogSourceStatus(currentStep);\n        if (currentStatus === LOG_SOURCE_WAITING) return stepUrls;\n        const urlOpts = {\n          ns: namespace,\n          name: podName,\n          path: 'log',\n          queryParams: {\n            container: name,\n            follow: 'true',\n          },\n        };\n        return {\n          ...stepUrls,\n          [name]: {\n            status: currentStatus,\n            url: resourceURL(PodModel, urlOpts),\n          } as WatchURLStatus,\n        };\n      }, {});\n      acc[currTask] = {\n        name: pipelineTaskName,\n        steps: { ...allStepUrls },\n      };\n      return acc;\n    }, {});\n  };\n\n  const fetchLogs = async (tasksPromise: Promise<StepsWatchUrl>) => {\n    const tasks = await tasksPromise;\n    const allRequests: Promise<string>[] = sortedTaskRuns.reduce((acc, currTask) => {\n      const task = tasks[currTask];\n      const promises: Promise<string>[] = Object.keys(task.steps).map((step, i) => {\n        let heading = '';\n        if (i === 0) {\n          heading += `${task.name}\\n\\n`;\n        }\n        heading += `${step}\\n\\n`;\n        const { url, status } = task.steps[step];\n        const getContentPromise = coFetchText(url).then((logs) => {\n          return `${heading}${logs}\\n\\n`;\n        });\n        if (status === LOG_SOURCE_TERMINATED) {\n          // If we are done, we want this log content\n          return getContentPromise;\n        }\n        // If we are not done, let's not wait indefinitely\n        return Promise.race([\n          getContentPromise,\n          new Promise<string>((resolve) => {\n            setTimeout(() => resolve(''), 1000);\n          }),\n        ]);\n      });\n      return [...acc, ...promises];\n    }, []);\n    const buffer = new LineBuffer(null);\n    return Promise.all(allRequests).then((allLogs) => {\n      buffer.ingest(allLogs.join(''));\n      const blob = buffer.getBlob({\n        type: 'text/plain;charset=utf-8',\n      });\n      saveAs(blob, `${pipelineRunName}.log`);\n      return null;\n    });\n  };\n  return (): Promise<Error> => {\n    return fetchLogs(getWatchUrls());\n  };\n};\n"]}]}