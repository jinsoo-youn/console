{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/components/utils/units.js","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/components/utils/units.js","mtime":1615298458750},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as _ from 'lodash-es';\nexport const units = {};\nexport const validate = {};\nconst TYPES = {\n    numeric: {\n        units: ['', 'k', 'm', 'b'],\n        space: false,\n        divisor: 1000,\n    },\n    decimalBytes: {\n        units: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'],\n        space: true,\n        divisor: 1000,\n    },\n    decimalBytesWithoutB: {\n        units: ['', 'k', 'M', 'G', 'T', 'P', 'E'],\n        space: true,\n        divisor: 1000,\n    },\n    binaryBytes: {\n        units: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'],\n        space: true,\n        divisor: 1024,\n    },\n    binaryBytesWithoutB: {\n        units: ['i', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei'],\n        space: true,\n        divisor: 1024,\n    },\n    SI: {\n        units: ['', 'k', 'M', 'G', 'T', 'P', 'E'],\n        space: false,\n        divisor: 1000,\n    },\n    decimalBytesPerSec: {\n        units: ['Bps', 'KBps', 'MBps', 'GBps', 'TBps', 'PBps', 'EBps'],\n        space: true,\n        divisor: 1000,\n    },\n    packetsPerSec: {\n        units: ['pps', 'kpps'],\n        space: true,\n        divisor: 1000,\n    },\n    seconds: {\n        units: ['ns', 'μs', 'ms', 's'],\n        space: true,\n        divisor: 1000,\n    },\n};\nexport const getType = (name) => {\n    const type = TYPES[name];\n    if (!_.isPlainObject(type)) {\n        return {\n            units: [],\n            space: false,\n            divisor: 1000,\n        };\n    }\n    return type;\n};\nconst convertBaseValueToUnits = (value, unitArray, divisor, initialUnit, preferredUnit) => {\n    const sliceIndex = initialUnit ? unitArray.indexOf(initialUnit) : 0;\n    const units_ = unitArray.slice(sliceIndex);\n    if (preferredUnit || preferredUnit === '') {\n        const unitIndex = units_.indexOf(preferredUnit);\n        if (unitIndex !== -1) {\n            return {\n                value: value / divisor ** unitIndex,\n                unit: preferredUnit,\n            };\n        }\n    }\n    let unit = units_.shift();\n    while (value >= divisor && units_.length > 0) {\n        value = value / divisor;\n        unit = units_.shift();\n    }\n    return { value, unit };\n};\nconst convertValueWithUnitsToBaseValue = (value, unitArray, divisor) => {\n    const defaultReturn = { value, unit: '' };\n    if (typeof value !== 'string') {\n        return defaultReturn;\n    }\n    let units_ = unitArray.slice().reverse();\n    // find which unit we're given\n    let truncateStringAt = -1;\n    const startingUnitIndex = _.findIndex(units_, function (currentUnitValue) {\n        const index = value.indexOf(currentUnitValue);\n        if (index > -1) {\n            truncateStringAt = index;\n            return true;\n        }\n        return false;\n    });\n    if (startingUnitIndex <= 0) {\n        // can't parse\n        return defaultReturn;\n    }\n    // get the numeric value & prepare unit array for conversion\n    units_ = units_.slice(startingUnitIndex);\n    value = value.substring(0, truncateStringAt);\n    value = _.toNumber(value);\n    let unit = units_.shift();\n    while (units_.length > 0) {\n        value = value * divisor;\n        unit = units_.shift();\n    }\n    return { value, unit };\n};\nconst getDefaultFractionDigits = (value) => {\n    if (value < 1) {\n        return 3;\n    }\n    if (value < 100) {\n        return 2;\n    }\n    return 1;\n};\nconst formatValue = (value, options) => {\n    const fractionDigits = getDefaultFractionDigits(value);\n    const _a = _.defaults(options, {\n        maximumFractionDigits: fractionDigits,\n    }), { locales } = _a, rest = __rest(_a, [\"locales\"]);\n    if (!isFinite(value)) {\n        return Intl.NumberFormat(locales, rest).format(0);\n    }\n    return Intl.NumberFormat(locales, rest).format(value);\n};\nconst round = (units.round = (value, fractionDigits) => {\n    if (!isFinite(value)) {\n        return 0;\n    }\n    const multiplier = Math.pow(10, fractionDigits || getDefaultFractionDigits(value));\n    return Math.round(value * multiplier) / multiplier;\n});\nconst humanize = (units.humanize = (value, typeName, useRound = false, initialUnit, preferredUnit) => {\n    const type = getType(typeName);\n    if (!isFinite(value)) {\n        value = 0;\n    }\n    let converted = convertBaseValueToUnits(value, type.units, type.divisor, initialUnit, preferredUnit);\n    if (useRound) {\n        converted.value = round(converted.value);\n        converted = convertBaseValueToUnits(converted.value, type.units, type.divisor, converted.unit, preferredUnit);\n    }\n    const formattedValue = formatValue(converted.value);\n    return {\n        string: type.space ? `${formattedValue} ${converted.unit}` : formattedValue + converted.unit,\n        unit: converted.unit,\n        value: converted.value,\n    };\n});\nconst formatPercentage = (value, options) => {\n    const _a = _.defaults({ style: 'percent' }, // Don't allow perent style to be overridden.\n    options, {\n        maximumFractionDigits: 1,\n    }), { locales } = _a, rest = __rest(_a, [\"locales\"]);\n    return Intl.NumberFormat(locales, rest).format(value);\n};\nexport const humanizeBinaryBytesWithoutB = (v, initialUnit, preferredUnit) => humanize(v, 'binaryBytesWithoutB', true, initialUnit, preferredUnit);\nexport const humanizeBinaryBytes = (v, initialUnit, preferredUnit) => humanize(v, 'binaryBytes', true, initialUnit, preferredUnit);\nexport const humanizeDecimalBytes = (v, initialUnit, preferredUnit) => humanize(v, 'decimalBytes', true, initialUnit, preferredUnit);\nexport const humanizeDecimalBytesPerSec = (v, initialUnit, preferredUnit) => humanize(v, 'decimalBytesPerSec', true, initialUnit, preferredUnit);\nexport const humanizePacketsPerSec = (v, initialUnit, preferredUnit) => humanize(v, 'packetsPerSec', true, initialUnit, preferredUnit);\nexport const humanizeNumber = (v, initialUnit, preferredUnit) => humanize(v, 'numeric', true, initialUnit, preferredUnit);\nexport const humanizeNumberSI = (v, initialUnit, preferredUnit) => humanize(v, 'SI', true, initialUnit, preferredUnit);\nexport const humanizeSeconds = (v, initialUnit, preferredUnit) => humanize(v, 'seconds', true, initialUnit, preferredUnit);\nexport const humanizeCpuCores = (v) => {\n    const value = v < 1 ? round(v * 1000) : v;\n    const unit = v < 1 ? 'm' : '';\n    return {\n        string: `${formatValue(value)}${unit}`,\n        unit,\n        value,\n    };\n};\nexport const humanizePercentage = (value) => {\n    if (!isFinite(value)) {\n        value = 0;\n    }\n    return {\n        string: formatPercentage(value / 100),\n        unit: '%',\n        value: round(value, 1),\n    };\n};\nunits.dehumanize = (value, typeName) => {\n    const type = getType(typeName);\n    return convertValueWithUnitsToBaseValue(value, type.units, type.divisor);\n};\nvalidate.split = (value) => {\n    const index = value.search(/([a-zA-Z]+)/g);\n    let number, unit;\n    if (index === -1) {\n        number = value;\n    }\n    else {\n        number = value.slice(0, index);\n        unit = value.slice(index);\n    }\n    return [parseFloat(number, 10), unit];\n};\nconst baseUnitedValidation = (value) => {\n    if (value === null || value.length === 0) {\n        return;\n    }\n    if (value.search(/\\s/g) !== -1) {\n        return 'white space is not allowed';\n    }\n};\nconst validateNumber = (float = '') => {\n    if (float < 0) {\n        return 'must be positive';\n    }\n    if (!isFinite(float)) {\n        return 'must be a number';\n    }\n};\nconst validCPUUnits = new Set(['m', '']);\nconst validateCPUUnit = (value = '') => {\n    if (validCPUUnits.has(value)) {\n        return;\n    }\n    return `unrecongnized unit: ${value}`;\n};\nvalidate.CPU = (value = '') => {\n    if (!value) {\n        return;\n    }\n    const error = baseUnitedValidation(value);\n    if (error) {\n        return error;\n    }\n    const [number, unit] = validate.split(value);\n    if (!unit) {\n        return validateNumber(number);\n    }\n    return validateNumber(number) || validateCPUUnit(unit);\n};\nconst validMemUnits = new Set(['E', 'P', 'T', 'G', 'M', 'k', 'Pi', 'Ti', 'Gi', 'Mi', 'Ki']);\nconst validateMemUnit = (value = '') => {\n    if (validMemUnits.has(value)) {\n        return;\n    }\n    return `unrecongnized unit: ${value}`;\n};\nconst validTimeUnits = new Set(['s', 'm', 'h', 'd', 'M', 'y']);\nconst validateTimeUnit = (value = '') => {\n    if (validTimeUnits.has(value)) {\n        return;\n    }\n    return `unrecongnized unit: ${value}`;\n};\nvalidate.time = (value = '') => {\n    if (!value) {\n        return;\n    }\n    const error = baseUnitedValidation(value);\n    if (error) {\n        return error;\n    }\n    const [number, unit] = validate.split(value);\n    if (!unit) {\n        return 'number and unit required';\n    }\n    return validateNumber(number) || validateTimeUnit(unit);\n};\nvalidate.memory = (value = '') => {\n    if (!value) {\n        return;\n    }\n    const error = baseUnitedValidation(value);\n    if (error) {\n        return error;\n    }\n    const [number, unit] = validate.split(value);\n    if (!unit) {\n        return validateNumber(value);\n    }\n    return validateNumber(number) || validateMemUnit(unit);\n};\n// Convert k8s compute resources values to a base value for comparison.\n// If the value has no unit, it just returns the number, so this function\n// can be used for any quota resource (resource counts). `units.dehumanize`\n// is problematic for comparing quota resources because you need to know\n// what unit you're dealing with already (e.g. decimal vs binary). Returns\n// null if value isn't recognized as valid.\nexport const convertToBaseValue = (value) => {\n    if (!_.isString(value)) {\n        return null;\n    }\n    const [number, unit] = validate.split(value);\n    const validationError = validateNumber(number);\n    if (validationError) {\n        return null;\n    }\n    if (!unit) {\n        return number;\n    }\n    // Handle CPU millicores specifically.\n    if (unit === 'm') {\n        return number / 1000;\n    }\n    if (TYPES.binaryBytesWithoutB.units.includes(unit)) {\n        return units.dehumanize(value, 'binaryBytesWithoutB').value;\n    }\n    if (TYPES.decimalBytesWithoutB.units.includes(unit)) {\n        return units.dehumanize(value, 'decimalBytesWithoutB').value;\n    }\n    // Unrecognized unit.\n    return null;\n};\nexport const secondsToNanoSeconds = (value) => {\n    const val = Number(value);\n    return Number.isFinite(val) ? val * 1000 ** 3 : 0;\n};\nexport const formatToFractionalDigits = (value, digits) => Intl.NumberFormat(undefined, {\n    minimumFractionDigits: digits,\n    maximumFractionDigits: digits,\n}).format(value);\nexport const formatBytesAsMiB = (bytes) => {\n    const mib = bytes / 1024 / 1024;\n    return formatToFractionalDigits(mib, 1);\n};\nexport const formatCores = (cores) => formatToFractionalDigits(cores, 3);\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/components/utils/units.js","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/components/utils/units.js"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash-es';\n\nexport const units = {};\nexport const validate = {};\n\nconst TYPES = {\n  numeric: {\n    units: ['', 'k', 'm', 'b'],\n    space: false,\n    divisor: 1000,\n  },\n  decimalBytes: {\n    units: ['B', 'KB', 'MB', 'GB', 'TB', 'PB', 'EB'],\n    space: true,\n    divisor: 1000,\n  },\n  decimalBytesWithoutB: {\n    units: ['', 'k', 'M', 'G', 'T', 'P', 'E'],\n    space: true,\n    divisor: 1000,\n  },\n  binaryBytes: {\n    units: ['B', 'KiB', 'MiB', 'GiB', 'TiB', 'PiB'],\n    space: true,\n    divisor: 1024,\n  },\n  binaryBytesWithoutB: {\n    units: ['i', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei'],\n    space: true,\n    divisor: 1024,\n  },\n  SI: {\n    units: ['', 'k', 'M', 'G', 'T', 'P', 'E'],\n    space: false,\n    divisor: 1000,\n  },\n  decimalBytesPerSec: {\n    units: ['Bps', 'KBps', 'MBps', 'GBps', 'TBps', 'PBps', 'EBps'],\n    space: true,\n    divisor: 1000,\n  },\n  packetsPerSec: {\n    units: ['pps', 'kpps'],\n    space: true,\n    divisor: 1000,\n  },\n  seconds: {\n    units: ['ns', 'μs', 'ms', 's'],\n    space: true,\n    divisor: 1000,\n  },\n};\n\nexport const getType = (name) => {\n  const type = TYPES[name];\n  if (!_.isPlainObject(type)) {\n    return {\n      units: [],\n      space: false,\n      divisor: 1000,\n    };\n  }\n  return type;\n};\n\nconst convertBaseValueToUnits = (value, unitArray, divisor, initialUnit, preferredUnit) => {\n  const sliceIndex = initialUnit ? unitArray.indexOf(initialUnit) : 0;\n  const units_ = unitArray.slice(sliceIndex);\n\n  if (preferredUnit || preferredUnit === '') {\n    const unitIndex = units_.indexOf(preferredUnit);\n    if (unitIndex !== -1) {\n      return {\n        value: value / divisor ** unitIndex,\n        unit: preferredUnit,\n      };\n    }\n  }\n\n  let unit = units_.shift();\n  while (value >= divisor && units_.length > 0) {\n    value = value / divisor;\n    unit = units_.shift();\n  }\n  return { value, unit };\n};\n\nconst convertValueWithUnitsToBaseValue = (value, unitArray, divisor) => {\n  const defaultReturn = { value, unit: '' };\n  if (typeof value !== 'string') {\n    return defaultReturn;\n  }\n\n  let units_ = unitArray.slice().reverse();\n\n  // find which unit we're given\n  let truncateStringAt = -1;\n  const startingUnitIndex = _.findIndex(units_, function(currentUnitValue) {\n    const index = value.indexOf(currentUnitValue);\n    if (index > -1) {\n      truncateStringAt = index;\n      return true;\n    }\n    return false;\n  });\n  if (startingUnitIndex <= 0) {\n    // can't parse\n    return defaultReturn;\n  }\n\n  // get the numeric value & prepare unit array for conversion\n  units_ = units_.slice(startingUnitIndex);\n  value = value.substring(0, truncateStringAt);\n  value = _.toNumber(value);\n\n  let unit = units_.shift();\n  while (units_.length > 0) {\n    value = value * divisor;\n    unit = units_.shift();\n  }\n\n  return { value, unit };\n};\n\nconst getDefaultFractionDigits = (value) => {\n  if (value < 1) {\n    return 3;\n  }\n  if (value < 100) {\n    return 2;\n  }\n  return 1;\n};\n\nconst formatValue = (value, options) => {\n  const fractionDigits = getDefaultFractionDigits(value);\n  const { locales, ...rest } = _.defaults(options, {\n    maximumFractionDigits: fractionDigits,\n  });\n\n  if (!isFinite(value)) {\n    return Intl.NumberFormat(locales, rest).format(0);\n  }\n  return Intl.NumberFormat(locales, rest).format(value);\n};\n\nconst round = (units.round = (value, fractionDigits) => {\n  if (!isFinite(value)) {\n    return 0;\n  }\n  const multiplier = Math.pow(10, fractionDigits || getDefaultFractionDigits(value));\n  return Math.round(value * multiplier) / multiplier;\n});\n\nconst humanize = (units.humanize = (\n  value,\n  typeName,\n  useRound = false,\n  initialUnit,\n  preferredUnit,\n) => {\n  const type = getType(typeName);\n\n  if (!isFinite(value)) {\n    value = 0;\n  }\n\n  let converted = convertBaseValueToUnits(\n    value,\n    type.units,\n    type.divisor,\n    initialUnit,\n    preferredUnit,\n  );\n\n  if (useRound) {\n    converted.value = round(converted.value);\n    converted = convertBaseValueToUnits(\n      converted.value,\n      type.units,\n      type.divisor,\n      converted.unit,\n      preferredUnit,\n    );\n  }\n\n  const formattedValue = formatValue(converted.value);\n\n  return {\n    string: type.space ? `${formattedValue} ${converted.unit}` : formattedValue + converted.unit,\n    unit: converted.unit,\n    value: converted.value,\n  };\n});\n\nconst formatPercentage = (value, options) => {\n  const { locales, ...rest } = _.defaults(\n    { style: 'percent' }, // Don't allow perent style to be overridden.\n    options,\n    {\n      maximumFractionDigits: 1,\n    },\n  );\n  return Intl.NumberFormat(locales, rest).format(value);\n};\n\nexport const humanizeBinaryBytesWithoutB = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'binaryBytesWithoutB', true, initialUnit, preferredUnit);\nexport const humanizeBinaryBytes = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'binaryBytes', true, initialUnit, preferredUnit);\nexport const humanizeDecimalBytes = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'decimalBytes', true, initialUnit, preferredUnit);\nexport const humanizeDecimalBytesPerSec = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'decimalBytesPerSec', true, initialUnit, preferredUnit);\nexport const humanizePacketsPerSec = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'packetsPerSec', true, initialUnit, preferredUnit);\nexport const humanizeNumber = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'numeric', true, initialUnit, preferredUnit);\nexport const humanizeNumberSI = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'SI', true, initialUnit, preferredUnit);\nexport const humanizeSeconds = (v, initialUnit, preferredUnit) =>\n  humanize(v, 'seconds', true, initialUnit, preferredUnit);\nexport const humanizeCpuCores = (v) => {\n  const value = v < 1 ? round(v * 1000) : v;\n  const unit = v < 1 ? 'm' : '';\n  return {\n    string: `${formatValue(value)}${unit}`,\n    unit,\n    value,\n  };\n};\nexport const humanizePercentage = (value) => {\n  if (!isFinite(value)) {\n    value = 0;\n  }\n  return {\n    string: formatPercentage(value / 100),\n    unit: '%',\n    value: round(value, 1),\n  };\n};\n\nunits.dehumanize = (value, typeName) => {\n  const type = getType(typeName);\n  return convertValueWithUnitsToBaseValue(value, type.units, type.divisor);\n};\n\nvalidate.split = (value) => {\n  const index = value.search(/([a-zA-Z]+)/g);\n  let number, unit;\n  if (index === -1) {\n    number = value;\n  } else {\n    number = value.slice(0, index);\n    unit = value.slice(index);\n  }\n  return [parseFloat(number, 10), unit];\n};\n\nconst baseUnitedValidation = (value) => {\n  if (value === null || value.length === 0) {\n    return;\n  }\n  if (value.search(/\\s/g) !== -1) {\n    return 'white space is not allowed';\n  }\n};\n\nconst validateNumber = (float = '') => {\n  if (float < 0) {\n    return 'must be positive';\n  }\n  if (!isFinite(float)) {\n    return 'must be a number';\n  }\n};\nconst validCPUUnits = new Set(['m', '']);\nconst validateCPUUnit = (value = '') => {\n  if (validCPUUnits.has(value)) {\n    return;\n  }\n  return `unrecongnized unit: ${value}`;\n};\n\nvalidate.CPU = (value = '') => {\n  if (!value) {\n    return;\n  }\n  const error = baseUnitedValidation(value);\n  if (error) {\n    return error;\n  }\n\n  const [number, unit] = validate.split(value);\n\n  if (!unit) {\n    return validateNumber(number);\n  }\n\n  return validateNumber(number) || validateCPUUnit(unit);\n};\n\nconst validMemUnits = new Set(['E', 'P', 'T', 'G', 'M', 'k', 'Pi', 'Ti', 'Gi', 'Mi', 'Ki']);\nconst validateMemUnit = (value = '') => {\n  if (validMemUnits.has(value)) {\n    return;\n  }\n  return `unrecongnized unit: ${value}`;\n};\n\nconst validTimeUnits = new Set(['s', 'm', 'h', 'd', 'M', 'y']);\nconst validateTimeUnit = (value = '') => {\n  if (validTimeUnits.has(value)) {\n    return;\n  }\n  return `unrecongnized unit: ${value}`;\n};\n\nvalidate.time = (value = '') => {\n  if (!value) {\n    return;\n  }\n  const error = baseUnitedValidation(value);\n  if (error) {\n    return error;\n  }\n\n  const [number, unit] = validate.split(value);\n\n  if (!unit) {\n    return 'number and unit required';\n  }\n\n  return validateNumber(number) || validateTimeUnit(unit);\n};\n\nvalidate.memory = (value = '') => {\n  if (!value) {\n    return;\n  }\n  const error = baseUnitedValidation(value);\n  if (error) {\n    return error;\n  }\n\n  const [number, unit] = validate.split(value);\n\n  if (!unit) {\n    return validateNumber(value);\n  }\n\n  return validateNumber(number) || validateMemUnit(unit);\n};\n\n// Convert k8s compute resources values to a base value for comparison.\n// If the value has no unit, it just returns the number, so this function\n// can be used for any quota resource (resource counts). `units.dehumanize`\n// is problematic for comparing quota resources because you need to know\n// what unit you're dealing with already (e.g. decimal vs binary). Returns\n// null if value isn't recognized as valid.\nexport const convertToBaseValue = (value) => {\n  if (!_.isString(value)) {\n    return null;\n  }\n\n  const [number, unit] = validate.split(value);\n  const validationError = validateNumber(number);\n  if (validationError) {\n    return null;\n  }\n\n  if (!unit) {\n    return number;\n  }\n\n  // Handle CPU millicores specifically.\n  if (unit === 'm') {\n    return number / 1000;\n  }\n\n  if (TYPES.binaryBytesWithoutB.units.includes(unit)) {\n    return units.dehumanize(value, 'binaryBytesWithoutB').value;\n  }\n\n  if (TYPES.decimalBytesWithoutB.units.includes(unit)) {\n    return units.dehumanize(value, 'decimalBytesWithoutB').value;\n  }\n\n  // Unrecognized unit.\n  return null;\n};\n\nexport const secondsToNanoSeconds = (value) => {\n  const val = Number(value);\n  return Number.isFinite(val) ? val * 1000 ** 3 : 0;\n};\n\nexport const formatToFractionalDigits = (value, digits) =>\n  Intl.NumberFormat(undefined, {\n    minimumFractionDigits: digits,\n    maximumFractionDigits: digits,\n  }).format(value);\n\nexport const formatBytesAsMiB = (bytes) => {\n  const mib = bytes / 1024 / 1024;\n  return formatToFractionalDigits(mib, 1);\n};\n\nexport const formatCores = (cores) => formatToFractionalDigits(cores, 3);\n"]}]}