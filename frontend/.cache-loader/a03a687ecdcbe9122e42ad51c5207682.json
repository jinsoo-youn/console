{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/anchor-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/anchor-utils.ts","mtime":1616735742460},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import Point from '../geom/Point';\nconst getEllipseAnchorPoint = (center, width, height, reference) => {\n    const { x, y } = reference;\n    if (width === 0 || height === 0 || (center.x === x && center.y === y)) {\n        return center;\n    }\n    const dispX = (center.x - x) / (width / 2);\n    const dispY = (center.y - y) / (height / 2);\n    const len = Math.sqrt(dispX * dispX + dispY * dispY);\n    const newLength = len - 1;\n    const lenProportion = newLength / len;\n    return new Point((center.x - x) * lenProportion + x, (center.y - y) * lenProportion + y);\n};\nconst getRectAnchorPoint = (center, width, height, reference) => {\n    let dx = reference.x - center.x;\n    let dy = reference.y - center.y;\n    if ((dx === 0 && dy === 0) || (width === 0 && height === 0)) {\n        return center;\n    }\n    const scale = 0.5 /\n        Math.max(width === 0 ? 0 : Math.abs(dx) / width, height === 0 ? 0 : Math.abs(dy) / height);\n    dx *= scale;\n    dy *= scale;\n    return center.clone().translate(dx, dy);\n};\nconst svgPointToPoint = (p) => {\n    return new Point(p.x, p.y);\n};\nconst distanceToPoint = (p, reference) => {\n    const dx = p.x - reference.x;\n    const dy = p.y - reference.y;\n    return dx * dx + dy * dy;\n};\nconst isBetween = (a, b1, b2) => {\n    return Math.ceil(a) >= Math.min(b1, b2) && Math.floor(a) <= Math.max(b1, b2);\n};\nconst getLinesIntersection = (line1, line2) => {\n    const line1xDelta = line1[0].x - line1[1].x;\n    const line1yDelta = line1[0].y - line1[1].y;\n    const line2xDelta = line2[0].x - line2[1].x;\n    const line2yDelta = line2[0].y - line2[1].y;\n    const denominator = line1xDelta * line2yDelta - line1yDelta * line2xDelta;\n    if (denominator === 0) {\n        // parallel lines do not intersect\n        return null;\n    }\n    const d1 = line1[0].x * line1[1].y - line1[0].y * line1[1].x;\n    const d2 = line2[0].x * line2[1].y - line2[0].y * line2[1].x;\n    const xValue = d1 * line2xDelta - line1xDelta * d2;\n    const yValue = d1 * line2yDelta - d2 * line1yDelta;\n    const intersection = new Point(xValue / denominator, yValue / denominator);\n    if (!isBetween(intersection.x, line1[0].x, line1[1].x) ||\n        !isBetween(intersection.y, line1[0].y, line1[1].y) ||\n        !isBetween(intersection.x, line2[0].x, line2[1].x) ||\n        !isBetween(intersection.y, line2[0].y, line2[1].y)) {\n        // intersection is not in range\n        return null;\n    }\n    return intersection;\n};\nconst getPathIntersectionPoint = (pathNode, line) => {\n    const pathLength = pathNode.getTotalLength();\n    const numSegments = Math.min(Math.round(pathLength / 5), 100);\n    for (let i = 0; i < numSegments; i++) {\n        const pos1 = pathNode.getPointAtLength((pathLength * i) / numSegments);\n        const pos2 = pathNode.getPointAtLength((pathLength * (i + 1)) / numSegments);\n        const intersectPoint = getLinesIntersection([svgPointToPoint(pos1), svgPointToPoint(pos2)], line);\n        if (intersectPoint) {\n            return intersectPoint;\n        }\n    }\n    // No intersection found, return the center point\n    const pathBox = pathNode.getBBox();\n    return new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);\n};\nconst getPathClosestPoint = (pathNode, reference) => {\n    const pathLength = pathNode.getTotalLength();\n    let precision = 8;\n    let best = pathNode.getPointAtLength(0);\n    let bestLength = 0;\n    let bestDistance = Infinity;\n    // linear scan for coarse approximation\n    for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n        const scan = pathNode.getPointAtLength(scanLength);\n        const scanDistance = distanceToPoint(svgPointToPoint(scan), reference);\n        if (scanDistance < bestDistance) {\n            best = scan;\n            bestLength = scanLength;\n            bestDistance = scanDistance;\n        }\n    }\n    // binary search for precise estimate\n    precision /= 2;\n    while (precision > 0.5) {\n        const beforeLength = bestLength - precision;\n        const before = pathNode.getPointAtLength(beforeLength);\n        const beforeDistance = distanceToPoint(svgPointToPoint(before), reference);\n        if (beforeLength >= 0 && beforeDistance < bestDistance) {\n            best = before;\n            bestLength = beforeLength;\n            bestDistance = beforeDistance;\n        }\n        else {\n            const afterLength = bestLength + precision;\n            const after = pathNode.getPointAtLength(afterLength);\n            const afterDistance = distanceToPoint(svgPointToPoint(after), reference);\n            if (afterLength <= pathLength && afterDistance < bestDistance) {\n                best = after;\n                bestLength = afterLength;\n                bestDistance = afterDistance;\n            }\n            else {\n                precision /= 2;\n            }\n        }\n    }\n    return svgPointToPoint(best);\n};\nconst getPathAnchorPoint = (pathNode, reference, useClosestPathPoint = false) => {\n    if (useClosestPathPoint) {\n        return getPathClosestPoint(pathNode, reference);\n    }\n    const pathBox = pathNode.getBBox();\n    const pathCenter = new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);\n    return getPathIntersectionPoint(pathNode, [reference, pathCenter]);\n};\nconst getPolygonAnchorPoint = (polygonNode, reference) => {\n    const polygonBox = polygonNode.getBBox();\n    const polygonCenter = new Point(polygonBox.x + polygonBox.width / 2, polygonBox.y + polygonBox.height / 2);\n    const { points } = polygonNode;\n    let bestPoint = polygonCenter;\n    let bestDistance = Infinity;\n    for (let i = 0; i < points.length; i++) {\n        const intersectPoint = getLinesIntersection([svgPointToPoint(points[i]), svgPointToPoint(points[i === points.length - 1 ? 0 : i + 1])], [polygonCenter, reference]);\n        if (intersectPoint) {\n            const intersectDistance = distanceToPoint(intersectPoint, reference);\n            if (intersectDistance < bestDistance) {\n                bestPoint = intersectPoint;\n                bestDistance = intersectDistance;\n            }\n        }\n    }\n    return bestPoint;\n};\nexport { getEllipseAnchorPoint, getRectAnchorPoint, getPathAnchorPoint, getPolygonAnchorPoint };\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/anchor-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/anchor-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import Point from '../geom/Point';\n\nconst getEllipseAnchorPoint = (\n  center: Point,\n  width: number,\n  height: number,\n  reference: Point,\n): Point => {\n  const { x, y } = reference;\n  if (width === 0 || height === 0 || (center.x === x && center.y === y)) {\n    return center;\n  }\n\n  const dispX = (center.x - x) / (width / 2);\n  const dispY = (center.y - y) / (height / 2);\n\n  const len = Math.sqrt(dispX * dispX + dispY * dispY);\n\n  const newLength = len - 1;\n\n  const lenProportion = newLength / len;\n\n  return new Point((center.x - x) * lenProportion + x, (center.y - y) * lenProportion + y);\n};\n\nconst getRectAnchorPoint = (\n  center: Point,\n  width: number,\n  height: number,\n  reference: Point,\n): Point => {\n  let dx = reference.x - center.x;\n  let dy = reference.y - center.y;\n\n  if ((dx === 0 && dy === 0) || (width === 0 && height === 0)) {\n    return center;\n  }\n\n  const scale =\n    0.5 /\n    Math.max(width === 0 ? 0 : Math.abs(dx) / width, height === 0 ? 0 : Math.abs(dy) / height);\n\n  dx *= scale;\n  dy *= scale;\n\n  return center.clone().translate(dx, dy);\n};\n\nconst svgPointToPoint = (p: SVGPoint): Point => {\n  return new Point(p.x, p.y);\n};\n\nconst distanceToPoint = (p: Point, reference: Point): number => {\n  const dx = p.x - reference.x;\n  const dy = p.y - reference.y;\n\n  return dx * dx + dy * dy;\n};\n\nconst isBetween = (a: number, b1: number, b2: number): boolean => {\n  return Math.ceil(a) >= Math.min(b1, b2) && Math.floor(a) <= Math.max(b1, b2);\n};\n\nconst getLinesIntersection = (line1: [Point, Point], line2: [Point, Point]): Point | null => {\n  const line1xDelta = line1[0].x - line1[1].x;\n  const line1yDelta = line1[0].y - line1[1].y;\n  const line2xDelta = line2[0].x - line2[1].x;\n  const line2yDelta = line2[0].y - line2[1].y;\n\n  const denominator = line1xDelta * line2yDelta - line1yDelta * line2xDelta;\n  if (denominator === 0) {\n    // parallel lines do not intersect\n    return null;\n  }\n\n  const d1 = line1[0].x * line1[1].y - line1[0].y * line1[1].x;\n  const d2 = line2[0].x * line2[1].y - line2[0].y * line2[1].x;\n  const xValue = d1 * line2xDelta - line1xDelta * d2;\n  const yValue = d1 * line2yDelta - d2 * line1yDelta;\n  const intersection: Point = new Point(xValue / denominator, yValue / denominator);\n\n  if (\n    !isBetween(intersection.x, line1[0].x, line1[1].x) ||\n    !isBetween(intersection.y, line1[0].y, line1[1].y) ||\n    !isBetween(intersection.x, line2[0].x, line2[1].x) ||\n    !isBetween(intersection.y, line2[0].y, line2[1].y)\n  ) {\n    // intersection is not in range\n    return null;\n  }\n\n  return intersection;\n};\n\nconst getPathIntersectionPoint = (pathNode: SVGPathElement, line: [Point, Point]): Point => {\n  const pathLength = pathNode.getTotalLength();\n  const numSegments = Math.min(Math.round(pathLength / 5), 100);\n  for (let i = 0; i < numSegments; i++) {\n    const pos1 = pathNode.getPointAtLength((pathLength * i) / numSegments);\n    const pos2 = pathNode.getPointAtLength((pathLength * (i + 1)) / numSegments);\n    const intersectPoint = getLinesIntersection(\n      [svgPointToPoint(pos1), svgPointToPoint(pos2)],\n      line,\n    );\n    if (intersectPoint) {\n      return intersectPoint;\n    }\n  }\n\n  // No intersection found, return the center point\n  const pathBox = pathNode.getBBox();\n  return new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);\n};\n\nconst getPathClosestPoint = (pathNode: SVGPathElement, reference: Point) => {\n  const pathLength = pathNode.getTotalLength();\n  let precision = 8;\n  let best: SVGPoint = pathNode.getPointAtLength(0);\n  let bestLength = 0;\n  let bestDistance = Infinity;\n\n  // linear scan for coarse approximation\n  for (let scanLength = 0; scanLength <= pathLength; scanLength += precision) {\n    const scan: SVGPoint = pathNode.getPointAtLength(scanLength);\n    const scanDistance: number = distanceToPoint(svgPointToPoint(scan), reference);\n    if (scanDistance < bestDistance) {\n      best = scan;\n      bestLength = scanLength;\n      bestDistance = scanDistance;\n    }\n  }\n\n  // binary search for precise estimate\n  precision /= 2;\n  while (precision > 0.5) {\n    const beforeLength: number = bestLength - precision;\n\n    const before: SVGPoint = pathNode.getPointAtLength(beforeLength);\n    const beforeDistance: number = distanceToPoint(svgPointToPoint(before), reference);\n\n    if (beforeLength >= 0 && beforeDistance < bestDistance) {\n      best = before;\n      bestLength = beforeLength;\n      bestDistance = beforeDistance;\n    } else {\n      const afterLength: number = bestLength + precision;\n      const after: SVGPoint = pathNode.getPointAtLength(afterLength);\n      const afterDistance: number = distanceToPoint(svgPointToPoint(after), reference);\n\n      if (afterLength <= pathLength && afterDistance < bestDistance) {\n        best = after;\n        bestLength = afterLength;\n        bestDistance = afterDistance;\n      } else {\n        precision /= 2;\n      }\n    }\n  }\n\n  return svgPointToPoint(best);\n};\n\nconst getPathAnchorPoint = (\n  pathNode: SVGPathElement,\n  reference: Point,\n  useClosestPathPoint: boolean = false,\n) => {\n  if (useClosestPathPoint) {\n    return getPathClosestPoint(pathNode, reference);\n  }\n\n  const pathBox = pathNode.getBBox();\n  const pathCenter = new Point(pathBox.x + pathBox.width / 2, pathBox.y + pathBox.height / 2);\n  return getPathIntersectionPoint(pathNode, [reference, pathCenter]);\n};\n\nconst getPolygonAnchorPoint = (polygonNode: SVGPolygonElement, reference: Point) => {\n  const polygonBox = polygonNode.getBBox();\n  const polygonCenter = new Point(\n    polygonBox.x + polygonBox.width / 2,\n    polygonBox.y + polygonBox.height / 2,\n  );\n  const { points } = polygonNode;\n  let bestPoint: Point = polygonCenter;\n  let bestDistance = Infinity;\n\n  for (let i = 0; i < points.length; i++) {\n    const intersectPoint: Point | null = getLinesIntersection(\n      [svgPointToPoint(points[i]), svgPointToPoint(points[i === points.length - 1 ? 0 : i + 1])],\n      [polygonCenter, reference],\n    );\n    if (intersectPoint) {\n      const intersectDistance: number = distanceToPoint(intersectPoint, reference);\n      if (intersectDistance < bestDistance) {\n        bestPoint = intersectPoint;\n        bestDistance = intersectDistance;\n      }\n    }\n  }\n\n  return bestPoint;\n};\n\nexport { getEllipseAnchorPoint, getRectAnchorPoint, getPathAnchorPoint, getPolygonAnchorPoint };\n"]}]}