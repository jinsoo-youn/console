{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/element-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/element-utils.ts","mtime":1616735742460},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nimport { isNode, isGraph } from '../types';\nconst groupNodeElements = (nodes) => {\n    if (!_.size(nodes)) {\n        return [];\n    }\n    const groupNodes = [];\n    _.forEach(nodes, (nextNode) => {\n        if (isNode(nextNode) && nextNode.isGroup() && !nextNode.isCollapsed()) {\n            groupNodes.push(nextNode);\n            groupNodes.push(...groupNodeElements(nextNode.getChildren()));\n        }\n    });\n    return groupNodes;\n};\nconst leafNodeElements = (nodeElements) => {\n    const nodes = [];\n    if (!nodeElements) {\n        return nodes;\n    }\n    if (Array.isArray(nodeElements)) {\n        _.forEach(nodeElements, (nodeElement) => {\n            nodes.push(...leafNodeElements(nodeElement));\n        });\n        return nodes;\n    }\n    if (nodeElements.isGroup() && !nodeElements.isCollapsed()) {\n        const leafNodes = [];\n        const children = nodeElements.getChildren();\n        if (_.size(children)) {\n            _.forEach(children.filter((e) => isNode(e)), (element) => {\n                leafNodes.push(...leafNodeElements(element));\n            });\n        }\n        return leafNodes;\n    }\n    return [nodeElements];\n};\nconst getTopCollapsedParent = (node) => {\n    let returnNode = node;\n    try {\n        let parent = !isGraph(node) && node.getParent();\n        while (parent && !isGraph(parent)) {\n            if (parent.isCollapsed()) {\n                returnNode = parent;\n            }\n            parent = parent.getParent();\n        }\n        // eslint-disable-next-line no-empty\n    }\n    catch (e) { }\n    return returnNode;\n};\nconst getClosestVisibleParent = (node) => {\n    if (!node) {\n        return null;\n    }\n    let returnNode = null;\n    try {\n        let parent = node.getParent();\n        while (parent) {\n            if (!parent.isVisible()) {\n                // parent isn't visible so no descendant could be visible\n                returnNode = null;\n            }\n            else if (parent.isCollapsed() || !returnNode) {\n                // parent is collapsed, no descendant is visible, but parent is\n                returnNode = parent;\n            }\n            parent = parent.getParent();\n        }\n        // eslint-disable-next-line no-empty\n    }\n    catch (e) { }\n    return returnNode;\n};\nconst getElementPadding = (element) => {\n    const stylePadding = element.getStyle().padding;\n    if (!stylePadding) {\n        return 0;\n    }\n    if (Array.isArray(stylePadding)) {\n        // For a padding that is not consistent on all sides, use the max padding\n        return stylePadding.reduce((val, current) => {\n            return Math.max(val, current);\n        }, 0);\n    }\n    return stylePadding;\n};\nconst getGroupPadding = (element, padding = 0) => {\n    if (isGraph(element)) {\n        return padding;\n    }\n    let newPadding = padding;\n    if (isNode(element) && element.isGroup() && !element.isCollapsed()) {\n        newPadding += getElementPadding(element);\n    }\n    if (element.getParent()) {\n        return getGroupPadding(element.getParent(), newPadding);\n    }\n    return newPadding;\n};\nexport { groupNodeElements, leafNodeElements, getTopCollapsedParent, getClosestVisibleParent, getElementPadding, getGroupPadding, };\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/element-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/element-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { GraphElement, Node, isNode, isGraph, NodeStyle } from '../types';\n\nconst groupNodeElements = (nodes: GraphElement[]): Node[] => {\n  if (!_.size(nodes)) {\n    return [];\n  }\n  const groupNodes: Node[] = [];\n  _.forEach(nodes, (nextNode) => {\n    if (isNode(nextNode) && nextNode.isGroup() && !nextNode.isCollapsed()) {\n      groupNodes.push(nextNode);\n      groupNodes.push(...groupNodeElements(nextNode.getChildren()));\n    }\n  });\n  return groupNodes;\n};\n\nconst leafNodeElements = (nodeElements: Node | Node[] | null): Node[] => {\n  const nodes: Node[] = [];\n\n  if (!nodeElements) {\n    return nodes;\n  }\n\n  if (Array.isArray(nodeElements)) {\n    _.forEach(nodeElements, (nodeElement: Node) => {\n      nodes.push(...leafNodeElements(nodeElement));\n    });\n    return nodes;\n  }\n\n  if (nodeElements.isGroup() && !nodeElements.isCollapsed()) {\n    const leafNodes: Node[] = [];\n    const children: GraphElement[] = nodeElements.getChildren();\n    if (_.size(children)) {\n      _.forEach(\n        children.filter((e) => isNode(e)),\n        (element: Node) => {\n          leafNodes.push(...leafNodeElements(element));\n        },\n      );\n    }\n    return leafNodes;\n  }\n\n  return [nodeElements];\n};\n\nconst getTopCollapsedParent = (node: Node): Node => {\n  let returnNode: Node = node;\n  try {\n    let parent = !isGraph(node) && node.getParent();\n    while (parent && !isGraph(parent)) {\n      if ((parent as Node).isCollapsed()) {\n        returnNode = parent as Node;\n      }\n      parent = parent.getParent();\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  return returnNode;\n};\n\nconst getClosestVisibleParent = (node: Node): Node | null => {\n  if (!node) {\n    return null;\n  }\n\n  let returnNode = null;\n  try {\n    let parent = node.getParent();\n    while (parent) {\n      if (!parent.isVisible()) {\n        // parent isn't visible so no descendant could be visible\n        returnNode = null;\n      } else if ((parent as Node).isCollapsed() || !returnNode) {\n        // parent is collapsed, no descendant is visible, but parent is\n        returnNode = parent as Node;\n      }\n      parent = parent.getParent();\n    }\n    // eslint-disable-next-line no-empty\n  } catch (e) {}\n  return returnNode;\n};\n\nconst getElementPadding = (element: GraphElement): number => {\n  const stylePadding = element.getStyle<NodeStyle>().padding;\n  if (!stylePadding) {\n    return 0;\n  }\n\n  if (Array.isArray(stylePadding)) {\n    // For a padding that is not consistent on all sides, use the max padding\n    return stylePadding.reduce((val, current) => {\n      return Math.max(val, current);\n    }, 0);\n  }\n\n  return stylePadding as number;\n};\n\nconst getGroupPadding = (element: GraphElement, padding = 0): number => {\n  if (isGraph(element)) {\n    return padding;\n  }\n  let newPadding = padding;\n  if (isNode(element) && element.isGroup() && !element.isCollapsed()) {\n    newPadding += getElementPadding(element);\n  }\n  if (element.getParent()) {\n    return getGroupPadding(element.getParent(), newPadding);\n  }\n  return newPadding;\n};\n\nexport {\n  groupNodeElements,\n  leafNodeElements,\n  getTopCollapsedParent,\n  getClosestVisibleParent,\n  getElementPadding,\n  getGroupPadding,\n};\n"]}]}