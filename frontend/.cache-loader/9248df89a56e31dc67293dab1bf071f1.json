{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/utils.ts","mtime":1615298458620},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nimport { getPipelineTasks } from '../../../utils/pipeline-utils';\nimport { NODE_HEIGHT, NodeType, NODE_WIDTH, PipelineLayout, DAGRE_BUILDER_PROPS, DAGRE_VIEWER_PROPS, } from './const';\nconst createGenericNode = (type, width) => (name, data) => ({\n    id: name,\n    data,\n    height: NODE_HEIGHT,\n    width: width != null ? width : NODE_WIDTH,\n    type,\n});\n// Node variations\nexport const createTaskNode = createGenericNode(NodeType.TASK_NODE);\nexport const createSpacerNode = createGenericNode(NodeType.SPACER_NODE, 0);\nexport const createTaskListNode = createGenericNode(NodeType.TASK_LIST_NODE);\nexport const createInvalidTaskListNode = createGenericNode(NodeType.INVALID_TASK_LIST_NODE);\nexport const createBuilderNode = createGenericNode(NodeType.BUILDER_NODE);\nexport const getNodeCreator = (type) => {\n    switch (type) {\n        case NodeType.TASK_LIST_NODE:\n            return createTaskListNode;\n        case NodeType.BUILDER_NODE:\n            return createBuilderNode;\n        case NodeType.SPACER_NODE:\n            return createSpacerNode;\n        case NodeType.TASK_NODE:\n        default:\n            return createTaskNode;\n    }\n};\nexport const handleParallelToParallelNodes = (nodes) => {\n    // Collect only multiple run-afters\n    const multipleRunBeforeMap = nodes.reduce((acc, node, idx) => {\n        const { data: { task: { runAfter }, }, } = node;\n        if (runAfter && runAfter.length > 1) {\n            const id = [...runAfter]\n                .sort((a, b) => a.localeCompare(b))\n                .reduce((str, ref) => `${str}|${ref}`);\n            if (!Array.isArray(acc[id])) {\n                acc[id] = [];\n            }\n            acc[id].push({\n                node,\n                runAfter,\n                atIndex: idx,\n            });\n        }\n        return acc;\n    }, {});\n    // Trim out single occurrences\n    const multiParallelToParallelList = Object.values(multipleRunBeforeMap).filter((data) => data.length > 1);\n    if (multiParallelToParallelList.length === 0) {\n        // No parallel to parallel\n        return nodes;\n    }\n    // Insert a spacer node between the multiple nodes on the sides of a parallel-to-parallel\n    const newNodes = [];\n    const newRunAfterNodeMap = {};\n    multiParallelToParallelList.forEach((p2p) => {\n        // All nodes in each array share their runAfters\n        const { runAfter } = p2p[0];\n        const names = p2p.map((p2pData) => p2pData.node.id);\n        const parallelSpacerName = `parallel-${names.join('-')}`;\n        names.forEach((p2pNodeId) => {\n            if (!Array.isArray(newRunAfterNodeMap[p2pNodeId])) {\n                newRunAfterNodeMap[p2pNodeId] = [];\n            }\n            newRunAfterNodeMap[p2pNodeId].push(parallelSpacerName);\n        });\n        newNodes.push(createSpacerNode(parallelSpacerName, {\n            task: {\n                name: parallelSpacerName,\n                runAfter,\n            },\n        }));\n    });\n    // Update all impacted nodes to point at the spacer node as the spacer points at their original runAfters\n    nodes.forEach((node) => {\n        const newRunAfters = newRunAfterNodeMap[node.id];\n        if (newRunAfters && newRunAfters.length > 0) {\n            const { data: { task }, type, } = node;\n            const createNode = getNodeCreator(type);\n            // Recreate the node with the new runAfter pointing to the spacer node\n            newNodes.push(createNode(node.id, Object.assign(Object.assign({}, node.data), { task: Object.assign(Object.assign({}, task), { runAfter: newRunAfters }) })));\n        }\n        else {\n            // Unaffected node, just carry it over\n            newNodes.push(node);\n        }\n    });\n    return newNodes;\n};\nexport const tasksToNodes = (taskList, pipeline, pipelineRun) => {\n    const nodeList = taskList.map((task) => createTaskNode(task.name, {\n        task,\n        pipeline,\n        pipelineRun,\n    }));\n    return handleParallelToParallelNodes(nodeList);\n};\nexport const tasksToBuilderNodes = (taskList, onAddNode, onNodeSelection, getError, selectedIds) => {\n    return taskList.map((task) => {\n        return createBuilderNode(task.name, {\n            error: getError(task.name),\n            task,\n            selected: selectedIds.includes(task.name),\n            onNodeSelection: () => {\n                onNodeSelection(task);\n            },\n            onAddNode: (direction) => {\n                onAddNode(task, direction);\n            },\n        });\n    });\n};\nexport const getEdgesFromNodes = (nodes) => _.flatten(nodes.map((node) => {\n    const { data: { task: { name: target, runAfter = [] }, }, } = node;\n    if (runAfter.length === 0)\n        return null;\n    return runAfter.map((source) => ({\n        id: `${source}~to~${target}`,\n        type: 'edge',\n        source,\n        target,\n    }));\n})).filter((edgeList) => !!edgeList);\nexport const getTopologyNodesEdges = (pipeline, pipelineRun) => {\n    const taskList = _.flatten(getPipelineTasks(pipeline, pipelineRun));\n    const nodes = tasksToNodes(taskList, pipeline, pipelineRun);\n    const edges = getEdgesFromNodes(nodes);\n    return { nodes, edges };\n};\nexport const getLayoutData = (layout) => {\n    switch (layout) {\n        case PipelineLayout.DAGRE_BUILDER:\n            return DAGRE_BUILDER_PROPS;\n        case PipelineLayout.DAGRE_VIEWER:\n            return DAGRE_VIEWER_PROPS;\n        default:\n            return null;\n    }\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as dagre from 'dagre';\nimport * as _ from 'lodash';\nimport { Pipeline, PipelineRun } from '../../../utils/pipeline-augment';\nimport { getPipelineTasks, PipelineVisualizationTaskItem } from '../../../utils/pipeline-utils';\nimport {\n  NODE_HEIGHT,\n  NodeType,\n  NODE_WIDTH,\n  AddNodeDirection,\n  PipelineLayout,\n  DAGRE_BUILDER_PROPS,\n  DAGRE_VIEWER_PROPS,\n} from './const';\nimport {\n  PipelineEdgeModel,\n  NodeCreator,\n  NodeCreatorSetup,\n  SpacerNodeModelData,\n  TaskListNodeModelData,\n  TaskNodeModelData,\n  PipelineMixedNodeModel,\n  PipelineTaskNodeModel,\n  BuilderNodeModelData,\n  PipelineRunAfterNodeModelData,\n} from './types';\n\nconst createGenericNode: NodeCreatorSetup = (type, width?) => (name, data) => ({\n  id: name,\n  data,\n  height: NODE_HEIGHT,\n  width: width != null ? width : NODE_WIDTH,\n  type,\n});\n\n// Node variations\nexport const createTaskNode: NodeCreator<TaskNodeModelData> = createGenericNode(NodeType.TASK_NODE);\nexport const createSpacerNode: NodeCreator<SpacerNodeModelData> = createGenericNode(\n  NodeType.SPACER_NODE,\n  0,\n);\nexport const createTaskListNode: NodeCreator<TaskListNodeModelData> = createGenericNode(\n  NodeType.TASK_LIST_NODE,\n);\nexport const createInvalidTaskListNode: NodeCreator<TaskListNodeModelData> = createGenericNode(\n  NodeType.INVALID_TASK_LIST_NODE,\n);\nexport const createBuilderNode: NodeCreator<BuilderNodeModelData> = createGenericNode(\n  NodeType.BUILDER_NODE,\n);\n\nexport const getNodeCreator = (type: NodeType): NodeCreator<PipelineRunAfterNodeModelData> => {\n  switch (type) {\n    case NodeType.TASK_LIST_NODE:\n      return createTaskListNode;\n    case NodeType.BUILDER_NODE:\n      return createBuilderNode;\n    case NodeType.SPACER_NODE:\n      return createSpacerNode;\n    case NodeType.TASK_NODE:\n    default:\n      return createTaskNode;\n  }\n};\n\nexport const handleParallelToParallelNodes = (\n  nodes: PipelineMixedNodeModel[],\n): PipelineMixedNodeModel[] => {\n  type ParallelNodeReference = {\n    node: PipelineTaskNodeModel;\n    runAfter: string[];\n    atIndex: number;\n  };\n  type ParallelNodeMap = {\n    [id: string]: ParallelNodeReference[];\n  };\n\n  // Collect only multiple run-afters\n  const multipleRunBeforeMap: ParallelNodeMap = nodes.reduce((acc, node, idx) => {\n    const {\n      data: {\n        task: { runAfter },\n      },\n    } = node;\n    if (runAfter && runAfter.length > 1) {\n      const id: string = [...runAfter]\n        .sort((a, b) => a.localeCompare(b))\n        .reduce((str, ref) => `${str}|${ref}`);\n\n      if (!Array.isArray(acc[id])) {\n        acc[id] = [];\n      }\n      acc[id].push({\n        node,\n        runAfter,\n        atIndex: idx,\n      });\n    }\n    return acc;\n  }, {} as ParallelNodeMap);\n\n  // Trim out single occurrences\n  const multiParallelToParallelList: ParallelNodeReference[][] = Object.values(\n    multipleRunBeforeMap,\n  ).filter((data: ParallelNodeReference[]) => data.length > 1);\n\n  if (multiParallelToParallelList.length === 0) {\n    // No parallel to parallel\n    return nodes;\n  }\n\n  // Insert a spacer node between the multiple nodes on the sides of a parallel-to-parallel\n  const newNodes: PipelineMixedNodeModel[] = [];\n  const newRunAfterNodeMap: { [nodeId: string]: string[] } = {};\n  multiParallelToParallelList.forEach((p2p: ParallelNodeReference[]) => {\n    // All nodes in each array share their runAfters\n    const { runAfter } = p2p[0];\n\n    const names: string[] = p2p.map((p2pData) => p2pData.node.id);\n    const parallelSpacerName = `parallel-${names.join('-')}`;\n\n    names.forEach((p2pNodeId) => {\n      if (!Array.isArray(newRunAfterNodeMap[p2pNodeId])) {\n        newRunAfterNodeMap[p2pNodeId] = [];\n      }\n      newRunAfterNodeMap[p2pNodeId].push(parallelSpacerName);\n    });\n\n    newNodes.push(\n      createSpacerNode(parallelSpacerName, {\n        task: {\n          name: parallelSpacerName,\n          runAfter,\n        },\n      }),\n    );\n  });\n\n  // Update all impacted nodes to point at the spacer node as the spacer points at their original runAfters\n  nodes.forEach((node) => {\n    const newRunAfters: string[] | undefined = newRunAfterNodeMap[node.id];\n    if (newRunAfters && newRunAfters.length > 0) {\n      const {\n        data: { task },\n        type,\n      } = node;\n\n      const createNode: NodeCreator<PipelineRunAfterNodeModelData> = getNodeCreator(type);\n\n      // Recreate the node with the new runAfter pointing to the spacer node\n      newNodes.push(\n        createNode(node.id, {\n          ...node.data,\n          task: {\n            ...task,\n            runAfter: newRunAfters,\n          },\n        }),\n      );\n    } else {\n      // Unaffected node, just carry it over\n      newNodes.push(node);\n    }\n  });\n\n  return newNodes;\n};\n\nexport const tasksToNodes = (\n  taskList: PipelineVisualizationTaskItem[],\n  pipeline?: Pipeline,\n  pipelineRun?: PipelineRun,\n): PipelineMixedNodeModel[] => {\n  const nodeList: PipelineTaskNodeModel[] = taskList.map((task) =>\n    createTaskNode(task.name, {\n      task,\n      pipeline,\n      pipelineRun,\n    }),\n  );\n\n  return handleParallelToParallelNodes(nodeList);\n};\n\nexport const tasksToBuilderNodes = (\n  taskList: PipelineVisualizationTaskItem[],\n  onAddNode: (task: PipelineVisualizationTaskItem, direction: AddNodeDirection) => void,\n  onNodeSelection: (task: PipelineVisualizationTaskItem) => void,\n  getError: (taskName: string) => string,\n  selectedIds: string[],\n): PipelineMixedNodeModel[] => {\n  return taskList.map((task) => {\n    return createBuilderNode(task.name, {\n      error: getError(task.name),\n      task,\n      selected: selectedIds.includes(task.name),\n      onNodeSelection: () => {\n        onNodeSelection(task);\n      },\n      onAddNode: (direction: AddNodeDirection) => {\n        onAddNode(task, direction);\n      },\n    });\n  });\n};\n\nexport const getEdgesFromNodes = (nodes: PipelineMixedNodeModel[]): PipelineEdgeModel[] =>\n  _.flatten(\n    nodes.map((node) => {\n      const {\n        data: {\n          task: { name: target, runAfter = [] },\n        },\n      } = node;\n\n      if (runAfter.length === 0) return null;\n\n      return runAfter.map((source) => ({\n        id: `${source}~to~${target}`,\n        type: 'edge',\n        source,\n        target,\n      }));\n    }),\n  ).filter((edgeList) => !!edgeList);\n\nexport const getTopologyNodesEdges = (\n  pipeline: Pipeline,\n  pipelineRun?: PipelineRun,\n): { nodes: PipelineMixedNodeModel[]; edges: PipelineEdgeModel[] } => {\n  const taskList: PipelineVisualizationTaskItem[] = _.flatten(\n    getPipelineTasks(pipeline, pipelineRun),\n  );\n  const nodes: PipelineMixedNodeModel[] = tasksToNodes(taskList, pipeline, pipelineRun);\n  const edges: PipelineEdgeModel[] = getEdgesFromNodes(nodes);\n\n  return { nodes, edges };\n};\n\nexport const getLayoutData = (layout: PipelineLayout): dagre.GraphLabel => {\n  switch (layout) {\n    case PipelineLayout.DAGRE_BUILDER:\n      return DAGRE_BUILDER_PROPS;\n    case PipelineLayout.DAGRE_VIEWER:\n      return DAGRE_VIEWER_PROPS;\n    default:\n      return null;\n  }\n};\n"]}]}