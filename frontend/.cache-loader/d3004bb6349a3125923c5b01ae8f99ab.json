{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/operator-lifecycle-manager/src/components/operand/DEPRECATED_operand-form.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/operator-lifecycle-manager/src/components/operand/DEPRECATED_operand-form.tsx","mtime":1616735742450},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["// THIS COMPONENT IS DEPRECATED AND WILL BE REMOVED IN v4.6.\nimport * as _ from 'lodash';\nimport * as classNames from 'classnames';\nimport * as Immutable from 'immutable';\nimport * as React from 'react';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport { Alert, ActionGroup, Button, Switch, Accordion, Checkbox, AccordionItem, AccordionToggle, AccordionContent, } from '@patternfly/react-core';\nimport { ConfigureUpdateStrategy } from '@console/internal/components/modals/configure-update-strategy-modal';\nimport { ExpandCollapse } from '@console/internal/components/utils/expand-collapse';\nimport { RadioGroup } from '@console/internal/components/radio';\nimport { ImagePullPolicy, k8sCreate, kindForReference, modelFor, } from '@console/internal/module/k8s';\nimport { NumberSpinner, history, SelectorInput, ListDropdown, useScrollToTopOnMount, Dropdown, } from '@console/internal/components/utils';\nimport { ClusterServiceVersionLogo } from '../index';\nimport { ResourceRequirements } from '../descriptors/spec/resource-requirements';\nimport { SpecCapability } from '../descriptors/types';\nimport { NodeAffinity, PodAffinity, DEFAULT_NODE_AFFINITY, DEFAULT_POD_AFFINITY, } from '../descriptors/spec/affinity';\n/*\n * Matches a path that contains an array index. Use Sting.match against an OperandField 'path'\n * property to determine if it contains an array index. It will parse the path into three parts,\n * [match, pathBeforeIndex, index, pathAfterIndex]. For example:\n *\n *   const [match, pathBeforeIndex, index, pathAfterIndex] =\n *     'path.before[0].path.after'.match(ARRAY_INDEX_PATTERN);\n *\n *   console.log(match);\n *   > 'path.before[0].path.after'\n *\n *   console.log(pathBeforeIndex);\n *   > 'path.before'\n *\n *   console.log(index)\n *   > '0'\n *\n *   console.log(pathAfterIndex)\n *   > 'path.after'\n *\n */\nconst ARRAY_INDEX_PATTERN = /^(.*)\\[(\\d+)\\]\\.?(.*)$/;\n// Regex for SpecCapability.arrayFieldGroup and SpecCapability.fieldGroup\nconst ARRAY_FIELD_GROUP_PATTERN = _.escapeRegExp(SpecCapability.arrayFieldGroup);\nconst FIELD_GROUP_PATTERN = _.escapeRegExp(SpecCapability.fieldGroup);\n/*\n * Matches either field group or array field group SpecCapabilty. Use String.match against an\n * OperandField.capability element to determine if it is a group descriptor and parse group type\n * and name. For example:\n *\n *   const [match, groupType, name] = 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:groupName';\n *\n *   console.log(match);\n *   > 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:groupName'\n *\n *   console.log(groupType);\n *   > 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:'\n *\n *   console.log(name);\n *   > 'groupName'\n */\nconst GROUP_PATTERN = new RegExp(`^(${FIELD_GROUP_PATTERN}|${ARRAY_FIELD_GROUP_PATTERN})(.*)$`);\n// Default max nesting depth the form should display\nconst MAX_DEPTH = 1;\nvar Validations;\n(function (Validations) {\n    Validations[\"maximum\"] = \"maximum\";\n    Validations[\"minimum\"] = \"minimum\";\n    Validations[\"maxLength\"] = \"maxLength\";\n    Validations[\"minLength\"] = \"minLength\";\n    Validations[\"pattern\"] = \"pattern\";\n})(Validations || (Validations = {}));\nconst idFromPath = (path) => `root_${path.split('.').join('_')}`;\n/*\n * Determines if a field contains a descriptor in it's capabilities. If only prefix is\n * provided, this will return true if the field has ANY capability that starts with the prefix. If\n * both prefix and suffix are provided, this will return true only if the field has a capability\n * that matches the concatenation of prefix + suffix.\n */\nconst hasDescriptor = (field, prefix, suffix = null) => {\n    return suffix\n        ? _.includes(field.capabilities, `${prefix}${suffix}`)\n        : _.some(field.capabilities, (capability) => capability.startsWith(prefix));\n};\n/*\n * Accepts an OperandField and returns a name and group type if that field is either a\n * a field group or array field group. Returned as object to allow destructuring of needed values\n * only.\n */\nconst parseGroupDescriptor = (field) => {\n    const groupDescriptor = _.find(field.capabilities, (descriptor) => descriptor.startsWith(SpecCapability.fieldGroup) ||\n        descriptor.startsWith(SpecCapability.arrayFieldGroup));\n    const [regexMatch, groupType, groupName] = groupDescriptor.match(GROUP_PATTERN) || [];\n    return { regexMatch, groupName, groupType };\n};\n/*\n * Splits a path string into path before the array index, the array index itself, and the path after\n * the index. Returns as object to allow destructuring of needed values only.\n */\nconst parseArrayPath = (path) => {\n    const [regexMatch, pathBeforeIndex, index, pathAfterIndex] = path.match(ARRAY_INDEX_PATTERN) || [];\n    return regexMatch\n        ? { index: _.parseInt(index), regexMatch, pathBeforeIndex, pathAfterIndex }\n        : { regexMatch };\n};\n/*\n * If the path contains an array index, this function will return the path with the 'operation'\n * callback return value in place of the existing array index. If no array index is in the path,\n * the original path is returned.\n */\nconst modifyArrayFieldPathIndex = (path, operation) => {\n    const { regexMatch, index, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n    return !regexMatch\n        ? path\n        : `${pathBeforeIndex}[${operation(index)}]${pathAfterIndex && `.${pathAfterIndex}`}`;\n};\n// Accepts a SpecCapbability[] array and returns an appropriate default value for that field\nconst defaultValueFor = (capabilities) => {\n    // String fields\n    if (_.intersection(capabilities, [\n        SpecCapability.podCount,\n        SpecCapability.password,\n        SpecCapability.text,\n        SpecCapability.number,\n        SpecCapability.select,\n    ]).length > 0) {\n        return '';\n    }\n    if (capabilities.includes(SpecCapability.imagePullPolicy)) {\n        return ImagePullPolicy.IfNotPresent;\n    }\n    // Resource requirement fields\n    if (capabilities.includes(SpecCapability.resourceRequirements)) {\n        return Immutable.fromJS({\n            limits: {\n                cpu: '',\n                memory: '',\n                'ephemeral-storage': '',\n            },\n            requirements: {\n                cpu: '',\n                memory: '',\n                'ephemeral-storage': '',\n            },\n        });\n    }\n    // Update strategy\n    if (capabilities.includes(SpecCapability.updateStrategy)) {\n        return Immutable.fromJS({\n            type: 'RollingUpdate',\n            rollingUpdate: {\n                maxUnavailable: '',\n                maxSurge: '',\n            },\n        });\n    }\n    // Node and pod affinities\n    if (capabilities.includes(SpecCapability.nodeAffinity)) {\n        return Immutable.fromJS(DEFAULT_NODE_AFFINITY).setIn(['preferredDuringSchedulingIgnoredDuringExecution', 'weight'], '');\n    }\n    if (capabilities.includes(SpecCapability.podAffinity) ||\n        capabilities.includes(SpecCapability.podAntiAffinity)) {\n        return Immutable.fromJS(DEFAULT_POD_AFFINITY).setIn(['preferredDuringSchedulingIgnoredDuringExecution', 'weight'], '');\n    }\n    // If none of these capabilities are present in the array, return null.\n    return null;\n};\n// Accepts an OpenAPI spec property and returns a corresponding SpecCapability[] array.\nconst capabilitiesFor = (property) => {\n    if (property.enum) {\n        return _.map(property.enum || [], (option) => `${SpecCapability.select}${option}`);\n    }\n    switch (property.type) {\n        case 'integer':\n            return [SpecCapability.number];\n        case 'boolean':\n            return [SpecCapability.booleanSwitch];\n        default:\n            return [SpecCapability.text];\n    }\n};\n/*\n * Recursively traverses OpenAPI spec properties and flattens all nested properties into an\n * OperandField[] array.\n * If a resource instance is provided in the 'obj' argument, then array-type spec properties\n * will be expanded into the appropriate number of fields.\n * If a matching providedAPI descriptor exists, it will take precedence over the openAPI spec,\n * except that the providedAPI x-descriptors will be unioned with OpenAPI capabilities.\n */\nconst flattenNestedProperties = (property, name, providedAPI, obj, { currentCapabilities = [], currentPath = [], fields = [], required = false, }) => {\n    // Null check\n    if (!property) {\n        return fields;\n    }\n    const handleObjectProperty = () => _.flatMap(property.properties, (nestedProperty, nestedPropertyName) => flattenNestedProperties(nestedProperty, nestedPropertyName, providedAPI, obj, {\n        currentCapabilities: [\n            ...currentCapabilities,\n            `${SpecCapability.fieldGroup}${name}`,\n        ],\n        currentPath: [...currentPath, name],\n        fields,\n        required: ((property === null || property === void 0 ? void 0 : property.required) || []).includes(nestedPropertyName),\n    }));\n    const handleArrayProperty = () => {\n        var _a, _b;\n        // Find the number of array elements that are already defined in the provided object\n        const n = _.get(obj, `spec.${currentPath.join('.')}${name}`, []).length || 1;\n        // Since _.times will return a multidimensional array of OperandFields (OperandField[][]), we\n        // need to flatten one level deeper than _.flatMap provides.\n        return _.flatMapDepth((_b = (_a = property.items) === null || _a === void 0 ? void 0 : _a.properties) !== null && _b !== void 0 ? _b : {}, (nestedProperty, nestedPropertyName) => \n        // Repeat recursion (n) times so that the correct number of fields are created for\n        // existing values in obj. This ensures that further nested fields also get created.\n        _.times(n, (index) => flattenNestedProperties(nestedProperty, nestedPropertyName, providedAPI, obj, {\n            currentCapabilities: [\n                ...currentCapabilities,\n                `${SpecCapability.arrayFieldGroup}${name}`,\n            ],\n            currentPath: [...currentPath, `${name}[${index}]`],\n            fields,\n            required: ((property === null || property === void 0 ? void 0 : property.required) || []).includes(nestedPropertyName),\n        })), 2);\n    };\n    const handleAtomicProperty = () => {\n        const path = [...currentPath, name].join('.');\n        // ProvidedAPI should only have a single descriptor for each array field. Regardless of the\n        // index of this field, use the providedAPI.specDescriptor at index 0.\n        const providedAPIField = _.find(providedAPI === null || providedAPI === void 0 ? void 0 : providedAPI.specDescriptors, {\n            path: modifyArrayFieldPathIndex(path, () => 0),\n        });\n        return [\n            ...fields,\n            {\n                capabilities: _.union((providedAPIField === null || providedAPIField === void 0 ? void 0 : providedAPIField['x-descriptors']) || [], currentCapabilities, capabilitiesFor(property)),\n                description: (providedAPIField === null || providedAPIField === void 0 ? void 0 : providedAPIField.description) || property.description,\n                displayName: (providedAPIField === null || providedAPIField === void 0 ? void 0 : providedAPIField.displayName) || _.startCase(name),\n                path: `spec.${path}`,\n                required,\n                type: property.type,\n                validation: _.pick(property, Object.keys(Validations)),\n            },\n        ];\n    };\n    switch (property.type) {\n        // If this property is of 'object' type, return a flat map of its properties\n        case 'object':\n            return handleObjectProperty();\n        // If this property of is of 'array' type, return a flat map of its item's properties.\n        case 'array':\n            return handleArrayProperty();\n        // This property is not an array or object, so it can be mapped to a specific descriptor\n        default:\n            return handleAtomicProperty();\n    }\n};\n// Returns traversal depth of an OpenAPI spec property.\nconst getPropertyDepth = (property, depth = 0) => {\n    var _a;\n    // If this property is not an array or object, we have reached the maximum depth\n    if (!property || !['object', 'array'].includes(property.type)) {\n        return depth;\n    }\n    // Return the maximum depth of the nested properties\n    return Math.max(0, ..._.map((property === null || property === void 0 ? void 0 : property.properties) || ((_a = property === null || property === void 0 ? void 0 : property.items) === null || _a === void 0 ? void 0 : _a.properties), (nestedProperty) => getPropertyDepth(nestedProperty, depth + 1)));\n};\n/*\n * Maps openAPI spec properties to OperandField[] array. This will return all fields with a traversal\n * depth less than the 'depth' argument, and will combine matching providedAPI descriptors with the\n * corresponding OpenAPI spec property in a way that providedAPI data will take precedence over\n * openAPI spec properties.\n */\nconst fieldsForOpenAPI = (schema, providedAPI, obj, depth = MAX_DEPTH) => {\n    return _.reduce((schema === null || schema === void 0 ? void 0 : schema.properties) || {}, (openAPIFieldsAccumulator, property, propertyName) => {\n        if (!(property === null || property === void 0 ? void 0 : property.type) || getPropertyDepth(property) > depth) {\n            return openAPIFieldsAccumulator;\n        }\n        return [\n            ...openAPIFieldsAccumulator,\n            ...flattenNestedProperties(property, propertyName, providedAPI, obj, {\n                required: ((schema === null || schema === void 0 ? void 0 : schema.required) || []).includes(propertyName),\n            }),\n        ];\n    }, []);\n};\n/*\n * Convert a CRD specDescriptor to appropriate OperandField type. Expands obj array properties\n * to the appropriate number of fields.\n */\nconst specDescriptorToFields = ({ description, displayName, path, 'x-descriptors': capabilities = [] }, obj) => {\n    // Use regex to check path for an array index, and parse out the parts of the path before\n    // and after the array index.\n    const { regexMatch, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n    // If match exists, the field represents an element in an array field group, which means we\n    // need to create 'n' duplicates of this field, where 'n' is the number of\n    // elements in the corresponding array property of 'obj'. If n = 0, we only create one field.\n    if (regexMatch) {\n        const n = _.get(obj, _.toPath(`spec.${pathBeforeIndex}`), []).length || 1;\n        return _.flatten(_.times(n, (index) => ({\n            path: `spec.${pathBeforeIndex}[${index}]${pathAfterIndex && `.${pathAfterIndex}`}`,\n            displayName,\n            description,\n            capabilities,\n            type: null,\n            required: null,\n            validation: null,\n        })));\n    }\n    return [\n        {\n            path: `spec.${path}`,\n            displayName,\n            description,\n            type: null,\n            required: null,\n            validation: null,\n            capabilities,\n        },\n    ];\n};\nconst pathToArray = (path) => _.map(_.toPath(path), (subPath) => {\n    return /^\\d+$/.test(subPath) ? _.parseInt(subPath) : subPath;\n});\nconst FieldGroup = ({ children, isExpanded = false, id, label }) => {\n    const [expanded, setExpanded] = React.useState(isExpanded);\n    const onToggle = (event) => {\n        event.preventDefault();\n        setExpanded((current) => !current);\n    };\n    return (React.createElement(\"div\", { id: `${id}_field-group`, className: \"co-dynamic-form__field-group\" },\n        React.createElement(AccordionItem, null,\n            React.createElement(AccordionToggle, { id: `${id}_accordion-toggle`, onClick: onToggle, isExpanded: expanded },\n                React.createElement(\"label\", { htmlFor: `${id}_accordion-content` }, label)),\n            React.createElement(AccordionContent, { id: `${id}_accordion-content`, isHidden: !expanded }, children))));\n};\n// Wrapper for individual operand form inputs\nconst OperandFormInputGroup = ({ error, field, input }) => {\n    const { description, displayName, path, required } = field;\n    const id = idFromPath(path);\n    return input ? (React.createElement(\"div\", { className: \"form-group co-dynamic-form__form-group\", \"data-test-selector\": path },\n        React.createElement(\"label\", { className: classNames('form-label', { 'co-required': required }), htmlFor: id }, displayName),\n        input,\n        description && (React.createElement(\"span\", { id: `${id}__description`, className: \"help-block\" }, description)),\n        error && React.createElement(\"span\", { className: \"co-error\" }, error))) : null;\n};\n// eslint-disable-next-line @typescript-eslint/camelcase\nexport const DEPRECATED_CreateOperandForm = ({ formData, csv, schema, model, onChange, providedAPI, match, next, }) => {\n    const immutableFormData = Immutable.fromJS(formData);\n    const handleFormDataUpdate = (path, value) => {\n        const { regexMatch, index, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n        // Immutable will not initialize a deep path as a List if it includes an integer, so we need to manually\n        // initialize non-existent array properties to a List instance before updating state at that path.\n        if (regexMatch && index === 0) {\n            const existing = immutableFormData.getIn([...pathToArray(pathBeforeIndex), 0]);\n            const item = Immutable.Map(existing || {}).setIn(pathToArray(pathAfterIndex), value);\n            const list = Immutable.List([item]);\n            onChange(immutableFormData.setIn(pathToArray(pathBeforeIndex), list).toJS());\n        }\n        onChange(immutableFormData.setIn(pathToArray(path), value).toJS());\n    };\n    const handleFormDataDelete = (path) => {\n        onChange(immutableFormData.deleteIn(pathToArray(path)).toJS());\n    };\n    // Map providedAPI spec descriptors and openAPI spec properties to OperandField[] array\n    const [fields, setFields] = React.useState(() => {\n        var _a, _b;\n        // Get fields from openAPI\n        const schemaFields = fieldsForOpenAPI((_a = schema === null || schema === void 0 ? void 0 : schema.properties) === null || _a === void 0 ? void 0 : _a.spec, providedAPI, formData);\n        // Get fields from providedAPI that do not exist in the OpenAPI spec.\n        const descriptorFields = _.reduce((_b = providedAPI === null || providedAPI === void 0 ? void 0 : providedAPI.specDescriptors) !== null && _b !== void 0 ? _b : [], (providedAPIFieldsAccumulator, specDescriptor) => {\n            // If this field was already created, ignore it.\n            if (_.find(schemaFields, { path: `spec.${specDescriptor.path}` })) {\n                return providedAPIFieldsAccumulator;\n            }\n            // Add the field if it doesn't exist\n            return [\n                ...providedAPIFieldsAccumulator,\n                ...specDescriptorToFields(specDescriptor, formData),\n            ];\n        }, []);\n        // Concatenate all fields and return\n        return [...schemaFields, ...descriptorFields];\n    });\n    const labelTags = React.useMemo(() => {\n        const formValue = immutableFormData.getIn(['metadata', 'labels']);\n        return SelectorInput.arrayify(_.isFunction(formValue === null || formValue === void 0 ? void 0 : formValue.toJS) ? formValue.toJS() : {});\n    }, [immutableFormData]);\n    const [error, setError] = React.useState();\n    const [formErrors, setFormErrors] = React.useState({});\n    // Group fields into advanced, arrayFieldGroup, fieldGroup, and normal fields for rendering.\n    // Note that arrayFieldGroup and fieldGroup fields are still flat after this. The memoized\n    // 'arrayFieldGroups' and 'fieldGroups' (below) further organizes these by their respective\n    // group descriptors to simplify rendering and state management.\n    const [advancedFields = [], arrayFields = [], groupFields = [], normalFields = [],] = React.useMemo(() => _.reduce(fields, ([advancedFieldsAccumulator = [], arrayFieldsAccumulator = [], groupFieldsAccumulator = [], normalFieldsAccumulator = [],], field) => {\n        if (hasDescriptor(field, SpecCapability.arrayFieldGroup)) {\n            return [\n                advancedFieldsAccumulator,\n                [...arrayFieldsAccumulator, field],\n                groupFieldsAccumulator,\n                normalFieldsAccumulator,\n            ];\n        }\n        if (hasDescriptor(field, SpecCapability.fieldGroup)) {\n            return [\n                advancedFieldsAccumulator,\n                arrayFieldsAccumulator,\n                [...groupFieldsAccumulator, field],\n                normalFieldsAccumulator,\n            ];\n        }\n        if (hasDescriptor(field, SpecCapability.advanced)) {\n            return [\n                [...advancedFieldsAccumulator, field],\n                arrayFieldsAccumulator,\n                groupFieldsAccumulator,\n                normalFieldsAccumulator,\n            ];\n        }\n        return [\n            advancedFieldsAccumulator,\n            arrayFieldsAccumulator,\n            groupFieldsAccumulator,\n            [...normalFieldsAccumulator, field],\n        ];\n    }, []), [fields]);\n    // Create memoized arrayFieldGroups. Organizes arrayFields into a structure that is easy to map\n    // and render.\n    const arrayFieldGroups = React.useMemo(() => {\n        // Group all fields by group name\n        const groupedByName = _.groupBy(arrayFields, (field) => {\n            const { groupName } = parseGroupDescriptor(field);\n            return groupName;\n        });\n        // Map {groupName: string, fieldLists: OperandField[][]}, where OperandField is a nested array\n        // of the appropriate fields, grouped by index.\n        return _.map(groupedByName, (fieldsInGroup, groupName) => ({\n            groupName,\n            fieldLists: _.reduce(fieldsInGroup, (fieldListsAccumulator, field) => {\n                const { index, regexMatch } = parseArrayPath(field.path);\n                if (regexMatch) {\n                    fieldListsAccumulator[index] = [...(fieldListsAccumulator[index] || []), field];\n                }\n                return fieldListsAccumulator;\n            }, []),\n        }));\n    }, [arrayFields]);\n    // Create memoized fieldGroups. Map to array of fields grouped by fieldGroup name so that sorting\n    // is easy.\n    const fieldGroups = React.useMemo(() => {\n        const groupedByName = _.groupBy(groupFields, (field) => {\n            const { groupName } = parseGroupDescriptor(field);\n            return groupName;\n        });\n        return _.map(groupedByName, (fieldList, groupName) => ({\n            groupName,\n            fieldList,\n        }));\n    }, [groupFields]);\n    const getFormData = (path) => immutableFormData.getIn(pathToArray(path));\n    // Validate form and submit API request if no validation failures\n    const submit = (event) => {\n        event.preventDefault();\n        const errors = fields\n            .filter((f) => !_.isNil(f.validation) || !_.isEmpty(f.validation))\n            .filter((f) => f.required || !_.isEqual(getFormData(f.path), defaultValueFor(f.capabilities)))\n            .reduce((allErrors, field) => {\n            // NOTE: Use server-side validation in Kubernetes 1.16 (https://github.com/kubernetes/kubernetes/issues/80718#issuecomment-521081640)\n            const fieldErrors = _.map(field.validation, (val, rule) => {\n                const formVal = getFormData(field.path);\n                switch (rule) {\n                    case Validations.minimum:\n                        return formVal >= val ? null : `Must be greater than ${val}.`;\n                    case Validations.maximum:\n                        return formVal <= val ? null : `Must be less than ${val}.`;\n                    case Validations.minLength:\n                        return formVal.length >= val ? null : `Must be at least ${val} characters.`;\n                    case Validations.maxLength:\n                        return formVal.length <= val ? null : `Must be greater than ${val} characters.`;\n                    case Validations.pattern:\n                        return new RegExp(val).test(formVal)\n                            ? null\n                            : `Does not match required pattern ${val}`;\n                    default:\n                        return null;\n                }\n            });\n            // Just use first error\n            return Object.assign(Object.assign({}, allErrors), { [field.path]: fieldErrors.find((e) => !_.isNil(e)) });\n        }, {});\n        setFormErrors(errors);\n        if (_.isEmpty(_.compact(_.values(errors)))) {\n            k8sCreate(model, model.namespaced\n                ? immutableFormData.setIn(['metadata', 'namespace'], match.params.ns).toJS()\n                : immutableFormData.toJS())\n                .then(() => history.push(next))\n                .catch((err) => setError(err.message || 'Unknown error.'));\n        }\n    };\n    // TODO(alecmerdler): Move this into a single `<SpecDescriptorInput>` entry component in the `descriptors/` directory\n    const inputFor = ({ capabilities, displayName, path, required, validation }) => {\n        var _a;\n        const id = idFromPath(path);\n        const formDataValue = getFormData(path);\n        const currentValue = _.isNil(formDataValue) ? defaultValueFor(capabilities) : formDataValue;\n        if (capabilities.find((c) => c.startsWith(SpecCapability.fieldDependency))) {\n            const controlFieldInfoList = capabilities.filter((c) => c.startsWith(SpecCapability.fieldDependency));\n            const controlFieldPathList = _.uniq(controlFieldInfoList\n                .map((c) => c.split(SpecCapability.fieldDependency)[1])\n                .reduce((infoList, info) => [info.split(':')[0], ...infoList], []));\n            const controlFieldPath = _.isArray(controlFieldPathList) && controlFieldPathList.length === 1\n                ? controlFieldPathList[0]\n                : null;\n            const currentControlFieldValue = !_.isNil(getFormData(`spec.${controlFieldPath}`))\n                ? getFormData(`spec.${controlFieldPath}`).toString()\n                : null;\n            const expectedControlFieldValueList = controlFieldInfoList\n                .map((c) => c.split(SpecCapability.fieldDependency)[1])\n                .reduce((infoList, info) => [info.split(':')[1], ...infoList], []);\n            if (!expectedControlFieldValueList.includes(currentControlFieldValue)) {\n                return null;\n            }\n        }\n        if (capabilities.includes(SpecCapability.podCount)) {\n            return (React.createElement(NumberSpinner, { id: id, className: \"pf-c-form-control\", value: currentValue, onChange: ({ currentTarget: { value } }) => handleFormDataUpdate(path, _.toInteger(value)), changeValueBy: (operation) => handleFormDataUpdate(path, _.toInteger(currentValue) + operation), autoFocus: true, required: true }));\n        }\n        if (capabilities.includes(SpecCapability.resourceRequirements)) {\n            const cpuLimitsPath = `limits.cpu`;\n            const memoryLimitsPath = `limits.memory`;\n            const storageLimitsPath = 'limits.ephemeral-storage';\n            const cpuRequestsPath = `requests.cpu`;\n            const memoryRequestsPath = `requests.memory`;\n            const storageRequestsPath = 'requests.ephemeral-storage';\n            return (React.createElement(\"dl\", { style: { marginLeft: '15px' } },\n                React.createElement(\"dt\", null, \"Limits\"),\n                React.createElement(\"dd\", null,\n                    React.createElement(ResourceRequirements, { cpu: currentValue.getIn(_.toPath(cpuLimitsPath)), memory: currentValue.getIn(_.toPath(memoryLimitsPath)), storage: currentValue.getIn(_.toPath(storageLimitsPath)), onChangeCPU: (value) => handleFormDataUpdate(`${path}.${cpuLimitsPath}`, value), onChangeMemory: (value) => handleFormDataUpdate(`${path}.${memoryLimitsPath}`, value), onChangeStorage: (value) => handleFormDataUpdate(`${path}.${storageLimitsPath}`, value), path: `${id}.limits` })),\n                React.createElement(\"dt\", null, \"Requests\"),\n                React.createElement(\"dd\", null,\n                    React.createElement(ResourceRequirements, { cpu: currentValue.getIn(_.toPath(cpuRequestsPath)), memory: currentValue.getIn(_.toPath(memoryRequestsPath)), storage: currentValue.getIn(_.toPath(storageRequestsPath)), onChangeCPU: (value) => handleFormDataUpdate(`${path}.${cpuRequestsPath}`, value), onChangeMemory: (value) => handleFormDataUpdate(`${path}.${memoryRequestsPath}`, value), onChangeStorage: (value) => handleFormDataUpdate(`${path}.${storageRequestsPath}`, value), path: `${id}.requests` }))));\n        }\n        if (capabilities.includes(SpecCapability.password)) {\n            return (React.createElement(\"div\", null,\n                React.createElement(\"input\", Object.assign({ className: \"pf-c-form-control\", id: id, type: \"password\" }, validation, { onChange: ({ currentTarget: { value } }) => handleFormDataUpdate(path, value), value: currentValue }))));\n        }\n        if (capabilities.some((c) => c.startsWith(SpecCapability.k8sResourcePrefix))) {\n            const groupVersionKind = capabilities\n                .find((c) => c.startsWith(SpecCapability.k8sResourcePrefix))\n                .split(SpecCapability.k8sResourcePrefix)[1]\n                .replace('core~v1~', '');\n            const k8sModel = modelFor(groupVersionKind);\n            if (!k8sModel) {\n                // eslint-disable-next-line no-console\n                console.warn('[Legacy CreateOperandForm] Cluster does not have resource', groupVersionKind);\n            }\n            return k8sModel ? (React.createElement(ListDropdown, { id: id, resources: [\n                    {\n                        kind: groupVersionKind,\n                        namespace: k8sModel.namespaced ? (_a = match === null || match === void 0 ? void 0 : match.params) === null || _a === void 0 ? void 0 : _a.ns : null,\n                    },\n                ], desc: displayName, placeholder: `Select ${kindForReference(groupVersionKind)}`, onChange: (value) => handleFormDataUpdate(path, value), selectedKey: currentValue ? `${currentValue}-${k8sModel === null || k8sModel === void 0 ? void 0 : k8sModel.kind}` : null })) : null;\n        }\n        if (capabilities.includes(SpecCapability.checkbox)) {\n            return (React.createElement(Checkbox, { id: id, style: { marginLeft: '10px' }, isChecked: (_.isNil(currentValue) ? false : currentValue), label: displayName, required: required, onChange: (value) => handleFormDataUpdate(path, value) }));\n        }\n        if (capabilities.includes(SpecCapability.booleanSwitch)) {\n            return (React.createElement(Switch, { key: id, id: id, isChecked: (_.isNil(currentValue) ? false : currentValue), onChange: (value) => handleFormDataUpdate(path, value), label: \"True\", labelOff: \"False\" }));\n        }\n        if (capabilities.includes(SpecCapability.imagePullPolicy)) {\n            return (React.createElement(RadioGroup, { id: id, currentValue: currentValue, items: _.values(ImagePullPolicy).map((policy) => ({\n                    value: policy,\n                    title: policy,\n                })), onChange: ({ currentTarget: { value } }) => handleFormDataUpdate(path, value) }));\n        }\n        if (capabilities.includes(SpecCapability.updateStrategy)) {\n            const maxUnavailablePath = `rollingUpdate.maxUnavailable`;\n            const maxSurgePath = `rollingUpdate.maxSurge`;\n            return (React.createElement(ConfigureUpdateStrategy, { strategyType: currentValue.get('type'), maxUnavailable: currentValue.getIn(_.toPath(maxUnavailablePath)), maxSurge: currentValue.getIn(_.toPath(maxSurgePath)), onChangeStrategyType: (value) => handleFormDataUpdate(`${path}.type`, value), onChangeMaxUnavailable: (value) => handleFormDataUpdate(`${path}.${maxUnavailablePath}`, value), onChangeMaxSurge: (value) => handleFormDataUpdate(`${path}.${maxSurgePath}`, value), replicas: 1, uid: id }));\n        }\n        if (capabilities.includes(SpecCapability.text)) {\n            return (React.createElement(\"div\", null,\n                React.createElement(\"input\", { key: id, className: \"pf-c-form-control\", id: id, type: \"text\", onChange: ({ currentTarget: { value } }) => handleFormDataUpdate(path, value), value: currentValue })));\n        }\n        if (capabilities.includes(SpecCapability.number)) {\n            return (React.createElement(\"div\", null,\n                React.createElement(\"input\", { key: path, className: \"pf-c-form-control\", id: id, type: \"number\", onChange: ({ currentTarget: { value } }) => handleFormDataUpdate(path, value !== '' ? _.toNumber(value) : ''), value: currentValue !== '' ? _.toNumber(currentValue) : '' })));\n        }\n        if (capabilities.includes(SpecCapability.nodeAffinity)) {\n            return (React.createElement(\"div\", { style: { marginLeft: '15px' } },\n                React.createElement(NodeAffinity, { affinity: currentValue.toJS(), onChange: (value) => handleFormDataUpdate(path, Immutable.fromJS(value)), uid: id })));\n        }\n        if (capabilities.includes(SpecCapability.podAffinity) ||\n            capabilities.includes(SpecCapability.podAntiAffinity)) {\n            return (React.createElement(\"div\", { style: { marginLeft: '15px' } },\n                React.createElement(PodAffinity, { affinity: currentValue.toJS(), onChange: (value) => handleFormDataUpdate(path, Immutable.fromJS(value)), uid: id })));\n        }\n        if (capabilities.some((c) => c.startsWith(SpecCapability.select))) {\n            return (React.createElement(\"div\", null,\n                React.createElement(Dropdown, { id: id, title: `Select ${displayName}`, selectedKey: currentValue, items: capabilities\n                        .filter((c) => c.startsWith(SpecCapability.select))\n                        .map((c) => c.split(SpecCapability.select)[1])\n                        .reduce((all, option) => (Object.assign({ [option]: option }, all)), {}), onChange: (value) => handleFormDataUpdate(path, value) })));\n        }\n        return null;\n    };\n    /* Inserts an arrayFieldGroup at nextIndex. The fieldList argument is an array of fields\n     * representing a single element in an arrayFieldGroup. To add an arrayFieldGroup, we duplicate\n     * each field in this fieldList, replacing the array index in field.path with the nextIndex\n     * argument\n     */\n    const addArrayFieldGroup = (fieldLists) => {\n        // Duplicate each field in fieldList, creating the corresponding field and formValue at\n        // arrayFieldGroup[nextIndex]\n        const addedFields = _.reduce(_.last(fieldLists), (fieldAccumulator, field) => {\n            // Replace index of field with nextIndex\n            const path = modifyArrayFieldPathIndex(field.path, () => fieldLists.length);\n            return [...fieldAccumulator, Object.assign(Object.assign({}, field), { path })];\n        }, []);\n        setFields((currentFields) => [...currentFields, ...addedFields]);\n    };\n    // Removes fields corresponding to an  arrayFieldGroup index from the form\n    const removeArrayFieldGroup = (fieldLists, indexToRemove) => {\n        // Flat array of fields in this arrayFieldGroup at index > removed.\n        const fieldsToLeftShift = _.flatten(_.filter(fieldLists, (_unused, index) => index > indexToRemove));\n        // List of paths to be removed from fields list. Fields and values in fieldsToLeftShift\n        // will be replaced with left-shifted equivalents\n        const fieldPathsToRemove = _.map([...fieldLists[indexToRemove], ...fieldsToLeftShift], 'path');\n        const [regexMatch, formDataPathToRemove] = ((fieldPathsToRemove === null || fieldPathsToRemove === void 0 ? void 0 : fieldPathsToRemove[0]) || '').match(/^(.*\\[\\d+\\]).*$/) || [];\n        const leftShiftedFields = _.reduce(fieldsToLeftShift, (fieldAccumulator, field) => {\n            const path = modifyArrayFieldPathIndex(field.path, (index) => index - 1);\n            return [...fieldAccumulator, Object.assign(Object.assign({}, field), { path })];\n        }, []);\n        // Remove arrayFieldGroup from fields and replace subsequent arrayFieldGroup fields with\n        // left-shifted ones.\n        setFields((currentFields) => {\n            return [\n                // Filter out all removed fields and fields that need to be left-shifted\n                ..._.filter(currentFields, (field) => !_.includes(fieldPathsToRemove, field.path)),\n                // Add new left-shifted fields\n                ...leftShiftedFields,\n            ];\n        });\n        regexMatch && handleFormDataDelete(formDataPathToRemove);\n    };\n    const renderArrayFieldGroups = () => _.map(_.sortBy(arrayFieldGroups, 'groupName'), ({ fieldLists, groupName }) => {\n        // If there is no name for this fieldGroup, or no fields associated with the group name, don't\n        // render anything\n        if (_.isEmpty(groupName) || _.isEmpty(fieldLists)) {\n            return null;\n        }\n        const groupDisplayName = _.startCase(groupName);\n        const singularGroupDisplayName = groupDisplayName.replace(/s$/, '');\n        const id = `root_spec_${groupName}`;\n        const isExpanded = !_.some(fieldLists, (fieldList) => _.some(fieldList, (f) => hasDescriptor(f, SpecCapability.advanced) && !f.required));\n        return (React.createElement(FieldGroup, { id: id, isExpanded: isExpanded, key: id, label: groupDisplayName },\n            _.map(fieldLists, (fieldList, index) => (React.createElement(React.Fragment, { key: `${groupName}-${index}` },\n                index > 0 && React.createElement(\"hr\", null),\n                fieldLists.length > 1 && (React.createElement(\"div\", { className: \"row co-array-field-group__remove\" },\n                    React.createElement(Button, { type: \"button\", className: \"co-array-field-group__remove-btn\", onClick: () => removeArrayFieldGroup(fieldLists, index), variant: \"link\" },\n                        React.createElement(MinusCircleIcon, { className: \"co-icon-space-r\" }),\n                        \"Remove \",\n                        singularGroupDisplayName))),\n                _.map(fieldList, (field) => (React.createElement(OperandFormInputGroup, { key: field.path, error: formErrors === null || formErrors === void 0 ? void 0 : formErrors[field.path], field: field, input: inputFor(field) })))))),\n            React.createElement(\"div\", { className: \"row\" },\n                React.createElement(Button, { type: \"button\", onClick: () => addArrayFieldGroup(fieldLists), variant: \"link\" },\n                    React.createElement(PlusCircleIcon, { className: \"co-icon-space-r\" }),\n                    \"Add \",\n                    singularGroupDisplayName))));\n    });\n    const renderFieldGroups = () => _.map(_.sortBy(fieldGroups, 'groupName'), ({ fieldList, groupName }) => {\n        if (_.isEmpty(groupName) || _.isEmpty(fieldList)) {\n            return null;\n        }\n        const id = `root_spec_${groupName}`;\n        const isExpanded = !_.some(fieldList, (f) => f.capabilities.includes(SpecCapability.advanced) && !f.required);\n        return (React.createElement(FieldGroup, { key: id, id: id, isExpanded: isExpanded, label: _.startCase(groupName) }, _.map(fieldList, (field) => (React.createElement(OperandFormInputGroup, { key: field.path, error: formErrors === null || formErrors === void 0 ? void 0 : formErrors[field.path], field: field, input: inputFor(field) })))));\n    });\n    const renderNormalFields = () => _.map(normalFields, (field) => (React.createElement(OperandFormInputGroup, { key: field.path, field: field, input: inputFor(field), error: formErrors === null || formErrors === void 0 ? void 0 : formErrors[field.path] })));\n    const renderAdvancedFields = () => advancedFields.length > 0 && (React.createElement(\"div\", null,\n        React.createElement(ExpandCollapse, { textExpanded: \"Advanced Configuration\", textCollapsed: \"Advanced Configuration\" }, _.map(advancedFields, (field) => (React.createElement(OperandFormInputGroup, { key: field.path, field: field, input: inputFor(field), error: formErrors === null || formErrors === void 0 ? void 0 : formErrors[field.path] }))))));\n    useScrollToTopOnMount();\n    return (React.createElement(\"div\", { className: \"co-m-pane__body\" },\n        React.createElement(\"div\", { className: \"row\" },\n            React.createElement(\"div\", { className: \"col-md-8 col-lg-7\" },\n                React.createElement(Alert, { isInline: true, className: \"co-alert co-break-word\", variant: \"info\", title: 'Note: Some fields may not be represented in this form. Please select \"YAML View\" for full control of object creation.' }),\n                React.createElement(\"form\", { className: \"co-dynamic-form\", onSubmit: submit },\n                    React.createElement(Accordion, { asDefinitionList: false, className: \"co-dynamic-form__accordion\" },\n                        React.createElement(\"div\", { key: 'metadata.name', className: \"form-group\" },\n                            React.createElement(\"label\", { className: \"control-label co-required\", htmlFor: \"name\" }, \"Name\"),\n                            React.createElement(\"input\", { className: \"pf-c-form-control\", type: \"text\", onChange: ({ target: { value } }) => handleFormDataUpdate('metadata.name', value), value: immutableFormData.getIn(['metadata', 'name']) || 'example', id: \"root_metadata_name\", required: true })),\n                        React.createElement(\"div\", { key: 'root_metadata_labels', className: \"form-group\" },\n                            React.createElement(\"label\", { className: \"control-label\", htmlFor: \"tags-input\" }, \"Labels\"),\n                            React.createElement(SelectorInput, { onChange: (value) => handleFormDataUpdate('metadata.labels', Immutable.fromJS(SelectorInput.objectify(value))), tags: labelTags })),\n                        renderArrayFieldGroups(),\n                        renderFieldGroups(),\n                        renderNormalFields(),\n                        renderAdvancedFields()),\n                    (!_.isEmpty(error) || !_.isEmpty(_.compact(_.values(formErrors)))) && (React.createElement(Alert, { isInline: true, className: \"co-alert co-break-word co-alert--scrollable\", variant: \"danger\", title: \"Error\" }, error || 'Fix above errors')),\n                    React.createElement(\"div\", { style: { paddingBottom: '30px' } },\n                        React.createElement(ActionGroup, { className: \"pf-c-form\" },\n                            React.createElement(Button, { onClick: submit, type: \"submit\", variant: \"primary\" }, \"Create\"),\n                            React.createElement(Button, { onClick: history.goBack, variant: \"secondary\" }, \"Cancel\"))))),\n            React.createElement(\"div\", { className: \"col-md-4 col-lg-5\" }, csv && providedAPI && (React.createElement(\"div\", { style: { marginBottom: '30px' } },\n                React.createElement(ClusterServiceVersionLogo, { displayName: providedAPI.displayName, icon: _.get(csv, 'spec.icon[0]'), provider: _.get(csv, 'spec.provider') }),\n                providedAPI.description))))));\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/operator-lifecycle-manager/src/components/operand/DEPRECATED_operand-form.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/operator-lifecycle-manager/src/components/operand/DEPRECATED_operand-form.tsx"],"names":[],"mappings":"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","sourcesContent":["// THIS COMPONENT IS DEPRECATED AND WILL BE REMOVED IN v4.6.\n\nimport * as _ from 'lodash';\nimport * as classNames from 'classnames';\nimport * as Immutable from 'immutable';\nimport * as React from 'react';\nimport { JSONSchema6, JSONSchema6TypeName } from 'json-schema';\nimport { MinusCircleIcon, PlusCircleIcon } from '@patternfly/react-icons';\nimport {\n  Alert,\n  ActionGroup,\n  Button,\n  Switch,\n  Accordion,\n  Checkbox,\n  AccordionItem,\n  AccordionToggle,\n  AccordionContent,\n} from '@patternfly/react-core';\nimport { ConfigureUpdateStrategy } from '@console/internal/components/modals/configure-update-strategy-modal';\nimport { ExpandCollapse } from '@console/internal/components/utils/expand-collapse';\nimport { RadioGroup } from '@console/internal/components/radio';\nimport {\n  GroupVersionKind,\n  ImagePullPolicy,\n  k8sCreate,\n  K8sResourceKind,\n  kindForReference,\n  modelFor,\n  NodeAffinity as NodeAffinityType,\n} from '@console/internal/module/k8s';\nimport {\n  NumberSpinner,\n  history,\n  SelectorInput,\n  ListDropdown,\n  useScrollToTopOnMount,\n  Dropdown,\n} from '@console/internal/components/utils';\nimport { ClusterServiceVersionLogo } from '../index';\nimport { ResourceRequirements } from '../descriptors/spec/resource-requirements';\nimport { Descriptor, SpecCapability, StatusCapability } from '../descriptors/types';\nimport {\n  NodeAffinity,\n  PodAffinity,\n  DEFAULT_NODE_AFFINITY,\n  DEFAULT_POD_AFFINITY,\n} from '../descriptors/spec/affinity';\nimport { OperandFormProps } from './operand-form';\nimport { ProvidedAPI } from '../../types';\n\n/*\n * Matches a path that contains an array index. Use Sting.match against an OperandField 'path'\n * property to determine if it contains an array index. It will parse the path into three parts,\n * [match, pathBeforeIndex, index, pathAfterIndex]. For example:\n *\n *   const [match, pathBeforeIndex, index, pathAfterIndex] =\n *     'path.before[0].path.after'.match(ARRAY_INDEX_PATTERN);\n *\n *   console.log(match);\n *   > 'path.before[0].path.after'\n *\n *   console.log(pathBeforeIndex);\n *   > 'path.before'\n *\n *   console.log(index)\n *   > '0'\n *\n *   console.log(pathAfterIndex)\n *   > 'path.after'\n *\n */\nconst ARRAY_INDEX_PATTERN = /^(.*)\\[(\\d+)\\]\\.?(.*)$/;\n\n// Regex for SpecCapability.arrayFieldGroup and SpecCapability.fieldGroup\nconst ARRAY_FIELD_GROUP_PATTERN = _.escapeRegExp(SpecCapability.arrayFieldGroup);\nconst FIELD_GROUP_PATTERN = _.escapeRegExp(SpecCapability.fieldGroup);\n\n/*\n * Matches either field group or array field group SpecCapabilty. Use String.match against an\n * OperandField.capability element to determine if it is a group descriptor and parse group type\n * and name. For example:\n *\n *   const [match, groupType, name] = 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:groupName';\n *\n *   console.log(match);\n *   > 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:groupName'\n *\n *   console.log(groupType);\n *   > 'urn:alm:descriptor:com.tectonic.ui:fieldGroup:'\n *\n *   console.log(name);\n *   > 'groupName'\n */\nconst GROUP_PATTERN = new RegExp(`^(${FIELD_GROUP_PATTERN}|${ARRAY_FIELD_GROUP_PATTERN})(.*)$`);\n\n// Default max nesting depth the form should display\nconst MAX_DEPTH = 1;\n\nenum Validations {\n  maximum = 'maximum',\n  minimum = 'minimum',\n  maxLength = 'maxLength',\n  minLength = 'minLength',\n  pattern = 'pattern',\n}\n\nconst idFromPath = (path) => `root_${path.split('.').join('_')}`;\n\n/*\n * Determines if a field contains a descriptor in it's capabilities. If only prefix is\n * provided, this will return true if the field has ANY capability that starts with the prefix. If\n * both prefix and suffix are provided, this will return true only if the field has a capability\n * that matches the concatenation of prefix + suffix.\n */\nconst hasDescriptor = (field: OperandField, prefix: string, suffix: string = null): boolean => {\n  return suffix\n    ? _.includes(field.capabilities, `${prefix}${suffix}`)\n    : _.some(field.capabilities, (capability) => capability.startsWith(prefix));\n};\n\n/*\n * Accepts an OperandField and returns a name and group type if that field is either a\n * a field group or array field group. Returned as object to allow destructuring of needed values\n * only.\n */\nconst parseGroupDescriptor = (\n  field: OperandField,\n): { groupName?: string; groupType?: string; regexMatch?: string } => {\n  const groupDescriptor = _.find(\n    field.capabilities,\n    (descriptor) =>\n      descriptor.startsWith(SpecCapability.fieldGroup) ||\n      descriptor.startsWith(SpecCapability.arrayFieldGroup),\n  );\n  const [regexMatch, groupType, groupName] = groupDescriptor.match(GROUP_PATTERN) || [];\n  return { regexMatch, groupName, groupType };\n};\n\n/*\n * Splits a path string into path before the array index, the array index itself, and the path after\n * the index. Returns as object to allow destructuring of needed values only.\n */\nconst parseArrayPath = (\n  path: string,\n): { index?: number; regexMatch?: string; pathBeforeIndex?: string; pathAfterIndex?: string } => {\n  const [regexMatch, pathBeforeIndex, index, pathAfterIndex] =\n    path.match(ARRAY_INDEX_PATTERN) || [];\n  return regexMatch\n    ? { index: _.parseInt(index), regexMatch, pathBeforeIndex, pathAfterIndex }\n    : { regexMatch };\n};\n\n/*\n * If the path contains an array index, this function will return the path with the 'operation'\n * callback return value in place of the existing array index. If no array index is in the path,\n * the original path is returned.\n */\nconst modifyArrayFieldPathIndex = (\n  path: string,\n  operation: (index?: number) => string | number,\n): string => {\n  const { regexMatch, index, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n  return !regexMatch\n    ? path\n    : `${pathBeforeIndex}[${operation(index)}]${pathAfterIndex && `.${pathAfterIndex}`}`;\n};\n\n// Accepts a SpecCapbability[] array and returns an appropriate default value for that field\nconst defaultValueFor = (capabilities: Capability[]): any => {\n  // String fields\n  if (\n    _.intersection(capabilities, [\n      SpecCapability.podCount,\n      SpecCapability.password,\n      SpecCapability.text,\n      SpecCapability.number,\n      SpecCapability.select,\n    ]).length > 0\n  ) {\n    return '';\n  }\n\n  if (capabilities.includes(SpecCapability.imagePullPolicy)) {\n    return ImagePullPolicy.IfNotPresent;\n  }\n\n  // Resource requirement fields\n  if (capabilities.includes(SpecCapability.resourceRequirements)) {\n    return Immutable.fromJS({\n      limits: {\n        cpu: '',\n        memory: '',\n        'ephemeral-storage': '',\n      },\n      requirements: {\n        cpu: '',\n        memory: '',\n        'ephemeral-storage': '',\n      },\n    });\n  }\n\n  // Update strategy\n  if (capabilities.includes(SpecCapability.updateStrategy)) {\n    return Immutable.fromJS({\n      type: 'RollingUpdate',\n      rollingUpdate: {\n        maxUnavailable: '',\n        maxSurge: '',\n      },\n    });\n  }\n\n  // Node and pod affinities\n  if (capabilities.includes(SpecCapability.nodeAffinity)) {\n    return Immutable.fromJS(DEFAULT_NODE_AFFINITY).setIn(\n      ['preferredDuringSchedulingIgnoredDuringExecution', 'weight'],\n      '',\n    );\n  }\n\n  if (\n    capabilities.includes(SpecCapability.podAffinity) ||\n    capabilities.includes(SpecCapability.podAntiAffinity)\n  ) {\n    return Immutable.fromJS(DEFAULT_POD_AFFINITY).setIn(\n      ['preferredDuringSchedulingIgnoredDuringExecution', 'weight'],\n      '',\n    );\n  }\n\n  // If none of these capabilities are present in the array, return null.\n  return null;\n};\n\n// Accepts an OpenAPI spec property and returns a corresponding SpecCapability[] array.\nconst capabilitiesFor = (property: JSONSchema6): SpecCapability[] => {\n  if (property.enum) {\n    return _.map(\n      property.enum || [],\n      (option: string) => `${SpecCapability.select}${option}` as SpecCapability,\n    );\n  }\n  switch (property.type) {\n    case 'integer':\n      return [SpecCapability.number];\n    case 'boolean':\n      return [SpecCapability.booleanSwitch];\n    default:\n      return [SpecCapability.text];\n  }\n};\n\n/*\n * Recursively traverses OpenAPI spec properties and flattens all nested properties into an\n * OperandField[] array.\n * If a resource instance is provided in the 'obj' argument, then array-type spec properties\n * will be expanded into the appropriate number of fields.\n * If a matching providedAPI descriptor exists, it will take precedence over the openAPI spec,\n * except that the providedAPI x-descriptors will be unioned with OpenAPI capabilities.\n */\nconst flattenNestedProperties = (\n  property: JSONSchema6,\n  name: string,\n  providedAPI: ProvidedAPI,\n  obj: K8sResourceKind,\n  {\n    currentCapabilities = [],\n    currentPath = [],\n    fields = [],\n    required = false,\n  }: FlattenNestedPropertiesAccumulator,\n): OperandField[] => {\n  // Null check\n  if (!property) {\n    return fields;\n  }\n\n  const handleObjectProperty = (): OperandField[] =>\n    _.flatMap(property.properties, (nestedProperty, nestedPropertyName) =>\n      flattenNestedProperties(nestedProperty as JSONSchema6, nestedPropertyName, providedAPI, obj, {\n        currentCapabilities: [\n          ...currentCapabilities,\n          `${SpecCapability.fieldGroup}${name}` as SpecCapability,\n        ],\n        currentPath: [...currentPath, name],\n        fields,\n        required: (property?.required || []).includes(nestedPropertyName),\n      }),\n    );\n\n  const handleArrayProperty = (): OperandField[] => {\n    // Find the number of array elements that are already defined in the provided object\n    const n = _.get(obj, `spec.${currentPath.join('.')}${name}`, []).length || 1;\n\n    // Since _.times will return a multidimensional array of OperandFields (OperandField[][]), we\n    // need to flatten one level deeper than _.flatMap provides.\n    return _.flatMapDepth(\n      (property.items as JSONSchema6)?.properties ?? {},\n      (nestedProperty, nestedPropertyName) =>\n        // Repeat recursion (n) times so that the correct number of fields are created for\n        // existing values in obj. This ensures that further nested fields also get created.\n        _.times(n, (index) =>\n          flattenNestedProperties(\n            nestedProperty as JSONSchema6,\n            nestedPropertyName,\n            providedAPI,\n            obj,\n            {\n              currentCapabilities: [\n                ...currentCapabilities,\n                `${SpecCapability.arrayFieldGroup}${name}` as SpecCapability,\n              ],\n              currentPath: [...currentPath, `${name}[${index}]`], // Array field paths must include an index\n              fields,\n              required: (property?.required || []).includes(nestedPropertyName),\n            },\n          ),\n        ),\n      2,\n    );\n  };\n\n  const handleAtomicProperty = (): OperandField[] => {\n    const path = [...currentPath, name].join('.');\n\n    // ProvidedAPI should only have a single descriptor for each array field. Regardless of the\n    // index of this field, use the providedAPI.specDescriptor at index 0.\n    const providedAPIField = _.find(providedAPI?.specDescriptors, {\n      path: modifyArrayFieldPathIndex(path, () => 0),\n    });\n    return [\n      ...fields,\n      {\n        capabilities: _.union(\n          providedAPIField?.['x-descriptors'] || [],\n          currentCapabilities,\n          capabilitiesFor(property as JSONSchema6),\n        ),\n        description: providedAPIField?.description || property.description,\n        displayName: providedAPIField?.displayName || _.startCase(name),\n        path: `spec.${path}`,\n        required,\n        type: property.type,\n        validation: _.pick(property, Object.keys(Validations)),\n      } as OperandField,\n    ];\n  };\n\n  switch (property.type) {\n    // If this property is of 'object' type, return a flat map of its properties\n    case 'object':\n      return handleObjectProperty();\n\n    // If this property of is of 'array' type, return a flat map of its item's properties.\n    case 'array':\n      return handleArrayProperty();\n\n    // This property is not an array or object, so it can be mapped to a specific descriptor\n    default:\n      return handleAtomicProperty();\n  }\n};\n\n// Returns traversal depth of an OpenAPI spec property.\nconst getPropertyDepth = (property: JSONSchema6, depth: number = 0): number => {\n  // If this property is not an array or object, we have reached the maximum depth\n  if (!property || !['object', 'array'].includes(property.type as string)) {\n    return depth;\n  }\n\n  // Return the maximum depth of the nested properties\n  return Math.max(\n    0,\n    ..._.map(\n      property?.properties || (property?.items as JSONSchema6)?.properties,\n      (nestedProperty) => getPropertyDepth(nestedProperty as JSONSchema6, depth + 1),\n    ),\n  );\n};\n\n/*\n * Maps openAPI spec properties to OperandField[] array. This will return all fields with a traversal\n * depth less than the 'depth' argument, and will combine matching providedAPI descriptors with the\n * corresponding OpenAPI spec property in a way that providedAPI data will take precedence over\n * openAPI spec properties.\n */\nconst fieldsForOpenAPI = (\n  schema: JSONSchema6,\n  providedAPI: ProvidedAPI,\n  obj: K8sResourceKind,\n  depth: number = MAX_DEPTH,\n): OperandField[] => {\n  return _.reduce(\n    schema?.properties || {},\n    (openAPIFieldsAccumulator: OperandField[], property: JSONSchema6, propertyName: string) => {\n      if (!property?.type || getPropertyDepth(property) > depth) {\n        return openAPIFieldsAccumulator;\n      }\n      return [\n        ...openAPIFieldsAccumulator,\n        ...flattenNestedProperties(property, propertyName, providedAPI, obj, {\n          required: (schema?.required || []).includes(propertyName),\n        }),\n      ];\n    },\n    [],\n  );\n};\n\n/*\n * Convert a CRD specDescriptor to appropriate OperandField type. Expands obj array properties\n * to the appropriate number of fields.\n */\nconst specDescriptorToFields = (\n  { description, displayName, path, 'x-descriptors': capabilities = [] }: Descriptor,\n  obj: K8sResourceKind,\n): OperandField[] => {\n  // Use regex to check path for an array index, and parse out the parts of the path before\n  // and after the array index.\n  const { regexMatch, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n\n  // If match exists, the field represents an element in an array field group, which means we\n  // need to create 'n' duplicates of this field, where 'n' is the number of\n  // elements in the corresponding array property of 'obj'. If n = 0, we only create one field.\n  if (regexMatch) {\n    const n = _.get(obj, _.toPath(`spec.${pathBeforeIndex}`), []).length || 1;\n    return _.flatten(\n      _.times(n, (index) => ({\n        path: `spec.${pathBeforeIndex}[${index}]${pathAfterIndex && `.${pathAfterIndex}`}`,\n        displayName,\n        description,\n        capabilities,\n        type: null,\n        required: null,\n        validation: null,\n      })),\n    );\n  }\n  return [\n    {\n      path: `spec.${path}`,\n      displayName,\n      description,\n      type: null,\n      required: null,\n      validation: null,\n      capabilities,\n    },\n  ];\n};\n\nconst pathToArray = (path: string): (string | number)[] =>\n  _.map(_.toPath(path), (subPath) => {\n    return /^\\d+$/.test(subPath) ? _.parseInt(subPath) : subPath;\n  });\n\nconst FieldGroup: React.FC<FieldGroupProps> = ({ children, isExpanded = false, id, label }) => {\n  const [expanded, setExpanded] = React.useState<boolean>(isExpanded);\n\n  const onToggle = (event) => {\n    event.preventDefault();\n    setExpanded((current) => !current);\n  };\n\n  return (\n    <div id={`${id}_field-group`} className=\"co-dynamic-form__field-group\">\n      <AccordionItem>\n        <AccordionToggle id={`${id}_accordion-toggle`} onClick={onToggle} isExpanded={expanded}>\n          <label htmlFor={`${id}_accordion-content`}>{label}</label>\n        </AccordionToggle>\n        <AccordionContent id={`${id}_accordion-content`} isHidden={!expanded}>\n          {children}\n        </AccordionContent>\n      </AccordionItem>\n    </div>\n  );\n};\n\n// Wrapper for individual operand form inputs\nconst OperandFormInputGroup: React.FC<OperandFormInputGroupProps> = ({ error, field, input }) => {\n  const { description, displayName, path, required } = field;\n  const id = idFromPath(path);\n  return input ? (\n    <div className=\"form-group co-dynamic-form__form-group\" data-test-selector={path}>\n      <label className={classNames('form-label', { 'co-required': required })} htmlFor={id}>\n        {displayName}\n      </label>\n      {input}\n      {description && (\n        <span id={`${id}__description`} className=\"help-block\">\n          {description}\n        </span>\n      )}\n      {error && <span className=\"co-error\">{error}</span>}\n    </div>\n  ) : null;\n};\n\n// eslint-disable-next-line @typescript-eslint/camelcase\nexport const DEPRECATED_CreateOperandForm: React.FC<OperandFormProps> = ({\n  formData,\n  csv,\n  schema,\n  model,\n  onChange,\n  providedAPI,\n  match,\n  next,\n}) => {\n  const immutableFormData = Immutable.fromJS(formData);\n  const handleFormDataUpdate = (path: string, value: any): void => {\n    const { regexMatch, index, pathBeforeIndex, pathAfterIndex } = parseArrayPath(path);\n\n    // Immutable will not initialize a deep path as a List if it includes an integer, so we need to manually\n    // initialize non-existent array properties to a List instance before updating state at that path.\n    if (regexMatch && index === 0) {\n      const existing = immutableFormData.getIn([...pathToArray(pathBeforeIndex), 0]);\n      const item = Immutable.Map(existing || {}).setIn(pathToArray(pathAfterIndex), value);\n      const list = Immutable.List([item]);\n      onChange(immutableFormData.setIn(pathToArray(pathBeforeIndex), list).toJS());\n    }\n    onChange(immutableFormData.setIn(pathToArray(path), value).toJS());\n  };\n\n  const handleFormDataDelete = (path) => {\n    onChange(immutableFormData.deleteIn(pathToArray(path)).toJS());\n  };\n\n  // Map providedAPI spec descriptors and openAPI spec properties to OperandField[] array\n  const [fields, setFields] = React.useState<OperandField[]>(() => {\n    // Get fields from openAPI\n    const schemaFields = fieldsForOpenAPI(\n      schema?.properties?.spec as JSONSchema6,\n      providedAPI,\n      formData,\n    );\n\n    // Get fields from providedAPI that do not exist in the OpenAPI spec.\n    const descriptorFields = _.reduce(\n      providedAPI?.specDescriptors ?? [],\n      (providedAPIFieldsAccumulator, specDescriptor) => {\n        // If this field was already created, ignore it.\n        if (_.find(schemaFields, { path: `spec.${specDescriptor.path}` })) {\n          return providedAPIFieldsAccumulator;\n        }\n\n        // Add the field if it doesn't exist\n        return [\n          ...providedAPIFieldsAccumulator,\n          ...specDescriptorToFields(specDescriptor, formData),\n        ];\n      },\n      [],\n    );\n\n    // Concatenate all fields and return\n    return [...schemaFields, ...descriptorFields];\n  });\n\n  const labelTags = React.useMemo(() => {\n    const formValue = immutableFormData.getIn(['metadata', 'labels']);\n    return SelectorInput.arrayify(_.isFunction(formValue?.toJS) ? formValue.toJS() : {});\n  }, [immutableFormData]);\n\n  const [error, setError] = React.useState<string>();\n  const [formErrors, setFormErrors] = React.useState<FieldErrors>({});\n\n  // Group fields into advanced, arrayFieldGroup, fieldGroup, and normal fields for rendering.\n  // Note that arrayFieldGroup and fieldGroup fields are still flat after this. The memoized\n  // 'arrayFieldGroups' and 'fieldGroups' (below) further organizes these by their respective\n  // group descriptors to simplify rendering and state management.\n  const [\n    advancedFields = [],\n    arrayFields = [],\n    groupFields = [],\n    normalFields = [],\n  ]: OperandField[][] = React.useMemo(\n    (): OperandField[][] =>\n      _.reduce(\n        fields,\n        (\n          [\n            advancedFieldsAccumulator = [],\n            arrayFieldsAccumulator = [],\n            groupFieldsAccumulator = [],\n            normalFieldsAccumulator = [],\n          ],\n          field,\n        ) => {\n          if (hasDescriptor(field, SpecCapability.arrayFieldGroup)) {\n            return [\n              advancedFieldsAccumulator,\n              [...arrayFieldsAccumulator, field],\n              groupFieldsAccumulator,\n              normalFieldsAccumulator,\n            ];\n          }\n          if (hasDescriptor(field, SpecCapability.fieldGroup)) {\n            return [\n              advancedFieldsAccumulator,\n              arrayFieldsAccumulator,\n              [...groupFieldsAccumulator, field],\n              normalFieldsAccumulator,\n            ];\n          }\n          if (hasDescriptor(field, SpecCapability.advanced)) {\n            return [\n              [...advancedFieldsAccumulator, field],\n              arrayFieldsAccumulator,\n              groupFieldsAccumulator,\n              normalFieldsAccumulator,\n            ];\n          }\n          return [\n            advancedFieldsAccumulator,\n            arrayFieldsAccumulator,\n            groupFieldsAccumulator,\n            [...normalFieldsAccumulator, field],\n          ];\n        },\n        [],\n      ),\n    [fields],\n  );\n\n  // Create memoized arrayFieldGroups. Organizes arrayFields into a structure that is easy to map\n  // and render.\n  const arrayFieldGroups = React.useMemo(() => {\n    // Group all fields by group name\n    const groupedByName = _.groupBy(arrayFields, (field) => {\n      const { groupName } = parseGroupDescriptor(field);\n      return groupName;\n    });\n\n    // Map {groupName: string, fieldLists: OperandField[][]}, where OperandField is a nested array\n    // of the appropriate fields, grouped by index.\n    return _.map(groupedByName, (fieldsInGroup, groupName: string) => ({\n      groupName,\n      fieldLists: _.reduce(\n        fieldsInGroup,\n        (fieldListsAccumulator, field) => {\n          const { index, regexMatch } = parseArrayPath(field.path);\n          if (regexMatch) {\n            fieldListsAccumulator[index] = [...(fieldListsAccumulator[index] || []), field];\n          }\n          return fieldListsAccumulator;\n        },\n        [],\n      ),\n    }));\n  }, [arrayFields]);\n\n  // Create memoized fieldGroups. Map to array of fields grouped by fieldGroup name so that sorting\n  // is easy.\n  const fieldGroups = React.useMemo(() => {\n    const groupedByName = _.groupBy(groupFields, (field) => {\n      const { groupName } = parseGroupDescriptor(field);\n      return groupName;\n    });\n\n    return _.map(groupedByName, (fieldList, groupName) => ({\n      groupName,\n      fieldList,\n    }));\n  }, [groupFields]);\n\n  const getFormData = (path): any => immutableFormData.getIn(pathToArray(path));\n\n  // Validate form and submit API request if no validation failures\n  const submit = (event) => {\n    event.preventDefault();\n    const errors = fields\n      .filter((f) => !_.isNil(f.validation) || !_.isEmpty(f.validation))\n      .filter((f) => f.required || !_.isEqual(getFormData(f.path), defaultValueFor(f.capabilities)))\n      .reduce<FieldErrors>((allErrors, field) => {\n        // NOTE: Use server-side validation in Kubernetes 1.16 (https://github.com/kubernetes/kubernetes/issues/80718#issuecomment-521081640)\n        const fieldErrors = _.map(field.validation, (val, rule: Validations) => {\n          const formVal = getFormData(field.path);\n          switch (rule) {\n            case Validations.minimum:\n              return formVal >= val ? null : `Must be greater than ${val}.`;\n            case Validations.maximum:\n              return formVal <= val ? null : `Must be less than ${val}.`;\n            case Validations.minLength:\n              return formVal.length >= val ? null : `Must be at least ${val} characters.`;\n            case Validations.maxLength:\n              return formVal.length <= val ? null : `Must be greater than ${val} characters.`;\n            case Validations.pattern:\n              return new RegExp(val as string).test(formVal)\n                ? null\n                : `Does not match required pattern ${val}`;\n            default:\n              return null;\n          }\n        });\n        // Just use first error\n        return { ...allErrors, [field.path]: fieldErrors.find((e) => !_.isNil(e)) };\n      }, {});\n    setFormErrors(errors);\n\n    if (_.isEmpty(_.compact(_.values(errors)))) {\n      k8sCreate(\n        model,\n        model.namespaced\n          ? immutableFormData.setIn(['metadata', 'namespace'], match.params.ns).toJS()\n          : immutableFormData.toJS(),\n      )\n        .then(() => history.push(next))\n        .catch((err: Error) => setError(err.message || 'Unknown error.'));\n    }\n  };\n\n  // TODO(alecmerdler): Move this into a single `<SpecDescriptorInput>` entry component in the `descriptors/` directory\n  const inputFor = ({ capabilities, displayName, path, required, validation }: OperandField) => {\n    const id = idFromPath(path);\n    const formDataValue = getFormData(path);\n    const currentValue = _.isNil(formDataValue) ? defaultValueFor(capabilities) : formDataValue;\n    if (capabilities.find((c) => c.startsWith(SpecCapability.fieldDependency))) {\n      const controlFieldInfoList = capabilities.filter((c) =>\n        c.startsWith(SpecCapability.fieldDependency),\n      );\n      const controlFieldPathList = _.uniq(\n        controlFieldInfoList\n          .map((c) => c.split(SpecCapability.fieldDependency)[1])\n          .reduce((infoList, info) => [info.split(':')[0], ...infoList], []),\n      );\n      const controlFieldPath =\n        _.isArray(controlFieldPathList) && controlFieldPathList.length === 1\n          ? controlFieldPathList[0]\n          : null;\n      const currentControlFieldValue = !_.isNil(getFormData(`spec.${controlFieldPath}`))\n        ? getFormData(`spec.${controlFieldPath}`).toString()\n        : null;\n      const expectedControlFieldValueList = controlFieldInfoList\n        .map((c) => c.split(SpecCapability.fieldDependency)[1])\n        .reduce((infoList, info) => [info.split(':')[1], ...infoList], []);\n\n      if (!expectedControlFieldValueList.includes(currentControlFieldValue)) {\n        return null;\n      }\n    }\n    if (capabilities.includes(SpecCapability.podCount)) {\n      return (\n        <NumberSpinner\n          id={id}\n          className=\"pf-c-form-control\"\n          value={currentValue}\n          onChange={({ currentTarget: { value } }) =>\n            handleFormDataUpdate(path, _.toInteger(value))\n          }\n          changeValueBy={(operation) =>\n            handleFormDataUpdate(path, _.toInteger(currentValue) + operation)\n          }\n          autoFocus\n          required\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.resourceRequirements)) {\n      const cpuLimitsPath = `limits.cpu`;\n      const memoryLimitsPath = `limits.memory`;\n      const storageLimitsPath = 'limits.ephemeral-storage';\n      const cpuRequestsPath = `requests.cpu`;\n      const memoryRequestsPath = `requests.memory`;\n      const storageRequestsPath = 'requests.ephemeral-storage';\n      return (\n        <dl style={{ marginLeft: '15px' }}>\n          <dt>Limits</dt>\n          <dd>\n            <ResourceRequirements\n              cpu={currentValue.getIn(_.toPath(cpuLimitsPath))}\n              memory={currentValue.getIn(_.toPath(memoryLimitsPath))}\n              storage={currentValue.getIn(_.toPath(storageLimitsPath))}\n              onChangeCPU={(value) => handleFormDataUpdate(`${path}.${cpuLimitsPath}`, value)}\n              onChangeMemory={(value) => handleFormDataUpdate(`${path}.${memoryLimitsPath}`, value)}\n              onChangeStorage={(value) =>\n                handleFormDataUpdate(`${path}.${storageLimitsPath}`, value)\n              }\n              path={`${id}.limits`}\n            />\n          </dd>\n          <dt>Requests</dt>\n          <dd>\n            <ResourceRequirements\n              cpu={currentValue.getIn(_.toPath(cpuRequestsPath))}\n              memory={currentValue.getIn(_.toPath(memoryRequestsPath))}\n              storage={currentValue.getIn(_.toPath(storageRequestsPath))}\n              onChangeCPU={(value) => handleFormDataUpdate(`${path}.${cpuRequestsPath}`, value)}\n              onChangeMemory={(value) =>\n                handleFormDataUpdate(`${path}.${memoryRequestsPath}`, value)\n              }\n              onChangeStorage={(value) =>\n                handleFormDataUpdate(`${path}.${storageRequestsPath}`, value)\n              }\n              path={`${id}.requests`}\n            />\n          </dd>\n        </dl>\n      );\n    }\n    if (capabilities.includes(SpecCapability.password)) {\n      return (\n        <div>\n          <input\n            className=\"pf-c-form-control\"\n            id={id}\n            type=\"password\"\n            {...validation}\n            onChange={({ currentTarget: { value } }) => handleFormDataUpdate(path, value)}\n            value={currentValue}\n          />\n        </div>\n      );\n    }\n    if (capabilities.some((c) => c.startsWith(SpecCapability.k8sResourcePrefix))) {\n      const groupVersionKind: GroupVersionKind = capabilities\n        .find((c) => c.startsWith(SpecCapability.k8sResourcePrefix))\n        .split(SpecCapability.k8sResourcePrefix)[1]\n        .replace('core~v1~', '');\n      const k8sModel = modelFor(groupVersionKind);\n      if (!k8sModel) {\n        // eslint-disable-next-line no-console\n        console.warn('[Legacy CreateOperandForm] Cluster does not have resource', groupVersionKind);\n      }\n      return k8sModel ? (\n        <ListDropdown\n          id={id}\n          resources={[\n            {\n              kind: groupVersionKind,\n              namespace: k8sModel.namespaced ? match?.params?.ns : null,\n            },\n          ]}\n          desc={displayName}\n          placeholder={`Select ${kindForReference(groupVersionKind)}`}\n          onChange={(value) => handleFormDataUpdate(path, value)}\n          selectedKey={currentValue ? `${currentValue}-${k8sModel?.kind}` : null}\n        />\n      ) : null;\n    }\n    if (capabilities.includes(SpecCapability.checkbox)) {\n      return (\n        <Checkbox\n          id={id}\n          style={{ marginLeft: '10px' }}\n          isChecked={(_.isNil(currentValue) ? false : currentValue) as boolean}\n          label={displayName}\n          required={required}\n          onChange={(value) => handleFormDataUpdate(path, value)}\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.booleanSwitch)) {\n      return (\n        <Switch\n          key={id}\n          id={id}\n          isChecked={(_.isNil(currentValue) ? false : currentValue) as boolean}\n          onChange={(value) => handleFormDataUpdate(path, value)}\n          label=\"True\"\n          labelOff=\"False\"\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.imagePullPolicy)) {\n      return (\n        <RadioGroup\n          id={id}\n          currentValue={currentValue}\n          items={_.values(ImagePullPolicy).map((policy) => ({\n            value: policy,\n            title: policy,\n          }))}\n          onChange={({ currentTarget: { value } }) => handleFormDataUpdate(path, value)}\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.updateStrategy)) {\n      const maxUnavailablePath = `rollingUpdate.maxUnavailable`;\n      const maxSurgePath = `rollingUpdate.maxSurge`;\n      return (\n        <ConfigureUpdateStrategy\n          strategyType={currentValue.get('type')}\n          maxUnavailable={currentValue.getIn(_.toPath(maxUnavailablePath))}\n          maxSurge={currentValue.getIn(_.toPath(maxSurgePath))}\n          onChangeStrategyType={(value) => handleFormDataUpdate(`${path}.type`, value)}\n          onChangeMaxUnavailable={(value) =>\n            handleFormDataUpdate(`${path}.${maxUnavailablePath}`, value)\n          }\n          onChangeMaxSurge={(value) => handleFormDataUpdate(`${path}.${maxSurgePath}`, value)}\n          replicas={1}\n          uid={id}\n        />\n      );\n    }\n    if (capabilities.includes(SpecCapability.text)) {\n      return (\n        <div>\n          <input\n            key={id}\n            className=\"pf-c-form-control\"\n            id={id}\n            type=\"text\"\n            onChange={({ currentTarget: { value } }) => handleFormDataUpdate(path, value)}\n            value={currentValue}\n          />\n        </div>\n      );\n    }\n    if (capabilities.includes(SpecCapability.number)) {\n      return (\n        <div>\n          <input\n            key={path}\n            className=\"pf-c-form-control\"\n            id={id}\n            type=\"number\"\n            onChange={({ currentTarget: { value } }) =>\n              handleFormDataUpdate(path, value !== '' ? _.toNumber(value) : '')\n            }\n            value={currentValue !== '' ? _.toNumber(currentValue) : ''}\n          />\n        </div>\n      );\n    }\n    if (capabilities.includes(SpecCapability.nodeAffinity)) {\n      return (\n        <div style={{ marginLeft: '15px' }}>\n          <NodeAffinity\n            affinity={currentValue.toJS() as NodeAffinityType}\n            onChange={(value) => handleFormDataUpdate(path, Immutable.fromJS(value))}\n            uid={id}\n          />\n        </div>\n      );\n    }\n    if (\n      capabilities.includes(SpecCapability.podAffinity) ||\n      capabilities.includes(SpecCapability.podAntiAffinity)\n    ) {\n      return (\n        <div style={{ marginLeft: '15px' }}>\n          <PodAffinity\n            affinity={currentValue.toJS()}\n            onChange={(value) => handleFormDataUpdate(path, Immutable.fromJS(value))}\n            uid={id}\n          />\n        </div>\n      );\n    }\n    if (capabilities.some((c) => c.startsWith(SpecCapability.select))) {\n      return (\n        <div>\n          <Dropdown\n            id={id}\n            title={`Select ${displayName}`}\n            selectedKey={currentValue}\n            items={capabilities\n              .filter((c) => c.startsWith(SpecCapability.select))\n              .map((c) => c.split(SpecCapability.select)[1])\n              .reduce((all, option) => ({ [option]: option, ...all }), {})}\n            onChange={(value) => handleFormDataUpdate(path, value)}\n          />\n        </div>\n      );\n    }\n    return null;\n  };\n\n  /* Inserts an arrayFieldGroup at nextIndex. The fieldList argument is an array of fields\n   * representing a single element in an arrayFieldGroup. To add an arrayFieldGroup, we duplicate\n   * each field in this fieldList, replacing the array index in field.path with the nextIndex\n   * argument\n   */\n  const addArrayFieldGroup = (fieldLists: OperandField[][]) => {\n    // Duplicate each field in fieldList, creating the corresponding field and formValue at\n    // arrayFieldGroup[nextIndex]\n    const addedFields = _.reduce(\n      _.last(fieldLists),\n      (fieldAccumulator, field) => {\n        // Replace index of field with nextIndex\n        const path = modifyArrayFieldPathIndex(field.path, () => fieldLists.length);\n        return [...fieldAccumulator, { ...field, path }];\n      },\n      [],\n    );\n\n    setFields((currentFields) => [...currentFields, ...addedFields]);\n  };\n\n  // Removes fields corresponding to an  arrayFieldGroup index from the form\n  const removeArrayFieldGroup = (fieldLists: OperandField[][], indexToRemove: number) => {\n    // Flat array of fields in this arrayFieldGroup at index > removed.\n    const fieldsToLeftShift = _.flatten(\n      _.filter(fieldLists, (_unused, index) => index > indexToRemove),\n    );\n\n    // List of paths to be removed from fields list. Fields and values in fieldsToLeftShift\n    // will be replaced with left-shifted equivalents\n    const fieldPathsToRemove = _.map([...fieldLists[indexToRemove], ...fieldsToLeftShift], 'path');\n    const [regexMatch, formDataPathToRemove] =\n      (fieldPathsToRemove?.[0] || '').match(/^(.*\\[\\d+\\]).*$/) || [];\n\n    const leftShiftedFields = _.reduce(\n      fieldsToLeftShift,\n      (fieldAccumulator, field) => {\n        const path = modifyArrayFieldPathIndex(field.path, (index) => index - 1);\n        return [...fieldAccumulator, { ...field, path }];\n      },\n      [],\n    );\n\n    // Remove arrayFieldGroup from fields and replace subsequent arrayFieldGroup fields with\n    // left-shifted ones.\n    setFields((currentFields) => {\n      return [\n        // Filter out all removed fields and fields that need to be left-shifted\n        ..._.filter(currentFields, (field) => !_.includes(fieldPathsToRemove, field.path)),\n        // Add new left-shifted fields\n        ...leftShiftedFields,\n      ];\n    });\n    regexMatch && handleFormDataDelete(formDataPathToRemove);\n  };\n\n  const renderArrayFieldGroups = () =>\n    _.map(_.sortBy(arrayFieldGroups, 'groupName'), ({ fieldLists, groupName }) => {\n      // If there is no name for this fieldGroup, or no fields associated with the group name, don't\n      // render anything\n      if (_.isEmpty(groupName) || _.isEmpty(fieldLists)) {\n        return null;\n      }\n\n      const groupDisplayName = _.startCase(groupName);\n      const singularGroupDisplayName = groupDisplayName.replace(/s$/, '');\n      const id = `root_spec_${groupName}`;\n      const isExpanded = !_.some(fieldLists, (fieldList) =>\n        _.some(fieldList, (f) => hasDescriptor(f, SpecCapability.advanced) && !f.required),\n      );\n\n      return (\n        <FieldGroup id={id} isExpanded={isExpanded} key={id} label={groupDisplayName}>\n          {_.map(fieldLists, (fieldList, index) => (\n            <React.Fragment key={`${groupName}-${index}`}>\n              {index > 0 && <hr />}\n              {fieldLists.length > 1 && (\n                <div className=\"row co-array-field-group__remove\">\n                  <Button\n                    type=\"button\"\n                    className=\"co-array-field-group__remove-btn\"\n                    onClick={() => removeArrayFieldGroup(fieldLists, index)}\n                    variant=\"link\"\n                  >\n                    <MinusCircleIcon className=\"co-icon-space-r\" />\n                    Remove {singularGroupDisplayName}\n                  </Button>\n                </div>\n              )}\n              {_.map(fieldList, (field) => (\n                <OperandFormInputGroup\n                  key={field.path}\n                  error={formErrors?.[field.path]}\n                  field={field}\n                  input={inputFor(field)}\n                />\n              ))}\n            </React.Fragment>\n          ))}\n          <div className=\"row\">\n            <Button type=\"button\" onClick={() => addArrayFieldGroup(fieldLists)} variant=\"link\">\n              <PlusCircleIcon className=\"co-icon-space-r\" />\n              Add {singularGroupDisplayName}\n            </Button>\n          </div>\n        </FieldGroup>\n      );\n    });\n\n  const renderFieldGroups = () =>\n    _.map(_.sortBy(fieldGroups, 'groupName'), ({ fieldList, groupName }) => {\n      if (_.isEmpty(groupName) || _.isEmpty(fieldList)) {\n        return null;\n      }\n      const id = `root_spec_${groupName}`;\n      const isExpanded = !_.some(\n        fieldList,\n        (f) => f.capabilities.includes(SpecCapability.advanced) && !f.required,\n      );\n      return (\n        <FieldGroup key={id} id={id} isExpanded={isExpanded} label={_.startCase(groupName)}>\n          {_.map(fieldList, (field) => (\n            <OperandFormInputGroup\n              key={field.path}\n              error={formErrors?.[field.path]}\n              field={field}\n              input={inputFor(field)}\n            />\n          ))}\n        </FieldGroup>\n      );\n    });\n\n  const renderNormalFields = () =>\n    _.map(normalFields, (field) => (\n      <OperandFormInputGroup\n        key={field.path}\n        field={field}\n        input={inputFor(field)}\n        error={formErrors?.[field.path]}\n      />\n    ));\n\n  const renderAdvancedFields = () =>\n    advancedFields.length > 0 && (\n      <div>\n        <ExpandCollapse\n          textExpanded=\"Advanced Configuration\"\n          textCollapsed=\"Advanced Configuration\"\n        >\n          {_.map(advancedFields, (field) => (\n            <OperandFormInputGroup\n              key={field.path}\n              field={field}\n              input={inputFor(field)}\n              error={formErrors?.[field.path]}\n            />\n          ))}\n        </ExpandCollapse>\n      </div>\n    );\n  useScrollToTopOnMount();\n\n  return (\n    <div className=\"co-m-pane__body\">\n      <div className=\"row\">\n        <div className=\"col-md-8 col-lg-7\">\n          <Alert\n            isInline\n            className=\"co-alert co-break-word\"\n            variant=\"info\"\n            title={\n              'Note: Some fields may not be represented in this form. Please select \"YAML View\" for full control of object creation.'\n            }\n          />\n          <form className=\"co-dynamic-form\" onSubmit={submit}>\n            <Accordion asDefinitionList={false} className=\"co-dynamic-form__accordion\">\n              <div key={'metadata.name'} className=\"form-group\">\n                <label className=\"control-label co-required\" htmlFor=\"name\">\n                  Name\n                </label>\n                <input\n                  className=\"pf-c-form-control\"\n                  type=\"text\"\n                  onChange={({ target: { value } }) => handleFormDataUpdate('metadata.name', value)}\n                  value={immutableFormData.getIn(['metadata', 'name']) || 'example'}\n                  id=\"root_metadata_name\"\n                  required\n                />\n              </div>\n              <div key={'root_metadata_labels'} className=\"form-group\">\n                <label className=\"control-label\" htmlFor=\"tags-input\">\n                  Labels\n                </label>\n                <SelectorInput\n                  onChange={(value) =>\n                    handleFormDataUpdate(\n                      'metadata.labels',\n                      Immutable.fromJS(SelectorInput.objectify(value)),\n                    )\n                  }\n                  tags={labelTags}\n                />\n              </div>\n              {renderArrayFieldGroups()}\n              {renderFieldGroups()}\n              {renderNormalFields()}\n              {renderAdvancedFields()}\n            </Accordion>\n            {(!_.isEmpty(error) || !_.isEmpty(_.compact(_.values(formErrors)))) && (\n              <Alert\n                isInline\n                className=\"co-alert co-break-word co-alert--scrollable\"\n                variant=\"danger\"\n                title=\"Error\"\n              >\n                {error || 'Fix above errors'}\n              </Alert>\n            )}\n            <div style={{ paddingBottom: '30px' }}>\n              <ActionGroup className=\"pf-c-form\">\n                <Button onClick={submit} type=\"submit\" variant=\"primary\">\n                  Create\n                </Button>\n                <Button onClick={history.goBack} variant=\"secondary\">\n                  Cancel\n                </Button>\n              </ActionGroup>\n            </div>\n          </form>\n        </div>\n        <div className=\"col-md-4 col-lg-5\">\n          {csv && providedAPI && (\n            <div style={{ marginBottom: '30px' }}>\n              <ClusterServiceVersionLogo\n                displayName={providedAPI.displayName}\n                icon={_.get(csv, 'spec.icon[0]')}\n                provider={_.get(csv, 'spec.provider')}\n              />\n              {providedAPI.description}\n            </div>\n          )}\n        </div>\n      </div>\n    </div>\n  );\n};\n\ntype Capability = SpecCapability | StatusCapability;\n\n/**\n * Combines OLM descriptor with JSONSchema.\n */\ntype OperandField = {\n  path: string;\n  displayName: string;\n  description?: string;\n  type: JSONSchema6TypeName;\n  required: boolean;\n  validation: {\n    [Validations.maximum]?: number;\n    [Validations.minimum]?: number;\n    [Validations.maxLength]?: number;\n    [Validations.pattern]?: string;\n    [Validations.minLength]?: number;\n  };\n  capabilities: Capability[];\n};\n\ntype FlattenNestedPropertiesAccumulator = {\n  currentCapabilities?: Capability[];\n  currentPath?: string[];\n  fields?: OperandField[];\n  required: boolean;\n};\n\ntype FieldErrors = {\n  [path: string]: string;\n};\n\ntype OperandFormInputGroupProps = {\n  field: OperandField;\n  input: JSX.Element;\n  error: string;\n};\n\ntype FieldGroupProps = {\n  isExpanded?: boolean;\n  id: string;\n  label: string;\n};\n"]}]}