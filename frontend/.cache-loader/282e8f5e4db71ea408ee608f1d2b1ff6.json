{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrop.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrop.tsx","mtime":1616735742450},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as React from 'react';\nimport * as d3 from 'd3';\nimport { observer } from 'mobx-react';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { pointInSvgPath } from 'point-in-svg-path';\nimport { comparer, computed } from 'mobx';\nimport ElementContext from '../utils/ElementContext';\nimport Point from '../geom/Point';\nimport { useDndManager } from './useDndManager';\nconst EMPTY_PROPS = Object.freeze({});\nexport const useDndDrop = (spec, props) => {\n    const specRef = React.useRef(spec);\n    specRef.current = spec;\n    const propsRef = React.useRef(props != null ? props : EMPTY_PROPS);\n    propsRef.current = props != null ? props : EMPTY_PROPS;\n    const dndManager = useDndManager();\n    const nodeRef = React.useRef(null);\n    const idRef = React.useRef();\n    const monitor = React.useMemo(() => {\n        const targetMonitor = {\n            getHandlerId: () => {\n                return idRef.current;\n            },\n            receiveHandlerId: (sourceId) => {\n                idRef.current = sourceId;\n            },\n            canDrop: () => {\n                return dndManager.canDropOnTarget(idRef.current);\n            },\n            isDragging: () => {\n                return dndManager.isDragging();\n            },\n            hasDropTarget: () => {\n                return dndManager.hasDropTarget();\n            },\n            getDropHints: () => {\n                return dndManager.getDropHints();\n            },\n            isOver(options) {\n                return dndManager.isOverTarget(idRef.current, options);\n            },\n            getItemType: () => {\n                return dndManager.getItemType();\n            },\n            getItem: () => {\n                return dndManager.getItem();\n            },\n            getDropResult: () => {\n                return dndManager.getDropResult();\n            },\n            didDrop: () => {\n                return dndManager.didDrop();\n            },\n            getDragEvent: () => {\n                return dndManager.getDragEvent();\n            },\n            getOperation: () => {\n                return dndManager.getOperation();\n            },\n            isCancelled: () => {\n                return dndManager.isCancelled();\n            },\n        };\n        return targetMonitor;\n    }, [dndManager]);\n    const element = React.useContext(ElementContext);\n    const elementRef = React.useRef(element);\n    elementRef.current = element;\n    React.useEffect(() => {\n        const dropTarget = {\n            type: spec.accept,\n            dropHint: () => {\n                return typeof specRef.current.dropHint === 'string'\n                    ? specRef.current.dropHint\n                    : typeof specRef.current.dropHint === 'function'\n                        ? specRef.current.dropHint(monitor.getItem(), monitor, propsRef.current)\n                        : elementRef.current.getType();\n            },\n            hitTest: (x, y) => {\n                if (specRef.current.hitTest) {\n                    return specRef.current.hitTest(x, y, propsRef.current);\n                }\n                if (nodeRef.current) {\n                    if (!(nodeRef.current instanceof SVGGraphicsElement)) {\n                        return false;\n                    }\n                    // Rounding the coordinates due to an issue with `point-in-svg-path` returning false\n                    // when the coordinates clearly are within the path.\n                    const point = Point.singleUse(Math.round(x), Math.round(y));\n                    // Translate to this element's coordinates.\n                    // Assumes the node is not within an svg element containing another transform.\n                    elementRef.current.translateFromAbsolute(point);\n                    // perform a fast bounds check\n                    const { x: bboxx, y: bboxy, width, height } = nodeRef.current.getBBox();\n                    if (point.x < bboxx ||\n                        point.x > bboxx + width ||\n                        point.y < bboxy ||\n                        point.y > bboxy + height) {\n                        return false;\n                    }\n                    if (nodeRef.current instanceof SVGPathElement) {\n                        const d = nodeRef.current.getAttribute('d');\n                        return pointInSvgPath(d, point.x, point.y);\n                    }\n                    if (nodeRef.current instanceof SVGCircleElement) {\n                        const { cx, cy, r } = nodeRef.current;\n                        return (Math.sqrt((point.x - cx.animVal.value) ** 2 + (point.y - cy.animVal.value) ** 2) <\n                            r.animVal.value);\n                    }\n                    if (nodeRef.current instanceof SVGEllipseElement) {\n                        const { cx, cy, rx, ry } = nodeRef.current;\n                        return ((point.x - cx.animVal.value) ** 2 / rx.animVal.value ** 2 +\n                            (point.y - cy.animVal.value) ** 2 / ry.animVal.value ** 2 <=\n                            1);\n                    }\n                    if (nodeRef.current instanceof SVGPolygonElement) {\n                        const arr = (nodeRef.current.getAttribute('points') || '')\n                            .replace(/,/g, ' ')\n                            .split(' ')\n                            .map((s) => +s);\n                        const points = [];\n                        for (let i = 0; i < arr.length; i += 2) {\n                            points.push(arr.slice(i, i + 2));\n                        }\n                        return d3.polygonContains(points, [point.x, point.y]);\n                    }\n                    // TODO support round rect\n                    // already passed the bbox test\n                    return true;\n                }\n                return false;\n            },\n            hover: () => {\n                specRef.current.hover &&\n                    specRef.current.hover(monitor.getItem(), monitor, propsRef.current);\n            },\n            canDrop: () => typeof specRef.current.canDrop === 'boolean'\n                ? specRef.current.canDrop\n                : typeof specRef.current.canDrop === 'function'\n                    ? specRef.current.canDrop(monitor.getItem(), monitor, propsRef.current)\n                    : true,\n            drop: () => specRef.current.drop\n                ? specRef.current.drop(monitor.getItem(), monitor, propsRef.current)\n                : !monitor.didDrop()\n                    ? elementRef.current\n                    : undefined,\n        };\n        const [targetId, unregister] = dndManager.registerTarget(dropTarget);\n        monitor.receiveHandlerId(targetId);\n        return unregister;\n    }, [spec.accept, dndManager, monitor]);\n    const collected = React.useMemo(() => computed(() => spec.collect ? spec.collect(monitor, propsRef.current) : {}, { equals: comparer.shallow }), [monitor, spec]);\n    return [collected.get(), nodeRef];\n};\nexport const withDndDrop = (spec) => (WrappedComponent) => {\n    const Component = (props) => {\n        // TODO fix cast to any\n        const [dndDropProps, dndDropRef] = useDndDrop(spec, props);\n        return React.createElement(WrappedComponent, Object.assign({}, props, dndDropProps, { dndDropRef: dndDropRef }));\n    };\n    return observer(Component);\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrop.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrop.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as d3 from 'd3';\nimport { observer } from 'mobx-react';\n// eslint-disable-next-line @typescript-eslint/ban-ts-ignore\n// @ts-ignore\nimport { pointInSvgPath } from 'point-in-svg-path';\nimport { comparer, computed } from 'mobx';\nimport ElementContext from '../utils/ElementContext';\nimport Point from '../geom/Point';\nimport { GraphElement } from '../types';\nimport {\n  ConnectDropTarget,\n  DropTargetSpec,\n  DropTargetMonitor,\n  Identifier,\n  DragEvent,\n  DropTarget,\n  DragOperationWithType,\n} from './dnd-types';\nimport { useDndManager } from './useDndManager';\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport const useDndDrop = <\n  DragObject,\n  DropResult = GraphElement,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DropTargetSpec<DragObject, DropResult, CollectedProps, Props>,\n  props?: Props,\n): [CollectedProps, ConnectDropTarget] => {\n  const specRef = React.useRef(spec);\n  specRef.current = spec;\n\n  const propsRef = React.useRef(props != null ? props : (EMPTY_PROPS as Props));\n  propsRef.current = props != null ? props : (EMPTY_PROPS as Props);\n\n  const dndManager = useDndManager();\n\n  const nodeRef = React.useRef<SVGElement | null>(null);\n  const idRef = React.useRef<string>();\n\n  const monitor = React.useMemo((): DropTargetMonitor => {\n    const targetMonitor: DropTargetMonitor = {\n      getHandlerId: (): string | undefined => {\n        return idRef.current;\n      },\n      receiveHandlerId: (sourceId: string | undefined): void => {\n        idRef.current = sourceId;\n      },\n      canDrop: (): boolean => {\n        return dndManager.canDropOnTarget(idRef.current);\n      },\n      isDragging: (): boolean => {\n        return dndManager.isDragging();\n      },\n      hasDropTarget: (): boolean => {\n        return dndManager.hasDropTarget();\n      },\n      getDropHints: (): string[] => {\n        return dndManager.getDropHints();\n      },\n      isOver(options?: { shallow?: boolean }): boolean {\n        return dndManager.isOverTarget(idRef.current, options);\n      },\n      getItemType: (): Identifier | undefined => {\n        return dndManager.getItemType();\n      },\n      getItem: (): any => {\n        return dndManager.getItem();\n      },\n      getDropResult: (): any => {\n        return dndManager.getDropResult();\n      },\n      didDrop: (): boolean => {\n        return dndManager.didDrop();\n      },\n      getDragEvent: (): DragEvent | undefined => {\n        return dndManager.getDragEvent();\n      },\n      getOperation: (): DragOperationWithType | undefined => {\n        return dndManager.getOperation();\n      },\n      isCancelled: (): boolean => {\n        return dndManager.isCancelled();\n      },\n    };\n    return targetMonitor;\n  }, [dndManager]);\n\n  const element = React.useContext(ElementContext);\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  React.useEffect(() => {\n    const dropTarget: DropTarget = {\n      type: spec.accept,\n      dropHint: () => {\n        return typeof specRef.current.dropHint === 'string'\n          ? specRef.current.dropHint\n          : typeof specRef.current.dropHint === 'function'\n          ? specRef.current.dropHint(monitor.getItem(), monitor, propsRef.current)\n          : elementRef.current.getType();\n      },\n      hitTest: (x: number, y: number) => {\n        if (specRef.current.hitTest) {\n          return specRef.current.hitTest(x, y, propsRef.current);\n        }\n        if (nodeRef.current) {\n          if (!(nodeRef.current instanceof SVGGraphicsElement)) {\n            return false;\n          }\n\n          // Rounding the coordinates due to an issue with `point-in-svg-path` returning false\n          // when the coordinates clearly are within the path.\n          const point = Point.singleUse(Math.round(x), Math.round(y));\n          // Translate to this element's coordinates.\n          // Assumes the node is not within an svg element containing another transform.\n          elementRef.current.translateFromAbsolute(point);\n\n          // perform a fast bounds check\n          const { x: bboxx, y: bboxy, width, height } = nodeRef.current.getBBox();\n          if (\n            point.x < bboxx ||\n            point.x > bboxx + width ||\n            point.y < bboxy ||\n            point.y > bboxy + height\n          ) {\n            return false;\n          }\n\n          if (nodeRef.current instanceof SVGPathElement) {\n            const d = nodeRef.current.getAttribute('d');\n            return pointInSvgPath(d, point.x, point.y);\n          }\n          if (nodeRef.current instanceof SVGCircleElement) {\n            const { cx, cy, r } = nodeRef.current;\n            return (\n              Math.sqrt((point.x - cx.animVal.value) ** 2 + (point.y - cy.animVal.value) ** 2) <\n              r.animVal.value\n            );\n          }\n          if (nodeRef.current instanceof SVGEllipseElement) {\n            const { cx, cy, rx, ry } = nodeRef.current;\n            return (\n              (point.x - cx.animVal.value) ** 2 / rx.animVal.value ** 2 +\n                (point.y - cy.animVal.value) ** 2 / ry.animVal.value ** 2 <=\n              1\n            );\n          }\n          if (nodeRef.current instanceof SVGPolygonElement) {\n            const arr = (nodeRef.current.getAttribute('points') || '')\n              .replace(/,/g, ' ')\n              .split(' ')\n              .map((s) => +s);\n            const points: [number, number][] = [];\n            for (let i = 0; i < arr.length; i += 2) {\n              points.push(arr.slice(i, i + 2) as [number, number]);\n            }\n            return d3.polygonContains(points, [point.x, point.y]);\n          }\n          // TODO support round rect\n\n          // already passed the bbox test\n          return true;\n        }\n        return false;\n      },\n      hover: () => {\n        specRef.current.hover &&\n          specRef.current.hover(monitor.getItem(), monitor, propsRef.current);\n      },\n      canDrop: () =>\n        typeof specRef.current.canDrop === 'boolean'\n          ? specRef.current.canDrop\n          : typeof specRef.current.canDrop === 'function'\n          ? specRef.current.canDrop(monitor.getItem(), monitor, propsRef.current)\n          : true,\n      drop: () =>\n        specRef.current.drop\n          ? specRef.current.drop(monitor.getItem(), monitor, propsRef.current)\n          : !monitor.didDrop()\n          ? elementRef.current\n          : undefined,\n    };\n    const [targetId, unregister] = dndManager.registerTarget(dropTarget);\n    monitor.receiveHandlerId(targetId);\n    return unregister;\n  }, [spec.accept, dndManager, monitor]);\n\n  const collected = React.useMemo(\n    () =>\n      computed(\n        () =>\n          spec.collect ? spec.collect(monitor, propsRef.current) : (({} as any) as CollectedProps),\n        { equals: comparer.shallow },\n      ),\n    [monitor, spec],\n  );\n\n  return [collected.get(), nodeRef as any];\n};\n\nexport type WithDndDropProps = {\n  dndDropRef: ConnectDropTarget;\n};\n\nexport const withDndDrop = <\n  DragObject,\n  DropResult = GraphElement,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DropTargetSpec<DragObject, DropResult, CollectedProps, Props>,\n) => <P extends WithDndDropProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithDndDropProps & CollectedProps>> = (props) => {\n    // TODO fix cast to any\n    const [dndDropProps, dndDropRef] = useDndDrop(spec, props as any);\n    return <WrappedComponent {...(props as any)} {...dndDropProps} dndDropRef={dndDropRef} />;\n  };\n  return observer(Component);\n};\n"]}]}