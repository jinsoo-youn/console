{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/svg-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/svg-utils.ts","mtime":1615298458710},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["export function createSvgIdUrl(id) {\n    return `url(${`${window.location.pathname}${window.location.search}`}#${id})`;\n}\n// Returns the vector 'v' scaled by 'scale'.\nexport function vecScale(scale, v) {\n    return [scale * v[0], scale * v[1]];\n}\n// Returns the sum of two vectors, or a combination of a point and a vector.\nexport function vecSum(pv1, pv2) {\n    return [pv1[0] + pv2[0], pv1[1] + pv2[1]];\n}\n// Returns the unit normal to the line segment from p0 to p1.\nexport function unitNormal(p0, p1) {\n    const n = [p0[1] - p1[1], p1[0] - p0[0]];\n    const nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n    return nLength > 0 ? [n[0] / nLength, n[1] / nLength] : [0, 0];\n}\n// Returns the path for a rounded hull around a single point (a circle).\nfunction roundedHull1(polyPoints, hp) {\n    const padding = hp(polyPoints[0]);\n    const p1 = [polyPoints[0][0], polyPoints[0][1] - padding];\n    const p2 = [polyPoints[0][0], polyPoints[0][1] + padding];\n    return `M ${p1} A ${padding},${padding},0,0,0,${p2} A ${padding},${padding},0,0,0,${p1}`;\n}\n// Returns the path for a rounded hull around two points (a \"capsule\" shape).\nexport function boundingBoxForLine(startPoint, endPoint, padding = 0) {\n    const hp = typeof padding === 'number' ? () => padding : padding;\n    const offsetVector1 = vecScale(hp(startPoint), unitNormal(startPoint, endPoint));\n    const invOffsetVector1 = vecScale(-1, offsetVector1);\n    const offsetVector2 = vecScale(hp(endPoint), unitNormal(startPoint, endPoint));\n    const invOffsetVector2 = vecScale(-1, offsetVector2);\n    const p0 = vecSum(startPoint, offsetVector1);\n    const p1 = vecSum(endPoint, offsetVector2);\n    const p2 = vecSum(endPoint, invOffsetVector2);\n    const p3 = vecSum(startPoint, invOffsetVector1);\n    return [p0, p1, p2, p3];\n}\n// Returns the path for a rounded hull around two points (a \"capsule\" shape).\nfunction roundedHull2(polyPoints, hp) {\n    const points = boundingBoxForLine(polyPoints[0], polyPoints[1], hp);\n    return `M ${points[0]} L ${points[1]} A ${hp(polyPoints[1])},${hp(polyPoints[1])},0,0,0,${points[2]} ${' '}\n   L ${points[3]} A ${hp(polyPoints[0])},${hp(polyPoints[0])},0,0,0,${points[0]}`;\n}\n// Returns the SVG path data string representing the polygon, expanded and rounded.\nexport function hullPath(polyPoints, hullPadding = 0) {\n    const hp = typeof hullPadding === 'number' ? () => hullPadding : hullPadding;\n    // Handle special cases\n    if (!polyPoints || polyPoints.length < 1) {\n        return '';\n    }\n    if (polyPoints.length === 1) {\n        return roundedHull1(polyPoints, hp);\n    }\n    if (polyPoints.length === 2) {\n        return roundedHull2(polyPoints, hp);\n    }\n    const segments = new Array(polyPoints.length);\n    // Calculate each offset (outwards) segment of the convex hull.\n    for (let segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\n        const p0 = segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\n        const p1 = polyPoints[segmentIndex];\n        // Compute the offset vector for the line segment, with length = hullPadding.\n        // const offset = vecScale(hullPadding, unitNormal(p0, p1));\n        segments[segmentIndex] = [\n            vecSum(p0, vecScale(hp(p0), unitNormal(p0, p1))),\n            vecSum(p1, vecScale(hp(p1), unitNormal(p0, p1))),\n        ];\n    }\n    return segments\n        .map((segment, index) => {\n        const p0 = index === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[index - 1];\n        return `${index === 0 ? `M ${segments[segments.length - 1][1]} ` : ''}A ${hp(p0)},${hp(p0)},0,0,0,${segment[0]} L ${segment[1]}`;\n    })\n        .join(' ');\n}\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/svg-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/svg-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { PointTuple } from '../types';\n\nexport function createSvgIdUrl(id: string): string {\n  return `url(${`${window.location.pathname}${window.location.search}`}#${id})`;\n}\n\nexport type HullPaddingGetter = (point: PointTuple) => number;\n\n// Returns the vector 'v' scaled by 'scale'.\nexport function vecScale(scale: number, v: PointTuple): PointTuple {\n  return [scale * v[0], scale * v[1]];\n}\n\n// Returns the sum of two vectors, or a combination of a point and a vector.\nexport function vecSum(pv1: PointTuple, pv2: PointTuple): PointTuple {\n  return [pv1[0] + pv2[0], pv1[1] + pv2[1]];\n}\n\n// Returns the unit normal to the line segment from p0 to p1.\nexport function unitNormal(p0: PointTuple, p1: PointTuple): PointTuple {\n  const n = [p0[1] - p1[1], p1[0] - p0[0]];\n  const nLength = Math.sqrt(n[0] * n[0] + n[1] * n[1]);\n  return nLength > 0 ? [n[0] / nLength, n[1] / nLength] : [0, 0];\n}\n\n// Returns the path for a rounded hull around a single point (a circle).\nfunction roundedHull1(polyPoints: PointTuple[], hp: HullPaddingGetter): string {\n  const padding = hp(polyPoints[0]);\n  const p1 = [polyPoints[0][0], polyPoints[0][1] - padding];\n  const p2 = [polyPoints[0][0], polyPoints[0][1] + padding];\n\n  return `M ${p1} A ${padding},${padding},0,0,0,${p2} A ${padding},${padding},0,0,0,${p1}`;\n}\n\n// Returns the path for a rounded hull around two points (a \"capsule\" shape).\nexport function boundingBoxForLine(\n  startPoint: PointTuple,\n  endPoint: PointTuple,\n  padding: number | HullPaddingGetter = 0,\n): [PointTuple, PointTuple, PointTuple, PointTuple] {\n  const hp = typeof padding === 'number' ? () => padding : padding;\n  const offsetVector1 = vecScale(hp(startPoint), unitNormal(startPoint, endPoint));\n  const invOffsetVector1 = vecScale(-1, offsetVector1);\n\n  const offsetVector2 = vecScale(hp(endPoint), unitNormal(startPoint, endPoint));\n  const invOffsetVector2 = vecScale(-1, offsetVector2);\n\n  const p0 = vecSum(startPoint, offsetVector1);\n  const p1 = vecSum(endPoint, offsetVector2);\n  const p2 = vecSum(endPoint, invOffsetVector2);\n  const p3 = vecSum(startPoint, invOffsetVector1);\n\n  return [p0, p1, p2, p3];\n}\n\n// Returns the path for a rounded hull around two points (a \"capsule\" shape).\nfunction roundedHull2(polyPoints: PointTuple[], hp: HullPaddingGetter): string {\n  const points = boundingBoxForLine(polyPoints[0], polyPoints[1], hp);\n\n  return `M ${points[0]} L ${points[1]} A ${hp(polyPoints[1])},${hp(polyPoints[1])},0,0,0,${\n    points[2]\n  } ${' '}\n   L ${points[3]} A ${hp(polyPoints[0])},${hp(polyPoints[0])},0,0,0,${points[0]}`;\n}\n\n// Returns the SVG path data string representing the polygon, expanded and rounded.\nexport function hullPath(\n  polyPoints: PointTuple[],\n  hullPadding: number | HullPaddingGetter = 0,\n): string {\n  const hp = typeof hullPadding === 'number' ? () => hullPadding : hullPadding;\n\n  // Handle special cases\n  if (!polyPoints || polyPoints.length < 1) {\n    return '';\n  }\n  if (polyPoints.length === 1) {\n    return roundedHull1(polyPoints, hp);\n  }\n  if (polyPoints.length === 2) {\n    return roundedHull2(polyPoints, hp);\n  }\n\n  const segments: PointTuple[][] = new Array(polyPoints.length);\n\n  // Calculate each offset (outwards) segment of the convex hull.\n  for (let segmentIndex = 0; segmentIndex < segments.length; ++segmentIndex) {\n    const p0 =\n      segmentIndex === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[segmentIndex - 1];\n    const p1 = polyPoints[segmentIndex];\n\n    // Compute the offset vector for the line segment, with length = hullPadding.\n    // const offset = vecScale(hullPadding, unitNormal(p0, p1));\n    segments[segmentIndex] = [\n      vecSum(p0, vecScale(hp(p0), unitNormal(p0, p1))),\n      vecSum(p1, vecScale(hp(p1), unitNormal(p0, p1))),\n    ];\n  }\n\n  return segments\n    .map((segment, index) => {\n      const p0 = index === 0 ? polyPoints[polyPoints.length - 1] : polyPoints[index - 1];\n      return `${index === 0 ? `M ${segments[segments.length - 1][1]} ` : ''}A ${hp(p0)},${hp(\n        p0,\n      )},0,0,0,${segment[0]} L ${segment[1]}`;\n    })\n    .join(' ');\n}\n"]}]}