{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/application-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/application-utils.ts","mtime":1616735742400},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as _ from 'lodash';\nimport { k8sGet, k8sList, k8sPatch, k8sKill, modelFor, k8sCreate, LabelSelector, referenceFor, referenceForModel, } from '@console/internal/module/k8s';\nimport { ImageStreamModel, BuildConfigModel, ServiceModel, DeploymentConfigModel, DeploymentModel, RouteModel, SecretModel, DaemonSetModel, StatefulSetModel, } from '@console/internal/models';\nimport { ClusterServiceVersionModel } from '@console/operator-lifecycle-manager';\nimport { ServiceModel as KnativeServiceModel, RouteModel as KnativeRouteModel, } from '@console/knative-plugin';\nimport { isDynamicEventResourceKind } from '@console/knative-plugin/src/utils/fetch-dynamic-eventsources-utils';\nimport { checkAccess } from '@console/internal/components/utils';\nimport { getOperatorBackedServiceKindMap } from '@console/shared';\nimport { CREATE_APPLICATION_KEY, UNASSIGNED_KEY } from '../const';\nimport { detectGitType } from '../components/import/import-validation-utils';\nimport { ServiceBindingRequestModel } from '../models';\nexport const sanitizeApplicationValue = (application, applicationType = application) => {\n    switch (applicationType) {\n        case UNASSIGNED_KEY:\n        case CREATE_APPLICATION_KEY:\n            return '';\n        default:\n            return application;\n    }\n};\nexport const edgesFromAnnotations = (annotations) => {\n    let edges = [];\n    if (_.has(annotations, ['app.openshift.io/connects-to'])) {\n        try {\n            edges = JSON.parse(annotations['app.openshift.io/connects-to']);\n        }\n        catch (e) {\n            // connects-to annotation should hold a JSON string value but failed to parse\n            // treat value as a comma separated list of strings\n            edges = annotations['app.openshift.io/connects-to'].split(',').map((v) => v.trim());\n        }\n    }\n    return edges;\n};\nexport const edgesFromServiceBinding = (source, sbrs) => {\n    const sourceBindings = [];\n    _.forEach(sbrs, (sbr) => {\n        let edgeExists = false;\n        if (_.get(sbr, 'spec.applicationSelector.resource') === modelFor(referenceFor(source)).plural) {\n            if (_.get(sbr, 'spec.applicationSelector.resourceRef') === source.metadata.name) {\n                edgeExists = true;\n            }\n            else {\n                const matchLabels = _.has(sbr, 'spec.applicationSelector.matchLabels');\n                if (matchLabels) {\n                    const sbrSelector = new LabelSelector(sbr.spec.applicationSelector);\n                    if (sbrSelector.matches(source)) {\n                        edgeExists = true;\n                    }\n                }\n            }\n        }\n        edgeExists && sourceBindings.push(sbr);\n    });\n    return sourceBindings;\n};\nconst listInstanceResources = (namespace, instanceName, labelSelector = {}) => {\n    const lists = [];\n    const instanceLabelSelector = Object.assign({ 'app.kubernetes.io/instance': instanceName }, labelSelector);\n    const kinds = ['ReplicationController', 'Route', 'Service', 'ReplicaSet', 'BuildConfig', 'Build'];\n    _.forEach(kinds, (kind) => {\n        lists.push(k8sList(modelFor(kind), {\n            ns: namespace,\n            labelSelector: instanceLabelSelector,\n        }).then((values) => {\n            return _.map(values, (value) => {\n                value.kind = kind;\n                return value;\n            });\n        }));\n    });\n    return Promise.all(lists);\n};\n// Updates the resource's labels to set its application grouping\nconst updateItemAppLabel = (resourceKind, item, application) => {\n    const labels = Object.assign(Object.assign({}, item.metadata.labels), { 'app.kubernetes.io/part-of': application || undefined });\n    if (!resourceKind) {\n        return Promise.reject();\n    }\n    const patch = [\n        {\n            op: _.isEmpty(labels) ? 'add' : 'replace',\n            path: '/metadata/labels',\n            value: labels,\n        },\n    ];\n    return k8sPatch(resourceKind, item, patch);\n};\n// Updates the given resource and its associated resources to the given application grouping\nexport const updateResourceApplication = (resourceKind, resource, application) => {\n    if (!resource) {\n        return Promise.reject(new Error('Error: no resource provided to update application for.'));\n    }\n    if (!resourceKind) {\n        return Promise.reject(new Error('Error: invalid resource kind provided for updating application.'));\n    }\n    const instanceName = _.get(resource, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n    const prevApplication = _.get(resource, ['metadata', 'labels', 'app.kubernetes.io/part-of']);\n    const patches = [updateItemAppLabel(resourceKind, resource, application)];\n    // If there is no instance label, only update this item\n    if (!instanceName) {\n        return Promise.all(patches);\n    }\n    // selector is for the instance name and current application if there is one\n    const labelSelector = {\n        'app.kubernetes.io/instance': instanceName,\n    };\n    if (prevApplication) {\n        labelSelector['app.kubernetes.io/part-of'] = prevApplication;\n    }\n    // Update all the instance's resources that were part of the previous application\n    return listInstanceResources(resource.metadata.namespace, instanceName, {\n        'app.kubernetes.io/part-of': prevApplication,\n    }).then((listsValue) => {\n        _.forEach(listsValue, (list) => {\n            _.forEach(list, (item) => {\n                // verify the case of no previous application\n                if (prevApplication || !_.get(item, ['metadata', 'labels', 'app.kubernetes.io/part-of'])) {\n                    patches.push(updateItemAppLabel(modelFor(item.kind), item, application));\n                }\n            });\n        });\n        return Promise.all(patches);\n    });\n};\n// Updates the item to add an new connect's to value replacing an old value if provided\nconst updateItemAppConnectTo = (item, connections, connectValue, oldValueIndex) => {\n    const model = modelFor(referenceFor(item) || item.kind);\n    if (!model) {\n        return Promise.reject(new Error(`Unable to retrieve model for: ${item.kind}`));\n    }\n    const tags = _.toPairs(item.metadata.annotations);\n    let op = _.size(tags) ? 'replace' : 'add';\n    const existingTag = _.find(tags, (tag) => tag[0] === 'app.openshift.io/connects-to');\n    if (existingTag) {\n        if (connections.includes(connectValue)) {\n            return Promise.resolve();\n        }\n        if (!connectValue) {\n            _.pullAt(connections, [oldValueIndex]);\n        }\n        else if (oldValueIndex >= 0) {\n            connections[oldValueIndex] = connectValue;\n        }\n        else {\n            connections.push(connectValue);\n        }\n        existingTag[1] = _.size(connections) && JSON.stringify(connections);\n        if (!existingTag[1]) {\n            _.remove(tags, (tag) => tag === existingTag);\n            if (!_.size(tags)) {\n                op = 'remove';\n            }\n        }\n    }\n    else {\n        if (!connectValue) {\n            // Removed connection not found, no need to remove\n            return Promise.resolve();\n        }\n        const connectionTag = [\n            'app.openshift.io/connects-to',\n            JSON.stringify([connectValue]),\n        ];\n        tags.push(connectionTag);\n    }\n    const patch = [{ path: '/metadata/annotations', op, value: _.fromPairs(tags) }];\n    return k8sPatch(model, item, patch);\n};\nexport const createServiceBinding = (source, target) => {\n    if (!source || !target || source === target) {\n        return Promise.reject();\n    }\n    const targetName = _.get(target, 'metadata.name');\n    const sourceName = _.get(source, 'metadata.name');\n    const namespace = _.get(source, 'metadata.namespace');\n    const sourceGroup = _.split(_.get(source, 'apiVersion'), '/');\n    const targetResourceGroup = _.split(_.get(target, 'metadata.ownerReferences[0].apiVersion'), '/');\n    const targetResourceKind = _.get(target, 'metadata.ownerReferences[0].kind');\n    const targetResourceRefName = _.get(target, 'metadata.ownerReferences[0].name');\n    const sbrName = `${sourceName}-${modelFor(referenceFor(source)).abbr}-${targetName}-${modelFor(target.kind).abbr}`;\n    const serviceBindingRequest = {\n        apiVersion: 'apps.openshift.io/v1alpha1',\n        kind: 'ServiceBindingRequest',\n        metadata: {\n            name: sbrName,\n            namespace,\n        },\n        spec: {\n            applicationSelector: {\n                resourceRef: sourceName,\n                group: sourceGroup[0],\n                version: sourceGroup[1],\n                resource: modelFor(referenceFor(source)).plural,\n            },\n            backingServiceSelector: {\n                group: targetResourceGroup[0],\n                version: targetResourceGroup[1],\n                kind: targetResourceKind,\n                resourceRef: targetResourceRefName,\n            },\n            detectBindingResources: true,\n        },\n    };\n    return k8sCreate(ServiceBindingRequestModel, serviceBindingRequest);\n};\nexport const removeServiceBinding = (sbr) => {\n    return k8sKill(ServiceBindingRequestModel, sbr);\n};\n// Get the index of the replaced target of the visual connector\nconst getReplacedTargetIndex = (replacedTarget, connections) => {\n    var _a, _b, _c;\n    if (replacedTarget) {\n        const replaceTargetName = (_a = replacedTarget.metadata) === null || _a === void 0 ? void 0 : _a.name;\n        const replaceTargetKind = replacedTarget.kind;\n        const replaceTargetApiVersion = replacedTarget.apiVersion;\n        const replaceValue = {\n            apiVersion: replaceTargetApiVersion,\n            kind: replaceTargetKind,\n            name: replaceTargetName,\n        };\n        const replaceTargetInstanceName = (_c = (_b = replacedTarget.metadata) === null || _b === void 0 ? void 0 : _b.labels) === null || _c === void 0 ? void 0 : _c['app.kubernetes.io/instance'];\n        let index = _.findIndex(connections, replaceValue);\n        if (index === -1) {\n            index = _.findIndex(connections, (connection) => connection === (replaceTargetInstanceName || replaceTargetName));\n        }\n        return index;\n    }\n    return -1;\n};\n// Create a connection from the source to the target replacing the connection to replacedTarget if provided\nexport const createResourceConnection = (source, target, replacedTarget = null) => {\n    var _a, _b;\n    if (!source || !target || source === target) {\n        return Promise.reject();\n    }\n    const connectTargetName = (_a = target.metadata) === null || _a === void 0 ? void 0 : _a.name;\n    const connectTargetKind = target.kind;\n    const connectTargetApiVersion = target.apiVersion;\n    const connectValue = {\n        apiVersion: connectTargetApiVersion,\n        kind: connectTargetKind,\n        name: connectTargetName,\n    };\n    const connections = edgesFromAnnotations((_b = source.metadata) === null || _b === void 0 ? void 0 : _b.annotations);\n    const replacedTargetIndex = getReplacedTargetIndex(replacedTarget, connections);\n    const instanceName = _.get(source, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n    const patches = [\n        updateItemAppConnectTo(source, connections, connectValue, replacedTargetIndex),\n    ];\n    // If there is no instance label, only update this item\n    if (!instanceName) {\n        return Promise.all(patches);\n    }\n    // Update all the instance's resources that were part of the previous application\n    return listInstanceResources(source.metadata.namespace, instanceName).then((listsValue) => {\n        _.forEach(listsValue, (list) => {\n            _.forEach(list, (item) => {\n                patches.push(updateItemAppConnectTo(item, connections, connectValue, replacedTargetIndex));\n            });\n        });\n        return Promise.all(patches);\n    });\n};\n// Remove the connection from the source to the target\nexport const removeResourceConnection = (source, target) => {\n    var _a;\n    if (!source || !target || source === target) {\n        return Promise.reject();\n    }\n    const connections = edgesFromAnnotations((_a = source.metadata) === null || _a === void 0 ? void 0 : _a.annotations);\n    const replacedTargetIndex = getReplacedTargetIndex(target, connections);\n    const instanceName = _.get(source, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n    const patches = [\n        updateItemAppConnectTo(source, connections, null, replacedTargetIndex),\n    ];\n    // If there is no instance label, only update this item\n    if (!instanceName) {\n        return Promise.all(patches);\n    }\n    // Update all the instance's resources that were part of the previous application\n    return listInstanceResources(source.metadata.namespace, instanceName).then((listsValue) => {\n        _.forEach(listsValue, (list) => {\n            _.forEach(list, (item) => {\n                patches.push(updateItemAppConnectTo(item, connections, null, replacedTargetIndex));\n            });\n        });\n        return Promise.all(patches);\n    });\n};\nconst safeKill = (model, obj) => __awaiter(void 0, void 0, void 0, function* () {\n    const resp = yield checkAccess({\n        group: model.apiGroup,\n        resource: model.plural,\n        verb: 'delete',\n        name: obj.metadata.name,\n        namespace: obj.metadata.namespace,\n    });\n    if (resp.status.allowed) {\n        return k8sKill(model, obj);\n    }\n    return null;\n});\nconst deleteWebhooks = (resource, workload) => {\n    var _a, _b, _c, _d, _e;\n    const isKnativeResource = (_b = (_a = workload === null || workload === void 0 ? void 0 : workload.data) === null || _a === void 0 ? void 0 : _a.isKnativeResource) !== null && _b !== void 0 ? _b : false;\n    const deploymentsAnnotations = (_d = (_c = resource.metadata) === null || _c === void 0 ? void 0 : _c.annotations) !== null && _d !== void 0 ? _d : {};\n    const gitType = detectGitType(deploymentsAnnotations['app.openshift.io/vcs-uri']);\n    const buildConfigs = (_e = workload === null || workload === void 0 ? void 0 : workload.resources) === null || _e === void 0 ? void 0 : _e.buildConfigs;\n    return buildConfigs === null || buildConfigs === void 0 ? void 0 : buildConfigs.reduce((requests, bc) => {\n        var _a, _b;\n        const triggers = (_b = (_a = bc.spec) === null || _a === void 0 ? void 0 : _a.triggers) !== null && _b !== void 0 ? _b : [];\n        const reqs = triggers.reduce((a, t) => {\n            var _a, _b;\n            let obj;\n            const webhookType = t.generic ? 'generic' : gitType;\n            const webhookTypeObj = t.generic || (!isKnativeResource && t[gitType]);\n            if (webhookTypeObj) {\n                obj = Object.assign(Object.assign({}, resource), { metadata: {\n                        name: (_b = (_a = webhookTypeObj.secretReference) === null || _a === void 0 ? void 0 : _a.name) !== null && _b !== void 0 ? _b : `${resource.metadata.name}-${webhookType}-webhook-secret`,\n                        namespace: resource.metadata.namespace,\n                    } });\n            }\n            return obj ? [...a, safeKill(SecretModel, obj)] : a;\n        }, []);\n        return [...requests, ...reqs];\n    }, []);\n};\nexport const cleanUpWorkload = (resource, workload) => {\n    var _a;\n    const reqs = [];\n    const isBuildConfigPresent = !_.isEmpty((_a = workload === null || workload === void 0 ? void 0 : workload.resources) === null || _a === void 0 ? void 0 : _a.buildConfigs);\n    const deleteModels = [ServiceModel, RouteModel];\n    const knativeDeleteModels = [KnativeServiceModel, KnativeRouteModel, ImageStreamModel];\n    if (isBuildConfigPresent) {\n        deleteModels.push(BuildConfigModel);\n        knativeDeleteModels.push(BuildConfigModel);\n    }\n    const resourceData = _.cloneDeep(resource);\n    const deleteRequest = (model, resourceObj) => {\n        const req = safeKill(model, resourceObj);\n        req && reqs.push(req);\n    };\n    const batchDeleteRequests = (models, resourceObj) => {\n        models.forEach((model) => deleteRequest(model, resourceObj));\n    };\n    if (isDynamicEventResourceKind(referenceFor(resource)))\n        deleteRequest(modelFor(referenceFor(resource)), resource);\n    switch (resource.kind) {\n        case DaemonSetModel.kind:\n        case StatefulSetModel.kind:\n            deleteRequest(modelFor(resource.kind), resource);\n            break;\n        case DeploymentModel.kind:\n        case DeploymentConfigModel.kind:\n            deleteRequest(modelFor(resource.kind), resource);\n            batchDeleteRequests(deleteModels, resource);\n            deleteRequest(ImageStreamModel, resource); // delete imageStream\n            break;\n        case KnativeServiceModel.kind:\n            batchDeleteRequests(knativeDeleteModels, resourceData);\n            break;\n        default:\n            break;\n    }\n    isBuildConfigPresent && reqs.push(...deleteWebhooks(resource, workload));\n    return Promise.all(reqs);\n};\nexport const doContextualBinding = (resources, contextualSource, serviceBindingAvailable = false) => __awaiter(void 0, void 0, void 0, function* () {\n    var _a, _b, _c;\n    if (!contextualSource) {\n        return Promise.reject(new Error('Cannot do a contextual binding without a source'));\n    }\n    const linkingModelRefs = [\n        referenceForModel(DeploymentConfigModel),\n        referenceForModel(DeploymentModel),\n    ];\n    const newResource = resources.find((resource) => linkingModelRefs.includes(referenceFor(resource)));\n    if (!newResource) {\n        // Not a resource we want to connect to\n        return resources;\n    }\n    const { metadata: { namespace }, } = newResource;\n    const [groupVersionKind, resourceName] = contextualSource.split('/');\n    const contextualResource = yield k8sGet(modelFor(groupVersionKind), resourceName, namespace);\n    if (!contextualResource) {\n        return Promise.reject(new Error(`Cannot find resource (${contextualSource}) to do a contextual binding to`));\n    }\n    if (serviceBindingAvailable) {\n        const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(yield k8sList(ClusterServiceVersionModel, { ns: namespace }));\n        const ownerResourceKind = (_c = (_b = (_a = newResource === null || newResource === void 0 ? void 0 : newResource.metadata) === null || _a === void 0 ? void 0 : _a.ownerReferences) === null || _b === void 0 ? void 0 : _b[0]) === null || _c === void 0 ? void 0 : _c.kind;\n        const isOperatorBacked = ownerResourceKind in operatorBackedServiceKindMap;\n        if (isOperatorBacked) {\n            yield createServiceBinding(contextualResource, newResource);\n        }\n    }\n    yield createResourceConnection(contextualResource, newResource);\n    return resources;\n});\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/application-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/application-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport {\n  K8sKind,\n  k8sGet,\n  k8sList,\n  k8sPatch,\n  k8sKill,\n  K8sResourceKind,\n  modelFor,\n  k8sCreate,\n  LabelSelector,\n  referenceFor,\n  referenceForModel,\n} from '@console/internal/module/k8s';\nimport {\n  ImageStreamModel,\n  BuildConfigModel,\n  ServiceModel,\n  DeploymentConfigModel,\n  DeploymentModel,\n  RouteModel,\n  SecretModel,\n  DaemonSetModel,\n  StatefulSetModel,\n} from '@console/internal/models';\nimport { ClusterServiceVersionModel } from '@console/operator-lifecycle-manager';\nimport {\n  ServiceModel as KnativeServiceModel,\n  RouteModel as KnativeRouteModel,\n} from '@console/knative-plugin';\nimport { isDynamicEventResourceKind } from '@console/knative-plugin/src/utils/fetch-dynamic-eventsources-utils';\nimport { checkAccess } from '@console/internal/components/utils';\nimport { getOperatorBackedServiceKindMap } from '@console/shared';\nimport { CREATE_APPLICATION_KEY, UNASSIGNED_KEY } from '../const';\nimport { TopologyDataObject, ConnectsToData } from '../components/topology/topology-types';\nimport { detectGitType } from '../components/import/import-validation-utils';\nimport { ServiceBindingRequestModel } from '../models';\n\nexport const sanitizeApplicationValue = (\n  application: string,\n  applicationType: string = application,\n): string => {\n  switch (applicationType) {\n    case UNASSIGNED_KEY:\n    case CREATE_APPLICATION_KEY:\n      return '';\n    default:\n      return application;\n  }\n};\n\nexport const edgesFromAnnotations = (annotations): (string | ConnectsToData)[] => {\n  let edges: (string | ConnectsToData)[] = [];\n  if (_.has(annotations, ['app.openshift.io/connects-to'])) {\n    try {\n      edges = JSON.parse(annotations['app.openshift.io/connects-to']);\n    } catch (e) {\n      // connects-to annotation should hold a JSON string value but failed to parse\n      // treat value as a comma separated list of strings\n      edges = annotations['app.openshift.io/connects-to'].split(',').map((v) => v.trim());\n    }\n  }\n\n  return edges;\n};\n\nexport const edgesFromServiceBinding = (\n  source: K8sResourceKind,\n  sbrs: K8sResourceKind[],\n): K8sResourceKind[] => {\n  const sourceBindings = [];\n  _.forEach(sbrs, (sbr) => {\n    let edgeExists = false;\n    if (_.get(sbr, 'spec.applicationSelector.resource') === modelFor(referenceFor(source)).plural) {\n      if (_.get(sbr, 'spec.applicationSelector.resourceRef') === source.metadata.name) {\n        edgeExists = true;\n      } else {\n        const matchLabels = _.has(sbr, 'spec.applicationSelector.matchLabels');\n        if (matchLabels) {\n          const sbrSelector = new LabelSelector(sbr.spec.applicationSelector);\n          if (sbrSelector.matches(source)) {\n            edgeExists = true;\n          }\n        }\n      }\n    }\n    edgeExists && sourceBindings.push(sbr);\n  });\n  return sourceBindings;\n};\n\nconst listInstanceResources = (\n  namespace: string,\n  instanceName: string,\n  labelSelector: any = {},\n): Promise<any> => {\n  const lists: Promise<any>[] = [];\n  const instanceLabelSelector = {\n    'app.kubernetes.io/instance': instanceName,\n    ...labelSelector,\n  };\n\n  const kinds = ['ReplicationController', 'Route', 'Service', 'ReplicaSet', 'BuildConfig', 'Build'];\n  _.forEach(kinds, (kind) => {\n    lists.push(\n      k8sList(modelFor(kind), {\n        ns: namespace,\n        labelSelector: instanceLabelSelector,\n      }).then((values) => {\n        return _.map(values, (value) => {\n          value.kind = kind;\n          return value;\n        });\n      }),\n    );\n  });\n\n  return Promise.all(lists);\n};\n\n// Updates the resource's labels to set its application grouping\nconst updateItemAppLabel = (\n  resourceKind: K8sKind,\n  item: K8sResourceKind,\n  application: string,\n): Promise<any> => {\n  const labels = { ...item.metadata.labels, 'app.kubernetes.io/part-of': application || undefined };\n\n  if (!resourceKind) {\n    return Promise.reject();\n  }\n\n  const patch = [\n    {\n      op: _.isEmpty(labels) ? 'add' : 'replace',\n      path: '/metadata/labels',\n      value: labels,\n    },\n  ];\n\n  return k8sPatch(resourceKind, item, patch);\n};\n\n// Updates the given resource and its associated resources to the given application grouping\nexport const updateResourceApplication = (\n  resourceKind: K8sKind,\n  resource: K8sResourceKind,\n  application: string,\n): Promise<any> => {\n  if (!resource) {\n    return Promise.reject(new Error('Error: no resource provided to update application for.'));\n  }\n  if (!resourceKind) {\n    return Promise.reject(\n      new Error('Error: invalid resource kind provided for updating application.'),\n    );\n  }\n\n  const instanceName = _.get(resource, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n  const prevApplication = _.get(resource, ['metadata', 'labels', 'app.kubernetes.io/part-of']);\n\n  const patches: Promise<any>[] = [updateItemAppLabel(resourceKind, resource, application)];\n\n  // If there is no instance label, only update this item\n  if (!instanceName) {\n    return Promise.all(patches);\n  }\n\n  // selector is for the instance name and current application if there is one\n  const labelSelector = {\n    'app.kubernetes.io/instance': instanceName,\n  };\n  if (prevApplication) {\n    labelSelector['app.kubernetes.io/part-of'] = prevApplication;\n  }\n\n  // Update all the instance's resources that were part of the previous application\n  return listInstanceResources(resource.metadata.namespace, instanceName, {\n    'app.kubernetes.io/part-of': prevApplication,\n  }).then((listsValue) => {\n    _.forEach(listsValue, (list) => {\n      _.forEach(list, (item) => {\n        // verify the case of no previous application\n        if (prevApplication || !_.get(item, ['metadata', 'labels', 'app.kubernetes.io/part-of'])) {\n          patches.push(updateItemAppLabel(modelFor(item.kind), item, application));\n        }\n      });\n    });\n\n    return Promise.all(patches);\n  });\n};\n\n// Updates the item to add an new connect's to value replacing an old value if provided\nconst updateItemAppConnectTo = (\n  item: K8sResourceKind,\n  connections: (string | ConnectsToData)[],\n  connectValue: ConnectsToData,\n  oldValueIndex: number,\n) => {\n  const model = modelFor(referenceFor(item) || item.kind);\n\n  if (!model) {\n    return Promise.reject(new Error(`Unable to retrieve model for: ${item.kind}`));\n  }\n\n  const tags = _.toPairs(item.metadata.annotations);\n  let op = _.size(tags) ? 'replace' : 'add';\n\n  const existingTag = _.find(tags, (tag) => tag[0] === 'app.openshift.io/connects-to');\n  if (existingTag) {\n    if (connections.includes(connectValue)) {\n      return Promise.resolve();\n    }\n\n    if (!connectValue) {\n      _.pullAt(connections, [oldValueIndex]);\n    } else if (oldValueIndex >= 0) {\n      connections[oldValueIndex] = connectValue;\n    } else {\n      connections.push(connectValue);\n    }\n    existingTag[1] = _.size(connections) && JSON.stringify(connections);\n\n    if (!existingTag[1]) {\n      _.remove(tags, (tag) => tag === existingTag);\n      if (!_.size(tags)) {\n        op = 'remove';\n      }\n    }\n  } else {\n    if (!connectValue) {\n      // Removed connection not found, no need to remove\n      return Promise.resolve();\n    }\n\n    const connectionTag: [string, string] = [\n      'app.openshift.io/connects-to',\n      JSON.stringify([connectValue]),\n    ];\n    tags.push(connectionTag);\n  }\n\n  const patch = [{ path: '/metadata/annotations', op, value: _.fromPairs(tags) }];\n\n  return k8sPatch(model, item, patch);\n};\n\nexport const createServiceBinding = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n): Promise<K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n\n  const targetName = _.get(target, 'metadata.name');\n  const sourceName = _.get(source, 'metadata.name');\n  const namespace = _.get(source, 'metadata.namespace');\n  const sourceGroup = _.split(_.get(source, 'apiVersion'), '/');\n  const targetResourceGroup = _.split(_.get(target, 'metadata.ownerReferences[0].apiVersion'), '/');\n  const targetResourceKind = _.get(target, 'metadata.ownerReferences[0].kind');\n  const targetResourceRefName = _.get(target, 'metadata.ownerReferences[0].name');\n  const sbrName = `${sourceName}-${modelFor(referenceFor(source)).abbr}-${targetName}-${\n    modelFor(target.kind).abbr\n  }`;\n\n  const serviceBindingRequest = {\n    apiVersion: 'apps.openshift.io/v1alpha1',\n    kind: 'ServiceBindingRequest',\n    metadata: {\n      name: sbrName,\n      namespace,\n    },\n    spec: {\n      applicationSelector: {\n        resourceRef: sourceName,\n        group: sourceGroup[0],\n        version: sourceGroup[1],\n        resource: modelFor(referenceFor(source)).plural,\n      },\n      backingServiceSelector: {\n        group: targetResourceGroup[0],\n        version: targetResourceGroup[1],\n        kind: targetResourceKind,\n        resourceRef: targetResourceRefName,\n      },\n      detectBindingResources: true,\n    },\n  };\n\n  return k8sCreate(ServiceBindingRequestModel, serviceBindingRequest);\n};\n\nexport const removeServiceBinding = (sbr: K8sResourceKind): Promise<any> => {\n  return k8sKill(ServiceBindingRequestModel, sbr);\n};\n\n// Get the index of the replaced target of the visual connector\nconst getReplacedTargetIndex = (\n  replacedTarget: K8sResourceKind,\n  connections: (string | ConnectsToData)[],\n): number => {\n  if (replacedTarget) {\n    const replaceTargetName = replacedTarget.metadata?.name;\n    const replaceTargetKind = replacedTarget.kind;\n    const replaceTargetApiVersion = replacedTarget.apiVersion;\n    const replaceValue = {\n      apiVersion: replaceTargetApiVersion,\n      kind: replaceTargetKind,\n      name: replaceTargetName,\n    };\n    const replaceTargetInstanceName =\n      replacedTarget.metadata?.labels?.['app.kubernetes.io/instance'];\n    let index = _.findIndex(connections, replaceValue);\n    if (index === -1) {\n      index = _.findIndex(\n        connections,\n        (connection) => connection === (replaceTargetInstanceName || replaceTargetName),\n      );\n    }\n    return index;\n  }\n  return -1;\n};\n\n// Create a connection from the source to the target replacing the connection to replacedTarget if provided\nexport const createResourceConnection = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n  replacedTarget: K8sResourceKind = null,\n): Promise<K8sResourceKind[] | K8sResourceKind> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n\n  const connectTargetName = target.metadata?.name;\n  const connectTargetKind = target.kind;\n  const connectTargetApiVersion = target.apiVersion;\n  const connectValue = {\n    apiVersion: connectTargetApiVersion,\n    kind: connectTargetKind,\n    name: connectTargetName,\n  };\n\n  const connections = edgesFromAnnotations(source.metadata?.annotations);\n\n  const replacedTargetIndex = getReplacedTargetIndex(replacedTarget, connections);\n\n  const instanceName = _.get(source, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n\n  const patches: Promise<K8sResourceKind>[] = [\n    updateItemAppConnectTo(source, connections, connectValue, replacedTargetIndex),\n  ];\n\n  // If there is no instance label, only update this item\n  if (!instanceName) {\n    return Promise.all(patches);\n  }\n\n  // Update all the instance's resources that were part of the previous application\n  return listInstanceResources(source.metadata.namespace, instanceName).then((listsValue) => {\n    _.forEach(listsValue, (list) => {\n      _.forEach(list, (item) => {\n        patches.push(updateItemAppConnectTo(item, connections, connectValue, replacedTargetIndex));\n      });\n    });\n\n    return Promise.all(patches);\n  });\n};\n\n// Remove the connection from the source to the target\nexport const removeResourceConnection = (\n  source: K8sResourceKind,\n  target: K8sResourceKind,\n): Promise<any> => {\n  if (!source || !target || source === target) {\n    return Promise.reject();\n  }\n  const connections = edgesFromAnnotations(source.metadata?.annotations);\n\n  const replacedTargetIndex = getReplacedTargetIndex(target, connections);\n\n  const instanceName = _.get(source, ['metadata', 'labels', 'app.kubernetes.io/instance']);\n\n  const patches: Promise<any>[] = [\n    updateItemAppConnectTo(source, connections, null, replacedTargetIndex),\n  ];\n\n  // If there is no instance label, only update this item\n  if (!instanceName) {\n    return Promise.all(patches);\n  }\n\n  // Update all the instance's resources that were part of the previous application\n  return listInstanceResources(source.metadata.namespace, instanceName).then((listsValue) => {\n    _.forEach(listsValue, (list) => {\n      _.forEach(list, (item) => {\n        patches.push(updateItemAppConnectTo(item, connections, null, replacedTargetIndex));\n      });\n    });\n\n    return Promise.all(patches);\n  });\n};\n\nconst safeKill = async (model: K8sKind, obj: K8sResourceKind) => {\n  const resp = await checkAccess({\n    group: model.apiGroup,\n    resource: model.plural,\n    verb: 'delete',\n    name: obj.metadata.name,\n    namespace: obj.metadata.namespace,\n  });\n  if (resp.status.allowed) {\n    return k8sKill(model, obj);\n  }\n  return null;\n};\n\nconst deleteWebhooks = (\n  resource: K8sResourceKind,\n  workload: TopologyDataObject<{ isKnativeResource?: boolean }>,\n) => {\n  const isKnativeResource = workload?.data?.isKnativeResource ?? false;\n  const deploymentsAnnotations = resource.metadata?.annotations ?? {};\n  const gitType = detectGitType(deploymentsAnnotations['app.openshift.io/vcs-uri']);\n  const buildConfigs = workload?.resources?.buildConfigs;\n  return buildConfigs?.reduce((requests, bc) => {\n    const triggers = bc.spec?.triggers ?? [];\n    const reqs = triggers.reduce((a, t) => {\n      let obj: K8sResourceKind;\n      const webhookType = t.generic ? 'generic' : gitType;\n      const webhookTypeObj = t.generic || (!isKnativeResource && t[gitType]);\n      if (webhookTypeObj) {\n        obj = {\n          ...resource,\n          metadata: {\n            name:\n              webhookTypeObj.secretReference?.name ??\n              `${resource.metadata.name}-${webhookType}-webhook-secret`,\n            namespace: resource.metadata.namespace,\n          },\n        };\n      }\n      return obj ? [...a, safeKill(SecretModel, obj)] : a;\n    }, []);\n    return [...requests, ...reqs];\n  }, []);\n};\n\nexport const cleanUpWorkload = (\n  resource: K8sResourceKind,\n  workload: TopologyDataObject,\n): Promise<K8sResourceKind[]> => {\n  const reqs = [];\n  const isBuildConfigPresent = !_.isEmpty(workload?.resources?.buildConfigs);\n\n  const deleteModels = [ServiceModel, RouteModel];\n  const knativeDeleteModels = [KnativeServiceModel, KnativeRouteModel, ImageStreamModel];\n  if (isBuildConfigPresent) {\n    deleteModels.push(BuildConfigModel);\n    knativeDeleteModels.push(BuildConfigModel);\n  }\n  const resourceData = _.cloneDeep(resource);\n  const deleteRequest = (model: K8sKind, resourceObj: K8sResourceKind) => {\n    const req = safeKill(model, resourceObj);\n    req && reqs.push(req);\n  };\n  const batchDeleteRequests = (models: K8sKind[], resourceObj: K8sResourceKind): void => {\n    models.forEach((model) => deleteRequest(model, resourceObj));\n  };\n  if (isDynamicEventResourceKind(referenceFor(resource)))\n    deleteRequest(modelFor(referenceFor(resource)), resource);\n  switch (resource.kind) {\n    case DaemonSetModel.kind:\n    case StatefulSetModel.kind:\n      deleteRequest(modelFor(resource.kind), resource);\n      break;\n    case DeploymentModel.kind:\n    case DeploymentConfigModel.kind:\n      deleteRequest(modelFor(resource.kind), resource);\n      batchDeleteRequests(deleteModels, resource);\n      deleteRequest(ImageStreamModel, resource); // delete imageStream\n      break;\n    case KnativeServiceModel.kind:\n      batchDeleteRequests(knativeDeleteModels, resourceData);\n      break;\n    default:\n      break;\n  }\n  isBuildConfigPresent && reqs.push(...deleteWebhooks(resource, workload));\n  return Promise.all(reqs);\n};\n\nexport const doContextualBinding = async (\n  resources: K8sResourceKind[],\n  contextualSource: string,\n  serviceBindingAvailable: boolean = false,\n): Promise<K8sResourceKind[]> => {\n  if (!contextualSource) {\n    return Promise.reject(new Error('Cannot do a contextual binding without a source'));\n  }\n\n  const linkingModelRefs = [\n    referenceForModel(DeploymentConfigModel),\n    referenceForModel(DeploymentModel),\n  ];\n  const newResource: K8sResourceKind = resources.find((resource) =>\n    linkingModelRefs.includes(referenceFor(resource)),\n  );\n\n  if (!newResource) {\n    // Not a resource we want to connect to\n    return resources;\n  }\n\n  const {\n    metadata: { namespace },\n  } = newResource;\n  const [groupVersionKind, resourceName] = contextualSource.split('/');\n  const contextualResource: K8sResourceKind = await k8sGet(\n    modelFor(groupVersionKind),\n    resourceName,\n    namespace,\n  );\n\n  if (!contextualResource) {\n    return Promise.reject(\n      new Error(`Cannot find resource (${contextualSource}) to do a contextual binding to`),\n    );\n  }\n\n  if (serviceBindingAvailable) {\n    const operatorBackedServiceKindMap = getOperatorBackedServiceKindMap(\n      await k8sList(ClusterServiceVersionModel, { ns: namespace }),\n    );\n    const ownerResourceKind = newResource?.metadata?.ownerReferences?.[0]?.kind;\n    const isOperatorBacked = ownerResourceKind in operatorBackedServiceKindMap;\n\n    if (isOperatorBacked) {\n      await createServiceBinding(contextualResource, newResource);\n    }\n  }\n\n  await createResourceConnection(contextualResource, newResource);\n\n  return resources;\n};\n"]}]}