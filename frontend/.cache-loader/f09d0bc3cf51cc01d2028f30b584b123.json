{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseNode.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseNode.ts","mtime":1616735742460},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { observable, computed } from 'mobx';\nimport { ModelKind, isNode, isEdge, AnchorEnd, NodeShape, NODE_COLLAPSE_CHANGE_EVENT, } from '../types';\nimport CenterAnchor from '../anchors/CenterAnchor';\nimport Rect from '../geom/Rect';\nimport BaseElement from './BaseElement';\nimport Dimensions from '../geom/Dimensions';\nimport Point from '../geom/Point';\nconst createAnchorKey = (end = AnchorEnd.both, type = '') => `${end}:${type}`;\nexport default class BaseNode extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.anchors = {\n            [createAnchorKey()]: new CenterAnchor(this),\n        };\n        this.dimensions = new Dimensions();\n        this.position = new Point();\n        this.group = false;\n        this.collapsed = false;\n    }\n    get nodes() {\n        if (this.isCollapsed()) {\n            return [];\n        }\n        return this.getChildren().filter(isNode);\n    }\n    get groupBounds() {\n        const children = this.getChildren()\n            .filter(isNode)\n            .filter((n) => n.isVisible());\n        if (!children.length) {\n            return this.getInternalBounds();\n        }\n        let rect;\n        children.forEach((c) => {\n            if (isNode(c)) {\n                const { padding } = c.getStyle();\n                const b = c.getBounds();\n                // Currently non-group nodes do not include their padding in the bounds\n                if (!c.isGroup() && padding) {\n                    b.padding(c.getStyle().padding);\n                }\n                if (!rect) {\n                    rect = b.clone();\n                }\n                else {\n                    rect.union(b);\n                }\n            }\n        });\n        if (!rect) {\n            rect = new Rect();\n        }\n        const { padding } = this.getStyle();\n        return rect.padding(padding);\n    }\n    get sourceEdges() {\n        return this.getGraph()\n            .getEdges()\n            .filter((e) => e.getSource() === this);\n    }\n    get targetEdges() {\n        return this.getGraph()\n            .getEdges()\n            .filter((e) => e.getTarget() === this);\n    }\n    getChildren() {\n        if (this.isCollapsed()) {\n            return super.getChildren().filter(isEdge);\n        }\n        return super.getChildren();\n    }\n    getKind() {\n        return ModelKind.node;\n    }\n    getInternalBounds() {\n        const { position, dimensions } = this;\n        return new Rect(position.x, position.y, dimensions.width, dimensions.height);\n    }\n    getBounds() {\n        return this.group && !this.collapsed ? this.groupBounds : this.getInternalBounds();\n    }\n    setBounds(bounds) {\n        const { width, height } = this.dimensions;\n        if (bounds.width !== width || bounds.height !== height) {\n            this.dimensions = new Dimensions(bounds.width, bounds.height);\n        }\n        const { x, y } = this.position;\n        if (bounds.x !== x || bounds.y !== y) {\n            this.position = new Point(bounds.x, bounds.y);\n        }\n    }\n    getPosition() {\n        return this.position;\n    }\n    setPosition(point) {\n        this.position = point;\n    }\n    getDimensions() {\n        return this.dimensions;\n    }\n    setDimensions(dimensions) {\n        this.dimensions = dimensions;\n    }\n    getAnchor(end, type) {\n        let anchor = this.anchors[createAnchorKey(end, type)];\n        if (!anchor && type) {\n            anchor = this.anchors[createAnchorKey(end)];\n        }\n        if (!anchor && (end === AnchorEnd.source || end === AnchorEnd.target)) {\n            anchor = this.anchors[createAnchorKey(AnchorEnd.both, type)];\n            if (!anchor && type) {\n                anchor = this.anchors[createAnchorKey(AnchorEnd.both)];\n            }\n        }\n        return anchor;\n    }\n    setAnchor(anchor, end, type) {\n        const key = createAnchorKey(end, type);\n        if (anchor) {\n            this.anchors[key] = anchor;\n        }\n        else {\n            delete this.anchors[key];\n        }\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    isGroup() {\n        return this.group;\n    }\n    setGroup(group) {\n        this.group = group;\n    }\n    isCollapsed() {\n        return this.collapsed;\n    }\n    setCollapsed(collapsed) {\n        if (collapsed !== this.collapsed) {\n            // Get the location prior to the collapse change and apply it after the collapse.\n            // This updates the new node(s) location(s) to be what the node was originally, basically\n            // keeping the nodes ln place so the layout doesn't start fresh (putting the new nodes at 0,0\n            // TODO: Update to better position the nodes at a point location rather than relying on the setCenter updating the nodes.\n            const prevCenter = this.getBounds().getCenter();\n            this.collapsed = collapsed;\n            this.setBounds(this.getBounds().setCenter(prevCenter.x, prevCenter.y));\n            this.getController().fireEvent(NODE_COLLAPSE_CHANGE_EVENT, { node: this });\n        }\n    }\n    getNodeShape() {\n        return this.shape || (this.group ? NodeShape.rect : NodeShape.circle);\n    }\n    setNodeShape(shape) {\n        this.shape = shape;\n    }\n    getSourceEdges() {\n        return this.sourceEdges;\n    }\n    getTargetEdges() {\n        return this.targetEdges;\n    }\n    setModel(model) {\n        super.setModel(model);\n        let d;\n        let p;\n        if ('width' in model && model.width != null) {\n            if (!d) {\n                d = this.dimensions.clone();\n            }\n            d.width = model.width;\n        }\n        if ('height' in model && model.height != null) {\n            if (!d) {\n                d = this.dimensions.clone();\n            }\n            d.height = model.height;\n        }\n        if (d) {\n            this.setDimensions(d);\n        }\n        if ('x' in model && model.x != null) {\n            if (!p) {\n                p = this.position.clone();\n            }\n            p.x = model.x;\n        }\n        if ('y' in model && model.y != null) {\n            if (!p) {\n                p = this.position.clone();\n            }\n            p.y = model.y;\n        }\n        if (p) {\n            this.setPosition(p);\n        }\n        if ('group' in model) {\n            this.setGroup(!!model.group);\n        }\n        if ('shape' in model) {\n            this.shape = model.shape;\n        }\n        if ('collapsed' in model) {\n            this.setCollapsed(!!model.collapsed);\n        }\n    }\n    translateToParent(t) {\n        if (!this.group || this.isCollapsed()) {\n            const { x, y } = this.getPosition();\n            t.translate(x, y);\n        }\n    }\n    translateFromParent(t) {\n        if (!this.group || this.isCollapsed()) {\n            const { x, y } = this.getPosition();\n            t.translate(-x, -y);\n        }\n    }\n}\n__decorate([\n    observable.shallow\n], BaseNode.prototype, \"anchors\", void 0);\n__decorate([\n    observable.ref\n], BaseNode.prototype, \"dimensions\", void 0);\n__decorate([\n    observable.ref\n], BaseNode.prototype, \"position\", void 0);\n__decorate([\n    computed\n], BaseNode.prototype, \"nodes\", null);\n__decorate([\n    observable\n], BaseNode.prototype, \"group\", void 0);\n__decorate([\n    observable\n], BaseNode.prototype, \"collapsed\", void 0);\n__decorate([\n    observable\n], BaseNode.prototype, \"shape\", void 0);\n__decorate([\n    computed\n], BaseNode.prototype, \"groupBounds\", null);\n__decorate([\n    computed\n], BaseNode.prototype, \"sourceEdges\", null);\n__decorate([\n    computed\n], BaseNode.prototype, \"targetEdges\", null);\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseNode.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseNode.ts"],"names":[],"mappings":"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","sourcesContent":["import { observable, computed } from 'mobx';\nimport {\n  Node,\n  Anchor,\n  NodeModel,\n  ModelKind,\n  isNode,\n  isEdge,\n  AnchorEnd,\n  NodeStyle,\n  NodeShape,\n  Edge,\n  GraphElement,\n  NODE_COLLAPSE_CHANGE_EVENT,\n} from '../types';\nimport CenterAnchor from '../anchors/CenterAnchor';\nimport Rect from '../geom/Rect';\nimport { Translatable } from '../geom/types';\nimport BaseElement from './BaseElement';\nimport Dimensions from '../geom/Dimensions';\nimport Point from '../geom/Point';\n\nconst createAnchorKey = (end: AnchorEnd = AnchorEnd.both, type: string = ''): string =>\n  `${end}:${type}`;\n\nexport default class BaseNode<E extends NodeModel = NodeModel, D = any> extends BaseElement<E, D>\n  implements Node<E, D> {\n  @observable.shallow\n  private anchors: { [type: string]: Anchor } = {\n    [createAnchorKey()]: new CenterAnchor(this),\n  };\n\n  @observable.ref\n  private dimensions = new Dimensions();\n\n  @observable.ref\n  private position = new Point();\n\n  @computed\n  private get nodes(): Node[] {\n    if (this.isCollapsed()) {\n      return [];\n    }\n\n    return this.getChildren().filter(isNode);\n  }\n\n  @observable\n  private group = false;\n\n  @observable\n  private collapsed = false;\n\n  @observable\n  private shape: NodeShape | undefined;\n\n  @computed\n  private get groupBounds(): Rect {\n    const children = this.getChildren()\n      .filter(isNode)\n      .filter((n) => n.isVisible());\n    if (!children.length) {\n      return this.getInternalBounds();\n    }\n\n    let rect: Rect | undefined;\n    children.forEach((c) => {\n      if (isNode(c)) {\n        const { padding } = c.getStyle<NodeStyle>();\n        const b = c.getBounds();\n        // Currently non-group nodes do not include their padding in the bounds\n        if (!c.isGroup() && padding) {\n          b.padding(c.getStyle<NodeStyle>().padding);\n        }\n        if (!rect) {\n          rect = b.clone();\n        } else {\n          rect.union(b);\n        }\n      }\n    });\n\n    if (!rect) {\n      rect = new Rect();\n    }\n\n    const { padding } = this.getStyle<NodeStyle>();\n\n    return rect.padding(padding);\n  }\n\n  @computed\n  private get sourceEdges(): Edge[] {\n    return this.getGraph()\n      .getEdges()\n      .filter((e) => e.getSource() === this);\n  }\n\n  @computed\n  private get targetEdges(): Edge[] {\n    return this.getGraph()\n      .getEdges()\n      .filter((e) => e.getTarget() === this);\n  }\n\n  getChildren(): GraphElement[] {\n    if (this.isCollapsed()) {\n      return super.getChildren().filter(isEdge);\n    }\n    return super.getChildren();\n  }\n\n  getKind(): ModelKind {\n    return ModelKind.node;\n  }\n\n  private getInternalBounds(): Rect {\n    const { position, dimensions } = this;\n    return new Rect(position.x, position.y, dimensions.width, dimensions.height);\n  }\n\n  getBounds(): Rect {\n    return this.group && !this.collapsed ? this.groupBounds : this.getInternalBounds();\n  }\n\n  setBounds(bounds: Rect): void {\n    const { width, height } = this.dimensions;\n    if (bounds.width !== width || bounds.height !== height) {\n      this.dimensions = new Dimensions(bounds.width, bounds.height);\n    }\n    const { x, y } = this.position;\n    if (bounds.x !== x || bounds.y !== y) {\n      this.position = new Point(bounds.x, bounds.y);\n    }\n  }\n\n  getPosition(): Point {\n    return this.position;\n  }\n\n  setPosition(point: Point): void {\n    this.position = point;\n  }\n\n  getDimensions(): Dimensions {\n    return this.dimensions;\n  }\n\n  setDimensions(dimensions: Dimensions): void {\n    this.dimensions = dimensions;\n  }\n\n  getAnchor(end?: AnchorEnd, type?: string): Anchor {\n    let anchor = this.anchors[createAnchorKey(end, type)];\n    if (!anchor && type) {\n      anchor = this.anchors[createAnchorKey(end)];\n    }\n    if (!anchor && (end === AnchorEnd.source || end === AnchorEnd.target)) {\n      anchor = this.anchors[createAnchorKey(AnchorEnd.both, type)];\n      if (!anchor && type) {\n        anchor = this.anchors[createAnchorKey(AnchorEnd.both)];\n      }\n    }\n    return anchor;\n  }\n\n  setAnchor(anchor: Anchor, end?: AnchorEnd, type?: string): void {\n    const key = createAnchorKey(end, type);\n    if (anchor) {\n      this.anchors[key] = anchor;\n    } else {\n      delete this.anchors[key];\n    }\n  }\n\n  getNodes(): Node[] {\n    return this.nodes;\n  }\n\n  isGroup(): boolean {\n    return this.group;\n  }\n\n  setGroup(group: boolean): void {\n    this.group = group;\n  }\n\n  isCollapsed(): boolean {\n    return this.collapsed;\n  }\n\n  setCollapsed(collapsed: boolean): void {\n    if (collapsed !== this.collapsed) {\n      // Get the location prior to the collapse change and apply it after the collapse.\n      // This updates the new node(s) location(s) to be what the node was originally, basically\n      // keeping the nodes ln place so the layout doesn't start fresh (putting the new nodes at 0,0\n      // TODO: Update to better position the nodes at a point location rather than relying on the setCenter updating the nodes.\n      const prevCenter = this.getBounds().getCenter();\n      this.collapsed = collapsed;\n      this.setBounds(this.getBounds().setCenter(prevCenter.x, prevCenter.y));\n      this.getController().fireEvent(NODE_COLLAPSE_CHANGE_EVENT, { node: this });\n    }\n  }\n\n  getNodeShape(): NodeShape {\n    return this.shape || (this.group ? NodeShape.rect : NodeShape.circle);\n  }\n\n  setNodeShape(shape: NodeShape): void {\n    this.shape = shape;\n  }\n\n  getSourceEdges(): Edge[] {\n    return this.sourceEdges;\n  }\n\n  getTargetEdges(): Edge[] {\n    return this.targetEdges;\n  }\n\n  setModel(model: E): void {\n    super.setModel(model);\n    let d: Dimensions | undefined;\n    let p: Point | undefined;\n\n    if ('width' in model && model.width != null) {\n      if (!d) {\n        d = this.dimensions.clone();\n      }\n      d.width = model.width;\n    }\n    if ('height' in model && model.height != null) {\n      if (!d) {\n        d = this.dimensions.clone();\n      }\n      d.height = model.height;\n    }\n    if (d) {\n      this.setDimensions(d);\n    }\n\n    if ('x' in model && model.x != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.x = model.x;\n    }\n    if ('y' in model && model.y != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.y = model.y;\n    }\n    if (p) {\n      this.setPosition(p);\n    }\n\n    if ('group' in model) {\n      this.setGroup(!!model.group);\n    }\n    if ('shape' in model) {\n      this.shape = model.shape;\n    }\n    if ('collapsed' in model) {\n      this.setCollapsed(!!model.collapsed);\n    }\n  }\n\n  translateToParent(t: Translatable): void {\n    if (!this.group || this.isCollapsed()) {\n      const { x, y } = this.getPosition();\n      t.translate(x, y);\n    }\n  }\n\n  translateFromParent(t: Translatable): void {\n    if (!this.group || this.isCollapsed()) {\n      const { x, y } = this.getPosition();\n      t.translate(-x, -y);\n    }\n  }\n}\n"]}]}