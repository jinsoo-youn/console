{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDragNode.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDragNode.tsx","mtime":1615298458710},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as React from 'react';\nimport { action } from 'mobx';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport { isNode } from '../types';\nimport { useDndDrag, Modifiers } from './useDndDrag';\nimport { useDndManager } from './useDndManager';\nexport const DRAG_NODE_EVENT = 'drag_node';\nexport const DRAG_NODE_START_EVENT = `${DRAG_NODE_EVENT}_start`;\nexport const DRAG_NODE_END_EVENT = `${DRAG_NODE_EVENT}_end`;\nexport const DRAG_MOVE_OPERATION = 'move.useDragNode';\nconst defaultOperation = {\n    [Modifiers.DEFAULT]: { type: DRAG_MOVE_OPERATION },\n};\nexport const useDragNode = (spec, props) => {\n    const element = React.useContext(ElementContext);\n    if (!isNode(element)) {\n        throw new Error('useDragNode must be used within the scope of a Node');\n    }\n    const elementRef = React.useRef(element);\n    elementRef.current = element;\n    const dndManager = useDndManager();\n    return useDndDrag(React.useMemo(() => {\n        const sourceSpec = {\n            item: (spec && spec.item) || { type: '#useDragNode#' },\n            operation: (monitor, p) => {\n                if (spec) {\n                    const operation = typeof spec.operation === 'function' ? spec.operation(monitor, p) : spec.operation;\n                    if (typeof operation === 'object' && Object.keys(operation).length > 0) {\n                        return Object.assign(Object.assign({}, defaultOperation), operation);\n                    }\n                }\n                return defaultOperation;\n            },\n            begin: (monitor, p) => {\n                elementRef.current.raise();\n                if (elementRef.current.isGroup()) {\n                    elementRef.current.getChildren().forEach((c) => {\n                        c.raise();\n                    });\n                }\n                const result = spec && spec.begin && spec.begin(monitor, p);\n                elementRef.current\n                    .getController()\n                    .fireEvent(DRAG_NODE_START_EVENT, elementRef.current, monitor.getDragEvent(), monitor.getOperation());\n                return result || elementRef.current;\n            },\n            drag: (event, monitor, p) => {\n                const { dx, dy } = event;\n                function moveElement(e) {\n                    let moved = true;\n                    if (e.isGroup()) {\n                        const nodeChildren = e.getChildren().filter(isNode);\n                        if (nodeChildren.length) {\n                            moved = false;\n                            nodeChildren.forEach(moveElement);\n                        }\n                    }\n                    if (moved) {\n                        e.setPosition(e\n                            .getPosition()\n                            .clone()\n                            .translate(dx, dy));\n                    }\n                }\n                moveElement(elementRef.current);\n                spec && spec.drag && spec.drag(event, monitor, p);\n                elementRef.current\n                    .getController()\n                    .fireEvent(DRAG_NODE_EVENT, elementRef.current, event, monitor.getOperation());\n            },\n            canDrag: spec ? spec.canDrag : undefined,\n            end: (dropResult, monitor, p) => __awaiter(void 0, void 0, void 0, function* () {\n                // FIXME: Get the controller up front due it issues with model updates during dnd operations\n                const controller = elementRef.current.getController();\n                if (spec && spec.end) {\n                    try {\n                        yield spec.end(dropResult, monitor, p);\n                    }\n                    catch (_a) {\n                        dndManager.cancel();\n                    }\n                }\n                action(() => {\n                    controller.fireEvent(DRAG_NODE_END_EVENT, elementRef.current, monitor.getDragEvent(), monitor.getOperation());\n                })();\n            }),\n            collect: spec ? spec.collect : undefined,\n            canCancel: spec ? spec.canCancel : true,\n        };\n        return sourceSpec;\n    }, [spec, dndManager]), props);\n};\nexport const withDragNode = (spec) => (WrappedComponent) => {\n    const Component = (props) => {\n        // TODO fix cast to any\n        const [dragNodeProps, dragNodeRef] = useDragNode(spec, props);\n        return React.createElement(WrappedComponent, Object.assign({}, props, { dragNodeRef: dragNodeRef }, dragNodeProps));\n    };\n    return observer(Component);\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDragNode.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDragNode.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { action } from 'mobx';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport { EventListener, isNode, Node } from '../types';\nimport { useDndDrag, WithDndDragProps, Modifiers } from './useDndDrag';\nimport {\n  DragSourceSpec,\n  DragEvent,\n  ConnectDragSource,\n  DragObjectWithType,\n  DragSpecOperationType,\n  DragOperationWithType,\n  DragSourceMonitor,\n} from './dnd-types';\nimport { useDndManager } from './useDndManager';\n\nexport const DRAG_NODE_EVENT = 'drag_node';\nexport const DRAG_NODE_START_EVENT = `${DRAG_NODE_EVENT}_start`;\nexport const DRAG_NODE_END_EVENT = `${DRAG_NODE_EVENT}_end`;\n\nexport type DragNodeEventListener = EventListener<[Node, DragEvent, DragOperationWithType]>;\n\nexport const DRAG_MOVE_OPERATION = 'move.useDragNode';\n\nconst defaultOperation = {\n  [Modifiers.DEFAULT]: { type: DRAG_MOVE_OPERATION },\n};\n\nexport const useDragNode = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec?: Omit<\n    DragSourceSpec<\n      DragObject,\n      DragSpecOperationType<DragOperationWithType>,\n      DropResult,\n      CollectedProps,\n      Props\n    >,\n    'item'\n  > & {\n    item?: DragObject;\n  },\n  props?: Props,\n): [CollectedProps, ConnectDragSource] => {\n  const element = React.useContext(ElementContext);\n  if (!isNode(element)) {\n    throw new Error('useDragNode must be used within the scope of a Node');\n  }\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  const dndManager = useDndManager();\n\n  return useDndDrag(\n    React.useMemo(() => {\n      const sourceSpec: DragSourceSpec<any, any, any, any, Props> = {\n        item: (spec && spec.item) || { type: '#useDragNode#' },\n        operation: (monitor: DragSourceMonitor, p: Props) => {\n          if (spec) {\n            const operation =\n              typeof spec.operation === 'function' ? spec.operation(monitor, p) : spec.operation;\n            if (typeof operation === 'object' && Object.keys(operation).length > 0) {\n              return {\n                ...defaultOperation,\n                ...operation,\n              };\n            }\n          }\n          return defaultOperation;\n        },\n        begin: (monitor, p) => {\n          elementRef.current.raise();\n          if (elementRef.current.isGroup()) {\n            elementRef.current.getChildren().forEach((c) => {\n              c.raise();\n            });\n          }\n\n          const result = spec && spec.begin && spec.begin(monitor, p);\n\n          elementRef.current\n            .getController()\n            .fireEvent(\n              DRAG_NODE_START_EVENT,\n              elementRef.current,\n              monitor.getDragEvent(),\n              monitor.getOperation(),\n            );\n\n          return result || elementRef.current;\n        },\n        drag: (event, monitor, p) => {\n          const { dx, dy } = event;\n\n          function moveElement(e: Node) {\n            let moved = true;\n            if (e.isGroup()) {\n              const nodeChildren = e.getChildren().filter(isNode);\n              if (nodeChildren.length) {\n                moved = false;\n                nodeChildren.forEach(moveElement);\n              }\n            }\n            if (moved) {\n              e.setPosition(\n                e\n                  .getPosition()\n                  .clone()\n                  .translate(dx, dy),\n              );\n            }\n          }\n\n          moveElement(elementRef.current);\n\n          spec && spec.drag && spec.drag(event, monitor, p);\n\n          elementRef.current\n            .getController()\n            .fireEvent(DRAG_NODE_EVENT, elementRef.current, event, monitor.getOperation());\n        },\n        canDrag: spec ? spec.canDrag : undefined,\n        end: async (dropResult, monitor, p) => {\n          // FIXME: Get the controller up front due it issues with model updates during dnd operations\n          const controller = elementRef.current.getController();\n          if (spec && spec.end) {\n            try {\n              await spec.end(dropResult, monitor, p);\n            } catch {\n              dndManager.cancel();\n            }\n          }\n\n          action(() => {\n            controller.fireEvent(\n              DRAG_NODE_END_EVENT,\n              elementRef.current,\n              monitor.getDragEvent(),\n              monitor.getOperation(),\n            );\n          })();\n        },\n        collect: spec ? spec.collect : undefined,\n        canCancel: spec ? spec.canCancel : true,\n      };\n      return sourceSpec;\n    }, [spec, dndManager]),\n    props,\n  );\n};\n\nexport type WithDragNodeProps = {\n  dragNodeRef: WithDndDragProps['dndDragRef'];\n};\n\nexport const withDragNode = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec?: Omit<\n    DragSourceSpec<\n      DragObject,\n      DragSpecOperationType<DragOperationWithType>,\n      DropResult,\n      CollectedProps,\n      Props\n    >,\n    'item'\n  > & {\n    item?: DragObject;\n  },\n) => <P extends WithDragNodeProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithDragNodeProps>> = (props) => {\n    // TODO fix cast to any\n    const [dragNodeProps, dragNodeRef] = useDragNode(spec, props as any);\n    return <WrappedComponent {...(props as any)} dragNodeRef={dragNodeRef} {...dragNodeProps} />;\n  };\n  return observer(Component);\n};\n"]}]}