{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/pods.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/pods.ts","mtime":1616735742510},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash-es';\nconst getRestartPolicy = (pod) => _.find({\n    Always: {\n        // A unique id to identify the type, used as the value when communicating with the API.\n        id: 'Always',\n        // What is shown in the UI.\n        label: 'Always Restart',\n        // Description in the UI.\n        description: 'If the container restarts for any reason, restart it. ' +\n            'Useful for stateless services that may fail from time to time.',\n        // Default selection for new pods.\n        default: true,\n    },\n    OnFailure: {\n        id: 'OnFailure',\n        label: 'Restart On Failure',\n        description: 'If the container exits with a non-zero status code, restart it.',\n    },\n    Never: {\n        id: 'Never',\n        label: 'Never Restart',\n        description: 'Never restart the container. ' +\n            'Useful for containers that exit when they have completed a specific job, like a data import daemon.',\n    },\n}, { id: _.get(pod, 'spec.restartPolicy') });\nexport const VolumeSource = {\n    emptyDir: {\n        id: 'emptyDir',\n        label: 'Container Volume',\n        description: \"Temporary directory that shares a pod's lifetime.\",\n    },\n    hostPath: {\n        id: 'hostPath',\n        label: 'Host Directory',\n        description: 'Pre-existing host file or directory, ' +\n            'generally for privileged system daemons or other agents tied to the host.',\n    },\n    gitRepo: {\n        id: 'gitRepo',\n        label: 'Git Repo',\n        description: 'Git repository at a particular revision.',\n    },\n    nfs: {\n        id: 'nfs',\n        label: 'NFS',\n        description: 'NFS volume that will be mounted in the host machine.',\n    },\n    secret: {\n        id: 'secret',\n        label: 'Secret',\n        description: 'Secret to populate volume.',\n    },\n    gcePersistentDisk: {\n        id: 'gcePersistentDisk',\n        label: 'GCE Persistent Disk',\n        description: 'GCE disk resource attached to the host machine on demand.',\n    },\n    awsElasticBlockStore: {\n        id: 'awsElasticBlockStore',\n        label: 'AWS Elastic Block Store',\n        description: 'AWS disk resource attached to the host machine on demand.',\n    },\n    glusterfs: {\n        id: 'glusterfs',\n        label: 'Gluster FS',\n        description: 'GlusterFS volume that will be mounted on the host machine.',\n    },\n    iscsi: {\n        id: 'iscsi',\n        label: 'iSCSI',\n        description: 'iSCSI disk attached to host machine on demand',\n    },\n    configMap: {\n        id: 'configMap',\n        label: 'ConfigMap',\n        description: 'ConfigMap to be consumed in volume.',\n    },\n    projected: {\n        id: 'projected',\n        label: 'Projected',\n        description: 'A projected volume maps several existing volume sources into the same directory.',\n    },\n};\nexport const getVolumeType = (volume) => {\n    if (!volume) {\n        return null;\n    }\n    return _.find(VolumeSource, function (v) {\n        return !!volume[v.id];\n    });\n};\nconst genericFormatter = (volInfo) => {\n    const keys = Object.keys(volInfo).sort();\n    const parts = keys.map(function (key) {\n        if (key === 'readOnly') {\n            return '';\n        }\n        return volInfo[key];\n    });\n    if (keys.indexOf('readOnly') !== -1) {\n        parts.push(volInfo.readOnly ? 'ro' : 'rw');\n    }\n    return parts.join(' ') || null;\n};\nexport const getVolumeLocation = (volume) => {\n    const vtype = getVolumeType(volume);\n    if (!vtype) {\n        return null;\n    }\n    const typeID = vtype.id;\n    const info = volume[typeID];\n    switch (typeID) {\n        // Override any special formatting cases.\n        case VolumeSource.gitRepo.id:\n            return `${info.repository}:${info.revision}`;\n        case VolumeSource.configMap.id:\n        case VolumeSource.emptyDir.id:\n        case VolumeSource.secret.id:\n        case VolumeSource.projected.id:\n            return null;\n        // Defaults to space separated sorted keys.\n        default:\n            return genericFormatter(info);\n    }\n};\nexport const getRestartPolicyLabel = (pod) => _.get(getRestartPolicy(pod), 'label', '');\nexport const getVolumeMountPermissions = (v) => {\n    if (!v) {\n        return null;\n    }\n    return v.readOnly ? 'Read-only' : 'Read/Write';\n};\nexport const getVolumeMountsByPermissions = (pod) => {\n    if (!pod || !pod.spec || !pod.spec.volumes) {\n        return [];\n    }\n    const m = {};\n    const volumes = (pod.spec.volumes || []).reduce((p, v) => {\n        p[v.name] = v;\n        return p;\n    }, {});\n    _.forEach(pod.spec.containers, (c) => {\n        _.forEach(c.volumeMounts, (v) => {\n            const k = `${v.name}_${v.readOnly ? 'ro' : 'rw'}`;\n            const mount = { container: c.name, mountPath: v.mountPath, subPath: v.subPath };\n            if (k in m) {\n                return m[k].mounts.push(mount);\n            }\n            m[k] = { mounts: [mount], name: v.name, readOnly: !!v.readOnly, volume: volumes[v.name] };\n        });\n    });\n    return _.values(m);\n};\nexport const podRestarts = (pod) => {\n    if (!pod || !pod.status) {\n        return 0;\n    }\n    const { initContainerStatuses = [], containerStatuses = [] } = pod.status;\n    const isInitializing = initContainerStatuses.some(({ state }) => {\n        return !state.terminated || state.terminated.exitCode !== 0;\n    });\n    const toCheck = isInitializing ? initContainerStatuses : containerStatuses;\n    return toCheck.reduce((restartCount, status) => restartCount + status.restartCount, 0);\n};\nexport const podReadiness = (pod) => {\n    var _a;\n    // Don't include init containers in readiness count. This is consistent with the CLI.\n    const containerStatuses = ((_a = pod === null || pod === void 0 ? void 0 : pod.status) === null || _a === void 0 ? void 0 : _a.containerStatuses) || [];\n    return containerStatuses.reduce((acc, { ready }) => {\n        if (ready) {\n            acc.readyCount = acc.readyCount + 1;\n        }\n        return acc;\n    }, { readyCount: 0, totalContainers: containerStatuses.length });\n};\n// This logic is replicated from k8s (at this writing, Kubernetes 1.17)\n// (See https://github.com/kubernetes/kubernetes/blob/release-1.17/pkg/printers/internalversion/printers.go)\nexport const podPhase = (pod) => {\n    if (!pod || !pod.status) {\n        return '';\n    }\n    if (pod.metadata.deletionTimestamp) {\n        return 'Terminating';\n    }\n    if (pod.status.reason === 'NodeLost') {\n        return 'Unknown';\n    }\n    if (pod.status.reason === 'Evicted') {\n        return 'Evicted';\n    }\n    let initializing = false;\n    let phase = pod.status.phase || pod.status.reason;\n    _.each(pod.status.initContainerStatuses, (container, i) => {\n        const { terminated, waiting } = container.state;\n        if (terminated && terminated.exitCode === 0) {\n            return true;\n        }\n        initializing = true;\n        if (terminated && terminated.reason) {\n            phase = `Init:${terminated.reason}`;\n        }\n        else if (terminated && !terminated.reason) {\n            phase = terminated.signal\n                ? `Init:Signal:${terminated.signal}`\n                : `Init:ExitCode:${terminated.exitCode}`;\n        }\n        else if (waiting && waiting.reason && waiting.reason !== 'PodInitializing') {\n            phase = `Init:${waiting.reason}`;\n        }\n        else {\n            phase = `Init:${i}/${pod.status.initContainerStatuses.length}`;\n        }\n        return false;\n    });\n    if (!initializing) {\n        let hasRunning = false;\n        const containerStatuses = pod.status.containerStatuses || [];\n        for (let i = containerStatuses.length - 1; i >= 0; i--) {\n            const { state: { running, terminated, waiting }, ready, } = containerStatuses[i];\n            if (terminated && terminated.reason) {\n                phase = terminated.reason;\n            }\n            else if (waiting && waiting.reason) {\n                phase = waiting.reason;\n            }\n            else if (waiting && !waiting.reason) {\n                phase = terminated.signal\n                    ? `Signal:${terminated.signal}`\n                    : `ExitCode:${terminated.exitCode}`;\n            }\n            else if (running && ready) {\n                hasRunning = true;\n            }\n        }\n        // Change pod status back to \"Running\" if there is at least one container\n        // still reporting as \"Running\" status.\n        if (phase === 'Completed' && hasRunning) {\n            phase = 'Running';\n        }\n    }\n    return phase;\n};\nexport const podPhaseFilterReducer = (pod) => {\n    const status = podPhase(pod);\n    if (status === 'Terminating') {\n        return status;\n    }\n    if (status.includes('CrashLoopBackOff')) {\n        return 'CrashLoopBackOff';\n    }\n    return _.get(pod, 'status.phase', 'Unknown');\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/pods.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/pods.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash-es';\n\nimport { ContainerSpec, ContainerStatus, PodKind, Volume, VolumeMount } from './types';\n\nconst getRestartPolicy = (pod: PodKind) =>\n  _.find(\n    {\n      Always: {\n        // A unique id to identify the type, used as the value when communicating with the API.\n        id: 'Always',\n        // What is shown in the UI.\n        label: 'Always Restart',\n        // Description in the UI.\n        description:\n          'If the container restarts for any reason, restart it. ' +\n          'Useful for stateless services that may fail from time to time.',\n        // Default selection for new pods.\n        default: true,\n      },\n      OnFailure: {\n        id: 'OnFailure',\n        label: 'Restart On Failure',\n        description: 'If the container exits with a non-zero status code, restart it.',\n      },\n      Never: {\n        id: 'Never',\n        label: 'Never Restart',\n        description:\n          'Never restart the container. ' +\n          'Useful for containers that exit when they have completed a specific job, like a data import daemon.',\n      },\n    },\n    { id: _.get<any, string>(pod, 'spec.restartPolicy') },\n  );\n\nexport const VolumeSource = {\n  emptyDir: {\n    id: 'emptyDir',\n    label: 'Container Volume',\n    description: \"Temporary directory that shares a pod's lifetime.\",\n  },\n  hostPath: {\n    id: 'hostPath',\n    label: 'Host Directory',\n    description:\n      'Pre-existing host file or directory, ' +\n      'generally for privileged system daemons or other agents tied to the host.',\n  },\n  gitRepo: {\n    id: 'gitRepo',\n    label: 'Git Repo',\n    description: 'Git repository at a particular revision.',\n  },\n  nfs: {\n    id: 'nfs',\n    label: 'NFS',\n    description: 'NFS volume that will be mounted in the host machine.',\n  },\n  secret: {\n    id: 'secret',\n    label: 'Secret',\n    description: 'Secret to populate volume.',\n  },\n  gcePersistentDisk: {\n    id: 'gcePersistentDisk',\n    label: 'GCE Persistent Disk',\n    description: 'GCE disk resource attached to the host machine on demand.',\n  },\n  awsElasticBlockStore: {\n    id: 'awsElasticBlockStore',\n    label: 'AWS Elastic Block Store',\n    description: 'AWS disk resource attached to the host machine on demand.',\n  },\n  glusterfs: {\n    id: 'glusterfs',\n    label: 'Gluster FS',\n    description: 'GlusterFS volume that will be mounted on the host machine.',\n  },\n  iscsi: {\n    id: 'iscsi',\n    label: 'iSCSI',\n    description: 'iSCSI disk attached to host machine on demand',\n  },\n  configMap: {\n    id: 'configMap',\n    label: 'ConfigMap',\n    description: 'ConfigMap to be consumed in volume.',\n  },\n  projected: {\n    id: 'projected',\n    label: 'Projected',\n    description: 'A projected volume maps several existing volume sources into the same directory.',\n  },\n};\n\nexport const getVolumeType = (volume: Volume) => {\n  if (!volume) {\n    return null;\n  }\n  return _.find(VolumeSource, function(v) {\n    return !!volume[v.id];\n  });\n};\n\nconst genericFormatter = (volInfo) => {\n  const keys = Object.keys(volInfo).sort();\n  const parts = keys.map(function(key) {\n    if (key === 'readOnly') {\n      return '';\n    }\n    return volInfo[key];\n  });\n  if (keys.indexOf('readOnly') !== -1) {\n    parts.push(volInfo.readOnly ? 'ro' : 'rw');\n  }\n  return parts.join(' ') || null;\n};\n\nexport const getVolumeLocation = (volume: Volume) => {\n  const vtype = getVolumeType(volume);\n  if (!vtype) {\n    return null;\n  }\n\n  const typeID = vtype.id;\n  const info = volume[typeID];\n  switch (typeID) {\n    // Override any special formatting cases.\n    case VolumeSource.gitRepo.id:\n      return `${info.repository}:${info.revision}`;\n    case VolumeSource.configMap.id:\n    case VolumeSource.emptyDir.id:\n    case VolumeSource.secret.id:\n    case VolumeSource.projected.id:\n      return null;\n    // Defaults to space separated sorted keys.\n    default:\n      return genericFormatter(info);\n  }\n};\n\nexport const getRestartPolicyLabel = (pod: PodKind) => _.get(getRestartPolicy(pod), 'label', '');\n\nexport type PodReadiness = string;\nexport type PodPhase = string;\n\nexport const getVolumeMountPermissions = (v: VolumeMount) => {\n  if (!v) {\n    return null;\n  }\n\n  return v.readOnly ? 'Read-only' : 'Read/Write';\n};\n\nexport const getVolumeMountsByPermissions = (pod: PodKind) => {\n  if (!pod || !pod.spec || !pod.spec.volumes) {\n    return [];\n  }\n  const m = {};\n\n  const volumes = (pod.spec.volumes || []).reduce((p, v: Volume) => {\n    p[v.name] = v;\n    return p;\n  }, {});\n\n  _.forEach(pod.spec.containers, (c: ContainerSpec) => {\n    _.forEach(c.volumeMounts, (v: VolumeMount) => {\n      const k = `${v.name}_${v.readOnly ? 'ro' : 'rw'}`;\n      const mount = { container: c.name, mountPath: v.mountPath, subPath: v.subPath };\n      if (k in m) {\n        return m[k].mounts.push(mount);\n      }\n      m[k] = { mounts: [mount], name: v.name, readOnly: !!v.readOnly, volume: volumes[v.name] };\n    });\n  });\n\n  return _.values(m);\n};\n\nexport const podRestarts = (pod: PodKind): number => {\n  if (!pod || !pod.status) {\n    return 0;\n  }\n  const { initContainerStatuses = [], containerStatuses = [] } = pod.status;\n  const isInitializing = initContainerStatuses.some(({ state }) => {\n    return !state.terminated || state.terminated.exitCode !== 0;\n  });\n  const toCheck = isInitializing ? initContainerStatuses : containerStatuses;\n  return toCheck.reduce(\n    (restartCount, status: ContainerStatus) => restartCount + status.restartCount,\n    0,\n  );\n};\n\nexport const podReadiness = (pod: PodKind): { readyCount: number; totalContainers: number } => {\n  // Don't include init containers in readiness count. This is consistent with the CLI.\n  const containerStatuses = pod?.status?.containerStatuses || [];\n  return containerStatuses.reduce(\n    (acc, { ready }: ContainerStatus) => {\n      if (ready) {\n        acc.readyCount = acc.readyCount + 1;\n      }\n      return acc;\n    },\n    { readyCount: 0, totalContainers: containerStatuses.length },\n  );\n};\n\n// This logic is replicated from k8s (at this writing, Kubernetes 1.17)\n// (See https://github.com/kubernetes/kubernetes/blob/release-1.17/pkg/printers/internalversion/printers.go)\nexport const podPhase = (pod: PodKind): PodPhase => {\n  if (!pod || !pod.status) {\n    return '';\n  }\n\n  if (pod.metadata.deletionTimestamp) {\n    return 'Terminating';\n  }\n\n  if (pod.status.reason === 'NodeLost') {\n    return 'Unknown';\n  }\n\n  if (pod.status.reason === 'Evicted') {\n    return 'Evicted';\n  }\n\n  let initializing = false;\n  let phase = pod.status.phase || pod.status.reason;\n\n  _.each(pod.status.initContainerStatuses, (container: ContainerStatus, i: number) => {\n    const { terminated, waiting } = container.state;\n    if (terminated && terminated.exitCode === 0) {\n      return true;\n    }\n\n    initializing = true;\n    if (terminated && terminated.reason) {\n      phase = `Init:${terminated.reason}`;\n    } else if (terminated && !terminated.reason) {\n      phase = terminated.signal\n        ? `Init:Signal:${terminated.signal}`\n        : `Init:ExitCode:${terminated.exitCode}`;\n    } else if (waiting && waiting.reason && waiting.reason !== 'PodInitializing') {\n      phase = `Init:${waiting.reason}`;\n    } else {\n      phase = `Init:${i}/${pod.status.initContainerStatuses.length}`;\n    }\n    return false;\n  });\n\n  if (!initializing) {\n    let hasRunning = false;\n    const containerStatuses = pod.status.containerStatuses || [];\n    for (let i = containerStatuses.length - 1; i >= 0; i--) {\n      const {\n        state: { running, terminated, waiting },\n        ready,\n      } = containerStatuses[i];\n      if (terminated && terminated.reason) {\n        phase = terminated.reason;\n      } else if (waiting && waiting.reason) {\n        phase = waiting.reason;\n      } else if (waiting && !waiting.reason) {\n        phase = terminated.signal\n          ? `Signal:${terminated.signal}`\n          : `ExitCode:${terminated.exitCode}`;\n      } else if (running && ready) {\n        hasRunning = true;\n      }\n    }\n\n    // Change pod status back to \"Running\" if there is at least one container\n    // still reporting as \"Running\" status.\n    if (phase === 'Completed' && hasRunning) {\n      phase = 'Running';\n    }\n  }\n\n  return phase;\n};\n\nexport const podPhaseFilterReducer = (pod: PodKind): PodPhase => {\n  const status = podPhase(pod);\n  if (status === 'Terminating') {\n    return status;\n  }\n  if (status.includes('CrashLoopBackOff')) {\n    return 'CrashLoopBackOff';\n  }\n  return _.get(pod, 'status.phase', 'Unknown');\n};\n"]}]}