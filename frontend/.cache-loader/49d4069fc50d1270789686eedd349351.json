{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/update-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/update-utils.ts","mtime":1615298458620},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import { getRandomChars } from '@console/shared/src/utils';\nimport { AddNodeDirection } from '../pipeline-topology/const';\nimport { getTaskParameters, getTaskResources } from '../resource-utils';\nimport { TaskErrorType, UpdateOperationType } from './const';\nimport { convertResourceToTask, taskParamIsRequired } from './utils';\nconst mapReplaceRelatedInOthers = (taskName, relatedTaskName, iterationTask) => {\n    var _a;\n    if (!((_a = iterationTask === null || iterationTask === void 0 ? void 0 : iterationTask.runAfter) === null || _a === void 0 ? void 0 : _a.includes(relatedTaskName))) {\n        return iterationTask;\n    }\n    const remainingRunAfters = iterationTask.runAfter.filter((runAfterName) => runAfterName !== relatedTaskName);\n    return Object.assign(Object.assign({}, iterationTask), { runAfter: [...remainingRunAfters, taskName] });\n};\nconst mapRemoveRelatedInOthers = (taskName, iterationTask) => {\n    var _a;\n    if (!((_a = iterationTask === null || iterationTask === void 0 ? void 0 : iterationTask.runAfter) === null || _a === void 0 ? void 0 : _a.includes(taskName))) {\n        return iterationTask;\n    }\n    return Object.assign(Object.assign({}, iterationTask), { runAfter: iterationTask.runAfter.filter((runAfterName) => runAfterName !== taskName) });\n};\nconst mapStitchReplaceInOthers = (removalTask, iterationTask) => {\n    var _a;\n    if (!(removalTask === null || removalTask === void 0 ? void 0 : removalTask.runAfter)) {\n        return mapRemoveRelatedInOthers(removalTask.name, iterationTask);\n    }\n    if (!((_a = iterationTask === null || iterationTask === void 0 ? void 0 : iterationTask.runAfter) === null || _a === void 0 ? void 0 : _a.includes(removalTask.name))) {\n        return iterationTask;\n    }\n    const updatedIterationTask = mapRemoveRelatedInOthers(removalTask.name, iterationTask);\n    if (updatedIterationTask.runAfter.length > 0) {\n        return updatedIterationTask;\n    }\n    return Object.assign(Object.assign({}, updatedIterationTask), { runAfter: removalTask.runAfter });\n};\nconst mapBeRelated = (newTaskName, relatedTaskName, iterationTask) => {\n    if (iterationTask.name !== relatedTaskName) {\n        return iterationTask;\n    }\n    return Object.assign(Object.assign({}, iterationTask), { runAfter: [newTaskName] });\n};\nconst mapAddRelatedToOthers = (taskName, relatedTaskName, iterationTask) => {\n    var _a;\n    if (!((_a = iterationTask === null || iterationTask === void 0 ? void 0 : iterationTask.runAfter) === null || _a === void 0 ? void 0 : _a.includes(relatedTaskName))) {\n        return iterationTask;\n    }\n    return Object.assign(Object.assign({}, iterationTask), { runAfter: [...iterationTask.runAfter, taskName] });\n};\n// TODO: Can we use yup? Do we need this level of checking for errors?\nconst getErrors = (task, resource) => {\n    var _a, _b, _c, _d, _e, _f;\n    const params = getTaskParameters(resource);\n    const resourceParams = params || [];\n    const requiredParamNames = resourceParams.filter(taskParamIsRequired).map((param) => param.name);\n    const hasNonDefaultParams = (_b = (_a = task.params) === null || _a === void 0 ? void 0 : _a.filter(({ name }) => requiredParamNames.includes(name))) === null || _b === void 0 ? void 0 : _b.map(({ value }) => !value).reduce((acc, missingDefault) => missingDefault || acc, false);\n    const needsName = !task.name;\n    const resources = getTaskResources(resource);\n    const taskInputResources = ((_d = (_c = task.resources) === null || _c === void 0 ? void 0 : _c.inputs) === null || _d === void 0 ? void 0 : _d.length) || 0;\n    const requiredInputResources = (resources.inputs || []).filter((r) => !(r === null || r === void 0 ? void 0 : r.optional)).length;\n    const missingInputResources = requiredInputResources - taskInputResources > 0;\n    const taskOutputResources = ((_f = (_e = task.resources) === null || _e === void 0 ? void 0 : _e.outputs) === null || _f === void 0 ? void 0 : _f.length) || 0;\n    const requiredOutputResources = (resources.outputs || []).filter((r) => !(r === null || r === void 0 ? void 0 : r.optional)).length;\n    const missingOutputResources = requiredOutputResources - taskOutputResources > 0;\n    const errorListing = [];\n    if (hasNonDefaultParams) {\n        errorListing.push(TaskErrorType.MISSING_REQUIRED_PARAMS);\n    }\n    if (missingInputResources || missingOutputResources) {\n        errorListing.push(TaskErrorType.MISSING_RESOURCES);\n    }\n    if (needsName) {\n        errorListing.push(TaskErrorType.MISSING_NAME);\n    }\n    return { [task.name]: errorListing.length > 0 ? errorListing : null };\n};\nconst addListNode = (tasks, listTasks, data) => {\n    const { direction, relatedTask } = data;\n    const newTaskName = `${direction}-${getRandomChars(6)}`;\n    const relatedTaskName = relatedTask.name;\n    switch (direction) {\n        case AddNodeDirection.BEFORE:\n            return {\n                tasks: tasks.map((pipelineTask) => mapBeRelated(newTaskName, relatedTaskName, pipelineTask)),\n                listTasks: [\n                    ...listTasks.map((listTask) => mapBeRelated(newTaskName, relatedTaskName, listTask)),\n                    { name: newTaskName, runAfter: relatedTask.runAfter },\n                ],\n            };\n        case AddNodeDirection.AFTER:\n            return {\n                tasks: tasks.map((pipelineTask) => mapReplaceRelatedInOthers(newTaskName, relatedTaskName, pipelineTask)),\n                listTasks: [\n                    ...listTasks.map((listTask) => mapReplaceRelatedInOthers(newTaskName, relatedTaskName, listTask)),\n                    { name: newTaskName, runAfter: [relatedTaskName] },\n                ],\n            };\n        case AddNodeDirection.PARALLEL:\n            return {\n                tasks: tasks.map((pipelineTask) => mapAddRelatedToOthers(newTaskName, relatedTaskName, pipelineTask)),\n                listTasks: [\n                    ...listTasks.map((listTask) => mapAddRelatedToOthers(newTaskName, relatedTaskName, listTask)),\n                    { name: newTaskName, runAfter: relatedTask.runAfter },\n                ],\n            };\n        default:\n            throw new Error(`Invalid direction ${direction}`);\n    }\n};\nconst convertListToTask = (tasks, listTasks, data) => {\n    const { name, resource, runAfter } = data;\n    const newPipelineTask = convertResourceToTask(resource, runAfter);\n    return {\n        tasks: [\n            ...tasks.map((pipelineTask) => mapReplaceRelatedInOthers(newPipelineTask.name, name, pipelineTask)),\n            newPipelineTask,\n        ],\n        listTasks: listTasks\n            .filter((n) => n.name !== name)\n            .map((listTask) => mapReplaceRelatedInOthers(newPipelineTask.name, name, listTask)),\n        errors: getErrors(newPipelineTask, resource),\n    };\n};\nconst removeAndUpdateTasks = (removalTaskName, updateAndRemoveTasks, updateOnlyTasks) => {\n    const removalTask = updateAndRemoveTasks.find((task) => task.name === removalTaskName);\n    return {\n        updateOnlyTasks: updateOnlyTasks.map((task) => mapStitchReplaceInOthers(removalTask, task)),\n        updateAndRemoveTasks: updateAndRemoveTasks\n            .filter((task) => task.name !== removalTaskName)\n            .map((task) => mapStitchReplaceInOthers(removalTask, task)),\n    };\n};\nconst deleteListTask = (tasks, listTasks, data) => {\n    const { listTaskName } = data;\n    const { updateOnlyTasks, updateAndRemoveTasks } = removeAndUpdateTasks(listTaskName, listTasks, tasks);\n    return {\n        tasks: updateOnlyTasks,\n        listTasks: updateAndRemoveTasks,\n        errors: null,\n    };\n};\nexport const removeTask = (tasks, listTasks, data) => {\n    const { taskName } = data;\n    const { updateOnlyTasks, updateAndRemoveTasks } = removeAndUpdateTasks(taskName, tasks, listTasks);\n    return {\n        tasks: updateAndRemoveTasks,\n        listTasks: updateOnlyTasks,\n        errors: { [taskName]: null },\n    };\n};\nconst applyResourceUpdate = (pipelineTask, resources) => {\n    var _a;\n    const { resourceTarget, selectedPipelineResource, taskResourceName } = resources;\n    const existingResources = ((_a = pipelineTask.resources) === null || _a === void 0 ? void 0 : _a[resourceTarget]) || [];\n    const filteredResources = existingResources.filter((resource) => {\n        return resource.name !== taskResourceName;\n    });\n    return Object.assign(Object.assign({}, pipelineTask), { resources: Object.assign(Object.assign({}, pipelineTask.resources), { [resourceTarget]: [\n                ...filteredResources,\n                {\n                    name: taskResourceName,\n                    resource: selectedPipelineResource.name,\n                },\n            ] }) });\n};\nconst applyParamsUpdate = (pipelineTask, params) => {\n    const { newValue, taskParamName } = params;\n    return Object.assign(Object.assign({}, pipelineTask), { params: pipelineTask.params.map((param) => {\n            if (param.name !== taskParamName) {\n                return param;\n            }\n            return Object.assign(Object.assign({}, param), { value: newValue });\n        }) });\n};\nconst updateTask = (tasks, listTasks, data) => {\n    const { thisPipelineTask, taskResource, newName, params, resources } = data;\n    const canRename = !!newName;\n    const updatedResourceIndex = tasks.findIndex((pipelineTask) => pipelineTask.name === thisPipelineTask.name);\n    const updatedTasks = tasks.map((pipelineTask) => {\n        if (pipelineTask.name !== thisPipelineTask.name) {\n            if (canRename) {\n                return mapReplaceRelatedInOthers(newName, thisPipelineTask.name, pipelineTask);\n            }\n            return pipelineTask;\n        }\n        let updatedResource = pipelineTask;\n        if (resources) {\n            updatedResource = applyResourceUpdate(updatedResource, resources);\n        }\n        if (params) {\n            updatedResource = applyParamsUpdate(updatedResource, params);\n        }\n        if (canRename) {\n            updatedResource = Object.assign(Object.assign({}, updatedResource), { name: newName });\n        }\n        return updatedResource;\n    });\n    const updatedResource = updatedTasks[updatedResourceIndex];\n    return {\n        tasks: updatedTasks,\n        listTasks: canRename\n            ? listTasks.map((listTask) => mapReplaceRelatedInOthers(newName, thisPipelineTask.name, listTask))\n            : listTasks,\n        errors: Object.assign({ [thisPipelineTask.name]: null }, getErrors(updatedResource, taskResource)),\n    };\n};\nconst fixInvalidListTask = (tasks, listTasks, data) => {\n    const { existingName, resource, runAfter } = data;\n    const newPipelineTask = convertResourceToTask(resource, runAfter);\n    return {\n        tasks: [\n            ...tasks\n                .filter((pipelineTask) => pipelineTask.name !== existingName)\n                .map((pipelineTask) => mapReplaceRelatedInOthers(newPipelineTask.name, existingName, pipelineTask)),\n            newPipelineTask,\n        ],\n        listTasks,\n        errors: getErrors(newPipelineTask, resource),\n    };\n};\nexport const applyChange = (taskGroup, op) => {\n    const { type, data } = op;\n    const { tasks, listTasks } = taskGroup;\n    switch (type) {\n        case UpdateOperationType.ADD_LIST_TASK:\n            return addListNode(tasks, listTasks, data);\n        case UpdateOperationType.CONVERT_LIST_TO_TASK:\n            return convertListToTask(tasks, listTasks, data);\n        case UpdateOperationType.DELETE_LIST_TASK:\n            return deleteListTask(tasks, listTasks, data);\n        case UpdateOperationType.REMOVE_TASK:\n            return removeTask(tasks, listTasks, data);\n        case UpdateOperationType.UPDATE_TASK:\n            return updateTask(tasks, listTasks, data);\n        case UpdateOperationType.FIX_INVALID_LIST_TASK:\n            return fixInvalidListTask(tasks, listTasks, data);\n        default:\n            throw new Error(`Invalid update operation ${type}`);\n    }\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/update-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/update-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { getRandomChars } from '@console/shared/src/utils';\nimport {\n  PipelineResourceTask,\n  PipelineTask,\n  PipelineTaskParam,\n  PipelineTaskResource,\n} from '../../../utils/pipeline-augment';\nimport { AddNodeDirection } from '../pipeline-topology/const';\nimport { getTaskParameters, getTaskResources } from '../resource-utils';\nimport { TaskErrorType, UpdateOperationType } from './const';\nimport {\n  CleanupResults,\n  PipelineBuilderListTask,\n  PipelineBuilderTaskBase,\n  PipelineBuilderTaskGroup,\n  TaskErrorMap,\n  UpdateOperation,\n  UpdateOperationAction,\n  UpdateOperationAddData,\n  UpdateOperationConvertToTaskData,\n  UpdateOperationDeleteListTaskData,\n  UpdateOperationFixInvalidTaskListData,\n  UpdateOperationRemoveTaskData,\n  UpdateOperationUpdateTaskData,\n  UpdateTaskParamData,\n  UpdateTaskResourceData,\n} from './types';\nimport { convertResourceToTask, taskParamIsRequired } from './utils';\n\nconst mapReplaceRelatedInOthers = <TaskType extends PipelineBuilderTaskBase>(\n  taskName: string,\n  relatedTaskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!iterationTask?.runAfter?.includes(relatedTaskName)) {\n    return iterationTask;\n  }\n\n  const remainingRunAfters = iterationTask.runAfter.filter(\n    (runAfterName) => runAfterName !== relatedTaskName,\n  );\n\n  return {\n    ...iterationTask,\n    runAfter: [...remainingRunAfters, taskName],\n  };\n};\n\nconst mapRemoveRelatedInOthers = <TaskType extends PipelineBuilderTaskBase>(\n  taskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!iterationTask?.runAfter?.includes(taskName)) {\n    return iterationTask;\n  }\n\n  return {\n    ...iterationTask,\n    runAfter: iterationTask.runAfter.filter((runAfterName) => runAfterName !== taskName),\n  };\n};\n\nconst mapStitchReplaceInOthers = <TaskType extends PipelineBuilderTaskBase>(\n  removalTask: PipelineBuilderTaskBase,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!removalTask?.runAfter) {\n    return mapRemoveRelatedInOthers<TaskType>(removalTask.name, iterationTask);\n  }\n  if (!iterationTask?.runAfter?.includes(removalTask.name)) {\n    return iterationTask;\n  }\n\n  const updatedIterationTask = mapRemoveRelatedInOthers(removalTask.name, iterationTask);\n  if (updatedIterationTask.runAfter.length > 0) {\n    return updatedIterationTask;\n  }\n\n  return {\n    ...updatedIterationTask,\n    runAfter: removalTask.runAfter,\n  };\n};\n\nconst mapBeRelated = <TaskType extends PipelineBuilderTaskBase>(\n  newTaskName: string,\n  relatedTaskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (iterationTask.name !== relatedTaskName) {\n    return iterationTask;\n  }\n\n  return {\n    ...iterationTask,\n    runAfter: [newTaskName],\n  };\n};\n\nconst mapAddRelatedToOthers = <TaskType extends PipelineBuilderTaskBase>(\n  taskName: string,\n  relatedTaskName: string,\n  iterationTask: TaskType,\n): TaskType => {\n  if (!iterationTask?.runAfter?.includes(relatedTaskName)) {\n    return iterationTask;\n  }\n\n  return {\n    ...iterationTask,\n    runAfter: [...iterationTask.runAfter, taskName],\n  };\n};\n\n// TODO: Can we use yup? Do we need this level of checking for errors?\nconst getErrors = (task: PipelineTask, resource: PipelineResourceTask): TaskErrorMap => {\n  const params = getTaskParameters(resource);\n  const resourceParams = params || [];\n  const requiredParamNames = resourceParams.filter(taskParamIsRequired).map((param) => param.name);\n  const hasNonDefaultParams = task.params\n    ?.filter(({ name }) => requiredParamNames.includes(name))\n    ?.map(({ value }) => !value)\n    .reduce((acc, missingDefault) => missingDefault || acc, false);\n\n  const needsName = !task.name;\n\n  const resources = getTaskResources(resource);\n\n  const taskInputResources = task.resources?.inputs?.length || 0;\n  const requiredInputResources = (resources.inputs || []).filter((r) => !r?.optional).length;\n  const missingInputResources = requiredInputResources - taskInputResources > 0;\n\n  const taskOutputResources = task.resources?.outputs?.length || 0;\n  const requiredOutputResources = (resources.outputs || []).filter((r) => !r?.optional).length;\n  const missingOutputResources = requiredOutputResources - taskOutputResources > 0;\n\n  const errorListing: TaskErrorType[] = [];\n  if (hasNonDefaultParams) {\n    errorListing.push(TaskErrorType.MISSING_REQUIRED_PARAMS);\n  }\n  if (missingInputResources || missingOutputResources) {\n    errorListing.push(TaskErrorType.MISSING_RESOURCES);\n  }\n  if (needsName) {\n    errorListing.push(TaskErrorType.MISSING_NAME);\n  }\n\n  return { [task.name]: errorListing.length > 0 ? errorListing : null };\n};\n\nconst addListNode: UpdateOperationAction<UpdateOperationAddData> = (tasks, listTasks, data) => {\n  const { direction, relatedTask } = data;\n\n  const newTaskName = `${direction}-${getRandomChars(6)}`;\n  const relatedTaskName = relatedTask.name;\n\n  switch (direction) {\n    case AddNodeDirection.BEFORE:\n      return {\n        tasks: tasks.map((pipelineTask) =>\n          mapBeRelated<PipelineTask>(newTaskName, relatedTaskName, pipelineTask),\n        ),\n        listTasks: [\n          ...listTasks.map((listTask) =>\n            mapBeRelated<PipelineBuilderListTask>(newTaskName, relatedTaskName, listTask),\n          ),\n          { name: newTaskName, runAfter: relatedTask.runAfter },\n        ],\n      };\n    case AddNodeDirection.AFTER:\n      return {\n        tasks: tasks.map((pipelineTask) =>\n          mapReplaceRelatedInOthers<PipelineTask>(newTaskName, relatedTaskName, pipelineTask),\n        ),\n        listTasks: [\n          ...listTasks.map((listTask) =>\n            mapReplaceRelatedInOthers<PipelineBuilderListTask>(\n              newTaskName,\n              relatedTaskName,\n              listTask,\n            ),\n          ),\n          { name: newTaskName, runAfter: [relatedTaskName] },\n        ],\n      };\n    case AddNodeDirection.PARALLEL:\n      return {\n        tasks: tasks.map((pipelineTask) =>\n          mapAddRelatedToOthers<PipelineTask>(newTaskName, relatedTaskName, pipelineTask),\n        ),\n        listTasks: [\n          ...listTasks.map((listTask) =>\n            mapAddRelatedToOthers<PipelineBuilderListTask>(newTaskName, relatedTaskName, listTask),\n          ),\n          { name: newTaskName, runAfter: relatedTask.runAfter },\n        ],\n      };\n    default:\n      throw new Error(`Invalid direction ${direction}`);\n  }\n};\n\nconst convertListToTask: UpdateOperationAction<UpdateOperationConvertToTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { name, resource, runAfter } = data;\n\n  const newPipelineTask: PipelineTask = convertResourceToTask(resource, runAfter);\n\n  return {\n    tasks: [\n      ...tasks.map((pipelineTask) =>\n        mapReplaceRelatedInOthers(newPipelineTask.name, name, pipelineTask),\n      ),\n      newPipelineTask,\n    ],\n    listTasks: listTasks\n      .filter((n) => n.name !== name)\n      .map((listTask) => mapReplaceRelatedInOthers(newPipelineTask.name, name, listTask)),\n    errors: getErrors(newPipelineTask, resource),\n  };\n};\n\nconst removeAndUpdateTasks = <\n  URT extends PipelineBuilderTaskBase,\n  UT extends PipelineBuilderTaskBase\n>(\n  removalTaskName: string,\n  updateAndRemoveTasks: URT[],\n  updateOnlyTasks: UT[],\n): { updateOnlyTasks: UT[]; updateAndRemoveTasks: URT[] } => {\n  const removalTask = updateAndRemoveTasks.find((task) => task.name === removalTaskName);\n  return {\n    updateOnlyTasks: updateOnlyTasks.map((task) => mapStitchReplaceInOthers<UT>(removalTask, task)),\n    updateAndRemoveTasks: updateAndRemoveTasks\n      .filter((task) => task.name !== removalTaskName)\n      .map((task) => mapStitchReplaceInOthers<URT>(removalTask, task)),\n  };\n};\n\nconst deleteListTask: UpdateOperationAction<UpdateOperationDeleteListTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { listTaskName } = data;\n\n  const { updateOnlyTasks, updateAndRemoveTasks } = removeAndUpdateTasks<\n    PipelineBuilderListTask,\n    PipelineTask\n  >(listTaskName, listTasks, tasks);\n  return {\n    tasks: updateOnlyTasks,\n    listTasks: updateAndRemoveTasks,\n    errors: null,\n  };\n};\n\nexport const removeTask: UpdateOperationAction<UpdateOperationRemoveTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { taskName } = data;\n\n  const { updateOnlyTasks, updateAndRemoveTasks } = removeAndUpdateTasks<\n    PipelineTask,\n    PipelineBuilderListTask\n  >(taskName, tasks, listTasks);\n  return {\n    tasks: updateAndRemoveTasks,\n    listTasks: updateOnlyTasks,\n    errors: { [taskName]: null },\n  };\n};\n\nconst applyResourceUpdate = (\n  pipelineTask: PipelineTask,\n  resources: UpdateTaskResourceData,\n): PipelineTask => {\n  const { resourceTarget, selectedPipelineResource, taskResourceName } = resources;\n\n  const existingResources: PipelineTaskResource[] = pipelineTask.resources?.[resourceTarget] || [];\n  const filteredResources = existingResources.filter((resource: PipelineTaskResource) => {\n    return resource.name !== taskResourceName;\n  });\n\n  return {\n    ...pipelineTask,\n    resources: {\n      ...pipelineTask.resources,\n      [resourceTarget]: [\n        ...filteredResources,\n        {\n          name: taskResourceName,\n          resource: selectedPipelineResource.name,\n        },\n      ],\n    },\n  };\n};\n\nconst applyParamsUpdate = (\n  pipelineTask: PipelineTask,\n  params: UpdateTaskParamData,\n): PipelineTask => {\n  const { newValue, taskParamName } = params;\n\n  return {\n    ...pipelineTask,\n    params: pipelineTask.params.map(\n      (param): PipelineTaskParam => {\n        if (param.name !== taskParamName) {\n          return param;\n        }\n\n        return {\n          ...param,\n          value: newValue,\n        };\n      },\n    ),\n  };\n};\n\nconst updateTask: UpdateOperationAction<UpdateOperationUpdateTaskData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { thisPipelineTask, taskResource, newName, params, resources } = data;\n\n  const canRename = !!newName;\n\n  const updatedResourceIndex = tasks.findIndex(\n    (pipelineTask) => pipelineTask.name === thisPipelineTask.name,\n  );\n  const updatedTasks = tasks.map((pipelineTask) => {\n    if (pipelineTask.name !== thisPipelineTask.name) {\n      if (canRename) {\n        return mapReplaceRelatedInOthers(newName, thisPipelineTask.name, pipelineTask);\n      }\n      return pipelineTask;\n    }\n\n    let updatedResource = pipelineTask;\n    if (resources) {\n      updatedResource = applyResourceUpdate(updatedResource, resources);\n    }\n    if (params) {\n      updatedResource = applyParamsUpdate(updatedResource, params);\n    }\n    if (canRename) {\n      updatedResource = {\n        ...updatedResource,\n        name: newName,\n      };\n    }\n\n    return updatedResource;\n  });\n  const updatedResource = updatedTasks[updatedResourceIndex];\n\n  return {\n    tasks: updatedTasks,\n    listTasks: canRename\n      ? listTasks.map((listTask) =>\n          mapReplaceRelatedInOthers(newName, thisPipelineTask.name, listTask),\n        )\n      : listTasks,\n    errors: {\n      [thisPipelineTask.name]: null,\n      ...getErrors(updatedResource, taskResource),\n    },\n  };\n};\n\nconst fixInvalidListTask: UpdateOperationAction<UpdateOperationFixInvalidTaskListData> = (\n  tasks,\n  listTasks,\n  data,\n) => {\n  const { existingName, resource, runAfter } = data;\n\n  const newPipelineTask: PipelineTask = convertResourceToTask(resource, runAfter);\n\n  return {\n    tasks: [\n      ...tasks\n        .filter((pipelineTask) => pipelineTask.name !== existingName)\n        .map((pipelineTask) =>\n          mapReplaceRelatedInOthers(newPipelineTask.name, existingName, pipelineTask),\n        ),\n      newPipelineTask,\n    ],\n    listTasks,\n    errors: getErrors(newPipelineTask, resource),\n  };\n};\n\nexport const applyChange = (\n  taskGroup: PipelineBuilderTaskGroup,\n  op: UpdateOperation,\n): CleanupResults => {\n  const { type, data } = op;\n  const { tasks, listTasks } = taskGroup;\n\n  switch (type) {\n    case UpdateOperationType.ADD_LIST_TASK:\n      return addListNode(tasks, listTasks, data as UpdateOperationAddData);\n    case UpdateOperationType.CONVERT_LIST_TO_TASK:\n      return convertListToTask(tasks, listTasks, data as UpdateOperationConvertToTaskData);\n    case UpdateOperationType.DELETE_LIST_TASK:\n      return deleteListTask(tasks, listTasks, data as UpdateOperationDeleteListTaskData);\n    case UpdateOperationType.REMOVE_TASK:\n      return removeTask(tasks, listTasks, data as UpdateOperationRemoveTaskData);\n    case UpdateOperationType.UPDATE_TASK:\n      return updateTask(tasks, listTasks, data as UpdateOperationUpdateTaskData);\n    case UpdateOperationType.FIX_INVALID_LIST_TASK:\n      return fixInvalidListTask(tasks, listTasks, data as UpdateOperationFixInvalidTaskListData);\n    default:\n      throw new Error(`Invalid update operation ${type}`);\n  }\n};\n"]}]}