{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/data-transformer.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/data-transformer.ts","mtime":1617154808370},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nimport { isGroupVersionKind, kindForReference, apiVersionForReference } from '@console/internal/module/k8s';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { getKnativeTopologyDataModel } from '@console/knative-plugin/src/topology/data-transformer';\nimport { getKubevirtTopologyDataModel, kubevirtAllowedResources } from '@console/kubevirt-plugin/src/topology/kubevirt-data-transformer';\nimport { TYPE_TRAFFIC_CONNECTOR, TYPE_WORKLOAD } from '../components/const';\nimport { allowedResources } from '../topology-utils';\nimport { addToTopologyDataModel, createInstanceForResource, createTopologyNodeData, getTopologyEdgeItems, getTopologyGroupItems, getTopologyNodeItem, mergeGroup } from './transform-utils';\nimport { getOperatorTopologyDataModel } from '../operators/operators-data-transformer';\nimport { getHelmTopologyDataModel } from '../helm/helm-data-transformer';\nexport const getFilteredTrafficWorkload = (nodes) => nodes.filter(({ data }) => data.nodeType === TYPE_WORKLOAD);\nexport const getTrafficConnectors = (trafficData, resources) => {\n    const filteredWorkload = getFilteredTrafficWorkload(trafficData.nodes);\n    return trafficData.edges.reduce((acc, { data }) => {\n        const { data: sourceTrafficNode } = filteredWorkload.find(wrkld => wrkld.data.id === data.source);\n        const { data: targetTrafficNode } = filteredWorkload.find(wrkld => wrkld.data.id === data.target);\n        const sourceResourceNode = resources.find(res => {\n            return res.metadata.name === sourceTrafficNode[sourceTrafficNode.nodeType];\n        });\n        const targetResourceNode = resources.find(res => res.metadata.name === targetTrafficNode[targetTrafficNode.nodeType]);\n        return sourceResourceNode && targetResourceNode\n            ? [\n                ...acc,\n                {\n                    id: `${sourceResourceNode.metadata.uid}_${targetResourceNode.metadata.uid}`,\n                    type: TYPE_TRAFFIC_CONNECTOR,\n                    source: sourceResourceNode.metadata.uid,\n                    target: targetResourceNode.metadata.uid,\n                    data: data.traffic,\n                },\n            ]\n            : acc;\n    }, []);\n};\nconst getBaseTopologyDataModel = (resources, allResources, installedOperators, utils, transformBy, serviceBindingRequests) => {\n    const baseDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n    };\n    const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n    _.forEach(transformBy, key => {\n        if (!_.isEmpty(resources[key].data)) {\n            const typedDataModel = {\n                graph: { nodes: [], edges: [], groups: [] },\n                topology: {},\n            };\n            transformResourceData[key](resources[key].data).forEach(item => {\n                const { obj: deploymentConfig } = item;\n                const uid = _.get(deploymentConfig, ['metadata', 'uid']);\n                typedDataModel.topology[uid] = createTopologyNodeData(item, TYPE_WORKLOAD, getImageForIconClass(`icon-openshift`));\n                typedDataModel.graph.nodes.push(getTopologyNodeItem(deploymentConfig, TYPE_WORKLOAD));\n                typedDataModel.graph.edges.push(...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests));\n                mergeGroup(getTopologyGroupItems(deploymentConfig), typedDataModel.graph.groups);\n            });\n            addToTopologyDataModel(typedDataModel, baseDataModel);\n        }\n    });\n    return baseDataModel;\n};\n/**\n * Tranforms the k8s resources objects into topology data\n */\nexport const transformTopologyData = (resources, transformBy, utils, trafficData, helmResourcesMap) => {\n    const installedOperators = _.get(resources, 'clusterServiceVersions.data');\n    const serviceBindingRequests = _.get(resources, 'serviceBindingRequests.data');\n    const topologyGraphAndNodeData = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n    };\n    // TODO: plugin\n    const allResourceTypes = [...allowedResources, ...kubevirtAllowedResources];\n    const allResourcesList = _.flatten(allResourceTypes.map(resourceKind => {\n        return resources[resourceKind]\n            ? resources[resourceKind].data.map(res => {\n                const resKind = resources[resourceKind].kind;\n                let kind = resKind;\n                let apiVersion;\n                if (resKind && isGroupVersionKind(resKind)) {\n                    kind = kindForReference(resKind);\n                    apiVersion = apiVersionForReference(resKind);\n                }\n                return Object.assign({ kind,\n                    apiVersion }, res);\n            })\n            : [];\n    }));\n    if (trafficData) {\n        topologyGraphAndNodeData.graph.edges = getTrafficConnectors(trafficData, allResourcesList);\n    }\n    // Copy the resources into a mutable list of resources, we don't want to effect the incoming lists\n    const dataResources = Object.keys(resources).reduce((obj, key) => {\n        obj[key] = Object.assign(Object.assign({}, resources[key]), { data: [...resources[key].data] });\n        return obj;\n    }, {});\n    // TODO: plugins\n    const knativeModel = getKnativeTopologyDataModel(dataResources, allResourcesList, installedOperators, utils);\n    addToTopologyDataModel(knativeModel, topologyGraphAndNodeData);\n    const operatorsModel = getOperatorTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n    addToTopologyDataModel(operatorsModel, topologyGraphAndNodeData);\n    const helmModel = getHelmTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests, helmResourcesMap);\n    addToTopologyDataModel(helmModel, topologyGraphAndNodeData);\n    const vmsModel = getKubevirtTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n    addToTopologyDataModel(vmsModel, topologyGraphAndNodeData);\n    const baseModel = getBaseTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n    addToTopologyDataModel(baseModel, topologyGraphAndNodeData);\n    return topologyGraphAndNodeData;\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/data-transformer.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/data-transformer.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { K8sResourceKind, isGroupVersionKind, kindForReference, apiVersionForReference } from '@console/internal/module/k8s';\nimport { getImageForIconClass } from '@console/internal/components/catalog/catalog-item-icon';\nimport { getKnativeTopologyDataModel } from '@console/knative-plugin/src/topology/data-transformer';\nimport { getKubevirtTopologyDataModel, kubevirtAllowedResources } from '@console/kubevirt-plugin/src/topology/kubevirt-data-transformer';\nimport { TopologyDataModel, TopologyDataResources, Edge, TrafficData, KialiNode } from '../topology-types';\nimport { TYPE_TRAFFIC_CONNECTOR, TYPE_WORKLOAD } from '../components/const';\nimport { HelmReleaseResourcesMap } from '../../helm/helm-types';\nimport { allowedResources } from '../topology-utils';\nimport { addToTopologyDataModel, createInstanceForResource, createTopologyNodeData, getTopologyEdgeItems, getTopologyGroupItems, getTopologyNodeItem, mergeGroup } from './transform-utils';\nimport { getOperatorTopologyDataModel } from '../operators/operators-data-transformer';\nimport { getHelmTopologyDataModel } from '../helm/helm-data-transformer';\n\nexport const getFilteredTrafficWorkload = (nodes: KialiNode[]): KialiNode[] => nodes.filter(({ data }) => data.nodeType === TYPE_WORKLOAD);\n\nexport const getTrafficConnectors = (trafficData: TrafficData, resources: K8sResourceKind[]): Edge[] => {\n  const filteredWorkload = getFilteredTrafficWorkload(trafficData.nodes);\n  return trafficData.edges.reduce((acc, { data }) => {\n    const { data: sourceTrafficNode } = filteredWorkload.find(wrkld => wrkld.data.id === data.source);\n    const { data: targetTrafficNode } = filteredWorkload.find(wrkld => wrkld.data.id === data.target);\n    const sourceResourceNode = resources.find(res => {\n      return res.metadata.name === sourceTrafficNode[sourceTrafficNode.nodeType];\n    });\n    const targetResourceNode = resources.find(res => res.metadata.name === targetTrafficNode[targetTrafficNode.nodeType]);\n    return sourceResourceNode && targetResourceNode\n      ? [\n          ...acc,\n          {\n            id: `${sourceResourceNode.metadata.uid}_${targetResourceNode.metadata.uid}`,\n            type: TYPE_TRAFFIC_CONNECTOR,\n            source: sourceResourceNode.metadata.uid,\n            target: targetResourceNode.metadata.uid,\n            data: data.traffic,\n          },\n        ]\n      : acc;\n  }, []);\n};\n\nconst getBaseTopologyDataModel = (resources: TopologyDataResources, allResources: K8sResourceKind[], installedOperators, utils: Function[], transformBy: string[], serviceBindingRequests: K8sResourceKind[]): TopologyDataModel => {\n  const baseDataModel: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  const transformResourceData = createInstanceForResource(resources, utils, installedOperators);\n\n  _.forEach(transformBy, key => {\n    if (!_.isEmpty(resources[key].data)) {\n      const typedDataModel: TopologyDataModel = {\n        graph: { nodes: [], edges: [], groups: [] },\n        topology: {},\n      };\n\n      transformResourceData[key](resources[key].data).forEach(item => {\n        const { obj: deploymentConfig } = item;\n        const uid = _.get(deploymentConfig, ['metadata', 'uid']);\n        typedDataModel.topology[uid] = createTopologyNodeData(item, TYPE_WORKLOAD, getImageForIconClass(`icon-openshift`));\n        typedDataModel.graph.nodes.push(getTopologyNodeItem(deploymentConfig, TYPE_WORKLOAD));\n        typedDataModel.graph.edges.push(...getTopologyEdgeItems(deploymentConfig, allResources, serviceBindingRequests));\n        mergeGroup(getTopologyGroupItems(deploymentConfig), typedDataModel.graph.groups);\n      });\n      addToTopologyDataModel(typedDataModel, baseDataModel);\n    }\n  });\n  return baseDataModel;\n};\n\n/**\n * Tranforms the k8s resources objects into topology data\n */\nexport const transformTopologyData = (resources: TopologyDataResources, transformBy: string[], utils?: Function[], trafficData?: TrafficData, helmResourcesMap?: HelmReleaseResourcesMap): TopologyDataModel => {\n  const installedOperators = _.get(resources, 'clusterServiceVersions.data');\n  const serviceBindingRequests = _.get(resources, 'serviceBindingRequests.data');\n  const topologyGraphAndNodeData: TopologyDataModel = {\n    graph: { nodes: [], edges: [], groups: [] },\n    topology: {},\n  };\n  // TODO: plugin\n  const allResourceTypes = [...allowedResources, ...kubevirtAllowedResources];\n  const allResourcesList = _.flatten(\n    allResourceTypes.map(resourceKind => {\n      return resources[resourceKind]\n        ? resources[resourceKind].data.map(res => {\n            const resKind = resources[resourceKind].kind;\n            let kind = resKind;\n            let apiVersion;\n            if (resKind && isGroupVersionKind(resKind)) {\n              kind = kindForReference(resKind);\n              apiVersion = apiVersionForReference(resKind);\n            }\n            return {\n              kind,\n              apiVersion,\n              ...res,\n            };\n          })\n        : [];\n    }),\n  );\n  if (trafficData) {\n    topologyGraphAndNodeData.graph.edges = getTrafficConnectors(trafficData, allResourcesList);\n  }\n\n  // Copy the resources into a mutable list of resources, we don't want to effect the incoming lists\n  const dataResources: TopologyDataResources = Object.keys(resources).reduce((obj, key) => {\n    obj[key] = {\n      ...resources[key],\n      data: [...resources[key].data],\n    };\n    return obj;\n  }, {} as TopologyDataResources);\n\n  // TODO: plugins\n  const knativeModel = getKnativeTopologyDataModel(dataResources, allResourcesList, installedOperators, utils);\n  addToTopologyDataModel(knativeModel, topologyGraphAndNodeData);\n\n  const operatorsModel = getOperatorTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n  addToTopologyDataModel(operatorsModel, topologyGraphAndNodeData);\n\n  const helmModel = getHelmTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests, helmResourcesMap);\n  addToTopologyDataModel(helmModel, topologyGraphAndNodeData);\n\n  const vmsModel = getKubevirtTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n  addToTopologyDataModel(vmsModel, topologyGraphAndNodeData);\n\n  const baseModel = getBaseTopologyDataModel(dataResources, allResourcesList, installedOperators, utils, transformBy, serviceBindingRequests);\n  addToTopologyDataModel(baseModel, topologyGraphAndNodeData);\n\n  return topologyGraphAndNodeData;\n};\n"]}]}