{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrag.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrag.tsx","mtime":1615298458710},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as React from 'react';\nimport * as d3 from 'd3';\nimport { action, computed, comparer, flow } from 'mobx';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport useCallbackRef from '../utils/useCallbackRef';\nimport { useDndManager } from './useDndManager';\nexport const Modifiers = {\n    DEFAULT: 0,\n    ALT: 0x01,\n    CTRL: 0x02,\n    META: 0x04,\n    SHIFT: 0x08,\n};\nconst getModifiers = (event) => {\n    let modifiers = Modifiers.DEFAULT;\n    if (event.altKey) {\n        // eslint-disable-next-line no-bitwise\n        modifiers |= Modifiers.ALT;\n    }\n    if (event.ctrlKey) {\n        // eslint-disable-next-line no-bitwise\n        modifiers |= Modifiers.CTRL;\n    }\n    if (event.metaKey) {\n        // eslint-disable-next-line no-bitwise\n        modifiers |= Modifiers.META;\n    }\n    if (event.shiftKey) {\n        // eslint-disable-next-line no-bitwise\n        modifiers |= Modifiers.SHIFT;\n    }\n    return modifiers;\n};\nconst getOperation = (operation) => {\n    if (!operation) {\n        return undefined;\n    }\n    if (operation.hasOwnProperty('type')) {\n        return operation;\n    }\n    return (operation[getModifiers((d3.event && d3.event.sourceEvent) || d3.event)] ||\n        operation[Modifiers.DEFAULT]);\n};\nconst hasOperation = (operation) => {\n    return !!(operation && (operation.hasOwnProperty('type') || Object.keys(operation).length > 0));\n};\nconst EMPTY_PROPS = Object.freeze({});\nexport const useDndDrag = (spec, props) => {\n    const specRef = React.useRef(spec);\n    specRef.current = spec;\n    const propsRef = React.useRef(props != null ? props : EMPTY_PROPS);\n    propsRef.current = props != null ? props : EMPTY_PROPS;\n    const dndManager = useDndManager();\n    const element = React.useContext(ElementContext);\n    const elementRef = React.useRef(element);\n    elementRef.current = element;\n    const idRef = React.useRef();\n    // source monitor\n    const monitor = React.useMemo(() => {\n        const sourceMonitor = {\n            getHandlerId: () => {\n                return idRef.current;\n            },\n            receiveHandlerId: (sourceId) => {\n                idRef.current = sourceId;\n            },\n            getDropHints: () => {\n                return dndManager.getDropHints();\n            },\n            canDrag: () => {\n                return dndManager.canDragSource(idRef.current);\n            },\n            isDragging: () => {\n                return dndManager.isDraggingSource(idRef.current);\n            },\n            getItemType: () => {\n                return dndManager.getItemType();\n            },\n            getItem: () => {\n                return dndManager.getItem();\n            },\n            getDropResult: () => {\n                return dndManager.getDropResult();\n            },\n            didDrop: () => {\n                return dndManager.didDrop();\n            },\n            getDragEvent: () => {\n                return dndManager.getDragEvent();\n            },\n            getOperation: () => {\n                return dndManager.getOperation();\n            },\n            isCancelled: () => {\n                return dndManager.isCancelled();\n            },\n        };\n        return sourceMonitor;\n    }, [dndManager]);\n    const refCallback = useCallbackRef(React.useCallback((node) => {\n        if (node) {\n            let operationChangeEvents;\n            let operation;\n            d3.select(node).call(d3\n                .drag()\n                .container(\n            // TODO bridge the gap between scene tree and dom tree\n            () => d3\n                .select(node.ownerSVGElement)\n                .select('[data-surface=\"true\"]')\n                .node())\n                .on('start', function () {\n                operation =\n                    typeof specRef.current.operation === 'function'\n                        ? specRef.current.operation(monitor, propsRef.current)\n                        : specRef.current.operation;\n                const updateOperation = () => __awaiter(this, void 0, void 0, function* () {\n                    if (operation && idRef.current) {\n                        const op = getOperation(operation);\n                        if (dndManager.getOperation() !== op) {\n                            // restart the drag with the new operation\n                            if (dndManager.isDragging()) {\n                                // copy the event otherwise it will be mutated by #cancel()\n                                const event = Object.assign({}, dndManager.getDragEvent());\n                                const cancelled = dndManager.cancel();\n                                operationChangeEvents = {\n                                    begin: [\n                                        cancelled ? event.initialX : event.x,\n                                        cancelled ? event.initialY : event.y,\n                                        cancelled ? event.initialPageX : event.pageX,\n                                        cancelled ? event.initialPageY : event.pageY,\n                                    ],\n                                    drag: [event.x, event.y, event.pageX, event.pageY],\n                                };\n                                yield dndManager.endDrag();\n                            }\n                            if (op && operationChangeEvents) {\n                                dndManager.beginDrag(idRef.current, op, ...operationChangeEvents.begin);\n                                dndManager.drag(...operationChangeEvents.drag);\n                                operationChangeEvents = undefined;\n                            }\n                        }\n                    }\n                });\n                d3.select(node.ownerDocument)\n                    .on('keydown.useDndDrag', flow(function* () {\n                    const e = d3.event;\n                    if (e.key === 'Escape') {\n                        if (dndManager.isDragging() && dndManager.cancel()) {\n                            operationChangeEvents = undefined;\n                            d3.select(d3.event.view).on('.drag', null);\n                            d3.select(node.ownerDocument).on('.useDndDrag', null);\n                            yield dndManager.endDrag();\n                        }\n                    }\n                    else {\n                        yield updateOperation();\n                    }\n                }))\n                    .on('keyup.useDndDrag', flow(function* () {\n                    yield updateOperation();\n                }));\n            })\n                .on('drag', action(() => {\n                const { pageX, pageY } = d3.event.sourceEvent;\n                const { x, y } = d3.event;\n                if (dndManager.isDragging()) {\n                    dndManager.drag(x, y, pageX, pageY);\n                }\n                else if (operationChangeEvents) {\n                    operationChangeEvents.drag = [x, y, pageX, pageY];\n                }\n                else {\n                    const op = getOperation(operation);\n                    if (op || !hasOperation(operation)) {\n                        if (idRef.current) {\n                            dndManager.beginDrag(idRef.current, op, x, y, pageX, pageY);\n                        }\n                    }\n                    else {\n                        operationChangeEvents = {\n                            begin: [x, y, pageX, pageY],\n                            drag: [x, y, pageX, pageY],\n                        };\n                    }\n                }\n            }))\n                .on('end', flow(function* () {\n                operationChangeEvents = undefined;\n                operation = undefined;\n                d3.select(node.ownerDocument).on('.useDndDrag', null);\n                if (dndManager.isDragging()) {\n                    dndManager.drop();\n                    yield dndManager.endDrag();\n                }\n            }))\n                .filter(() => !d3.event.ctrlKey && !d3.event.button && dndManager.canDragSource(idRef.current)));\n        }\n        return () => {\n            node && d3.select(node).on('mousedown.drag', null);\n        };\n    }, [dndManager, monitor]));\n    React.useEffect(() => {\n        const dragSource = {\n            type: spec.item.type,\n            canCancel: () => typeof specRef.current.canCancel === 'boolean'\n                ? specRef.current.canCancel\n                : typeof specRef.current.canCancel === 'function'\n                    ? specRef.current.canCancel(monitor, propsRef.current)\n                    : true,\n            canDrag: () => typeof specRef.current.canDrag === 'boolean'\n                ? specRef.current.canDrag\n                : typeof specRef.current.canDrag === 'function'\n                    ? specRef.current.canDrag(monitor, propsRef.current)\n                    : true,\n            beginDrag: () => specRef.current.begin ? specRef.current.begin(monitor, propsRef.current) : undefined,\n            drag: () => {\n                if (specRef.current.drag) {\n                    const event = monitor.getDragEvent();\n                    if (event) {\n                        specRef.current.drag(event, monitor, propsRef.current);\n                    }\n                }\n            },\n            endDrag: () => specRef.current.end\n                ? specRef.current.end(monitor.getDropResult(), monitor, propsRef.current)\n                : undefined,\n        };\n        const [sourceId, unregister] = dndManager.registerSource(dragSource);\n        monitor.receiveHandlerId(sourceId);\n        return unregister;\n    }, [spec.item.type, dndManager, monitor]);\n    const collected = React.useMemo(() => computed(() => spec.collect ? spec.collect(monitor, propsRef.current) : {}, { equals: comparer.shallow }), [monitor, spec]);\n    return [collected.get(), refCallback];\n};\nexport const withDndDrag = (spec) => (WrappedComponent) => {\n    const Component = (props) => {\n        // TODO fix cast to any\n        const [dndDragProps, dndDragRef] = useDndDrag(spec, props);\n        return React.createElement(WrappedComponent, Object.assign({}, props, dndDragProps, { dndDragRef: dndDragRef }));\n    };\n    return observer(Component);\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrag.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndDrag.tsx"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,KAAK,EAAE,MAAM,IAAI,CAAC;AACzB,OAAO,EAAE,MAAM,EAAE,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,MAAM,MAAM,CAAC;AACxD,OAAO,EAAE,QAAQ,EAAE,MAAM,YAAY,CAAC;AACtC,OAAO,cAAc,MAAM,yBAAyB,CAAC;AACrD,OAAO,cAAc,MAAM,yBAAyB,CAAC;AAYrD,OAAO,EAAE,aAAa,EAAE,MAAM,iBAAiB,CAAC;AAEhD,MAAM,CAAC,MAAM,SAAS,GAAG;IACvB,OAAO,EAAE,CAAC;IACV,GAAG,EAAE,IAAI;IACT,IAAI,EAAE,IAAI;IACV,IAAI,EAAE,IAAI;IACV,KAAK,EAAE,IAAI;CACZ,CAAC;AAEF,MAAM,YAAY,GAAG,CAAC,KAA8C,EAAU,EAAE;IAC9E,IAAI,SAAS,GAAG,SAAS,CAAC,OAAO,CAAC;IAClC,IAAI,KAAK,CAAC,MAAM,EAAE;QAChB,sCAAsC;QACtC,SAAS,IAAI,SAAS,CAAC,GAAG,CAAC;KAC5B;IACD,IAAI,KAAK,CAAC,OAAO,EAAE;QACjB,sCAAsC;QACtC,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC;KAC7B;IACD,IAAI,KAAK,CAAC,OAAO,EAAE;QACjB,sCAAsC;QACtC,SAAS,IAAI,SAAS,CAAC,IAAI,CAAC;KAC7B;IACD,IAAI,KAAK,CAAC,QAAQ,EAAE;QAClB,sCAAsC;QACtC,SAAS,IAAI,SAAS,CAAC,KAAK,CAAC;KAC9B;IACD,OAAO,SAAS,CAAC;AACnB,CAAC,CAAC;AAEF,MAAM,YAAY,GAAG,CACnB,SAAmE,EAChC,EAAE;IACrC,IAAI,CAAC,SAAS,EAAE;QACd,OAAO,SAAS,CAAC;KAClB;IACD,IAAI,SAAS,CAAC,cAAc,CAAC,MAAM,CAAC,EAAE;QACpC,OAAO,SAAkC,CAAC;KAC3C;IACD,OAAO,CACL,SAAS,CAAC,YAAY,CAAC,CAAC,EAAE,CAAC,KAAK,IAAI,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC;QACvE,SAAS,CAAC,SAAS,CAAC,OAAO,CAAC,CAC7B,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,YAAY,GAAG,CACnB,SAAmE,EAC1D,EAAE;IACX,OAAO,CAAC,CAAC,CAAC,SAAS,IAAI,CAAC,SAAS,CAAC,cAAc,CAAC,MAAM,CAAC,IAAI,MAAM,CAAC,IAAI,CAAC,SAAS,CAAC,CAAC,MAAM,GAAG,CAAC,CAAC,CAAC,CAAC;AAClG,CAAC,CAAC;AAEF,MAAM,WAAW,GAAG,MAAM,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC;AAEtC,MAAM,CAAC,MAAM,UAAU,GAAG,CAMxB,IAMC,EACD,KAAa,EACwB,EAAE;IACvC,MAAM,OAAO,GAAG,KAAK,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC;IACnC,OAAO,CAAC,OAAO,GAAG,IAAI,CAAC;IAEvB,MAAM,QAAQ,GAAG,KAAK,CAAC,MAAM,CAAQ,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAE,WAAqB,CAAC,CAAC;IACrF,QAAQ,CAAC,OAAO,GAAG,KAAK,IAAI,IAAI,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC,CAAE,WAAqB,CAAC;IAElE,MAAM,UAAU,GAAG,aAAa,EAAE,CAAC;IAEnC,MAAM,OAAO,GAAG,KAAK,CAAC,UAAU,CAAC,cAAc,CAAC,CAAC;IACjD,MAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,OAAO,CAAC,CAAC;IACzC,UAAU,CAAC,OAAO,GAAG,OAAO,CAAC;IAE7B,MAAM,KAAK,GAAG,KAAK,CAAC,MAAM,EAAU,CAAC;IAErC,iBAAiB;IACjB,MAAM,OAAO,GAAG,KAAK,CAAC,OAAO,CAAC,GAAG,EAAE;QACjC,MAAM,aAAa,GAAsB;YACvC,YAAY,EAAE,GAAuB,EAAE;gBACrC,OAAO,KAAK,CAAC,OAAO,CAAC;YACvB,CAAC;YACD,gBAAgB,EAAE,CAAC,QAA4B,EAAQ,EAAE;gBACvD,KAAK,CAAC,OAAO,GAAG,QAAQ,CAAC;YAC3B,CAAC;YACD,YAAY,EAAE,GAAa,EAAE;gBAC3B,OAAO,UAAU,CAAC,YAAY,EAAE,CAAC;YACnC,CAAC;YACD,OAAO,EAAE,GAAY,EAAE;gBACrB,OAAO,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YACjD,CAAC;YACD,UAAU,EAAE,GAAY,EAAE;gBACxB,OAAO,UAAU,CAAC,gBAAgB,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC;YACpD,CAAC;YACD,WAAW,EAAE,GAA2B,EAAE;gBACxC,OAAO,UAAU,CAAC,WAAW,EAAE,CAAC;YAClC,CAAC;YACD,OAAO,EAAE,GAAQ,EAAE;gBACjB,OAAO,UAAU,CAAC,OAAO,EAAE,CAAC;YAC9B,CAAC;YACD,aAAa,EAAE,GAAQ,EAAE;gBACvB,OAAO,UAAU,CAAC,aAAa,EAAE,CAAC;YACpC,CAAC;YACD,OAAO,EAAE,GAAY,EAAE;gBACrB,OAAO,UAAU,CAAC,OAAO,EAAE,CAAC;YAC9B,CAAC;YACD,YAAY,EAAE,GAA0B,EAAE;gBACxC,OAAO,UAAU,CAAC,YAAY,EAAE,CAAC;YACnC,CAAC;YACD,YAAY,EAAE,GAAsC,EAAE;gBACpD,OAAO,UAAU,CAAC,YAAY,EAAE,CAAC;YACnC,CAAC;YACD,WAAW,EAAE,GAAY,EAAE;gBACzB,OAAO,UAAU,CAAC,WAAW,EAAE,CAAC;YAClC,CAAC;SACF,CAAC;QACF,OAAO,aAAa,CAAC;IACvB,CAAC,EAAE,CAAC,UAAU,CAAC,CAAC,CAAC;IAEjB,MAAM,WAAW,GAAG,cAAc,CAChC,KAAK,CAAC,WAAW,CACf,CAAC,IAAuB,EAAE,EAAE;QAC1B,IAAI,IAAI,EAAE;YACR,IAAI,qBAKS,CAAC;YACd,IAAI,SAAmE,CAAC;YACxE,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,IAAI,CAClB,EAAE;iBACC,IAAI,EAAE;iBACN,SAAS;YACR,sDAAsD;YACtD,GAAG,EAAE,CACH,EAAE;iBACC,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC;iBAC5B,MAAM,CAAC,uBAAuB,CAAC;iBAC/B,IAAI,EAAS,CACnB;iBACA,EAAE,CAAC,OAAO,EAAE;gBACX,SAAS;oBACP,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,KAAK,UAAU;wBAC7C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC;wBACtD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC;gBAChC,MAAM,eAAe,GAAG,GAAS,EAAE;oBACjC,IAAI,SAAS,IAAI,KAAK,CAAC,OAAO,EAAE;wBAC9B,MAAM,EAAE,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;wBACnC,IAAI,UAAU,CAAC,YAAY,EAAE,KAAK,EAAE,EAAE;4BACpC,0CAA0C;4BAC1C,IAAI,UAAU,CAAC,UAAU,EAAE,EAAE;gCAC3B,2DAA2D;gCAC3D,MAAM,KAAK,qBAAS,UAAU,CAAC,YAAY,EAAgB,CAAE,CAAC;gCAC9D,MAAM,SAAS,GAAG,UAAU,CAAC,MAAM,EAAE,CAAC;gCACtC,qBAAqB,GAAG;oCACtB,KAAK,EAAE;wCACL,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;wCACpC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,CAAC,CAAC;wCACpC,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK;wCAC5C,SAAS,CAAC,CAAC,CAAC,KAAK,CAAC,YAAY,CAAC,CAAC,CAAC,KAAK,CAAC,KAAK;qCAC7C;oCACD,IAAI,EAAE,CAAC,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,CAAC,EAAE,KAAK,CAAC,KAAK,EAAE,KAAK,CAAC,KAAK,CAAC;iCACnD,CAAC;gCACF,MAAM,UAAU,CAAC,OAAO,EAAE,CAAC;6BAC5B;4BACD,IAAI,EAAE,IAAI,qBAAqB,EAAE;gCAC/B,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,EAAE,GAAG,qBAAqB,CAAC,KAAK,CAAC,CAAC;gCACxE,UAAU,CAAC,IAAI,CAAC,GAAG,qBAAqB,CAAC,IAAI,CAAC,CAAC;gCAC/C,qBAAqB,GAAG,SAAS,CAAC;6BACnC;yBACF;qBACF;gBACH,CAAC,CAAA,CAAC;gBACF,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC;qBAC1B,EAAE,CACD,oBAAoB,EACpB,IAAI,CAAC,QAAQ,CAAC;oBACZ,MAAM,CAAC,GAAG,EAAE,CAAC,KAAsB,CAAC;oBACpC,IAAI,CAAC,CAAC,GAAG,KAAK,QAAQ,EAAE;wBACtB,IAAI,UAAU,CAAC,UAAU,EAAE,IAAI,UAAU,CAAC,MAAM,EAAE,EAAE;4BAClD,qBAAqB,GAAG,SAAS,CAAC;4BAClC,EAAE,CAAC,MAAM,CAAC,EAAE,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,OAAO,EAAE,IAAI,CAAC,CAAC;4BAC3C,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;4BACtD,MAAM,UAAU,CAAC,OAAO,EAAE,CAAC;yBAC5B;qBACF;yBAAM;wBACL,MAAM,eAAe,EAAE,CAAC;qBACzB;gBACH,CAAC,CAAC,CACH;qBACA,EAAE,CACD,kBAAkB,EAClB,IAAI,CAAC,QAAQ,CAAC;oBACZ,MAAM,eAAe,EAAE,CAAC;gBAC1B,CAAC,CAAC,CACH,CAAC;YACN,CAAC,CAAC;iBACD,EAAE,CACD,MAAM,EACN,MAAM,CAAC,GAAG,EAAE;gBACV,MAAM,EAAE,KAAK,EAAE,KAAK,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC,WAAW,CAAC;gBAC9C,MAAM,EAAE,CAAC,EAAE,CAAC,EAAE,GAAG,EAAE,CAAC,KAAK,CAAC;gBAC1B,IAAI,UAAU,CAAC,UAAU,EAAE,EAAE;oBAC3B,UAAU,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;iBACrC;qBAAM,IAAI,qBAAqB,EAAE;oBAChC,qBAAqB,CAAC,IAAI,GAAG,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;iBACnD;qBAAM;oBACL,MAAM,EAAE,GAAG,YAAY,CAAC,SAAS,CAAC,CAAC;oBACnC,IAAI,EAAE,IAAI,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE;wBAClC,IAAI,KAAK,CAAC,OAAO,EAAE;4BACjB,UAAU,CAAC,SAAS,CAAC,KAAK,CAAC,OAAO,EAAE,EAAE,EAAE,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC,CAAC;yBAC7D;qBACF;yBAAM;wBACL,qBAAqB,GAAG;4BACtB,KAAK,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC;4BAC3B,IAAI,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,EAAE,KAAK,CAAC;yBAC3B,CAAC;qBACH;iBACF;YACH,CAAC,CAAC,CACH;iBACA,EAAE,CACD,KAAK,EACL,IAAI,CAAC,QAAQ,CAAC;gBACZ,qBAAqB,GAAG,SAAS,CAAC;gBAClC,SAAS,GAAG,SAAS,CAAC;gBACtB,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,aAAa,CAAC,CAAC,EAAE,CAAC,aAAa,EAAE,IAAI,CAAC,CAAC;gBACtD,IAAI,UAAU,CAAC,UAAU,EAAE,EAAE;oBAC3B,UAAU,CAAC,IAAI,EAAE,CAAC;oBAClB,MAAM,UAAU,CAAC,OAAO,EAAE,CAAC;iBAC5B;YACH,CAAC,CAAC,CACH;iBACA,MAAM,CACL,GAAG,EAAE,CACH,CAAC,EAAE,CAAC,KAAK,CAAC,OAAO,IAAI,CAAC,EAAE,CAAC,KAAK,CAAC,MAAM,IAAI,UAAU,CAAC,aAAa,CAAC,KAAK,CAAC,OAAO,CAAC,CACnF,CACJ,CAAC;SACH;QACD,OAAO,GAAG,EAAE;YACV,IAAI,IAAI,EAAE,CAAC,MAAM,CAAC,IAAI,CAAC,CAAC,EAAE,CAAC,gBAAgB,EAAE,IAAI,CAAC,CAAC;QACrD,CAAC,CAAC;IACJ,CAAC,EACD,CAAC,UAAU,EAAE,OAAO,CAAC,CACtB,CACF,CAAC;IAEF,KAAK,CAAC,SAAS,CAAC,GAAG,EAAE;QACnB,MAAM,UAAU,GAAe;YAC7B,IAAI,EAAE,IAAI,CAAC,IAAI,CAAC,IAAI;YACpB,SAAS,EAAE,GAAG,EAAE,CACd,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,KAAK,SAAS;gBAC5C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS;gBAC3B,CAAC,CAAC,OAAO,OAAO,CAAC,OAAO,CAAC,SAAS,KAAK,UAAU;oBACjD,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,SAAS,CAAC,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC;oBACtD,CAAC,CAAC,IAAI;YACV,OAAO,EAAE,GAAG,EAAE,CACZ,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,KAAK,SAAS;gBAC1C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO;gBACzB,CAAC,CAAC,OAAO,OAAO,CAAC,OAAO,CAAC,OAAO,KAAK,UAAU;oBAC/C,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC;oBACpD,CAAC,CAAC,IAAI;YACV,SAAS,EAAE,GAAG,EAAE,CACd,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,KAAK,CAAC,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAC,SAAS;YACtF,IAAI,EAAE,GAAG,EAAE;gBACT,IAAI,OAAO,CAAC,OAAO,CAAC,IAAI,EAAE;oBACxB,MAAM,KAAK,GAAG,OAAO,CAAC,YAAY,EAAE,CAAC;oBACrC,IAAI,KAAK,EAAE;wBACT,OAAO,CAAC,OAAO,CAAC,IAAI,CAAC,KAAK,EAAE,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC;qBACxD;iBACF;YACH,CAAC;YACD,OAAO,EAAE,GAAG,EAAE,CACZ,OAAO,CAAC,OAAO,CAAC,GAAG;gBACjB,CAAC,CAAC,OAAO,CAAC,OAAO,CAAC,GAAG,CAAC,OAAO,CAAC,aAAa,EAAE,EAAE,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC;gBACzE,CAAC,CAAC,SAAS;SAChB,CAAC;QACF,MAAM,CAAC,QAAQ,EAAE,UAAU,CAAC,GAAG,UAAU,CAAC,cAAc,CAAC,UAAU,CAAC,CAAC;QACrE,OAAO,CAAC,gBAAgB,CAAC,QAAQ,CAAC,CAAC;QACnC,OAAO,UAAU,CAAC;IACpB,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,IAAI,EAAE,UAAU,EAAE,OAAO,CAAC,CAAC,CAAC;IAE1C,MAAM,SAAS,GAAG,KAAK,CAAC,OAAO,CAC7B,GAAG,EAAE,CACH,QAAQ,CACN,GAAG,EAAE,CACH,IAAI,CAAC,OAAO,CAAC,CAAC,CAAC,IAAI,CAAC,OAAO,CAAC,OAAO,EAAE,QAAQ,CAAC,OAAO,CAAC,CAAC,CAAC,CAAG,EAA6B,EAC1F,EAAE,MAAM,EAAE,QAAQ,CAAC,OAAO,EAAE,CAC7B,EACH,CAAC,OAAO,EAAE,IAAI,CAAC,CAChB,CAAC;IAEF,OAAO,CAAC,SAAS,CAAC,GAAG,EAAE,EAAE,WAAW,CAAC,CAAC;AACxC,CAAC,CAAC;AAMF,MAAM,CAAC,MAAM,WAAW,GAAG,CAMzB,IAMC,EACD,EAAE,CAAC,CACH,gBAAwC,EACxC,EAAE;IACF,MAAM,SAAS,GAA+D,CAAC,KAAK,EAAE,EAAE;QACtF,uBAAuB;QACvB,MAAM,CAAC,YAAY,EAAE,UAAU,CAAC,GAAG,UAAU,CAAC,IAAI,EAAE,KAAY,CAAC,CAAC;QAClE,OAAO,oBAAC,gBAAgB,oBAAM,KAAa,EAAM,YAAY,IAAE,UAAU,EAAE,UAAU,IAAI,CAAC;IAC5F,CAAC,CAAC;IACF,OAAO,QAAQ,CAAC,SAAS,CAAC,CAAC;AAC7B,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport * as d3 from 'd3';\nimport { action, computed, comparer, flow } from 'mobx';\nimport { observer } from 'mobx-react';\nimport ElementContext from '../utils/ElementContext';\nimport useCallbackRef from '../utils/useCallbackRef';\nimport {\n  DragSourceSpec,\n  ConnectDragSource,\n  DragObjectWithType,\n  DragSourceMonitor,\n  Identifier,\n  DragEvent,\n  DragSpecOperationType,\n  DragSource,\n  DragOperationWithType,\n} from './dnd-types';\nimport { useDndManager } from './useDndManager';\n\nexport const Modifiers = {\n  DEFAULT: 0,\n  ALT: 0x01,\n  CTRL: 0x02,\n  META: 0x04,\n  SHIFT: 0x08,\n};\n\nconst getModifiers = (event: MouseEvent | TouchEvent | KeyboardEvent): number => {\n  let modifiers = Modifiers.DEFAULT;\n  if (event.altKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.ALT;\n  }\n  if (event.ctrlKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.CTRL;\n  }\n  if (event.metaKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.META;\n  }\n  if (event.shiftKey) {\n    // eslint-disable-next-line no-bitwise\n    modifiers |= Modifiers.SHIFT;\n  }\n  return modifiers;\n};\n\nconst getOperation = (\n  operation: DragSpecOperationType<DragOperationWithType> | undefined,\n): DragOperationWithType | undefined => {\n  if (!operation) {\n    return undefined;\n  }\n  if (operation.hasOwnProperty('type')) {\n    return operation as DragOperationWithType;\n  }\n  return (\n    operation[getModifiers((d3.event && d3.event.sourceEvent) || d3.event)] ||\n    operation[Modifiers.DEFAULT]\n  );\n};\n\nconst hasOperation = (\n  operation: DragSpecOperationType<DragOperationWithType> | undefined,\n): boolean => {\n  return !!(operation && (operation.hasOwnProperty('type') || Object.keys(operation).length > 0));\n};\n\nconst EMPTY_PROPS = Object.freeze({});\n\nexport const useDndDrag = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DragSourceSpec<\n    DragObject,\n    DragSpecOperationType<DragOperationWithType>,\n    DropResult,\n    CollectedProps,\n    Props\n  >,\n  props?: Props,\n): [CollectedProps, ConnectDragSource] => {\n  const specRef = React.useRef(spec);\n  specRef.current = spec;\n\n  const propsRef = React.useRef<Props>(props != null ? props : (EMPTY_PROPS as Props));\n  propsRef.current = props != null ? props : (EMPTY_PROPS as Props);\n\n  const dndManager = useDndManager();\n\n  const element = React.useContext(ElementContext);\n  const elementRef = React.useRef(element);\n  elementRef.current = element;\n\n  const idRef = React.useRef<string>();\n\n  // source monitor\n  const monitor = React.useMemo(() => {\n    const sourceMonitor: DragSourceMonitor = {\n      getHandlerId: (): string | undefined => {\n        return idRef.current;\n      },\n      receiveHandlerId: (sourceId: string | undefined): void => {\n        idRef.current = sourceId;\n      },\n      getDropHints: (): string[] => {\n        return dndManager.getDropHints();\n      },\n      canDrag: (): boolean => {\n        return dndManager.canDragSource(idRef.current);\n      },\n      isDragging: (): boolean => {\n        return dndManager.isDraggingSource(idRef.current);\n      },\n      getItemType: (): Identifier | undefined => {\n        return dndManager.getItemType();\n      },\n      getItem: (): any => {\n        return dndManager.getItem();\n      },\n      getDropResult: (): any => {\n        return dndManager.getDropResult();\n      },\n      didDrop: (): boolean => {\n        return dndManager.didDrop();\n      },\n      getDragEvent: (): DragEvent | undefined => {\n        return dndManager.getDragEvent();\n      },\n      getOperation: (): DragOperationWithType | undefined => {\n        return dndManager.getOperation();\n      },\n      isCancelled: (): boolean => {\n        return dndManager.isCancelled();\n      },\n    };\n    return sourceMonitor;\n  }, [dndManager]);\n\n  const refCallback = useCallbackRef(\n    React.useCallback(\n      (node: SVGElement | null) => {\n        if (node) {\n          let operationChangeEvents:\n            | {\n                begin: [number, number, number, number];\n                drag: [number, number, number, number];\n              }\n            | undefined;\n          let operation: DragSpecOperationType<DragOperationWithType> | undefined;\n          d3.select(node).call(\n            d3\n              .drag()\n              .container(\n                // TODO bridge the gap between scene tree and dom tree\n                () =>\n                  d3\n                    .select(node.ownerSVGElement)\n                    .select('[data-surface=\"true\"]')\n                    .node() as any,\n              )\n              .on('start', function() {\n                operation =\n                  typeof specRef.current.operation === 'function'\n                    ? specRef.current.operation(monitor, propsRef.current)\n                    : specRef.current.operation;\n                const updateOperation = async () => {\n                  if (operation && idRef.current) {\n                    const op = getOperation(operation);\n                    if (dndManager.getOperation() !== op) {\n                      // restart the drag with the new operation\n                      if (dndManager.isDragging()) {\n                        // copy the event otherwise it will be mutated by #cancel()\n                        const event = { ...(dndManager.getDragEvent() as DragEvent) };\n                        const cancelled = dndManager.cancel();\n                        operationChangeEvents = {\n                          begin: [\n                            cancelled ? event.initialX : event.x,\n                            cancelled ? event.initialY : event.y,\n                            cancelled ? event.initialPageX : event.pageX,\n                            cancelled ? event.initialPageY : event.pageY,\n                          ],\n                          drag: [event.x, event.y, event.pageX, event.pageY],\n                        };\n                        await dndManager.endDrag();\n                      }\n                      if (op && operationChangeEvents) {\n                        dndManager.beginDrag(idRef.current, op, ...operationChangeEvents.begin);\n                        dndManager.drag(...operationChangeEvents.drag);\n                        operationChangeEvents = undefined;\n                      }\n                    }\n                  }\n                };\n                d3.select(node.ownerDocument)\n                  .on(\n                    'keydown.useDndDrag',\n                    flow(function*() {\n                      const e = d3.event as KeyboardEvent;\n                      if (e.key === 'Escape') {\n                        if (dndManager.isDragging() && dndManager.cancel()) {\n                          operationChangeEvents = undefined;\n                          d3.select(d3.event.view).on('.drag', null);\n                          d3.select(node.ownerDocument).on('.useDndDrag', null);\n                          yield dndManager.endDrag();\n                        }\n                      } else {\n                        yield updateOperation();\n                      }\n                    }),\n                  )\n                  .on(\n                    'keyup.useDndDrag',\n                    flow(function*() {\n                      yield updateOperation();\n                    }),\n                  );\n              })\n              .on(\n                'drag',\n                action(() => {\n                  const { pageX, pageY } = d3.event.sourceEvent;\n                  const { x, y } = d3.event;\n                  if (dndManager.isDragging()) {\n                    dndManager.drag(x, y, pageX, pageY);\n                  } else if (operationChangeEvents) {\n                    operationChangeEvents.drag = [x, y, pageX, pageY];\n                  } else {\n                    const op = getOperation(operation);\n                    if (op || !hasOperation(operation)) {\n                      if (idRef.current) {\n                        dndManager.beginDrag(idRef.current, op, x, y, pageX, pageY);\n                      }\n                    } else {\n                      operationChangeEvents = {\n                        begin: [x, y, pageX, pageY],\n                        drag: [x, y, pageX, pageY],\n                      };\n                    }\n                  }\n                }),\n              )\n              .on(\n                'end',\n                flow(function*() {\n                  operationChangeEvents = undefined;\n                  operation = undefined;\n                  d3.select(node.ownerDocument).on('.useDndDrag', null);\n                  if (dndManager.isDragging()) {\n                    dndManager.drop();\n                    yield dndManager.endDrag();\n                  }\n                }),\n              )\n              .filter(\n                () =>\n                  !d3.event.ctrlKey && !d3.event.button && dndManager.canDragSource(idRef.current),\n              ),\n          );\n        }\n        return () => {\n          node && d3.select(node).on('mousedown.drag', null);\n        };\n      },\n      [dndManager, monitor],\n    ),\n  );\n\n  React.useEffect(() => {\n    const dragSource: DragSource = {\n      type: spec.item.type,\n      canCancel: () =>\n        typeof specRef.current.canCancel === 'boolean'\n          ? specRef.current.canCancel\n          : typeof specRef.current.canCancel === 'function'\n          ? specRef.current.canCancel(monitor, propsRef.current)\n          : true,\n      canDrag: () =>\n        typeof specRef.current.canDrag === 'boolean'\n          ? specRef.current.canDrag\n          : typeof specRef.current.canDrag === 'function'\n          ? specRef.current.canDrag(monitor, propsRef.current)\n          : true,\n      beginDrag: () =>\n        specRef.current.begin ? specRef.current.begin(monitor, propsRef.current) : undefined,\n      drag: () => {\n        if (specRef.current.drag) {\n          const event = monitor.getDragEvent();\n          if (event) {\n            specRef.current.drag(event, monitor, propsRef.current);\n          }\n        }\n      },\n      endDrag: () =>\n        specRef.current.end\n          ? specRef.current.end(monitor.getDropResult(), monitor, propsRef.current)\n          : undefined,\n    };\n    const [sourceId, unregister] = dndManager.registerSource(dragSource);\n    monitor.receiveHandlerId(sourceId);\n    return unregister;\n  }, [spec.item.type, dndManager, monitor]);\n\n  const collected = React.useMemo(\n    () =>\n      computed(\n        () =>\n          spec.collect ? spec.collect(monitor, propsRef.current) : (({} as any) as CollectedProps),\n        { equals: comparer.shallow },\n      ),\n    [monitor, spec],\n  );\n\n  return [collected.get(), refCallback];\n};\n\nexport type WithDndDragProps = {\n  dndDragRef: ConnectDragSource;\n};\n\nexport const withDndDrag = <\n  DragObject extends DragObjectWithType = DragObjectWithType,\n  DropResult = any,\n  CollectedProps extends {} = {},\n  Props extends {} = {}\n>(\n  spec: DragSourceSpec<\n    DragObject,\n    DragSpecOperationType<DragOperationWithType>,\n    DropResult,\n    CollectedProps,\n    Props\n  >,\n) => <P extends WithDndDragProps & CollectedProps & Props>(\n  WrappedComponent: React.ComponentType<P>,\n) => {\n  const Component: React.FC<Omit<P, keyof WithDndDragProps & CollectedProps>> = (props) => {\n    // TODO fix cast to any\n    const [dndDragProps, dndDragRef] = useDndDrag(spec, props as any);\n    return <WrappedComponent {...(props as any)} {...dndDragProps} dndDragRef={dndDragRef} />;\n  };\n  return observer(Component);\n};\n"]}]}