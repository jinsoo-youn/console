{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/knative-plugin/src/topology/layouts/layoutConstraints.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/knative-plugin/src/topology/layouts/layoutConstraints.ts","mtime":1615298458640},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nimport { ColaGroup, getGroupPadding } from '@console/topology';\nimport { TYPE_EVENT_SOURCE_LINK, TYPE_KNATIVE_SERVICE } from '../const';\nconst getNodeTimeStamp = (node) => {\n    const data = node.element.getData();\n    return new Date(_.get(data, 'resources.obj.metadata.creationTimestamp', 0));\n};\n// Sort nodes most recent to least recent\nconst nodeSorter = (node1, node2) => getNodeTimeStamp(node1) > getNodeTimeStamp(node2) ? -1 : 1;\nexport const layoutConstraints = (nodes, groups, edges, options) => {\n    const constraints = [];\n    [...groups, ...nodes]\n        .filter((g) => g.element.getType() === TYPE_KNATIVE_SERVICE)\n        .forEach((g) => {\n        const serviceConstraint = {\n            type: 'alignment',\n            axis: 'y',\n            offsets: [],\n        };\n        // Sort revisions such that most recent is to the left\n        const revisions = g instanceof ColaGroup && g.leaves.sort(nodeSorter);\n        if (revisions) {\n            for (let i = 0; i < revisions.length; i++) {\n                serviceConstraint.offsets.push({ node: revisions[i].index, offset: 0 });\n                if (i < revisions.length - 1) {\n                    // Space out each revision horizontally\n                    constraints.push({\n                        axis: 'x',\n                        left: revisions[i].index,\n                        right: revisions[i + 1].index,\n                        gap: revisions[i].width,\n                        equality: true,\n                    });\n                }\n            }\n            if (serviceConstraint.offsets.length) {\n                constraints.push(serviceConstraint);\n            }\n        }\n        const eventSourceLinks = edges\n            .filter((e) => e.element.getType() === TYPE_EVENT_SOURCE_LINK &&\n            (e.target.element === g.element || e.target.element.getParent() === g.element))\n            .sort((l1, l2) => nodeSorter(l1.source, l2.source));\n        if (eventSourceLinks.length) {\n            const height = eventSourceLinks.reduce((current, nextLink) => {\n                return current + nextLink.source.height;\n            }, 0);\n            const serviceNode = (revisions && _.last(revisions)) || g;\n            const serviceDistance = revisions\n                ? serviceNode.radius + getGroupPadding(g.element)\n                : serviceNode.width / 2;\n            const eventSourceConstraint = {\n                type: 'alignment',\n                axis: 'y',\n                offsets: [{ node: eventSourceLinks[0].target.index, offset: 0 }],\n            };\n            let nextOffset = -height / 2;\n            eventSourceLinks.forEach((link) => {\n                // Evenly space out the event sources vertically\n                eventSourceConstraint.offsets.push({\n                    node: link.source.index,\n                    offset: nextOffset + link.source.height / 2,\n                });\n                // Keep the event sources to the right\n                constraints.push({\n                    axis: 'x',\n                    left: serviceNode.index,\n                    right: link.source.index,\n                    gap: serviceDistance + link.source.width / 2 + options.linkDistance,\n                    equality: true,\n                });\n                nextOffset += link.source.height;\n            });\n            constraints.push(eventSourceConstraint);\n        }\n    });\n    return constraints;\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/knative-plugin/src/topology/layouts/layoutConstraints.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/knative-plugin/src/topology/layouts/layoutConstraints.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { ColaGroup, ColaLink, ColaNode, getGroupPadding, LayoutOptions } from '@console/topology';\nimport { TYPE_EVENT_SOURCE_LINK, TYPE_KNATIVE_SERVICE } from '../const';\n\nconst getNodeTimeStamp = (node: ColaNode): Date => {\n  const data = node.element.getData();\n  return new Date(_.get(data, 'resources.obj.metadata.creationTimestamp', 0));\n};\n\n// Sort nodes most recent to least recent\nconst nodeSorter = (node1: ColaNode, node2: ColaNode) =>\n  getNodeTimeStamp(node1) > getNodeTimeStamp(node2) ? -1 : 1;\n\nexport const layoutConstraints = (\n  nodes: ColaNode[],\n  groups: ColaGroup[],\n  edges: ColaLink[],\n  options: LayoutOptions,\n): any[] => {\n  const constraints: any[] = [];\n\n  [...groups, ...nodes]\n    .filter((g) => g.element.getType() === TYPE_KNATIVE_SERVICE)\n    .forEach((g) => {\n      const serviceConstraint: any = {\n        type: 'alignment',\n        axis: 'y',\n        offsets: [],\n      };\n\n      // Sort revisions such that most recent is to the left\n      const revisions = g instanceof ColaGroup && g.leaves.sort(nodeSorter);\n      if (revisions) {\n        for (let i = 0; i < revisions.length; i++) {\n          serviceConstraint.offsets.push({ node: revisions[i].index, offset: 0 });\n          if (i < revisions.length - 1) {\n            // Space out each revision horizontally\n            constraints.push({\n              axis: 'x',\n              left: revisions[i].index,\n              right: revisions[i + 1].index,\n              gap: revisions[i].width,\n              equality: true,\n            });\n          }\n        }\n        if (serviceConstraint.offsets.length) {\n          constraints.push(serviceConstraint);\n        }\n      }\n\n      const eventSourceLinks = edges\n        .filter(\n          (e) =>\n            e.element.getType() === TYPE_EVENT_SOURCE_LINK &&\n            (e.target.element === g.element || e.target.element.getParent() === g.element),\n        )\n        .sort((l1: ColaLink, l2: ColaLink) => nodeSorter(l1.source, l2.source));\n      if (eventSourceLinks.length) {\n        const height = eventSourceLinks.reduce((current: number, nextLink: ColaLink) => {\n          return current + nextLink.source.height;\n        }, 0);\n        const serviceNode = (revisions && _.last(revisions)) || g;\n        const serviceDistance = revisions\n          ? (serviceNode as ColaNode).radius + getGroupPadding(g.element)\n          : (serviceNode as ColaNode).width / 2;\n\n        const eventSourceConstraint: any = {\n          type: 'alignment',\n          axis: 'y',\n          offsets: [{ node: eventSourceLinks[0].target.index, offset: 0 }],\n        };\n        let nextOffset = -height / 2;\n        eventSourceLinks.forEach((link: ColaLink) => {\n          // Evenly space out the event sources vertically\n          eventSourceConstraint.offsets.push({\n            node: link.source.index,\n            offset: nextOffset + link.source.height / 2,\n          });\n          // Keep the event sources to the right\n          constraints.push({\n            axis: 'x',\n            left: serviceNode.index,\n            right: link.source.index,\n            gap: serviceDistance + link.source.width / 2 + options.linkDistance,\n            equality: true,\n          });\n          nextOffset += link.source.height;\n        });\n        constraints.push(eventSourceConstraint);\n      }\n    });\n  return constraints;\n};\n"]}]}