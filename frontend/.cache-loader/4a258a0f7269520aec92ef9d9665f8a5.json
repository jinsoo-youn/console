{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-utils.ts","mtime":1615298458640},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nimport { formatDuration } from '@console/internal/components/utils/datetime';\nimport { k8sUpdate, k8sGet, } from '@console/internal/module/k8s';\nimport { LOG_SOURCE_RESTARTING, LOG_SOURCE_WAITING, LOG_SOURCE_RUNNING, LOG_SOURCE_TERMINATED, } from '@console/internal/components/utils';\nimport { ServiceAccountModel } from '@console/internal/models';\nimport { errorModal } from '@console/internal/components/modals/error-modal';\nimport { PIPELINE_SERVICE_ACCOUNT, SecretAnnotationId } from '../components/pipelines/const';\nimport { getLatestRun, runStatus, } from './pipeline-augment';\nimport { pipelineFilterReducer, pipelineRunStatus } from './pipeline-filter-reducer';\nexport const TaskStatusClassNameMap = {\n    'In Progress': 'is-running',\n    Succeeded: 'is-done',\n    Failed: 'is-error',\n    Idle: 'is-idle',\n};\nexport const conditions = {\n    hasFromDependency: (task) => task.resources &&\n        task.resources.inputs &&\n        task.resources.inputs.length > 0 &&\n        !!task.resources.inputs[0].from,\n    hasRunAfterDependency: (task) => task.runAfter && task.runAfter.length > 0,\n};\nexport var ListFilterId;\n(function (ListFilterId) {\n    ListFilterId[\"Running\"] = \"Running\";\n    ListFilterId[\"Failed\"] = \"Failed\";\n    ListFilterId[\"Succeeded\"] = \"Succeeded\";\n    ListFilterId[\"Cancelled\"] = \"Cancelled\";\n    ListFilterId[\"Other\"] = \"-\";\n})(ListFilterId || (ListFilterId = {}));\nexport const ListFilterLabels = {\n    [ListFilterId.Running]: 'Running',\n    [ListFilterId.Failed]: 'Failed',\n    [ListFilterId.Succeeded]: 'Complete',\n    [ListFilterId.Cancelled]: 'Cancelled',\n    [ListFilterId.Other]: 'Other',\n};\n// to be used by both Pipeline and Pipelinerun visualisation\nconst sortTasksByRunAfterAndFrom = (tasks) => {\n    // check and sort tasks by 'runAfter' and 'from' dependency\n    const output = tasks;\n    for (let i = 0; i < output.length; i++) {\n        let flag = -1;\n        if (conditions.hasRunAfterDependency(output[i])) {\n            for (let j = 0; j < output.length; j++) {\n                if (i < j && output[j].taskRef.name === output[i].runAfter[output[i].runAfter.length - 1]) {\n                    flag = j;\n                }\n            }\n        }\n        else if (conditions.hasFromDependency(output[i])) {\n            for (let j = i + 1; j < output.length; j++) {\n                if (output[j].taskRef.name === output[i].resources.inputs[0].from[0]) {\n                    flag = j;\n                }\n            }\n        }\n        if (flag > -1) {\n            // swap with last matching task\n            const temp = output[flag];\n            output[flag] = output[i];\n            output[i] = temp;\n        }\n    }\n    return output;\n};\n/**\n * Appends the pipeline run status to each tasks in the pipeline.\n * @param pipeline\n * @param pipelineRun\n */\nconst appendPipelineRunStatus = (pipeline, pipelineRun) => {\n    return _.map(pipeline.spec.tasks, (task) => {\n        if (!pipelineRun.status) {\n            return task;\n        }\n        if (pipelineRun.status && !pipelineRun.status.taskRuns && !pipelineRun.status.runs) {\n            return _.merge(task, { status: { reason: runStatus.Failed } });\n        }\n        const mTask = _.merge(task, {\n            status: _.get(_.find(pipelineRun.status.taskRuns, { pipelineTaskName: task.name }) || _.find(pipelineRun.status.runs, { pipelineTaskName: task.name }), 'status'),\n        });\n        // append task duration\n        if (mTask.status && mTask.status.completionTime && mTask.status.startTime) {\n            const date = new Date(mTask.status.completionTime).getTime() -\n                new Date(mTask.status.startTime).getTime();\n            mTask.status.duration = formatDuration(date);\n        }\n        // append task status\n        if (!mTask.status) {\n            mTask.status = { reason: runStatus.Idle };\n        }\n        else if (mTask.status && mTask.status.conditions) {\n            mTask.status.reason = pipelineRunStatus(mTask) || runStatus.Idle;\n        }\n        return mTask;\n    });\n};\nexport const getPipelineTasks = (pipeline, pipelineRun = {\n    apiVersion: '',\n    metadata: {},\n    kind: 'PipelineRun',\n}) => {\n    // Each unit in 'out' array is termed as stage | out = [stage1 = [task1], stage2 = [task2,task3], stage3 = [task4]]\n    const out = [];\n    if (!pipeline.spec || !pipeline.spec.tasks) {\n        return out;\n    }\n    const taskList = appendPipelineRunStatus(pipeline, pipelineRun);\n    // Step 1: Sort Tasks to get in correct order\n    const tasks = sortTasksByRunAfterAndFrom(taskList);\n    // Step 2: Push all nodes without any dependencies in different stages\n    tasks.forEach((task) => {\n        if (!conditions.hasFromDependency(task) && !conditions.hasRunAfterDependency(task)) {\n            if (out.length === 0) {\n                out.push([]);\n            }\n            out[0].push(task);\n        }\n    });\n    // Step 3: Push nodes with 'from' dependency and stack similar tasks in a stage\n    tasks.forEach((task) => {\n        if (!conditions.hasRunAfterDependency(task) && conditions.hasFromDependency(task)) {\n            let flag = out.length - 1;\n            for (let i = 0; i < out.length; i++) {\n                for (const t of out[i]) {\n                    if (t.taskRef.name === task.resources.inputs[0].from[0] ||\n                        t.name === task.resources.inputs[0].from[0]) {\n                        flag = i;\n                    }\n                }\n            }\n            const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n            if (nextToFlag &&\n                nextToFlag[0] &&\n                nextToFlag[0].resources &&\n                nextToFlag[0].resources.inputs &&\n                nextToFlag[0].resources.inputs[0] &&\n                nextToFlag[0].resources.inputs[0].from &&\n                nextToFlag[0].resources.inputs[0].from[0] &&\n                nextToFlag[0].resources.inputs[0].from[0] === task.resources.inputs[0].from[0]) {\n                nextToFlag.push(task);\n            }\n            else {\n                out.splice(flag + 1, 0, [task]);\n            }\n        }\n    });\n    // Step 4: Push nodes with 'runAfter' dependencies and stack similar tasks in a stage\n    tasks.forEach((task) => {\n        if (conditions.hasRunAfterDependency(task)) {\n            let flag = out.length - 1;\n            for (let i = 0; i < out.length; i++) {\n                for (const t of out[i]) {\n                    if (t.taskRef.name === task.runAfter[0] || t.name === task.runAfter[0]) {\n                        flag = i;\n                    }\n                }\n            }\n            const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n            if (nextToFlag &&\n                nextToFlag[0].runAfter &&\n                nextToFlag[0].runAfter[0] &&\n                nextToFlag[0].runAfter[0] === task.runAfter[0]) {\n                nextToFlag.push(task);\n            }\n            else {\n                out.splice(flag + 1, 0, [task]);\n            }\n        }\n    });\n    return out;\n};\nexport const containerToLogSourceStatus = (container) => {\n    if (!container) {\n        return LOG_SOURCE_WAITING;\n    }\n    const { state, lastState } = container;\n    if (state.waiting && !_.isEmpty(lastState)) {\n        return LOG_SOURCE_RESTARTING;\n    }\n    if (state.waiting) {\n        return LOG_SOURCE_WAITING;\n    }\n    if (state.terminated) {\n        return LOG_SOURCE_TERMINATED;\n    }\n    return LOG_SOURCE_RUNNING;\n};\n/**\n * Takes a pipeline and a series of matching pipeline runs and produces a current pipeline state.\n */\nexport const constructCurrentPipeline = (pipeline, pipelineRuns) => {\n    if (!pipeline || !pipelineRuns || pipelineRuns.length === 0) {\n        // Not enough data to build the current state\n        return null;\n    }\n    const latestRun = getLatestRun({ data: pipelineRuns }, 'creationTimestamp');\n    if (!latestRun) {\n        // Without the latestRun we will not have progress to show\n        return null;\n    }\n    const currentPipeline = Object.assign(Object.assign({}, pipeline), { latestRun });\n    let status = pipelineFilterReducer(currentPipeline);\n    if (status === '-') {\n        status = runStatus.Pending;\n    }\n    return {\n        currentPipeline,\n        status,\n    };\n};\nexport const getPipelineRunParams = (pipelineParams) => {\n    return (pipelineParams &&\n        pipelineParams.map((param) => ({\n            name: param.name,\n            value: param.default,\n        })));\n};\nexport const getPipelineRunWorkspaces = (pipelineWorkspaces) => {\n    return (pipelineWorkspaces &&\n        pipelineWorkspaces.map((workspace) => (Object.assign({ name: workspace.name }, workspace.data))));\n};\nexport const calculateRelativeTime = (startTime, completionTime) => {\n    const start = new Date(startTime).getTime();\n    const end = completionTime ? new Date(completionTime).getTime() : new Date().getTime();\n    const secondsAgo = (end - start) / 1000;\n    const minutesAgo = secondsAgo / 60;\n    const hoursAgo = minutesAgo / 60;\n    if (minutesAgo > 90) {\n        const count = Math.round(hoursAgo);\n        return `about ${count} hours`;\n    }\n    if (minutesAgo > 45) {\n        return 'about an hour';\n    }\n    if (secondsAgo > 90) {\n        const count = Math.round(minutesAgo);\n        return `about ${count} minutes`;\n    }\n    if (secondsAgo > 45) {\n        return 'about a minute';\n    }\n    return 'a few seconds';\n};\nexport const pipelineRunDuration = (run) => {\n    const startTime = _.get(run, ['status', 'startTime'], null);\n    const completionTime = _.get(run, ['status', 'completionTime'], null);\n    // Duration cannot be computed if start time is missing or a completed/failed pipeline has no end time\n    if (!startTime || (!completionTime && pipelineRunStatus(run) !== 'Running')) {\n        return '-';\n    }\n    return calculateRelativeTime(startTime, completionTime);\n};\nexport const updateServiceAccount = (secretName, originalServiceAccount) => {\n    const updatedServiceAccount = _.cloneDeep(originalServiceAccount);\n    updatedServiceAccount.secrets = [...updatedServiceAccount.secrets, { name: secretName }];\n    return k8sUpdate(ServiceAccountModel, updatedServiceAccount);\n};\nexport const associateServiceAccountToSecret = (secret, namespace) => {\n    k8sGet(ServiceAccountModel, PIPELINE_SERVICE_ACCOUNT, namespace)\n        .then((serviceAccount) => {\n        if (_.find(serviceAccount.secrets, (s) => s.name === secret.metadata.name) === undefined) {\n            updateServiceAccount(secret.metadata.name, serviceAccount);\n        }\n    })\n        .catch((err) => {\n        errorModal({ error: err.message });\n    });\n};\nexport const getSecretAnnotations = (annotation) => {\n    const annotations = {};\n    const annotationPrefix = 'tekton.dev';\n    if ((annotation === null || annotation === void 0 ? void 0 : annotation.key) === SecretAnnotationId.Git) {\n        annotations[`${annotationPrefix}/${SecretAnnotationId.Git}-0`] = annotation === null || annotation === void 0 ? void 0 : annotation.value;\n    }\n    else if ((annotation === null || annotation === void 0 ? void 0 : annotation.key) === SecretAnnotationId.Image) {\n        annotations[`${annotationPrefix}/${SecretAnnotationId.Image}-0`] = annotation === null || annotation === void 0 ? void 0 : annotation.value;\n    }\n    return annotations;\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-utils.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,CAAC,MAAM,QAAQ,CAAC;AAC5B,OAAO,EAAE,cAAc,EAAE,MAAM,6CAA6C,CAAC;AAC7E,OAAO,EAGL,SAAS,EACT,MAAM,GAGP,MAAM,8BAA8B,CAAC;AACtC,OAAO,EACL,qBAAqB,EACrB,kBAAkB,EAClB,kBAAkB,EAClB,qBAAqB,GACtB,MAAM,oCAAoC,CAAC;AAC5C,OAAO,EAAE,mBAAmB,EAAE,MAAM,0BAA0B,CAAC;AAC/D,OAAO,EAAE,UAAU,EAAE,MAAM,iDAAiD,CAAC;AAC7E,OAAO,EAAE,wBAAwB,EAAE,kBAAkB,EAAE,MAAM,+BAA+B,CAAC;AAC7F,OAAO,EACL,YAAY,EAGZ,SAAS,GAMV,MAAM,oBAAoB,CAAC;AAC5B,OAAO,EAAE,qBAAqB,EAAE,iBAAiB,EAAE,MAAM,2BAA2B,CAAC;AAwBrF,MAAM,CAAC,MAAM,sBAAsB,GAAG;IACpC,aAAa,EAAE,YAAY;IAC3B,SAAS,EAAE,SAAS;IACpB,MAAM,EAAE,UAAU;IAClB,IAAI,EAAE,SAAS;CAChB,CAAC;AAEF,MAAM,CAAC,MAAM,UAAU,GAAG;IACxB,iBAAiB,EAAE,CAAC,IAAmC,EAAW,EAAE,CAClE,IAAI,CAAC,SAAS;QACd,IAAI,CAAC,SAAS,CAAC,MAAM;QACrB,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,MAAM,GAAG,CAAC;QAChC,CAAC,CAAC,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI;IACjC,qBAAqB,EAAE,CAAC,IAAmC,EAAW,EAAE,CACtE,IAAI,CAAC,QAAQ,IAAI,IAAI,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC;CAC5C,CAAC;AAEF,MAAM,CAAN,IAAY,YAMX;AAND,WAAY,YAAY;IACtB,mCAAmB,CAAA;IACnB,iCAAiB,CAAA;IACjB,uCAAuB,CAAA;IACvB,uCAAuB,CAAA;IACvB,2BAAW,CAAA;AACb,CAAC,EANW,YAAY,KAAZ,YAAY,QAMvB;AAED,MAAM,CAAC,MAAM,gBAAgB,GAAG;IAC9B,CAAC,YAAY,CAAC,OAAO,CAAC,EAAE,SAAS;IACjC,CAAC,YAAY,CAAC,MAAM,CAAC,EAAE,QAAQ;IAC/B,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE,UAAU;IACpC,CAAC,YAAY,CAAC,SAAS,CAAC,EAAE,WAAW;IACrC,CAAC,YAAY,CAAC,KAAK,CAAC,EAAE,OAAO;CAC9B,CAAC;AAEF,4DAA4D;AAC5D,MAAM,0BAA0B,GAAG,CACjC,KAAsC,EACL,EAAE;IACnC,2DAA2D;IAC3D,MAAM,MAAM,GAAG,KAAK,CAAC;IACrB,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;QACtC,IAAI,IAAI,GAAG,CAAC,CAAC,CAAC;QACd,IAAI,UAAU,CAAC,qBAAqB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;YAC/C,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACtC,IAAI,CAAC,GAAG,CAAC,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC,CAAC,EAAE;oBACzF,IAAI,GAAG,CAAC,CAAC;iBACV;aACF;SACF;aAAM,IAAI,UAAU,CAAC,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,EAAE;YAClD,KAAK,IAAI,CAAC,GAAG,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,MAAM,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBAC1C,IAAI,MAAM,CAAC,CAAC,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,MAAM,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAAE;oBACpE,IAAI,GAAG,CAAC,CAAC;iBACV;aACF;SACF;QACD,IAAI,IAAI,GAAG,CAAC,CAAC,EAAE;YACb,+BAA+B;YAC/B,MAAM,IAAI,GAAG,MAAM,CAAC,IAAI,CAAC,CAAC;YAC1B,MAAM,CAAC,IAAI,CAAC,GAAG,MAAM,CAAC,CAAC,CAAC,CAAC;YACzB,MAAM,CAAC,CAAC,CAAC,GAAG,IAAI,CAAC;SAClB;KACF;IACD,OAAO,MAAM,CAAC;AAChB,CAAC,CAAC;AAEF;;;;GAIG;AACH,MAAM,uBAAuB,GAAG,CAAC,QAAQ,EAAE,WAAW,EAAE,EAAE;IACxD,OAAO,CAAC,CAAC,GAAG,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE,CAAC,IAAI,EAAE,EAAE;QACzC,IAAI,CAAC,WAAW,CAAC,MAAM,EAAE;YACvB,OAAO,IAAI,CAAC;SACb;QACD,IAAI,WAAW,CAAC,MAAM,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE;YAClF,OAAO,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE,EAAE,MAAM,EAAE,EAAE,MAAM,EAAE,SAAS,CAAC,MAAM,EAAE,EAAE,CAAC,CAAC;SAChE;QACD,MAAM,KAAK,GAAG,CAAC,CAAC,KAAK,CAAC,IAAI,EAAE;YAC1B,MAAM,EAAE,CAAC,CAAC,GAAG,CAAC,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,QAAQ,EAAE,EAAE,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,IAAI,CAAC,CAAC,IAAI,CAAC,WAAW,CAAC,MAAM,CAAC,IAAI,EAAE,EAAE,gBAAgB,EAAE,IAAI,CAAC,IAAI,EAAE,CAAC,EAAE,QAAQ,CAAC;SAClK,CAAC,CAAC;QACH,uBAAuB;QACvB,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,cAAc,IAAI,KAAK,CAAC,MAAM,CAAC,SAAS,EAAE;YACzE,MAAM,IAAI,GACR,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,cAAc,CAAC,CAAC,OAAO,EAAE;gBAC/C,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;YAC7C,KAAK,CAAC,MAAM,CAAC,QAAQ,GAAG,cAAc,CAAC,IAAI,CAAC,CAAC;SAC9C;QACD,qBAAqB;QACrB,IAAI,CAAC,KAAK,CAAC,MAAM,EAAE;YACjB,KAAK,CAAC,MAAM,GAAG,EAAE,MAAM,EAAE,SAAS,CAAC,IAAI,EAAE,CAAC;SAC3C;aAAM,IAAI,KAAK,CAAC,MAAM,IAAI,KAAK,CAAC,MAAM,CAAC,UAAU,EAAE;YAClD,KAAK,CAAC,MAAM,CAAC,MAAM,GAAG,iBAAiB,CAAC,KAAK,CAAC,IAAI,SAAS,CAAC,IAAI,CAAC;SAClE;QACD,OAAO,KAAK,CAAC;IACf,CAAC,CAAC,CAAC;AACL,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,gBAAgB,GAAG,CAC9B,QAAyB,EACzB,cAA+B;IAC7B,UAAU,EAAE,EAAE;IACd,QAAQ,EAAE,EAAE;IACZ,IAAI,EAAE,aAAa;CACpB,EACkC,EAAE;IACrC,mHAAmH;IACnH,MAAM,GAAG,GAAG,EAAE,CAAC;IACf,IAAI,CAAC,QAAQ,CAAC,IAAI,IAAI,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,EAAE;QAC1C,OAAO,GAAG,CAAC;KACZ;IACD,MAAM,QAAQ,GAAG,uBAAuB,CAAC,QAAQ,EAAE,WAAW,CAAC,CAAC;IAChE,6CAA6C;IAC7C,MAAM,KAAK,GAAG,0BAA0B,CAAC,QAAQ,CAAC,CAAC;IAEnD,sEAAsE;IACtE,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACrB,IAAI,CAAC,UAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,EAAE;YAClF,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE;gBACpB,GAAG,CAAC,IAAI,CAAC,EAAE,CAAC,CAAC;aACd;YACD,GAAG,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;SACnB;IACH,CAAC,CAAC,CAAC;IAEH,+EAA+E;IAC/E,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACrB,IAAI,CAAC,UAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,IAAI,UAAU,CAAC,iBAAiB,CAAC,IAAI,CAAC,EAAE;YACjF,IAAI,IAAI,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;YAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnC,KAAK,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE;oBACtB,IACE,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;wBACnD,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAC3C;wBACA,IAAI,GAAG,CAAC,CAAC;qBACV;iBACF;aACF;YACD,MAAM,UAAU,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YACxD,IACE,UAAU;gBACV,UAAU,CAAC,CAAC,CAAC;gBACb,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS;gBACvB,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM;gBAC9B,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC;gBACjC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI;gBACtC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;gBACzC,UAAU,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,SAAS,CAAC,MAAM,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,EAC9E;gBACA,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACvB;iBAAM;gBACL,GAAG,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;aACjC;SACF;IACH,CAAC,CAAC,CAAC;IAEH,qFAAqF;IACrF,KAAK,CAAC,OAAO,CAAC,CAAC,IAAI,EAAE,EAAE;QACrB,IAAI,UAAU,CAAC,qBAAqB,CAAC,IAAI,CAAC,EAAE;YAC1C,IAAI,IAAI,GAAG,GAAG,CAAC,MAAM,GAAG,CAAC,CAAC;YAC1B,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;gBACnC,KAAK,MAAM,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,EAAE;oBACtB,IAAI,CAAC,CAAC,OAAO,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,IAAI,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAAE;wBACtE,IAAI,GAAG,CAAC,CAAC;qBACV;iBACF;aACF;YACD,MAAM,UAAU,GAAG,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,CAAC,CAAC,IAAI,CAAC;YACxD,IACE,UAAU;gBACV,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ;gBACtB,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC;gBACzB,UAAU,CAAC,CAAC,CAAC,CAAC,QAAQ,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,QAAQ,CAAC,CAAC,CAAC,EAC9C;gBACA,UAAU,CAAC,IAAI,CAAC,IAAI,CAAC,CAAC;aACvB;iBAAM;gBACL,GAAG,CAAC,MAAM,CAAC,IAAI,GAAG,CAAC,EAAE,CAAC,EAAE,CAAC,IAAI,CAAC,CAAC,CAAC;aACjC;SACF;IACH,CAAC,CAAC,CAAC;IACH,OAAO,GAAG,CAAC;AACb,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,0BAA0B,GAAG,CAAC,SAA0B,EAAU,EAAE;IAC/E,IAAI,CAAC,SAAS,EAAE;QACd,OAAO,kBAAkB,CAAC;KAC3B;IACD,MAAM,EAAE,KAAK,EAAE,SAAS,EAAE,GAAG,SAAS,CAAC;IACvC,IAAI,KAAK,CAAC,OAAO,IAAI,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;QAC1C,OAAO,qBAAqB,CAAC;KAC9B;IACD,IAAI,KAAK,CAAC,OAAO,EAAE;QACjB,OAAO,kBAAkB,CAAC;KAC3B;IACD,IAAI,KAAK,CAAC,UAAU,EAAE;QACpB,OAAO,qBAAqB,CAAC;KAC9B;IACD,OAAO,kBAAkB,CAAC;AAC5B,CAAC,CAAC;AAOF;;GAEG;AACH,MAAM,CAAC,MAAM,wBAAwB,GAAG,CACtC,QAAkB,EAClB,YAA2B,EACJ,EAAE;IACzB,IAAI,CAAC,QAAQ,IAAI,CAAC,YAAY,IAAI,YAAY,CAAC,MAAM,KAAK,CAAC,EAAE;QAC3D,6CAA6C;QAC7C,OAAO,IAAI,CAAC;KACb;IAED,MAAM,SAAS,GAAG,YAAY,CAAC,EAAE,IAAI,EAAE,YAAY,EAAE,EAAE,mBAAmB,CAAC,CAAC;IAE5E,IAAI,CAAC,SAAS,EAAE;QACd,0DAA0D;QAC1D,OAAO,IAAI,CAAC;KACb;IAED,MAAM,eAAe,mCAChB,QAAQ,KACX,SAAS,GACV,CAAC;IAEF,IAAI,MAAM,GAAW,qBAAqB,CAAC,eAAe,CAAC,CAAC;IAC5D,IAAI,MAAM,KAAK,GAAG,EAAE;QAClB,MAAM,GAAG,SAAS,CAAC,OAAO,CAAC;KAC5B;IAED,OAAO;QACL,eAAe;QACf,MAAM;KACP,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,cAA+B,EAAsB,EAAE;IAC1F,OAAO,CACL,cAAc;QACd,cAAc,CAAC,GAAG,CAAC,CAAC,KAAK,EAAE,EAAE,CAAC,CAAC;YAC7B,IAAI,EAAE,KAAK,CAAC,IAAI;YAChB,KAAK,EAAE,KAAK,CAAC,OAAO;SACrB,CAAC,CAAC,CACJ,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,wBAAwB,GAAG,CACtC,kBAAuC,EACf,EAAE;IAC1B,OAAO,CACL,kBAAkB;QAClB,kBAAkB,CAAC,GAAG,CAAC,CAAC,SAAS,EAAE,EAAE,CAAC,iBACpC,IAAI,EAAE,SAAS,CAAC,IAAI,IACjB,SAAS,CAAC,IAAI,EACjB,CAAC,CACJ,CAAC;AACJ,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,qBAAqB,GAAG,CAAC,SAAiB,EAAE,cAAuB,EAAE,EAAE;IAClF,MAAM,KAAK,GAAG,IAAI,IAAI,CAAC,SAAS,CAAC,CAAC,OAAO,EAAE,CAAC;IAC5C,MAAM,GAAG,GAAG,cAAc,CAAC,CAAC,CAAC,IAAI,IAAI,CAAC,cAAc,CAAC,CAAC,OAAO,EAAE,CAAC,CAAC,CAAC,IAAI,IAAI,EAAE,CAAC,OAAO,EAAE,CAAC;IACvF,MAAM,UAAU,GAAG,CAAC,GAAG,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC;IACxC,MAAM,UAAU,GAAG,UAAU,GAAG,EAAE,CAAC;IACnC,MAAM,QAAQ,GAAG,UAAU,GAAG,EAAE,CAAC;IAEjC,IAAI,UAAU,GAAG,EAAE,EAAE;QACnB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC;QACnC,OAAO,SAAS,KAAK,QAAQ,CAAC;KAC/B;IACD,IAAI,UAAU,GAAG,EAAE,EAAE;QACnB,OAAO,eAAe,CAAC;KACxB;IACD,IAAI,UAAU,GAAG,EAAE,EAAE;QACnB,MAAM,KAAK,GAAG,IAAI,CAAC,KAAK,CAAC,UAAU,CAAC,CAAC;QACrC,OAAO,SAAS,KAAK,UAAU,CAAC;KACjC;IACD,IAAI,UAAU,GAAG,EAAE,EAAE;QACnB,OAAO,gBAAgB,CAAC;KACzB;IACD,OAAO,eAAe,CAAC;AACzB,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,mBAAmB,GAAG,CAAC,GAAgB,EAAU,EAAE;IAC9D,MAAM,SAAS,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,WAAW,CAAC,EAAE,IAAI,CAAC,CAAC;IAC5D,MAAM,cAAc,GAAG,CAAC,CAAC,GAAG,CAAC,GAAG,EAAE,CAAC,QAAQ,EAAE,gBAAgB,CAAC,EAAE,IAAI,CAAC,CAAC;IAEtE,sGAAsG;IACtG,IAAI,CAAC,SAAS,IAAI,CAAC,CAAC,cAAc,IAAI,iBAAiB,CAAC,GAAG,CAAC,KAAK,SAAS,CAAC,EAAE;QAC3E,OAAO,GAAG,CAAC;KACZ;IACD,OAAO,qBAAqB,CAAC,SAAS,EAAE,cAAc,CAAC,CAAC;AAC1D,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAClC,UAAkB,EAClB,sBAA0C,EACb,EAAE;IAC/B,MAAM,qBAAqB,GAAG,CAAC,CAAC,SAAS,CAAC,sBAAsB,CAAC,CAAC;IAClE,qBAAqB,CAAC,OAAO,GAAG,CAAC,GAAG,qBAAqB,CAAC,OAAO,EAAE,EAAE,IAAI,EAAE,UAAU,EAAE,CAAC,CAAC;IACzF,OAAO,SAAS,CAAC,mBAAmB,EAAE,qBAAqB,CAAC,CAAC;AAC/D,CAAC,CAAC;AAEF,MAAM,CAAC,MAAM,+BAA+B,GAAG,CAAC,MAAkB,EAAE,SAAiB,EAAE,EAAE;IACvF,MAAM,CAAC,mBAAmB,EAAE,wBAAwB,EAAE,SAAS,CAAC;SAC7D,IAAI,CAAC,CAAC,cAAc,EAAE,EAAE;QACvB,IAAI,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,OAAO,EAAE,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,IAAI,KAAK,MAAM,CAAC,QAAQ,CAAC,IAAI,CAAC,KAAK,SAAS,EAAE;YACxF,oBAAoB,CAAC,MAAM,CAAC,QAAQ,CAAC,IAAI,EAAE,cAAc,CAAC,CAAC;SAC5D;IACH,CAAC,CAAC;SACD,KAAK,CAAC,CAAC,GAAG,EAAE,EAAE;QACb,UAAU,CAAC,EAAE,KAAK,EAAE,GAAG,CAAC,OAAO,EAAE,CAAC,CAAC;IACrC,CAAC,CAAC,CAAC;AACP,CAAC,CAAC;AAMF,MAAM,CAAC,MAAM,oBAAoB,GAAG,CAAC,UAAwB,EAAE,EAAE;IAC/D,MAAM,WAAW,GAAG,EAAE,CAAC;IACvB,MAAM,gBAAgB,GAAG,YAAY,CAAC;IACtC,IAAI,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,GAAG,MAAK,kBAAkB,CAAC,GAAG,EAAE;QAC9C,WAAW,CAAC,GAAG,gBAAgB,IAAI,kBAAkB,CAAC,GAAG,IAAI,CAAC,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,KAAK,CAAC;KACpF;SAAM,IAAI,CAAA,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,GAAG,MAAK,kBAAkB,CAAC,KAAK,EAAE;QACvD,WAAW,CAAC,GAAG,gBAAgB,IAAI,kBAAkB,CAAC,KAAK,IAAI,CAAC,GAAG,UAAU,aAAV,UAAU,uBAAV,UAAU,CAAE,KAAK,CAAC;KACtF;IACD,OAAO,WAAW,CAAC;AACrB,CAAC,CAAC","sourcesContent":["import * as _ from 'lodash';\nimport { formatDuration } from '@console/internal/components/utils/datetime';\nimport {\n  ContainerStatus,\n  K8sResourceKind,\n  k8sUpdate,\n  k8sGet,\n  SecretKind,\n  K8sResourceCommon,\n} from '@console/internal/module/k8s';\nimport {\n  LOG_SOURCE_RESTARTING,\n  LOG_SOURCE_WAITING,\n  LOG_SOURCE_RUNNING,\n  LOG_SOURCE_TERMINATED,\n} from '@console/internal/components/utils';\nimport { ServiceAccountModel } from '@console/internal/models';\nimport { errorModal } from '@console/internal/components/modals/error-modal';\nimport { PIPELINE_SERVICE_ACCOUNT, SecretAnnotationId } from '../components/pipelines/const';\nimport {\n  getLatestRun,\n  Pipeline,\n  PipelineRun,\n  runStatus,\n  PipelineParam,\n  PipelineRunParam,\n  PipelineTaskRef,\n  PipelineWorkspace,\n  PipelineRunWorkspace,\n} from './pipeline-augment';\nimport { pipelineFilterReducer, pipelineRunStatus } from './pipeline-filter-reducer';\n\ninterface Resources {\n  inputs?: Resource[];\n  outputs?: Resource[];\n}\n\ninterface Resource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport type ServiceAccountType = {\n  secrets: { [name: string]: string }[];\n} & K8sResourceCommon;\n\nexport interface PipelineVisualizationTaskItem {\n  name: string;\n  resources?: Resources;\n  params?: object;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n}\n\nexport const TaskStatusClassNameMap = {\n  'In Progress': 'is-running',\n  Succeeded: 'is-done',\n  Failed: 'is-error',\n  Idle: 'is-idle',\n};\n\nexport const conditions = {\n  hasFromDependency: (task: PipelineVisualizationTaskItem): boolean =>\n    task.resources &&\n    task.resources.inputs &&\n    task.resources.inputs.length > 0 &&\n    !!task.resources.inputs[0].from,\n  hasRunAfterDependency: (task: PipelineVisualizationTaskItem): boolean =>\n    task.runAfter && task.runAfter.length > 0,\n};\n\nexport enum ListFilterId {\n  Running = 'Running',\n  Failed = 'Failed',\n  Succeeded = 'Succeeded',\n  Cancelled = 'Cancelled',\n  Other = '-',\n}\n\nexport const ListFilterLabels = {\n  [ListFilterId.Running]: 'Running',\n  [ListFilterId.Failed]: 'Failed',\n  [ListFilterId.Succeeded]: 'Complete',\n  [ListFilterId.Cancelled]: 'Cancelled',\n  [ListFilterId.Other]: 'Other',\n};\n\n// to be used by both Pipeline and Pipelinerun visualisation\nconst sortTasksByRunAfterAndFrom = (\n  tasks: PipelineVisualizationTaskItem[],\n): PipelineVisualizationTaskItem[] => {\n  // check and sort tasks by 'runAfter' and 'from' dependency\n  const output = tasks;\n  for (let i = 0; i < output.length; i++) {\n    let flag = -1;\n    if (conditions.hasRunAfterDependency(output[i])) {\n      for (let j = 0; j < output.length; j++) {\n        if (i < j && output[j].taskRef.name === output[i].runAfter[output[i].runAfter.length - 1]) {\n          flag = j;\n        }\n      }\n    } else if (conditions.hasFromDependency(output[i])) {\n      for (let j = i + 1; j < output.length; j++) {\n        if (output[j].taskRef.name === output[i].resources.inputs[0].from[0]) {\n          flag = j;\n        }\n      }\n    }\n    if (flag > -1) {\n      // swap with last matching task\n      const temp = output[flag];\n      output[flag] = output[i];\n      output[i] = temp;\n    }\n  }\n  return output;\n};\n\n/**\n * Appends the pipeline run status to each tasks in the pipeline.\n * @param pipeline\n * @param pipelineRun\n */\nconst appendPipelineRunStatus = (pipeline, pipelineRun) => {\n  return _.map(pipeline.spec.tasks, (task) => {\n    if (!pipelineRun.status) {\n      return task;\n    }\n    if (pipelineRun.status && !pipelineRun.status.taskRuns && !pipelineRun.status.runs) {\n      return _.merge(task, { status: { reason: runStatus.Failed } });\n    }\n    const mTask = _.merge(task, {\n      status: _.get(_.find(pipelineRun.status.taskRuns, { pipelineTaskName: task.name }) || _.find(pipelineRun.status.runs, { pipelineTaskName: task.name }), 'status'),\n    });\n    // append task duration\n    if (mTask.status && mTask.status.completionTime && mTask.status.startTime) {\n      const date =\n        new Date(mTask.status.completionTime).getTime() -\n        new Date(mTask.status.startTime).getTime();\n      mTask.status.duration = formatDuration(date);\n    }\n    // append task status\n    if (!mTask.status) {\n      mTask.status = { reason: runStatus.Idle };\n    } else if (mTask.status && mTask.status.conditions) {\n      mTask.status.reason = pipelineRunStatus(mTask) || runStatus.Idle;\n    }\n    return mTask;\n  });\n};\n\nexport const getPipelineTasks = (\n  pipeline: K8sResourceKind,\n  pipelineRun: K8sResourceKind = {\n    apiVersion: '',\n    metadata: {},\n    kind: 'PipelineRun',\n  },\n): PipelineVisualizationTaskItem[][] => {\n  // Each unit in 'out' array is termed as stage | out = [stage1 = [task1], stage2 = [task2,task3], stage3 = [task4]]\n  const out = [];\n  if (!pipeline.spec || !pipeline.spec.tasks) {\n    return out;\n  }\n  const taskList = appendPipelineRunStatus(pipeline, pipelineRun);\n  // Step 1: Sort Tasks to get in correct order\n  const tasks = sortTasksByRunAfterAndFrom(taskList);\n\n  // Step 2: Push all nodes without any dependencies in different stages\n  tasks.forEach((task) => {\n    if (!conditions.hasFromDependency(task) && !conditions.hasRunAfterDependency(task)) {\n      if (out.length === 0) {\n        out.push([]);\n      }\n      out[0].push(task);\n    }\n  });\n\n  // Step 3: Push nodes with 'from' dependency and stack similar tasks in a stage\n  tasks.forEach((task) => {\n    if (!conditions.hasRunAfterDependency(task) && conditions.hasFromDependency(task)) {\n      let flag = out.length - 1;\n      for (let i = 0; i < out.length; i++) {\n        for (const t of out[i]) {\n          if (\n            t.taskRef.name === task.resources.inputs[0].from[0] ||\n            t.name === task.resources.inputs[0].from[0]\n          ) {\n            flag = i;\n          }\n        }\n      }\n      const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n      if (\n        nextToFlag &&\n        nextToFlag[0] &&\n        nextToFlag[0].resources &&\n        nextToFlag[0].resources.inputs &&\n        nextToFlag[0].resources.inputs[0] &&\n        nextToFlag[0].resources.inputs[0].from &&\n        nextToFlag[0].resources.inputs[0].from[0] &&\n        nextToFlag[0].resources.inputs[0].from[0] === task.resources.inputs[0].from[0]\n      ) {\n        nextToFlag.push(task);\n      } else {\n        out.splice(flag + 1, 0, [task]);\n      }\n    }\n  });\n\n  // Step 4: Push nodes with 'runAfter' dependencies and stack similar tasks in a stage\n  tasks.forEach((task) => {\n    if (conditions.hasRunAfterDependency(task)) {\n      let flag = out.length - 1;\n      for (let i = 0; i < out.length; i++) {\n        for (const t of out[i]) {\n          if (t.taskRef.name === task.runAfter[0] || t.name === task.runAfter[0]) {\n            flag = i;\n          }\n        }\n      }\n      const nextToFlag = out[flag + 1] ? out[flag + 1] : null;\n      if (\n        nextToFlag &&\n        nextToFlag[0].runAfter &&\n        nextToFlag[0].runAfter[0] &&\n        nextToFlag[0].runAfter[0] === task.runAfter[0]\n      ) {\n        nextToFlag.push(task);\n      } else {\n        out.splice(flag + 1, 0, [task]);\n      }\n    }\n  });\n  return out;\n};\n\nexport const containerToLogSourceStatus = (container: ContainerStatus): string => {\n  if (!container) {\n    return LOG_SOURCE_WAITING;\n  }\n  const { state, lastState } = container;\n  if (state.waiting && !_.isEmpty(lastState)) {\n    return LOG_SOURCE_RESTARTING;\n  }\n  if (state.waiting) {\n    return LOG_SOURCE_WAITING;\n  }\n  if (state.terminated) {\n    return LOG_SOURCE_TERMINATED;\n  }\n  return LOG_SOURCE_RUNNING;\n};\n\ntype CurrentPipelineStatus = {\n  currentPipeline: Pipeline;\n  status: string;\n};\n\n/**\n * Takes a pipeline and a series of matching pipeline runs and produces a current pipeline state.\n */\nexport const constructCurrentPipeline = (\n  pipeline: Pipeline,\n  pipelineRuns: PipelineRun[],\n): CurrentPipelineStatus => {\n  if (!pipeline || !pipelineRuns || pipelineRuns.length === 0) {\n    // Not enough data to build the current state\n    return null;\n  }\n\n  const latestRun = getLatestRun({ data: pipelineRuns }, 'creationTimestamp');\n\n  if (!latestRun) {\n    // Without the latestRun we will not have progress to show\n    return null;\n  }\n\n  const currentPipeline: Pipeline = {\n    ...pipeline,\n    latestRun,\n  };\n\n  let status: string = pipelineFilterReducer(currentPipeline);\n  if (status === '-') {\n    status = runStatus.Pending;\n  }\n\n  return {\n    currentPipeline,\n    status,\n  };\n};\n\nexport const getPipelineRunParams = (pipelineParams: PipelineParam[]): PipelineRunParam[] => {\n  return (\n    pipelineParams &&\n    pipelineParams.map((param) => ({\n      name: param.name,\n      value: param.default,\n    }))\n  );\n};\n\nexport const getPipelineRunWorkspaces = (\n  pipelineWorkspaces: PipelineWorkspace[],\n): PipelineRunWorkspace[] => {\n  return (\n    pipelineWorkspaces &&\n    pipelineWorkspaces.map((workspace) => ({\n      name: workspace.name,\n      ...workspace.data,\n    }))\n  );\n};\n\nexport const calculateRelativeTime = (startTime: string, completionTime?: string) => {\n  const start = new Date(startTime).getTime();\n  const end = completionTime ? new Date(completionTime).getTime() : new Date().getTime();\n  const secondsAgo = (end - start) / 1000;\n  const minutesAgo = secondsAgo / 60;\n  const hoursAgo = minutesAgo / 60;\n\n  if (minutesAgo > 90) {\n    const count = Math.round(hoursAgo);\n    return `about ${count} hours`;\n  }\n  if (minutesAgo > 45) {\n    return 'about an hour';\n  }\n  if (secondsAgo > 90) {\n    const count = Math.round(minutesAgo);\n    return `about ${count} minutes`;\n  }\n  if (secondsAgo > 45) {\n    return 'about a minute';\n  }\n  return 'a few seconds';\n};\n\nexport const pipelineRunDuration = (run: PipelineRun): string => {\n  const startTime = _.get(run, ['status', 'startTime'], null);\n  const completionTime = _.get(run, ['status', 'completionTime'], null);\n\n  // Duration cannot be computed if start time is missing or a completed/failed pipeline has no end time\n  if (!startTime || (!completionTime && pipelineRunStatus(run) !== 'Running')) {\n    return '-';\n  }\n  return calculateRelativeTime(startTime, completionTime);\n};\n\nexport const updateServiceAccount = (\n  secretName: string,\n  originalServiceAccount: ServiceAccountType,\n): Promise<ServiceAccountType> => {\n  const updatedServiceAccount = _.cloneDeep(originalServiceAccount);\n  updatedServiceAccount.secrets = [...updatedServiceAccount.secrets, { name: secretName }];\n  return k8sUpdate(ServiceAccountModel, updatedServiceAccount);\n};\n\nexport const associateServiceAccountToSecret = (secret: SecretKind, namespace: string) => {\n  k8sGet(ServiceAccountModel, PIPELINE_SERVICE_ACCOUNT, namespace)\n    .then((serviceAccount) => {\n      if (_.find(serviceAccount.secrets, (s) => s.name === secret.metadata.name) === undefined) {\n        updateServiceAccount(secret.metadata.name, serviceAccount);\n      }\n    })\n    .catch((err) => {\n      errorModal({ error: err.message });\n    });\n};\n\ntype KeyValuePair = {\n  key: string;\n  value: string;\n};\nexport const getSecretAnnotations = (annotation: KeyValuePair) => {\n  const annotations = {};\n  const annotationPrefix = 'tekton.dev';\n  if (annotation?.key === SecretAnnotationId.Git) {\n    annotations[`${annotationPrefix}/${SecretAnnotationId.Git}-0`] = annotation?.value;\n  } else if (annotation?.key === SecretAnnotationId.Image) {\n    annotations[`${annotationPrefix}/${SecretAnnotationId.Image}-0`] = annotation?.value;\n  }\n  return annotations;\n};\n"]}]}