{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/componentUtils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/componentUtils.ts","mtime":1617154808360},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { action } from 'mobx';\nimport { errorModal } from '@console/internal/components/modals';\nimport { Modifiers, isEdge, isNode, CREATE_CONNECTOR_DROP_TYPE, CREATE_CONNECTOR_OPERATION, withContextMenu as withTopologyContextMenu, isGraph, withDndDrop } from '@console/topology';\nimport { createConnection } from './createConnection';\nimport { removeConnection } from './removeConnection';\nimport { moveNodeToGroup } from './moveNodeToGroup';\nimport { graphContextMenu, groupContextMenu } from './nodeContextMenu';\nimport './GraphComponent.scss';\nconst MOVE_CONNECTOR_DROP_TYPE = '#moveConnector#';\nconst NODE_DRAG_TYPE = '#node#';\nconst EDGE_DRAG_TYPE = '#edge#';\nconst MOVE_CONNECTOR_OPERATION = 'moveconnector';\nconst REGROUP_OPERATION = 'regroup';\nconst canDropEdgeOnNode = (operation, edge, node) => {\n    if (edge.getSource() === node) {\n        return false;\n    }\n    if (edge.getTarget() === node) {\n        return true;\n    }\n    return !node.getTargetEdges().find(e => e.getSource() === edge.getSource());\n};\nconst highlightNode = (monitor, element) => {\n    const operation = monitor.getOperation();\n    if (!monitor.isDragging() || !operation) {\n        return false;\n    }\n    if (operation.type === CREATE_CONNECTOR_OPERATION) {\n        return (monitor.getItem() !== element &&\n            !monitor\n                .getItem()\n                .getSourceEdges()\n                .find(e => e.getTarget() === element));\n    }\n    return operation.canDropOnNode && operation.canDropOnNode(operation.type, monitor.getItem(), element);\n};\nconst nodeDragSourceSpec = (type, allowRegroup = true, canEdit = false) => ({\n    item: { type: NODE_DRAG_TYPE },\n    operation: (monitor, props) => {\n        return (canEdit || props.canEdit) && allowRegroup\n            ? {\n                [Modifiers.SHIFT]: { type: REGROUP_OPERATION, edit: true },\n            }\n            : undefined;\n    },\n    canCancel: monitor => { var _a; return ((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type) === REGROUP_OPERATION; },\n    begin: (monitor, props) => {\n        return {\n            element: props.element,\n            allowRegroup: (canEdit || props.canEdit) && allowRegroup,\n        };\n    },\n    end: (dropResult, monitor, props) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        if (!monitor.isCancelled() && ((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type) === REGROUP_OPERATION) {\n            if (monitor.didDrop() && dropResult && props && props.element.getParent() !== dropResult) {\n                const controller = props.element.getController();\n                yield moveNodeToGroup(props.element, isNode(dropResult) ? dropResult : null);\n                // perform the optimistic update in an action so as not to render too soon\n                action(() => {\n                    // FIXME: check shouldn't be necessary if we handled the async and backend data refresh correctly\n                    if (controller.getNodeById(props.element.getId())) {\n                        dropResult.appendChild(props.element);\n                    }\n                })();\n            }\n            else {\n                // cancel operation\n                return Promise.reject();\n            }\n        }\n        return undefined;\n    }),\n    collect: monitor => {\n        var _a;\n        return ({\n            dragging: monitor.isDragging(),\n            regrouping: ((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type) === REGROUP_OPERATION,\n        });\n    },\n});\nconst nodesEdgeIsDragging = (monitor, props) => {\n    if (!monitor.isDragging()) {\n        return false;\n    }\n    if (monitor.getOperation() === MOVE_CONNECTOR_OPERATION) {\n        return monitor.getItem().getSource() === props.element;\n    }\n    if (monitor.getOperation() === CREATE_CONNECTOR_OPERATION) {\n        return monitor.getItem() === props.element;\n    }\n    return false;\n};\nconst nodeDropTargetSpec = {\n    accept: [EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n    canDrop: (item, monitor, props) => {\n        var _a;\n        if (isEdge(item)) {\n            return canDropEdgeOnNode((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type, item, props.element);\n        }\n        if (item === props.element) {\n            return false;\n        }\n        return !props.element.getTargetEdges().find(e => e.getSource() === item);\n    },\n    collect: (monitor, props) => ({\n        canDrop: highlightNode(monitor, props.element),\n        dropTarget: monitor.isOver({ shallow: true }),\n        edgeDragging: nodesEdgeIsDragging(monitor, props),\n    }),\n};\nconst graphDropTargetSpec = {\n    accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n    hitTest: () => true,\n    canDrop: (item, monitor, props) => {\n        var _a;\n        return (monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) &&\n            ((((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type) === REGROUP_OPERATION &&\n                // FIXME: the hasParent check is necessary due to model updates during async actions\n                item.element.hasParent() &&\n                item.element.getParent() !== props.element) ||\n                monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE));\n    },\n    collect: monitor => {\n        const operation = monitor.getOperation();\n        const dragEditInProgress = monitor.isDragging() && ((operation === null || operation === void 0 ? void 0 : operation.type) === CREATE_CONNECTOR_OPERATION || (operation === null || operation === void 0 ? void 0 : operation.edit));\n        const dragCreate = dragEditInProgress && (monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE || monitor.getItemType() === MOVE_CONNECTOR_DROP_TYPE);\n        return {\n            dragEditInProgress,\n            dragCreate,\n            hasDropTarget: dragEditInProgress && monitor.hasDropTarget(),\n        };\n    },\n    dropHint: 'create',\n};\nconst applicationGroupDropTargetSpec = {\n    accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n    canDrop: (item, monitor) => { var _a; return monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) && (((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type) === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE); },\n    collect: monitor => {\n        var _a, _b, _c;\n        return {\n            droppable: monitor.isDragging() && ((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type) === REGROUP_OPERATION,\n            dropTarget: monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }),\n            canDrop: monitor.isDragging() && (((_b = monitor.getOperation()) === null || _b === void 0 ? void 0 : _b.type) === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n            dragRegroupable: monitor.isDragging() && ((_c = monitor.getItem()) === null || _c === void 0 ? void 0 : _c.allowRegroup),\n        };\n    },\n    dropHint: 'create',\n};\nconst edgeDragSourceSpec = (type, serviceBinding, callback, failureTitle = 'Error moving connection') => ({\n    item: { type: EDGE_DRAG_TYPE },\n    operation: { type: MOVE_CONNECTOR_OPERATION, edit: true, canDropOnNode: canDropEdgeOnNode },\n    begin: (monitor, props) => {\n        props.element.raise();\n        return props.element;\n    },\n    drag: (event, monitor, props) => {\n        props.element.setEndPoint(event.x, event.y);\n    },\n    end: (dropResult, monitor, props) => {\n        var _a;\n        props.element.setEndPoint();\n        if (monitor.didDrop() && dropResult && canDropEdgeOnNode((_a = monitor.getOperation()) === null || _a === void 0 ? void 0 : _a.type, props.element, dropResult)) {\n            callback(props.element.getSource(), dropResult, props.element.getTarget(), serviceBinding).catch(error => {\n                errorModal({ title: failureTitle, error: error.message, showIcon: true });\n            });\n        }\n    },\n    collect: monitor => ({\n        dragging: monitor.isDragging(),\n    }),\n});\nconst noDropTargetSpec = {\n    accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n    canDrop: () => {\n        return false;\n    },\n};\nconst withNoDrop = () => {\n    return withDndDrop(noDropTargetSpec);\n};\nconst withContextMenu = (actions) => {\n    return withTopologyContextMenu(actions, document.getElementById('popper-container'), 'odc-topology-context-menu');\n};\nconst createConnectorCallback = (serviceBinding) => (source, target) => {\n    if (source === target) {\n        return null;\n    }\n    if (isGraph(target)) {\n        return graphContextMenu(target, source);\n    }\n    if (target.isGroup()) {\n        return groupContextMenu(target, source);\n    }\n    createConnection(source, target, null, serviceBinding).catch(error => {\n        errorModal({ title: 'Error creating connection', error: error.message });\n    });\n    return null;\n};\nconst removeConnectorCallback = (edge) => {\n    removeConnection(edge).catch(error => {\n        errorModal({ title: 'Error removing connection', error: error.message });\n    });\n    return null;\n};\nexport { nodesEdgeIsDragging, nodeDragSourceSpec, nodeDropTargetSpec, graphDropTargetSpec, applicationGroupDropTargetSpec, edgeDragSourceSpec, noDropTargetSpec, createConnectorCallback, removeConnectorCallback, REGROUP_OPERATION, MOVE_CONNECTOR_DROP_TYPE, NODE_DRAG_TYPE, EDGE_DRAG_TYPE, withNoDrop, withContextMenu };\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/componentUtils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/componentUtils.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { action } from 'mobx';\nimport { K8sResourceKind } from '@console/internal/module/k8s';\nimport { errorModal } from '@console/internal/components/modals';\nimport { Modifiers, Edge, GraphElement, isEdge, isNode, Node, Graph, DragSourceSpec, DragObjectWithType, DropTargetSpec, DropTargetMonitor, DragSpecOperationType, CREATE_CONNECTOR_DROP_TYPE, CREATE_CONNECTOR_OPERATION, withContextMenu as withTopologyContextMenu, isGraph, withDndDrop } from '@console/topology';\nimport { createConnection } from './createConnection';\nimport { removeConnection } from './removeConnection';\nimport { moveNodeToGroup } from './moveNodeToGroup';\nimport { graphContextMenu, groupContextMenu } from './nodeContextMenu';\n\nimport './GraphComponent.scss';\n\nconst MOVE_CONNECTOR_DROP_TYPE = '#moveConnector#';\n\nconst NODE_DRAG_TYPE = '#node#';\nconst EDGE_DRAG_TYPE = '#edge#';\n\nconst MOVE_CONNECTOR_OPERATION = 'moveconnector';\nconst REGROUP_OPERATION = 'regroup';\n\ntype GraphComponentProps = {\n  element: Graph;\n};\n\ntype NodeComponentProps = {\n  element: Node;\n};\n\ntype EdgeComponentProps = {\n  element: Edge;\n};\n\n/**\n * type: the drag operation type\n * edit: true if the operation performs an edit, used to dim invalid drop targets\n * canDropOnNode: true if the drag object can be dropped on node, used to highlight valid drop nodes\n */\ntype EditableDragOperationType = {\n  type: string;\n  edit?: boolean;\n  canDropOnNode?: (operationType: string, dragElement: GraphElement, node: Node) => boolean;\n};\n\ntype DragNodeObject = {\n  element: GraphElement;\n  allowRegroup: boolean;\n};\n\nconst canDropEdgeOnNode = (operation: string, edge: Edge, node: Node): boolean => {\n  if (edge.getSource() === node) {\n    return false;\n  }\n\n  if (edge.getTarget() === node) {\n    return true;\n  }\n\n  return !node.getTargetEdges().find(e => e.getSource() === edge.getSource());\n};\n\nconst highlightNode = (monitor: DropTargetMonitor, element: Node): boolean => {\n  const operation = monitor.getOperation() as EditableDragOperationType;\n  if (!monitor.isDragging() || !operation) {\n    return false;\n  }\n\n  if (operation.type === CREATE_CONNECTOR_OPERATION) {\n    return (\n      monitor.getItem() !== element &&\n      !monitor\n        .getItem()\n        .getSourceEdges()\n        .find(e => e.getTarget() === element)\n    );\n  }\n\n  return operation.canDropOnNode && operation.canDropOnNode(operation.type, monitor.getItem(), element);\n};\n\nconst nodeDragSourceSpec = (\n  type: string,\n  allowRegroup: boolean = true,\n  canEdit: boolean = false,\n): DragSourceSpec<\n  DragObjectWithType,\n  DragSpecOperationType<EditableDragOperationType>,\n  Node,\n  {\n    dragging?: boolean;\n    regrouping?: boolean;\n  },\n  NodeComponentProps & { canEdit?: boolean }\n> => ({\n  item: { type: NODE_DRAG_TYPE },\n  operation: (monitor, props) => {\n    return (canEdit || props.canEdit) && allowRegroup\n      ? {\n          [Modifiers.SHIFT]: { type: REGROUP_OPERATION, edit: true },\n        }\n      : undefined;\n  },\n  canCancel: monitor => monitor.getOperation()?.type === REGROUP_OPERATION,\n  begin: (monitor, props): DragNodeObject => {\n    return {\n      element: props.element,\n      allowRegroup: (canEdit || props.canEdit) && allowRegroup,\n    };\n  },\n  end: async (dropResult, monitor, props) => {\n    if (!monitor.isCancelled() && monitor.getOperation()?.type === REGROUP_OPERATION) {\n      if (monitor.didDrop() && dropResult && props && props.element.getParent() !== dropResult) {\n        const controller = props.element.getController();\n        await moveNodeToGroup(props.element, isNode(dropResult) ? dropResult : null);\n\n        // perform the optimistic update in an action so as not to render too soon\n        action(() => {\n          // FIXME: check shouldn't be necessary if we handled the async and backend data refresh correctly\n          if (controller.getNodeById(props.element.getId())) {\n            dropResult.appendChild(props.element);\n          }\n        })();\n      } else {\n        // cancel operation\n        return Promise.reject();\n      }\n    }\n    return undefined;\n  },\n  collect: monitor => ({\n    dragging: monitor.isDragging(),\n    regrouping: monitor.getOperation()?.type === REGROUP_OPERATION,\n  }),\n});\n\nconst nodesEdgeIsDragging = (monitor, props) => {\n  if (!monitor.isDragging()) {\n    return false;\n  }\n  if (monitor.getOperation() === MOVE_CONNECTOR_OPERATION) {\n    return monitor.getItem().getSource() === props.element;\n  }\n  if (monitor.getOperation() === CREATE_CONNECTOR_OPERATION) {\n    return monitor.getItem() === props.element;\n  }\n  return false;\n};\n\nconst nodeDropTargetSpec: DropTargetSpec<GraphElement, any, { canDrop: boolean; dropTarget: boolean; edgeDragging: boolean }, NodeComponentProps> = {\n  accept: [EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: (item, monitor, props) => {\n    if (isEdge(item)) {\n      return canDropEdgeOnNode(monitor.getOperation()?.type, item, props.element);\n    }\n    if (item === props.element) {\n      return false;\n    }\n    return !props.element.getTargetEdges().find(e => e.getSource() === item);\n  },\n  collect: (monitor, props) => ({\n    canDrop: highlightNode(monitor, props.element),\n    dropTarget: monitor.isOver({ shallow: true }),\n    edgeDragging: nodesEdgeIsDragging(monitor, props),\n  }),\n};\n\nconst graphDropTargetSpec: DropTargetSpec<DragNodeObject, any, { dragEditInProgress: boolean }, GraphComponentProps> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  hitTest: () => true,\n  canDrop: (item, monitor, props) => {\n    return (\n      monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) &&\n      ((monitor.getOperation()?.type === REGROUP_OPERATION &&\n        // FIXME: the hasParent check is necessary due to model updates during async actions\n        item.element.hasParent() &&\n        item.element.getParent() !== props.element) ||\n        monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE)\n    );\n  },\n  collect: monitor => {\n    const operation = monitor.getOperation() as EditableDragOperationType;\n    const dragEditInProgress = monitor.isDragging() && (operation?.type === CREATE_CONNECTOR_OPERATION || operation?.edit);\n    const dragCreate = dragEditInProgress && (monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE || monitor.getItemType() === MOVE_CONNECTOR_DROP_TYPE);\n    return {\n      dragEditInProgress,\n      dragCreate,\n      hasDropTarget: dragEditInProgress && monitor.hasDropTarget(),\n    };\n  },\n  dropHint: 'create',\n};\n\nconst applicationGroupDropTargetSpec: DropTargetSpec<any, any, { droppable: boolean; dropTarget: boolean; canDrop: boolean }, any> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: (item, monitor) => monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }) && (monitor.getOperation()?.type === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n  collect: monitor => {\n    return {\n      droppable: monitor.isDragging() && monitor.getOperation()?.type === REGROUP_OPERATION,\n      dropTarget: monitor.isOver({ shallow: monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE }),\n      canDrop: monitor.isDragging() && (monitor.getOperation()?.type === REGROUP_OPERATION || monitor.getItemType() === CREATE_CONNECTOR_DROP_TYPE),\n      dragRegroupable: monitor.isDragging() && monitor.getItem()?.allowRegroup,\n    };\n  },\n  dropHint: 'create',\n};\n\nconst edgeDragSourceSpec = (type: string, serviceBinding: boolean, callback: (sourceNode: Node, targetNode: Node, replaceTargetNode?: Node, serviceBindingFlag?: boolean) => Promise<K8sResourceKind[] | K8sResourceKind>, failureTitle: string = 'Error moving connection'): DragSourceSpec<DragObjectWithType, DragSpecOperationType<EditableDragOperationType>, Node, { dragging: boolean }, EdgeComponentProps> => ({\n  item: { type: EDGE_DRAG_TYPE },\n  operation: { type: MOVE_CONNECTOR_OPERATION, edit: true, canDropOnNode: canDropEdgeOnNode },\n  begin: (monitor, props) => {\n    props.element.raise();\n    return props.element;\n  },\n  drag: (event, monitor, props) => {\n    props.element.setEndPoint(event.x, event.y);\n  },\n  end: (dropResult, monitor, props) => {\n    props.element.setEndPoint();\n    if (monitor.didDrop() && dropResult && canDropEdgeOnNode(monitor.getOperation()?.type, props.element, dropResult)) {\n      callback(props.element.getSource(), dropResult, props.element.getTarget(), serviceBinding).catch(error => {\n        errorModal({ title: failureTitle, error: error.message, showIcon: true });\n      });\n    }\n  },\n  collect: monitor => ({\n    dragging: monitor.isDragging(),\n  }),\n});\n\nconst noDropTargetSpec: DropTargetSpec<GraphElement, any, {}, { element: GraphElement }> = {\n  accept: [NODE_DRAG_TYPE, EDGE_DRAG_TYPE, CREATE_CONNECTOR_DROP_TYPE],\n  canDrop: () => {\n    return false;\n  },\n};\n\nconst withNoDrop = () => {\n  return withDndDrop<any, any, {}, NodeComponentProps>(noDropTargetSpec);\n};\n\nconst withContextMenu = <E extends GraphElement>(actions: (element: E) => React.ReactElement[]) => {\n  return withTopologyContextMenu(actions, document.getElementById('popper-container'), 'odc-topology-context-menu');\n};\n\nconst createConnectorCallback = (serviceBinding: boolean) => (source: Node, target: Node | Graph): React.ReactElement[] | null => {\n  if (source === target) {\n    return null;\n  }\n\n  if (isGraph(target)) {\n    return graphContextMenu(target, source);\n  }\n  if (target.isGroup()) {\n    return groupContextMenu(target, source);\n  }\n  createConnection(source, target, null, serviceBinding).catch(error => {\n    errorModal({ title: 'Error creating connection', error: error.message });\n  });\n  return null;\n};\n\nconst removeConnectorCallback = (edge: Edge): void => {\n  removeConnection(edge).catch(error => {\n    errorModal({ title: 'Error removing connection', error: error.message });\n  });\n  return null;\n};\n\nexport { GraphComponentProps, NodeComponentProps, EdgeComponentProps, EditableDragOperationType, DragNodeObject, nodesEdgeIsDragging, nodeDragSourceSpec, nodeDropTargetSpec, graphDropTargetSpec, applicationGroupDropTargetSpec, edgeDragSourceSpec, noDropTargetSpec, createConnectorCallback, removeConnectorCallback, REGROUP_OPERATION, MOVE_CONNECTOR_DROP_TYPE, NODE_DRAG_TYPE, EDGE_DRAG_TYPE, withNoDrop, withContextMenu };\n"]}]}