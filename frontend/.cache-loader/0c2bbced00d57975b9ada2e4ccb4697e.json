{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/label-selector.js","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/label-selector.js","mtime":1616735742510},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["/* eslint-disable guard-for-in, default-case, no-case-declarations */\n/**\n * Converted from Angular based  \"kubernetes-label-selector\"\n *    git://github.com/kubernetes-ui/label-selector.git\n *    author: Jessica Forrester <jforrest@redhat.com>\n **/\nimport * as _ from 'lodash-es';\n// selector (optional) - the JSON format as returned by k8s API, will also\n//      handle {key: null} as the key exists operator (not currently returned\n//      by API)\n// emptySelectsAll (optional) - whether a label selector with no conjuncts\n//      selects objects.  Typical behavior is false.  Example of an\n//      exceptional case is when filtering by labels, no label selectors\n//      means no filters.\nexport class LabelSelector {\n    constructor(selector, emptySelectsAll) {\n        this._conjuncts = {};\n        this._emptySelectsAll = !!emptySelectsAll;\n        // expects the JSON format as returned by k8s API\n        // Supports both the old selector syntax of just key: value pairs like on RCs\n        // as well as the new matchLabel and matchExpression syntax on newer controllers like ReplicaSets\n        // For now it will also handle key: null as key exists for backwards compatibility from before\n        // the matchExpression support was added.\n        this._OPERATOR_MAP = {\n            In: 'in',\n            NotIn: 'not in',\n            Exists: 'exists',\n            DoesNotExist: 'does not exist',\n        };\n        this._REVERSE_OPERATOR_MAP = {\n            in: 'In',\n            'not in': 'NotIn',\n            exists: 'Exists',\n            'does not exist': 'DoesNotExist',\n        };\n        if (selector) {\n            if (selector.matchLabels || selector.matchExpressions) {\n                _.forEach(selector.matchLabels, (details, key) => {\n                    this.addConjunct(key, 'in', [details]);\n                }, this);\n                _.forEach(selector.matchExpressions, (expression) => {\n                    this.addConjunct(expression.key, this._OPERATOR_MAP[expression.operator], expression.values);\n                }, this);\n            }\n            else {\n                _.forEach(selector, (details, key) => {\n                    if (details || details === '') {\n                        this.addConjunct(key, 'in', [details]);\n                    }\n                    else {\n                        this.addConjunct(key, 'exists', []);\n                    }\n                }, this);\n            }\n        }\n    }\n    addConjunct(key, operator, values) {\n        const conjunct = {\n            key,\n            operator,\n            values,\n        };\n        const id = this._getIdForConjunct(conjunct);\n        this._conjuncts[id] = conjunct;\n        conjunct.id = id;\n        conjunct.string = this._getStringForConjunct(conjunct);\n        return conjunct;\n    }\n    // Can accept either the id of the conjunct to remove, or the conjunct\n    // object that was returned from a call to addConjunct\n    removeConjunct(conjunct) {\n        if (conjunct.id) {\n            delete this._conjuncts[conjunct.id];\n        }\n        else {\n            delete this._conjuncts[conjunct];\n        }\n    }\n    clearConjuncts() {\n        this._conjuncts = {};\n    }\n    isEmpty() {\n        return _.isEmpty(this._conjuncts);\n    }\n    each(fn) {\n        _.forEach(this._conjuncts, fn);\n    }\n    select(resources) {\n        // If passed an array, return an array.\n        if (_.isArray(resources)) {\n            return _.filter(resources, _.bind(this.matches, this));\n        }\n        // Otherwise handle it as a map.\n        return _.pickBy(resources, _.bind(this.matches, this));\n    }\n    matches(resource) {\n        if (!resource) {\n            return false;\n        }\n        if (this.isEmpty()) {\n            return this._emptySelectsAll;\n        }\n        const labels = resource.metadata.labels || {};\n        for (const id in this._conjuncts) {\n            const conjunct = this._conjuncts[id];\n            switch (conjunct.operator) {\n                case 'exists':\n                    if (!labels[conjunct.key] && labels[conjunct.key] !== '') {\n                        return false;\n                    }\n                    break;\n                case 'does not exist':\n                    if (labels[conjunct.key] || labels[conjunct.key] === '') {\n                        return false;\n                    }\n                    break;\n                case 'in':\n                    let found = false;\n                    if (labels[conjunct.key] || labels[conjunct.key] === '') {\n                        for (let i = 0; !found && i < conjunct.values.length; i++) {\n                            if (labels[conjunct.key] === conjunct.values[i]) {\n                                found = true;\n                            }\n                        }\n                    }\n                    if (!found) {\n                        return false;\n                    }\n                    break;\n                case 'not in':\n                    let keep = true;\n                    if (labels[conjunct.key]) {\n                        for (let i = 0; keep && i < conjunct.values.length; i++) {\n                            keep = labels[conjunct.key] !== conjunct.values[i];\n                        }\n                    }\n                    if (!keep) {\n                        return false;\n                    }\n            }\n        }\n        return true;\n    }\n    hasConjunct(conjunct) {\n        return !!this._conjuncts[this._getIdForConjunct(conjunct)];\n    }\n    findConjunctsMatching(operator, key) {\n        return _.pickBy(this._conjuncts, _.matches({\n            operator,\n            key,\n        }));\n    }\n    // Test whether this label selector covers the given selector\n    covers(selector) {\n        if (this.isEmpty()) {\n            // TODO don't think we ever want to consider an empty\n            // label selector as covering any other label selector\n            return false;\n        }\n        return _.every(this._conjuncts, function (conjunct) {\n            // Return true immediately if we find an exact match for operator/key/values\n            if (selector.hasConjunct(conjunct)) {\n                return true;\n            }\n            // If we can't find a conjunct that matches exactly, do a more detailed check\n            switch (conjunct.operator) {\n                case 'exists':\n                    // If an Exists conjunct existed for the same key in selector it\n                    // would have passed the exact match, just need to check if an In\n                    // conjunct exists for the same key\n                    return !_.isEmpty(selector.findConjunctsMatching('in', conjunct.key));\n                case 'does not exist':\n                    // A DoesNotExist can only cover a DoesNotExist operator, if we got here\n                    // then we didn't have a DNE with the same key so we know we can't cover\n                    return false;\n                case 'in':\n                    // In (A,B,C) covers In (A,B) AND In (B,C)\n                    const inConjuncts = selector.findConjunctsMatching('in', conjunct.key);\n                    if (_.isEmpty(inConjuncts)) {\n                        return false;\n                    }\n                    return _.every(inConjuncts, function (inConjunct) {\n                        return (inConjunct.values.length === _.intersection(inConjunct.values, conjunct.values).length);\n                    });\n                case 'not in':\n                    // NotIn (A,B) covers NotIn (A,B,C) AND NotIn (A,B,D)\n                    const notInConjuncts = selector.findConjunctsMatching('not in', conjunct.key);\n                    if (_.isEmpty(notInConjuncts)) {\n                        return false;\n                    }\n                    return _.every(notInConjuncts, function (notInConjunct) {\n                        return (conjunct.values.length ===\n                            _.intersection(notInConjunct.values, conjunct.values).length);\n                    });\n            }\n            return true;\n        });\n    }\n    // Exports the labelSelector as a string in the API format, exports as matchExpressions\n    exportJSON() {\n        const result = {\n            matchExpressions: [],\n        };\n        for (const id in this._conjuncts) {\n            const conjunct = this._conjuncts[id];\n            const expression = {\n                key: conjunct.key,\n                operator: this._REVERSE_OPERATOR_MAP[conjunct.operator],\n                values: conjunct.values,\n            };\n            result.matchExpressions.push(expression);\n        }\n        return JSON.stringify(result);\n    }\n    // We assume label values have no whitespace, commas, parens, etc. based\n    // on k8s def for label values\n    _getStringForConjunct(conjunct) {\n        let conjunctString = conjunct.key;\n        if (conjunct.operator === 'exists') {\n            return `${conjunctString} exists`;\n        }\n        else if (conjunct.operator === 'does not exist') {\n            return `${conjunctString} does not exist`;\n        }\n        if (conjunct.operator === 'not in') {\n            conjunctString += ' not';\n        }\n        conjunctString += ' in (';\n        for (let i = 0; i < conjunct.values.length; i++) {\n            if (conjunct.values[i] === '') {\n                conjunctString += '\"\"';\n            }\n            else {\n                conjunctString += conjunct.values[i];\n            }\n            if (i !== conjunct.values.length - 1) {\n                conjunctString += ', ';\n            }\n        }\n        conjunctString += ')';\n        return conjunctString;\n    }\n    _getIdForConjunct(conjunct) {\n        let id = `${conjunct.key}-${conjunct.operator}`;\n        if (conjunct.values) {\n            id += `-${conjunct.values.join(',')}`;\n        }\n        return id;\n    }\n}\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/label-selector.js","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/label-selector.js"],"names":[],"mappings":"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","sourcesContent":["/* eslint-disable guard-for-in, default-case, no-case-declarations */\n\n/**\n * Converted from Angular based  \"kubernetes-label-selector\"\n *    git://github.com/kubernetes-ui/label-selector.git\n *    author: Jessica Forrester <jforrest@redhat.com>\n **/\nimport * as _ from 'lodash-es';\n// selector (optional) - the JSON format as returned by k8s API, will also\n//      handle {key: null} as the key exists operator (not currently returned\n//      by API)\n// emptySelectsAll (optional) - whether a label selector with no conjuncts\n//      selects objects.  Typical behavior is false.  Example of an\n//      exceptional case is when filtering by labels, no label selectors\n//      means no filters.\nexport class LabelSelector {\n  constructor(selector, emptySelectsAll) {\n    this._conjuncts = {};\n    this._emptySelectsAll = !!emptySelectsAll;\n    // expects the JSON format as returned by k8s API\n    // Supports both the old selector syntax of just key: value pairs like on RCs\n    // as well as the new matchLabel and matchExpression syntax on newer controllers like ReplicaSets\n    // For now it will also handle key: null as key exists for backwards compatibility from before\n    // the matchExpression support was added.\n    this._OPERATOR_MAP = {\n      In: 'in',\n      NotIn: 'not in',\n      Exists: 'exists',\n      DoesNotExist: 'does not exist',\n    };\n    this._REVERSE_OPERATOR_MAP = {\n      in: 'In',\n      'not in': 'NotIn',\n      exists: 'Exists',\n      'does not exist': 'DoesNotExist',\n    };\n    if (selector) {\n      if (selector.matchLabels || selector.matchExpressions) {\n        _.forEach(\n          selector.matchLabels,\n          (details, key) => {\n            this.addConjunct(key, 'in', [details]);\n          },\n          this,\n        );\n        _.forEach(\n          selector.matchExpressions,\n          (expression) => {\n            this.addConjunct(\n              expression.key,\n              this._OPERATOR_MAP[expression.operator],\n              expression.values,\n            );\n          },\n          this,\n        );\n      } else {\n        _.forEach(\n          selector,\n          (details, key) => {\n            if (details || details === '') {\n              this.addConjunct(key, 'in', [details]);\n            } else {\n              this.addConjunct(key, 'exists', []);\n            }\n          },\n          this,\n        );\n      }\n    }\n  }\n\n  addConjunct(key, operator, values) {\n    const conjunct = {\n      key,\n      operator,\n      values,\n    };\n    const id = this._getIdForConjunct(conjunct);\n    this._conjuncts[id] = conjunct;\n    conjunct.id = id;\n    conjunct.string = this._getStringForConjunct(conjunct);\n    return conjunct;\n  }\n\n  // Can accept either the id of the conjunct to remove, or the conjunct\n  // object that was returned from a call to addConjunct\n  removeConjunct(conjunct) {\n    if (conjunct.id) {\n      delete this._conjuncts[conjunct.id];\n    } else {\n      delete this._conjuncts[conjunct];\n    }\n  }\n  clearConjuncts() {\n    this._conjuncts = {};\n  }\n  isEmpty() {\n    return _.isEmpty(this._conjuncts);\n  }\n  each(fn) {\n    _.forEach(this._conjuncts, fn);\n  }\n  select(resources) {\n    // If passed an array, return an array.\n    if (_.isArray(resources)) {\n      return _.filter(resources, _.bind(this.matches, this));\n    }\n    // Otherwise handle it as a map.\n    return _.pickBy(resources, _.bind(this.matches, this));\n  }\n  matches(resource) {\n    if (!resource) {\n      return false;\n    }\n    if (this.isEmpty()) {\n      return this._emptySelectsAll;\n    }\n    const labels = resource.metadata.labels || {};\n    for (const id in this._conjuncts) {\n      const conjunct = this._conjuncts[id];\n      switch (conjunct.operator) {\n        case 'exists':\n          if (!labels[conjunct.key] && labels[conjunct.key] !== '') {\n            return false;\n          }\n          break;\n        case 'does not exist':\n          if (labels[conjunct.key] || labels[conjunct.key] === '') {\n            return false;\n          }\n          break;\n        case 'in':\n          let found = false;\n          if (labels[conjunct.key] || labels[conjunct.key] === '') {\n            for (let i = 0; !found && i < conjunct.values.length; i++) {\n              if (labels[conjunct.key] === conjunct.values[i]) {\n                found = true;\n              }\n            }\n          }\n          if (!found) {\n            return false;\n          }\n          break;\n        case 'not in':\n          let keep = true;\n          if (labels[conjunct.key]) {\n            for (let i = 0; keep && i < conjunct.values.length; i++) {\n              keep = labels[conjunct.key] !== conjunct.values[i];\n            }\n          }\n          if (!keep) {\n            return false;\n          }\n      }\n    }\n    return true;\n  }\n  hasConjunct(conjunct) {\n    return !!this._conjuncts[this._getIdForConjunct(conjunct)];\n  }\n  findConjunctsMatching(operator, key) {\n    return _.pickBy(\n      this._conjuncts,\n      _.matches({\n        operator,\n        key,\n      }),\n    );\n  }\n  // Test whether this label selector covers the given selector\n  covers(selector) {\n    if (this.isEmpty()) {\n      // TODO don't think we ever want to consider an empty\n      // label selector as covering any other label selector\n      return false;\n    }\n    return _.every(this._conjuncts, function(conjunct) {\n      // Return true immediately if we find an exact match for operator/key/values\n      if (selector.hasConjunct(conjunct)) {\n        return true;\n      }\n      // If we can't find a conjunct that matches exactly, do a more detailed check\n      switch (conjunct.operator) {\n        case 'exists':\n          // If an Exists conjunct existed for the same key in selector it\n          // would have passed the exact match, just need to check if an In\n          // conjunct exists for the same key\n          return !_.isEmpty(selector.findConjunctsMatching('in', conjunct.key));\n        case 'does not exist':\n          // A DoesNotExist can only cover a DoesNotExist operator, if we got here\n          // then we didn't have a DNE with the same key so we know we can't cover\n          return false;\n        case 'in':\n          // In (A,B,C) covers In (A,B) AND In (B,C)\n          const inConjuncts = selector.findConjunctsMatching('in', conjunct.key);\n          if (_.isEmpty(inConjuncts)) {\n            return false;\n          }\n          return _.every(inConjuncts, function(inConjunct) {\n            return (\n              inConjunct.values.length === _.intersection(inConjunct.values, conjunct.values).length\n            );\n          });\n        case 'not in':\n          // NotIn (A,B) covers NotIn (A,B,C) AND NotIn (A,B,D)\n          const notInConjuncts = selector.findConjunctsMatching('not in', conjunct.key);\n          if (_.isEmpty(notInConjuncts)) {\n            return false;\n          }\n          return _.every(notInConjuncts, function(notInConjunct) {\n            return (\n              conjunct.values.length ===\n              _.intersection(notInConjunct.values, conjunct.values).length\n            );\n          });\n      }\n      return true;\n    });\n  }\n\n  // Exports the labelSelector as a string in the API format, exports as matchExpressions\n  exportJSON() {\n    const result = {\n      matchExpressions: [],\n    };\n    for (const id in this._conjuncts) {\n      const conjunct = this._conjuncts[id];\n      const expression = {\n        key: conjunct.key,\n        operator: this._REVERSE_OPERATOR_MAP[conjunct.operator],\n        values: conjunct.values,\n      };\n      result.matchExpressions.push(expression);\n    }\n    return JSON.stringify(result);\n  }\n\n  // We assume label values have no whitespace, commas, parens, etc. based\n  // on k8s def for label values\n  _getStringForConjunct(conjunct) {\n    let conjunctString = conjunct.key;\n    if (conjunct.operator === 'exists') {\n      return `${conjunctString} exists`;\n    } else if (conjunct.operator === 'does not exist') {\n      return `${conjunctString} does not exist`;\n    }\n    if (conjunct.operator === 'not in') {\n      conjunctString += ' not';\n    }\n    conjunctString += ' in (';\n    for (let i = 0; i < conjunct.values.length; i++) {\n      if (conjunct.values[i] === '') {\n        conjunctString += '\"\"';\n      } else {\n        conjunctString += conjunct.values[i];\n      }\n      if (i !== conjunct.values.length - 1) {\n        conjunctString += ', ';\n      }\n    }\n    conjunctString += ')';\n\n    return conjunctString;\n  }\n\n  _getIdForConjunct(conjunct) {\n    let id = `${conjunct.key}-${conjunct.operator}`;\n    if (conjunct.values) {\n      id += `-${conjunct.values.join(',')}`;\n    }\n    return id;\n  }\n}\n"]}]}