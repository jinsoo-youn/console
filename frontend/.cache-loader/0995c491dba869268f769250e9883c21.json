{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/openapi-to-json-schema.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/openapi-to-json-schema.ts","mtime":1615298458760},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["// contains all the relevant information for transforming openapi specifications (such as kuberneres openapi)\n// to json schemas\n/**\n * Given an array of GroupVersionKind objects, return their JSON Schema representation as enums\n */\nfunction groupVersionKindToEnums(gvkObjArray) {\n    const versionEnum = [];\n    const kindEnum = [];\n    for (const gvkObj of gvkObjArray) {\n        if (gvkObj.group && gvkObj.version) {\n            versionEnum.push(`${gvkObj.group}/${gvkObj.version}`);\n        }\n        else if (gvkObj.version) {\n            versionEnum.push(gvkObj.version);\n        }\n        if (gvkObj.kind) {\n            kindEnum.push(gvkObj.kind);\n        }\n    }\n    return {\n        versionEnum,\n        kindEnum,\n    };\n}\n/**\n * Append enums to APIVersion or create the object if it doesn't exist\n */\nfunction createOrAppendAPIVersion(openAPI, apiVersionEnum) {\n    if (openAPI.apiVersion) {\n        if (openAPI.apiVersion.enum) {\n            openAPI.apiVersion.enum.push(...apiVersionEnum);\n        }\n        else {\n            openAPI.apiVersion.enum = apiVersionEnum;\n        }\n    }\n    else {\n        openAPI.apiVersion = {\n            enum: apiVersionEnum,\n        };\n    }\n}\n/**\n * Append enums to kind or create the object if it doesn't exist\n */\nfunction createOrAppendKind(openAPI, kindEnum) {\n    if (openAPI.kind) {\n        if (openAPI.kind.enum) {\n            openAPI.kind.enum.push(...kindEnum);\n        }\n        else {\n            openAPI.kind.enum = kindEnum;\n        }\n    }\n    else {\n        openAPI.kind = {\n            enum: kindEnum,\n        };\n    }\n}\n/**\n * Converts the openAPI kubernetes specification for group, version, kind to JSON Schema\n *\n * Context: The openAPI specification gives the group, version, and kind objects as 'x-kubernetes-group-version-kind'\n * instead of adding the values to the enum's\n */\nfunction convertGroupVersionKindToJSONSchema(openAPI) {\n    for (const definition in openAPI) {\n        if (openAPI.hasOwnProperty(definition)) {\n            const openAPIDefinition = openAPI[definition];\n            const groupVersionKind = openAPIDefinition['x-kubernetes-group-version-kind'];\n            // If this object has x-kubernetes-group-version-kind then add their values into correct places in JSON Schema\n            if (groupVersionKind && openAPIDefinition.properties) {\n                const gvkEnums = groupVersionKindToEnums(groupVersionKind);\n                createOrAppendAPIVersion(openAPIDefinition.properties, gvkEnums.versionEnum);\n                createOrAppendKind(openAPIDefinition.properties, gvkEnums.kindEnum);\n            }\n        }\n    }\n    return openAPI;\n}\n/**\n * Takes in the stored kubernetes openAPI object and outputs a JSON Schema of the object\n */\nexport function openAPItoJSONSchema(openAPI) {\n    if (!openAPI) {\n        return null;\n    }\n    const convertedOpenAPI = convertGroupVersionKindToJSONSchema(openAPI);\n    const oneOfSchemas = [];\n    const openAPIDefinitions = {};\n    for (const schemaProperty in convertedOpenAPI) {\n        if (convertedOpenAPI.hasOwnProperty(schemaProperty)) {\n            openAPIDefinitions[schemaProperty] = convertedOpenAPI[schemaProperty];\n            oneOfSchemas.push({\n                $ref: `#/definitions/${schemaProperty}`,\n            });\n        }\n    }\n    return {\n        definitions: Object.assign({}, openAPIDefinitions),\n        oneOf: oneOfSchemas,\n    };\n}\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/openapi-to-json-schema.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/openapi-to-json-schema.ts"],"names":[],"mappings":"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","sourcesContent":["// contains all the relevant information for transforming openapi specifications (such as kuberneres openapi)\n// to json schemas\n\ninterface GroupVersionKind {\n  kind: string;\n  version: string;\n  group: string;\n}\n\n/**\n * Given an array of GroupVersionKind objects, return their JSON Schema representation as enums\n */\nfunction groupVersionKindToEnums(gvkObjArray: [GroupVersionKind]) {\n  const versionEnum = [];\n  const kindEnum = [];\n  for (const gvkObj of gvkObjArray) {\n    if (gvkObj.group && gvkObj.version) {\n      versionEnum.push(`${gvkObj.group}/${gvkObj.version}`);\n    } else if (gvkObj.version) {\n      versionEnum.push(gvkObj.version);\n    }\n    if (gvkObj.kind) {\n      kindEnum.push(gvkObj.kind);\n    }\n  }\n  return {\n    versionEnum,\n    kindEnum,\n  };\n}\n\n/**\n * Append enums to APIVersion or create the object if it doesn't exist\n */\nfunction createOrAppendAPIVersion(openAPI, apiVersionEnum: string[]) {\n  if (openAPI.apiVersion) {\n    if (openAPI.apiVersion.enum) {\n      openAPI.apiVersion.enum.push(...apiVersionEnum);\n    } else {\n      openAPI.apiVersion.enum = apiVersionEnum;\n    }\n  } else {\n    openAPI.apiVersion = {\n      enum: apiVersionEnum,\n    };\n  }\n}\n\n/**\n * Append enums to kind or create the object if it doesn't exist\n */\nfunction createOrAppendKind(openAPI, kindEnum: string[]) {\n  if (openAPI.kind) {\n    if (openAPI.kind.enum) {\n      openAPI.kind.enum.push(...kindEnum);\n    } else {\n      openAPI.kind.enum = kindEnum;\n    }\n  } else {\n    openAPI.kind = {\n      enum: kindEnum,\n    };\n  }\n}\n\n/**\n * Converts the openAPI kubernetes specification for group, version, kind to JSON Schema\n *\n * Context: The openAPI specification gives the group, version, and kind objects as 'x-kubernetes-group-version-kind'\n * instead of adding the values to the enum's\n */\nfunction convertGroupVersionKindToJSONSchema(openAPI) {\n  for (const definition in openAPI) {\n    if (openAPI.hasOwnProperty(definition)) {\n      const openAPIDefinition = openAPI[definition];\n      const groupVersionKind = openAPIDefinition['x-kubernetes-group-version-kind'];\n\n      // If this object has x-kubernetes-group-version-kind then add their values into correct places in JSON Schema\n      if (groupVersionKind && openAPIDefinition.properties) {\n        const gvkEnums = groupVersionKindToEnums(groupVersionKind);\n        createOrAppendAPIVersion(openAPIDefinition.properties, gvkEnums.versionEnum);\n        createOrAppendKind(openAPIDefinition.properties, gvkEnums.kindEnum);\n      }\n    }\n  }\n  return openAPI;\n}\n\n/**\n * Takes in the stored kubernetes openAPI object and outputs a JSON Schema of the object\n */\nexport function openAPItoJSONSchema(openAPI) {\n  if (!openAPI) {\n    return null;\n  }\n\n  const convertedOpenAPI = convertGroupVersionKindToJSONSchema(openAPI);\n\n  const oneOfSchemas = [];\n  const openAPIDefinitions = {};\n  for (const schemaProperty in convertedOpenAPI) {\n    if (convertedOpenAPI.hasOwnProperty(schemaProperty)) {\n      openAPIDefinitions[schemaProperty] = convertedOpenAPI[schemaProperty];\n      oneOfSchemas.push({\n        $ref: `#/definitions/${schemaProperty}`,\n      });\n    }\n  }\n\n  return {\n    definitions: {\n      ...openAPIDefinitions,\n    },\n    oneOf: oneOfSchemas,\n  };\n}\n"]}]}