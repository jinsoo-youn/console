{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/topology-model.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/topology-model.ts","mtime":1617154808370},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import { createAggregateEdges } from '@console/topology';\nimport { ALL_APPLICATIONS_KEY } from '@console/shared/src';\nimport { getKnativeNodeModel, getKnativeGroupModel, getKnativeEdgeModel } from '@console/knative-plugin/src/topology/knative-topology-model';\nimport { getKubevirtGroupModel, getKubevirtNodeModel, getKubevirtEdgeModel } from '@console/kubevirt-plugin/src/topology/kubevirt-topology-model';\nimport { getHelmEdgeModel, getHelmGroupModel, getHelmNodeModel } from '../helm/helm-topology-model';\nimport { getOperatorEdgeModel, getOperatorGroupModel, getOperatorNodeModel } from '../operators/operators-topology-model';\nimport { TYPE_APPLICATION_GROUP, TYPE_AGGREGATE_EDGE, NODE_WIDTH, NODE_HEIGHT, NODE_PADDING, GROUP_WIDTH, GROUP_HEIGHT, GROUP_PADDING } from '../components/const';\nimport { dataObjectFromModel } from './transform-utils';\nconst getApplicationGroupForNode = (node, groups) => {\n    const group = groups.find(g => g.children.includes(node.id));\n    if (!group) {\n        return null;\n    }\n    if (group.type === TYPE_APPLICATION_GROUP) {\n        return group;\n    }\n    return getApplicationGroupForNode(group, groups);\n};\nexport const topologyModelFromDataModel = (dataModel, application = ALL_APPLICATIONS_KEY, filters) => {\n    const groupNodes = dataModel.graph.groups.map(d => {\n        // TODO: Change to use plugins\n        let node = getKnativeGroupModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        node = getKubevirtGroupModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        node = getHelmGroupModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        node = getOperatorGroupModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        const data = dataModel.topology[d.id] || dataObjectFromModel(d);\n        data.groupResources = d.nodes.map(id => dataModel.topology[id]);\n        return {\n            width: GROUP_WIDTH,\n            height: GROUP_HEIGHT,\n            id: d.id,\n            group: true,\n            type: d.type,\n            visible: d.type !== TYPE_APPLICATION_GROUP || application === ALL_APPLICATIONS_KEY || d.name === application,\n            collapsed: filters && d.type === TYPE_APPLICATION_GROUP && !filters.display.appGrouping,\n            data,\n            children: d.nodes,\n            label: d.name,\n            style: {\n                padding: GROUP_PADDING,\n            },\n        };\n    });\n    const nodes = dataModel.graph.nodes.map(d => {\n        // TODO: Change to use plugins\n        let node = getKnativeNodeModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        node = getKubevirtNodeModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        node = getHelmNodeModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        node = getOperatorNodeModel(d, dataModel, filters);\n        if (node) {\n            return node;\n        }\n        return {\n            width: NODE_WIDTH,\n            height: NODE_HEIGHT,\n            id: d.id,\n            type: d.type,\n            label: dataModel.topology[d.id].name,\n            data: dataModel.topology[d.id],\n            visible: true,\n            style: {\n                padding: NODE_PADDING,\n            },\n        };\n    });\n    const allNodes = [...nodes, ...groupNodes];\n    // Flag any hidden nodes\n    if (application !== ALL_APPLICATIONS_KEY) {\n        const allGroups = [...groupNodes, ...nodes.filter(n => n.group)];\n        allNodes\n            .filter(g => g.type !== TYPE_APPLICATION_GROUP)\n            .forEach(g => {\n            const group = getApplicationGroupForNode(g, allGroups);\n            const hidden = application !== ALL_APPLICATIONS_KEY && (!group || application !== group.label);\n            g.visible = !hidden;\n        });\n    }\n    // create links from data, only include those which have a valid source and target\n    const edges = dataModel.graph.edges\n        .filter(d => {\n        return allNodes.find(n => n.id === d.source) && allNodes.find(n => n.id === d.target);\n    })\n        .map((d) => {\n        // TODO: Change to use plugins\n        let edge = getKnativeEdgeModel(d, dataModel, filters);\n        if (edge) {\n            return edge;\n        }\n        edge = getKubevirtEdgeModel(d, dataModel, filters);\n        if (edge) {\n            return edge;\n        }\n        edge = getHelmEdgeModel(d, dataModel, filters);\n        if (edge) {\n            return edge;\n        }\n        edge = getOperatorEdgeModel(d, dataModel, filters);\n        if (edge) {\n            return edge;\n        }\n        return {\n            data: d,\n            source: d.source,\n            target: d.target,\n            id: `${d.source}_${d.target}`,\n            type: d.type,\n        };\n    });\n    // create topology model\n    const model = {\n        nodes: allNodes,\n        edges: createAggregateEdges(TYPE_AGGREGATE_EDGE, edges, allNodes),\n    };\n    return model;\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/topology-model.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/data-transforms/topology-model.ts"],"names":[],"mappings":"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","sourcesContent":["import { EdgeModel, Model, NodeModel, createAggregateEdges } from '@console/topology';\nimport { ALL_APPLICATIONS_KEY } from '@console/shared/src';\nimport { getKnativeNodeModel, getKnativeGroupModel, getKnativeEdgeModel } from '@console/knative-plugin/src/topology/knative-topology-model';\nimport { getKubevirtGroupModel, getKubevirtNodeModel, getKubevirtEdgeModel } from '@console/kubevirt-plugin/src/topology/kubevirt-topology-model';\nimport { getHelmEdgeModel, getHelmGroupModel, getHelmNodeModel } from '../helm/helm-topology-model';\nimport { getOperatorEdgeModel, getOperatorGroupModel, getOperatorNodeModel } from '../operators/operators-topology-model';\nimport { TopologyFilters } from '../filters';\nimport { TopologyDataModel, TopologyDataObject, Node } from '../topology-types';\nimport { TYPE_APPLICATION_GROUP, TYPE_AGGREGATE_EDGE, NODE_WIDTH, NODE_HEIGHT, NODE_PADDING, GROUP_WIDTH, GROUP_HEIGHT, GROUP_PADDING } from '../components/const';\nimport { dataObjectFromModel } from './transform-utils';\n\nconst getApplicationGroupForNode = (node: Node, groups: NodeModel[]): NodeModel => {\n  const group = groups.find(g => g.children.includes(node.id));\n  if (!group) {\n    return null;\n  }\n  if (group.type === TYPE_APPLICATION_GROUP) {\n    return group;\n  }\n  return getApplicationGroupForNode(group, groups);\n};\n\nexport const topologyModelFromDataModel = (dataModel: TopologyDataModel, application: string = ALL_APPLICATIONS_KEY, filters?: TopologyFilters): Model => {\n  const groupNodes: NodeModel[] = dataModel.graph.groups.map(d => {\n    // TODO: Change to use plugins\n    let node = getKnativeGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getKubevirtGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getHelmGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getOperatorGroupModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    const data: TopologyDataObject = dataModel.topology[d.id] || dataObjectFromModel(d);\n    data.groupResources = d.nodes.map(id => dataModel.topology[id]);\n\n    return {\n      width: GROUP_WIDTH,\n      height: GROUP_HEIGHT,\n      id: d.id,\n      group: true,\n      type: d.type,\n      visible: d.type !== TYPE_APPLICATION_GROUP || application === ALL_APPLICATIONS_KEY || d.name === application,\n      collapsed: filters && d.type === TYPE_APPLICATION_GROUP && !filters.display.appGrouping,\n      data,\n      children: d.nodes,\n      label: d.name,\n      style: {\n        padding: GROUP_PADDING,\n      },\n    };\n  });\n\n  const nodes: NodeModel[] = dataModel.graph.nodes.map(d => {\n    // TODO: Change to use plugins\n    let node = getKnativeNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getKubevirtNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getHelmNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n    node = getOperatorNodeModel(d, dataModel, filters);\n    if (node) {\n      return node;\n    }\n\n    return {\n      width: NODE_WIDTH,\n      height: NODE_HEIGHT,\n      id: d.id,\n      type: d.type,\n      label: dataModel.topology[d.id].name,\n      data: dataModel.topology[d.id],\n      visible: true,\n      style: {\n        padding: NODE_PADDING,\n      },\n    };\n  });\n\n  const allNodes = [...nodes, ...groupNodes];\n\n  // Flag any hidden nodes\n  if (application !== ALL_APPLICATIONS_KEY) {\n    const allGroups = [...groupNodes, ...nodes.filter(n => n.group)];\n    allNodes\n      .filter(g => g.type !== TYPE_APPLICATION_GROUP)\n      .forEach(g => {\n        const group = getApplicationGroupForNode(g, allGroups);\n        const hidden = application !== ALL_APPLICATIONS_KEY && (!group || application !== group.label);\n        g.visible = !hidden;\n      });\n  }\n\n  // create links from data, only include those which have a valid source and target\n  const edges = dataModel.graph.edges\n    .filter(d => {\n      return allNodes.find(n => n.id === d.source) && allNodes.find(n => n.id === d.target);\n    })\n    .map(\n      (d): EdgeModel => {\n        // TODO: Change to use plugins\n        let edge = getKnativeEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getKubevirtEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getHelmEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n        edge = getOperatorEdgeModel(d, dataModel, filters);\n        if (edge) {\n          return edge;\n        }\n\n        return {\n          data: d,\n          source: d.source,\n          target: d.target,\n          id: `${d.source}_${d.target}`,\n          type: d.type,\n        };\n      },\n    );\n\n  // create topology model\n  const model: Model = {\n    nodes: allNodes,\n    edges: createAggregateEdges(TYPE_AGGREGATE_EDGE, edges, allNodes),\n  };\n\n  return model;\n};\n"]}]}