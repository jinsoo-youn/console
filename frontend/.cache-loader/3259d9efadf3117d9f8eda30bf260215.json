{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/groups/ApplicationGroup.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/groups/ApplicationGroup.tsx","mtime":1617154808370},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as React from 'react';\nimport { polygonHull } from 'd3-polygon';\nimport * as _ from 'lodash';\nimport { Layer, NodeShape, maxPadding, observer, useCombineRefs, useHover, useDragNode, createSvgIdUrl, hullPath } from '@console/topology';\nimport * as classNames from 'classnames';\nimport { useDisplayFilters, useSearchFilter } from '../../filters';\nimport SvgBoxedText from '../../../svg/SvgBoxedText';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID, NODE_SHADOW_FILTER_ID_HOVER } from '../NodeShadows';\n// Return the point whose Y is the largest value.\n// If multiple points are found, compute the center X between them\n// export for testing only\nexport function computeLabelLocation(points) {\n    let lowPoints;\n    const threshold = 5;\n    _.forEach(points, p => {\n        const delta = !lowPoints ? Infinity : Math.round(p[1]) - Math.round(lowPoints[0][1]);\n        if (delta > threshold) {\n            lowPoints = [p];\n        }\n        else if (Math.abs(delta) <= threshold) {\n            lowPoints.push(p);\n        }\n    });\n    return [\n        (_.minBy(lowPoints, p => p[0])[0] + _.maxBy(lowPoints, p => p[0])[0]) / 2,\n        lowPoints[0][1],\n        // use the max size value\n        _.maxBy(lowPoints, p => p[2])[2],\n    ];\n}\nconst ApplicationGroup = ({ element, selected, onSelect, dndDropRef, droppable, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging }) => {\n    const [hover, hoverRef] = useHover();\n    const [labelHover, labelHoverRef] = useHover();\n    const labelLocation = React.useRef();\n    const pathRef = React.useRef();\n    const dragNodeRef = useDragNode()[1];\n    const dragLabelRef = useDragNode()[1];\n    const refs = useCombineRefs(hoverRef, dragNodeRef);\n    const [filtered] = useSearchFilter(element.getLabel());\n    const displayFilters = useDisplayFilters();\n    const showLabels = displayFilters.showLabels || hover;\n    // cast to number and coerce\n    const padding = maxPadding(element.getStyle().padding);\n    const hullPadding = (point) => (point[2] || 0) + padding;\n    if (!droppable || !pathRef.current || !labelLocation.current) {\n        const children = element.getNodes().filter(c => c.isVisible());\n        if (children.length === 0) {\n            return null;\n        }\n        const points = [];\n        _.forEach(children, c => {\n            if (c.getNodeShape() === NodeShape.circle) {\n                const bounds = c.getBounds();\n                const { width, height } = bounds;\n                const { x, y } = bounds.getCenter();\n                const radius = Math.max(width, height) / 2;\n                points.push([x, y, radius]);\n            }\n            else {\n                // add all 4 corners\n                const { width, height, x, y } = c.getBounds();\n                points.push([x, y, 0]);\n                points.push([x + width, y, 0]);\n                points.push([x, y + height, 0]);\n                points.push([x + width, y + height, 0]);\n            }\n        });\n        const hullPoints = points.length > 2 ? polygonHull(points) : points;\n        if (!hullPoints) {\n            return null;\n        }\n        // change the box only when not dragging\n        pathRef.current = hullPath(hullPoints, hullPadding);\n        // Compute the location of the group label.\n        labelLocation.current = computeLabelLocation(hullPoints);\n    }\n    return (React.createElement(\"g\", { ref: labelHoverRef, onContextMenu: onContextMenu, onClick: onSelect, className: classNames('odc-application-group', {\n            'is-dragging': dragging,\n            'is-highlight': canDrop,\n            'is-filtered': filtered,\n        }) },\n        React.createElement(NodeShadows, null),\n        React.createElement(Layer, { id: \"groups\" },\n            React.createElement(\"g\", { ref: refs, onContextMenu: onContextMenu, onClick: onSelect, className: classNames('odc-application-group', {\n                    'is-dragging': dragging,\n                    'is-highlight': canDrop,\n                    'is-selected': selected,\n                    'is-dropTarget': canDrop && dropTarget,\n                    'is-filtered': filtered,\n                }) },\n                React.createElement(\"path\", { ref: dndDropRef, className: \"odc-application-group__bg\", filter: createSvgIdUrl(hover || labelHover || dragging || contextMenuOpen || dropTarget ? NODE_SHADOW_FILTER_ID_HOVER : NODE_SHADOW_FILTER_ID), d: pathRef.current }))),\n        showLabels && (React.createElement(SvgBoxedText, { className: \"odc-application-group__label\", kind: \"application\", x: labelLocation.current[0], y: labelLocation.current[1] + hullPadding(labelLocation.current) + 24, paddingX: 8, paddingY: 5, dragRef: dragLabelRef }, element.getLabel()))));\n};\nexport default observer(ApplicationGroup);\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/groups/ApplicationGroup.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/topology/components/groups/ApplicationGroup.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { polygonHull } from 'd3-polygon';\nimport * as _ from 'lodash';\nimport { Layer, Node, PointTuple, NodeShape, NodeStyle, maxPadding, observer, useCombineRefs, useHover, useDragNode, WithDndDropProps, WithSelectionProps, WithContextMenuProps, createSvgIdUrl, hullPath } from '@console/topology';\nimport * as classNames from 'classnames';\nimport { useDisplayFilters, useSearchFilter } from '../../filters';\nimport SvgBoxedText from '../../../svg/SvgBoxedText';\nimport { NodeShadows, NODE_SHADOW_FILTER_ID, NODE_SHADOW_FILTER_ID_HOVER } from '../NodeShadows';\n\ntype ApplicationGroupProps = {\n  element: Node;\n  droppable?: boolean;\n  canDrop?: boolean;\n  dropTarget?: boolean;\n  dragging?: boolean;\n} & WithSelectionProps &\n  WithDndDropProps &\n  WithContextMenuProps;\n\ntype PointWithSize = [number, number, number];\n\n// Return the point whose Y is the largest value.\n// If multiple points are found, compute the center X between them\n// export for testing only\nexport function computeLabelLocation(points: PointWithSize[]): PointWithSize {\n  let lowPoints: PointWithSize[];\n  const threshold = 5;\n\n  _.forEach(points, p => {\n    const delta = !lowPoints ? Infinity : Math.round(p[1]) - Math.round(lowPoints[0][1]);\n    if (delta > threshold) {\n      lowPoints = [p];\n    } else if (Math.abs(delta) <= threshold) {\n      lowPoints.push(p);\n    }\n  });\n  return [\n    (_.minBy(lowPoints, p => p[0])[0] + _.maxBy(lowPoints, p => p[0])[0]) / 2,\n    lowPoints[0][1],\n    // use the max size value\n    _.maxBy(lowPoints, p => p[2])[2],\n  ];\n}\n\nconst ApplicationGroup: React.FC<ApplicationGroupProps> = ({ element, selected, onSelect, dndDropRef, droppable, canDrop, dropTarget, onContextMenu, contextMenuOpen, dragging }) => {\n  const [hover, hoverRef] = useHover();\n  const [labelHover, labelHoverRef] = useHover();\n  const labelLocation = React.useRef<PointWithSize>();\n  const pathRef = React.useRef<string>();\n  const dragNodeRef = useDragNode()[1];\n  const dragLabelRef = useDragNode()[1];\n  const refs = useCombineRefs<SVGPathElement>(hoverRef, dragNodeRef);\n  const [filtered] = useSearchFilter(element.getLabel());\n  const displayFilters = useDisplayFilters();\n  const showLabels = displayFilters.showLabels || hover;\n\n  // cast to number and coerce\n  const padding = maxPadding(element.getStyle<NodeStyle>().padding);\n  const hullPadding = (point: PointWithSize | PointTuple) => (point[2] || 0) + padding;\n\n  if (!droppable || !pathRef.current || !labelLocation.current) {\n    const children = element.getNodes().filter(c => c.isVisible());\n    if (children.length === 0) {\n      return null;\n    }\n    const points: (PointWithSize | PointTuple)[] = [];\n    _.forEach(children, c => {\n      if (c.getNodeShape() === NodeShape.circle) {\n        const bounds = c.getBounds();\n        const { width, height } = bounds;\n        const { x, y } = bounds.getCenter();\n        const radius = Math.max(width, height) / 2;\n        points.push([x, y, radius] as PointWithSize);\n      } else {\n        // add all 4 corners\n        const { width, height, x, y } = c.getBounds();\n        points.push([x, y, 0] as PointWithSize);\n        points.push([x + width, y, 0] as PointWithSize);\n        points.push([x, y + height, 0] as PointWithSize);\n        points.push([x + width, y + height, 0] as PointWithSize);\n      }\n    });\n    const hullPoints: (PointWithSize | PointTuple)[] = points.length > 2 ? polygonHull(points as PointTuple[]) : (points as PointTuple[]);\n    if (!hullPoints) {\n      return null;\n    }\n\n    // change the box only when not dragging\n    pathRef.current = hullPath(hullPoints as PointTuple[], hullPadding);\n\n    // Compute the location of the group label.\n    labelLocation.current = computeLabelLocation(hullPoints as PointWithSize[]);\n  }\n\n  return (\n    <g\n      ref={labelHoverRef}\n      onContextMenu={onContextMenu}\n      onClick={onSelect}\n      className={classNames('odc-application-group', {\n        'is-dragging': dragging,\n        'is-highlight': canDrop,\n        'is-filtered': filtered,\n      })}\n    >\n      <NodeShadows />\n      <Layer id=\"groups\">\n        <g\n          ref={refs}\n          onContextMenu={onContextMenu}\n          onClick={onSelect}\n          className={classNames('odc-application-group', {\n            'is-dragging': dragging,\n            'is-highlight': canDrop,\n            'is-selected': selected,\n            'is-dropTarget': canDrop && dropTarget,\n            'is-filtered': filtered,\n          })}\n        >\n          <path ref={dndDropRef} className=\"odc-application-group__bg\" filter={createSvgIdUrl(hover || labelHover || dragging || contextMenuOpen || dropTarget ? NODE_SHADOW_FILTER_ID_HOVER : NODE_SHADOW_FILTER_ID)} d={pathRef.current} />\n        </g>\n      </Layer>\n      {showLabels && (\n        <SvgBoxedText className=\"odc-application-group__label\" kind=\"application\" x={labelLocation.current[0]} y={labelLocation.current[1] + hullPadding(labelLocation.current) + 24} paddingX={8} paddingY={5} dragRef={dragLabelRef}>\n          {element.getLabel()}\n        </SvgBoxedText>\n      )}\n    </g>\n  );\n};\n\nexport default observer(ApplicationGroup);\n"]}]}