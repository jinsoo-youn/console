{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/createAggregateEdges.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/createAggregateEdges.ts","mtime":1615298458710},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as _ from 'lodash';\nconst getNodeParent = (nodeId, nodes) => {\n    return nodes.find((n) => { var _a; return (_a = n.children) === null || _a === void 0 ? void 0 : _a.includes(nodeId); });\n};\nconst getDisplayedNodeForNode = (nodeId, nodes) => {\n    if (!nodeId || !nodes) {\n        return '';\n    }\n    let displayedNode = nodes && nodes.find((n) => n.id === nodeId);\n    let parent = displayedNode ? getNodeParent(displayedNode.id, nodes) : null;\n    while (parent) {\n        if (parent.collapsed) {\n            displayedNode = parent;\n        }\n        parent = getNodeParent(parent.id, nodes);\n    }\n    return displayedNode ? displayedNode.id : '';\n};\nconst createAggregateEdges = (aggregateEdgeType, edges, nodes) => {\n    const aggregateEdges = [];\n    return _.reduce(edges, (newEdges, edge) => {\n        const source = getDisplayedNodeForNode(edge.source, nodes);\n        const target = getDisplayedNodeForNode(edge.target, nodes);\n        // Make sure visible is defined so that changes override what could already be in the element\n        edge.visible = 'visible' in edge ? edge.visible : true;\n        if (source !== edge.source || target !== edge.target) {\n            if (source !== target) {\n                const existing = aggregateEdges.find((e) => (e.source === source || e.source === target) &&\n                    (e.target === target || e.target === source));\n                if (existing) {\n                    // At least one other edge, add this edge and add the aggregate edge to the edges\n                    // Add this edge to the aggregate and set it not visible\n                    existing.children && existing.children.push(edge.id);\n                    edge.visible = false;\n                    // Hide edges that are depicted by this aggregate edge\n                    _.forEach(existing.children, (existingChild) => {\n                        const updateEdge = newEdges.find((newEdge) => newEdge.id === existingChild);\n                        if (updateEdge) {\n                            updateEdge.visible = false;\n                        }\n                    });\n                    // Update the aggregate edges bidirectional flag\n                    existing.data.bidirectional =\n                        existing.data.bidirectional || existing.source !== edge.source;\n                    // Check if this edge has already been added\n                    if (!newEdges.find((e) => (e.source === source || e.source === target) &&\n                        (e.target === target || e.target === source))) {\n                        newEdges.push(existing);\n                    }\n                }\n                else {\n                    const newEdge = {\n                        data: { bidirectional: false },\n                        children: [edge.id],\n                        source,\n                        target,\n                        id: `aggregate_${source}_${target}`,\n                        type: aggregateEdgeType,\n                    };\n                    aggregateEdges.push(newEdge);\n                }\n            }\n            else {\n                // Hide edges that connect to a non-visible node to its ancestor\n                edge.visible = false;\n            }\n        }\n        newEdges.push(edge);\n        return newEdges;\n    }, []);\n};\nexport { createAggregateEdges };\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/createAggregateEdges.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/createAggregateEdges.ts"],"names":[],"mappings":"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","sourcesContent":["import * as _ from 'lodash';\nimport { EdgeModel, NodeModel } from '../types';\n\nconst getNodeParent = (nodeId: string, nodes: NodeModel[]): NodeModel | undefined => {\n  return nodes.find((n) => n.children?.includes(nodeId));\n};\n\nconst getDisplayedNodeForNode = (\n  nodeId: string | undefined,\n  nodes: NodeModel[] | undefined,\n): string => {\n  if (!nodeId || !nodes) {\n    return '';\n  }\n\n  let displayedNode = nodes && nodes.find((n) => n.id === nodeId);\n  let parent = displayedNode ? getNodeParent(displayedNode.id, nodes) : null;\n  while (parent) {\n    if (parent.collapsed) {\n      displayedNode = parent;\n    }\n    parent = getNodeParent(parent.id, nodes);\n  }\n  return displayedNode ? displayedNode.id : '';\n};\n\nconst createAggregateEdges = (\n  aggregateEdgeType: string,\n  edges: EdgeModel[] | undefined,\n  nodes: NodeModel[] | undefined,\n): EdgeModel[] => {\n  const aggregateEdges: EdgeModel[] = [];\n\n  return _.reduce(\n    edges,\n    (newEdges: EdgeModel[], edge: EdgeModel) => {\n      const source = getDisplayedNodeForNode(edge.source, nodes);\n      const target = getDisplayedNodeForNode(edge.target, nodes);\n\n      // Make sure visible is defined so that changes override what could already be in the element\n      edge.visible = 'visible' in edge ? edge.visible : true;\n\n      if (source !== edge.source || target !== edge.target) {\n        if (source !== target) {\n          const existing = aggregateEdges.find(\n            (e) =>\n              (e.source === source || e.source === target) &&\n              (e.target === target || e.target === source),\n          );\n\n          if (existing) {\n            // At least one other edge, add this edge and add the aggregate edge to the edges\n\n            // Add this edge to the aggregate and set it not visible\n            existing.children && existing.children.push(edge.id);\n            edge.visible = false;\n\n            // Hide edges that are depicted by this aggregate edge\n            _.forEach(existing.children, (existingChild) => {\n              const updateEdge = newEdges.find((newEdge) => newEdge.id === existingChild);\n              if (updateEdge) {\n                updateEdge.visible = false;\n              }\n            });\n\n            // Update the aggregate edges bidirectional flag\n            existing.data.bidirectional =\n              existing.data.bidirectional || existing.source !== edge.source;\n\n            // Check if this edge has already been added\n            if (\n              !newEdges.find(\n                (e) =>\n                  (e.source === source || e.source === target) &&\n                  (e.target === target || e.target === source),\n              )\n            ) {\n              newEdges.push(existing);\n            }\n          } else {\n            const newEdge: EdgeModel = {\n              data: { bidirectional: false },\n              children: [edge.id],\n              source,\n              target,\n              id: `aggregate_${source}_${target}`,\n              type: aggregateEdgeType,\n            };\n            aggregateEdges.push(newEdge);\n          }\n        } else {\n          // Hide edges that connect to a non-visible node to its ancestor\n          edge.visible = false;\n        }\n      }\n      newEdges.push(edge);\n      return newEdges;\n    },\n    [] as EdgeModel[],\n  );\n};\n\nexport { createAggregateEdges };\n"]}]}