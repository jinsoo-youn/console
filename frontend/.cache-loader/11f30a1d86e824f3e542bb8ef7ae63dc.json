{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/useHover.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/useHover.ts","mtime":1616735742460},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as React from 'react';\nimport useCallbackRef from './useCallbackRef';\nconst useHover = (delayIn = 200, delayOut = 200) => {\n    const [hover, setHover] = React.useState(false);\n    const unmountRef = React.useRef(false);\n    // need to ensure we do not start the unset timer on unmount\n    React.useEffect(() => () => {\n        unmountRef.current = true;\n    }, []);\n    // The unset handle needs to be referred by listeners in different closures.\n    const unsetHandle = React.useRef();\n    const callbackRef = useCallbackRef(React.useCallback((node) => {\n        if (node) {\n            // store locally instead of a ref because it only needs to be referred by inner closures\n            let delayHandle;\n            const delayedStateChange = (newState, delay) => {\n                clearTimeout(unsetHandle.current);\n                clearTimeout(delayHandle);\n                if (delay != null) {\n                    delayHandle = window.setTimeout(() => {\n                        clearTimeout(unsetHandle.current);\n                        setHover(newState);\n                    }, delay);\n                }\n                else {\n                    setHover(newState);\n                }\n            };\n            const onMouseEnter = () => {\n                delayedStateChange(true, delayIn);\n            };\n            const onMouseLeave = () => {\n                delayedStateChange(false, delayOut);\n            };\n            node.addEventListener('mouseenter', onMouseEnter);\n            node.addEventListener('mouseleave', onMouseLeave);\n            return () => {\n                node.removeEventListener('mouseenter', onMouseEnter);\n                node.removeEventListener('mouseleave', onMouseLeave);\n                clearTimeout(delayHandle);\n                if (!unmountRef.current) {\n                    // Queue the unset in case reattaching to a new node in the same location.\n                    // This can happen with layers. Rendering a node to a new layer will unmount the old node\n                    // and remount a new node at the same location. This will prevent flickering and getting\n                    // stuck in a hover state.\n                    unsetHandle.current = window.setTimeout(() => setHover(false), Math.max(delayIn, delayOut));\n                }\n            };\n        }\n        return undefined;\n    }, [delayIn, delayOut]));\n    return [hover, callbackRef];\n};\nexport default useHover;\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/useHover.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/utils/useHover.ts"],"names":[],"mappings":"AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,cAAc,MAAM,kBAAkB,CAAC;AAE9C,MAAM,QAAQ,GAAG,CACf,UAAkB,GAAG,EACrB,WAAmB,GAAG,EAC4B,EAAE;IACpD,MAAM,CAAC,KAAK,EAAE,QAAQ,CAAC,GAAG,KAAK,CAAC,QAAQ,CAAU,KAAK,CAAC,CAAC;IACzD,MAAM,UAAU,GAAG,KAAK,CAAC,MAAM,CAAC,KAAK,CAAC,CAAC;IAEvC,4DAA4D;IAC5D,KAAK,CAAC,SAAS,CACb,GAAG,EAAE,CAAC,GAAG,EAAE;QACT,UAAU,CAAC,OAAO,GAAG,IAAI,CAAC;IAC5B,CAAC,EACD,EAAE,CACH,CAAC;IAEF,4EAA4E;IAC5E,MAAM,WAAW,GAAG,KAAK,CAAC,MAAM,EAAU,CAAC;IAE3C,MAAM,WAAW,GAAG,cAAc,CAChC,KAAK,CAAC,WAAW,CACf,CAAC,IAAO,EAAE,EAAE;QACV,IAAI,IAAI,EAAE;YACR,wFAAwF;YACxF,IAAI,WAAgB,CAAC;YAErB,MAAM,kBAAkB,GAAG,CAAC,QAAiB,EAAE,KAAa,EAAE,EAAE;gBAC9D,YAAY,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;gBAClC,YAAY,CAAC,WAAW,CAAC,CAAC;gBAE1B,IAAI,KAAK,IAAI,IAAI,EAAE;oBACjB,WAAW,GAAG,MAAM,CAAC,UAAU,CAAC,GAAG,EAAE;wBACnC,YAAY,CAAC,WAAW,CAAC,OAAO,CAAC,CAAC;wBAClC,QAAQ,CAAC,QAAQ,CAAC,CAAC;oBACrB,CAAC,EAAE,KAAK,CAAC,CAAC;iBACX;qBAAM;oBACL,QAAQ,CAAC,QAAQ,CAAC,CAAC;iBACpB;YACH,CAAC,CAAC;YAEF,MAAM,YAAY,GAAG,GAAG,EAAE;gBACxB,kBAAkB,CAAC,IAAI,EAAE,OAAO,CAAC,CAAC;YACpC,CAAC,CAAC;YAEF,MAAM,YAAY,GAAG,GAAG,EAAE;gBACxB,kBAAkB,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;YACtC,CAAC,CAAC;YAEF,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;YAClD,IAAI,CAAC,gBAAgB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;YAElD,OAAO,GAAG,EAAE;gBACV,IAAI,CAAC,mBAAmB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;gBACrD,IAAI,CAAC,mBAAmB,CAAC,YAAY,EAAE,YAAY,CAAC,CAAC;gBACrD,YAAY,CAAC,WAAW,CAAC,CAAC;gBAC1B,IAAI,CAAC,UAAU,CAAC,OAAO,EAAE;oBACvB,0EAA0E;oBAC1E,yFAAyF;oBACzF,wFAAwF;oBACxF,0BAA0B;oBAC1B,WAAW,CAAC,OAAO,GAAG,MAAM,CAAC,UAAU,CACrC,GAAG,EAAE,CAAC,QAAQ,CAAC,KAAK,CAAC,EACrB,IAAI,CAAC,GAAG,CAAC,OAAO,EAAE,QAAQ,CAAC,CAC5B,CAAC;iBACH;YACH,CAAC,CAAC;SACH;QACD,OAAO,SAAS,CAAC;IACnB,CAAC,EACD,CAAC,OAAO,EAAE,QAAQ,CAAC,CACpB,CACF,CAAC;IAEF,OAAO,CAAC,KAAK,EAAE,WAAW,CAAC,CAAC;AAC9B,CAAC,CAAC;AAEF,eAAe,QAAQ,CAAC","sourcesContent":["import * as React from 'react';\nimport useCallbackRef from './useCallbackRef';\n\nconst useHover = <T extends Element>(\n  delayIn: number = 200,\n  delayOut: number = 200,\n): [boolean, (node: T) => (() => void) | undefined] => {\n  const [hover, setHover] = React.useState<boolean>(false);\n  const unmountRef = React.useRef(false);\n\n  // need to ensure we do not start the unset timer on unmount\n  React.useEffect(\n    () => () => {\n      unmountRef.current = true;\n    },\n    [],\n  );\n\n  // The unset handle needs to be referred by listeners in different closures.\n  const unsetHandle = React.useRef<number>();\n\n  const callbackRef = useCallbackRef(\n    React.useCallback(\n      (node: T) => {\n        if (node) {\n          // store locally instead of a ref because it only needs to be referred by inner closures\n          let delayHandle: any;\n\n          const delayedStateChange = (newState: boolean, delay: number) => {\n            clearTimeout(unsetHandle.current);\n            clearTimeout(delayHandle);\n\n            if (delay != null) {\n              delayHandle = window.setTimeout(() => {\n                clearTimeout(unsetHandle.current);\n                setHover(newState);\n              }, delay);\n            } else {\n              setHover(newState);\n            }\n          };\n\n          const onMouseEnter = () => {\n            delayedStateChange(true, delayIn);\n          };\n\n          const onMouseLeave = () => {\n            delayedStateChange(false, delayOut);\n          };\n\n          node.addEventListener('mouseenter', onMouseEnter);\n          node.addEventListener('mouseleave', onMouseLeave);\n\n          return () => {\n            node.removeEventListener('mouseenter', onMouseEnter);\n            node.removeEventListener('mouseleave', onMouseLeave);\n            clearTimeout(delayHandle);\n            if (!unmountRef.current) {\n              // Queue the unset in case reattaching to a new node in the same location.\n              // This can happen with layers. Rendering a node to a new layer will unmount the old node\n              // and remount a new node at the same location. This will prevent flickering and getting\n              // stuck in a hover state.\n              unsetHandle.current = window.setTimeout(\n                () => setHover(false),\n                Math.max(delayIn, delayOut),\n              );\n            }\n          };\n        }\n        return undefined;\n      },\n      [delayIn, delayOut],\n    ),\n  );\n\n  return [hover, callbackRef];\n};\n\nexport default useHover;\n"]}]}