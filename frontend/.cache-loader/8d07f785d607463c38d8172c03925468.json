{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/hooks.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/hooks.ts","mtime":1616735742390},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport { k8sList } from '@console/internal/module/k8s';\nimport { ClusterTaskModel, TaskModel } from '../../../models';\nimport { createInvalidTaskListNode, createTaskListNode, handleParallelToParallelNodes, tasksToBuilderNodes, } from '../pipeline-topology/utils';\nimport { nodeTaskErrors, TaskErrorType, UpdateOperationType } from './const';\nimport { getErrorMessage } from './utils';\nexport const useTasks = (namespace) => {\n    const [namespacedTasks, setNamespacedTasks] = React.useState(null);\n    const [clusterTasks, setClusterTasks] = React.useState(null);\n    const [loadErrorMsg, setLoadErrorMsg] = React.useState(undefined);\n    React.useEffect(() => {\n        let ignore = false;\n        if (loadErrorMsg) {\n            return null;\n        }\n        if (!namespacedTasks) {\n            if (!namespace) {\n                setNamespacedTasks([]);\n            }\n            else {\n                k8sList(TaskModel, { ns: namespace })\n                    .then((res) => {\n                    if (ignore) {\n                        return;\n                    }\n                    setNamespacedTasks(res);\n                })\n                    .catch(() => {\n                    setLoadErrorMsg(`Failed to load namespace Tasks. ${loadErrorMsg || ''}`);\n                });\n            }\n        }\n        if (!clusterTasks) {\n            k8sList(ClusterTaskModel)\n                .then((res) => {\n                if (ignore) {\n                    return;\n                }\n                setClusterTasks(res);\n            })\n                .catch(() => {\n                setLoadErrorMsg(`Failed to load ClusterTasks. ${loadErrorMsg || ''}`);\n            });\n        }\n        return () => {\n            ignore = true;\n        };\n    }, [\n        namespace,\n        namespacedTasks,\n        setNamespacedTasks,\n        clusterTasks,\n        setClusterTasks,\n        setLoadErrorMsg,\n        loadErrorMsg,\n    ]);\n    return {\n        namespacedTasks,\n        clusterTasks,\n        errorMsg: loadErrorMsg,\n    };\n};\nexport const useNodes = (namespace, onTaskSelection, onUpdateTasks, taskGroup, tasksInError) => {\n    var _a;\n    const { clusterTasks, namespacedTasks, errorMsg } = useTasks(namespace);\n    const getTask = (taskRef) => {\n        if (taskRef.kind === ClusterTaskModel.kind) {\n            return clusterTasks === null || clusterTasks === void 0 ? void 0 : clusterTasks.find((task) => task.metadata.name === taskRef.name);\n        }\n        return namespacedTasks === null || namespacedTasks === void 0 ? void 0 : namespacedTasks.find((task) => task.metadata.name === taskRef.name);\n    };\n    const taskGroupRef = React.useRef(taskGroup);\n    taskGroupRef.current = taskGroup;\n    const onNewListNode = (task, direction) => {\n        const data = { direction, relatedTask: task };\n        onUpdateTasks(taskGroupRef.current, { type: UpdateOperationType.ADD_LIST_TASK, data });\n    };\n    const onNewTask = (resource, name, runAfter) => {\n        const data = { resource, name, runAfter };\n        onUpdateTasks(taskGroupRef.current, { type: UpdateOperationType.CONVERT_LIST_TO_TASK, data });\n    };\n    // TODO: Fix id collisions then remove this utility; we shouldn't need to trim the tasks\n    const noDuplicates = (resource) => !taskGroupRef.current.tasks.find((pt) => pt.name === resource.metadata.name);\n    const newListNode = (name, runAfter, firstTask) => createTaskListNode(name, {\n        namespaceTaskList: namespacedTasks === null || namespacedTasks === void 0 ? void 0 : namespacedTasks.filter(noDuplicates),\n        clusterTaskList: clusterTasks === null || clusterTasks === void 0 ? void 0 : clusterTasks.filter(noDuplicates),\n        onNewTask: (resource) => {\n            onNewTask(resource, name, runAfter);\n        },\n        onRemoveTask: firstTask\n            ? null\n            : () => {\n                onUpdateTasks(taskGroupRef.current, {\n                    type: UpdateOperationType.DELETE_LIST_TASK,\n                    data: { listTaskName: name },\n                });\n            },\n        task: {\n            name,\n            runAfter: runAfter || [],\n        },\n    });\n    const soloTask = (name = 'initial-node') => newListNode(name, undefined, true);\n    const newInvalidListNode = (name, runAfter) => createInvalidTaskListNode(name, {\n        namespaceTaskList: namespacedTasks === null || namespacedTasks === void 0 ? void 0 : namespacedTasks.filter(noDuplicates),\n        clusterTaskList: clusterTasks === null || clusterTasks === void 0 ? void 0 : clusterTasks.filter(noDuplicates),\n        onNewTask: (resource) => {\n            const data = {\n                existingName: name,\n                resource,\n                runAfter,\n            };\n            onUpdateTasks(taskGroupRef.current, {\n                type: UpdateOperationType.FIX_INVALID_LIST_TASK,\n                data,\n            });\n        },\n        onRemoveTask: () => {\n            onUpdateTasks(taskGroupRef.current, {\n                type: UpdateOperationType.REMOVE_TASK,\n                data: { taskName: name },\n            });\n        },\n        task: {\n            name,\n            runAfter: runAfter || [],\n        },\n    });\n    const invalidTaskList = taskGroup.tasks.filter((task) => !getTask(task.taskRef));\n    const validTaskList = taskGroup.tasks.filter((task) => !!getTask(task.taskRef));\n    const invalidTaskListNodes = invalidTaskList.map((task) => newInvalidListNode(task.name, task.runAfter));\n    const taskNodes = validTaskList.length > 0\n        ? tasksToBuilderNodes(validTaskList, onNewListNode, (task) => onTaskSelection(task, getTask(task.taskRef)), getErrorMessage(nodeTaskErrors, tasksInError), taskGroup.highlightedIds)\n        : [];\n    const taskListNodes = taskGroup.tasks.length === 0 && taskGroup.listTasks.length <= 1\n        ? [soloTask((_a = taskGroup.listTasks[0]) === null || _a === void 0 ? void 0 : _a.name)]\n        : taskGroup.listTasks.map((listTask) => newListNode(listTask.name, listTask.runAfter));\n    const nodes = handleParallelToParallelNodes([\n        ...taskNodes,\n        ...taskListNodes,\n        ...invalidTaskListNodes,\n    ]);\n    const localTaskCount = (namespacedTasks === null || namespacedTasks === void 0 ? void 0 : namespacedTasks.length) || 0;\n    const clusterTaskCount = (clusterTasks === null || clusterTasks === void 0 ? void 0 : clusterTasks.length) || 0;\n    return {\n        tasksCount: localTaskCount + clusterTaskCount,\n        tasksLoaded: !!namespacedTasks && !!clusterTasks,\n        loadingTasksError: errorMsg,\n        nodes,\n    };\n};\nexport const useResourceValidation = (tasks, resourceValues, onError) => {\n    const [previousErrorIds, setPreviousErrorIds] = React.useState([]);\n    React.useEffect(() => {\n        const resourceNames = resourceValues.map((r) => r.name);\n        const errors = tasks.reduce((acc, task) => {\n            var _a, _b;\n            const output = ((_a = task.resources) === null || _a === void 0 ? void 0 : _a.outputs) || [];\n            const input = ((_b = task.resources) === null || _b === void 0 ? void 0 : _b.inputs) || [];\n            const missingResources = [...output, ...input].filter((r) => !resourceNames.includes(r.resource));\n            if (missingResources.length === 0) {\n                return acc;\n            }\n            return Object.assign(Object.assign({}, acc), { [task.name]: [TaskErrorType.MISSING_RESOURCES] });\n        }, {});\n        if (!_.isEmpty(errors) || previousErrorIds.length > 0) {\n            const outputErrors = previousErrorIds.reduce((acc, id) => {\n                if (acc[id]) {\n                    // Error exists, leave it alone\n                    return acc;\n                }\n                // Error doesn't exist but we had it once, make sure it is cleared\n                return Object.assign(Object.assign({}, acc), { [id]: null });\n            }, errors);\n            const currentErrorIds = Object.keys(outputErrors).filter((id) => !!outputErrors[id]);\n            if (!_.isEqual(currentErrorIds, previousErrorIds)) {\n                setPreviousErrorIds(currentErrorIds);\n            }\n            onError(outputErrors);\n        }\n    }, [tasks, resourceValues, onError, previousErrorIds, setPreviousErrorIds]);\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/hooks.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-builder/hooks.ts"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as _ from 'lodash';\nimport { k8sList } from '@console/internal/module/k8s';\nimport { ClusterTaskModel, TaskModel } from '../../../models';\nimport {\n  PipelineResource,\n  PipelineResourceTask,\n  PipelineTask,\n  PipelineTaskRef,\n} from '../../../utils/pipeline-augment';\nimport { PipelineVisualizationTaskItem } from '../../../utils/pipeline-utils';\nimport { AddNodeDirection } from '../pipeline-topology/const';\nimport {\n  PipelineBuilderTaskNodeModel,\n  PipelineMixedNodeModel,\n  PipelineTaskListNodeModel,\n} from '../pipeline-topology/types';\nimport {\n  createInvalidTaskListNode,\n  createTaskListNode,\n  handleParallelToParallelNodes,\n  tasksToBuilderNodes,\n} from '../pipeline-topology/utils';\nimport {\n  PipelineBuilderTaskGroup,\n  SelectTaskCallback,\n  TaskErrorMap,\n  UpdateErrors,\n  UpdateOperationAddData,\n  UpdateOperationConvertToTaskData,\n  UpdateOperationFixInvalidTaskListData,\n  UpdateTasksCallback,\n} from './types';\nimport { nodeTaskErrors, TaskErrorType, UpdateOperationType } from './const';\nimport { getErrorMessage } from './utils';\n\ntype UseTasks = {\n  namespacedTasks: PipelineResourceTask[] | null;\n  clusterTasks: PipelineResourceTask[] | null;\n  errorMsg?: string;\n};\nexport const useTasks = (namespace?: string): UseTasks => {\n  const [namespacedTasks, setNamespacedTasks] = React.useState<PipelineResourceTask[]>(null);\n  const [clusterTasks, setClusterTasks] = React.useState<PipelineResourceTask[]>(null);\n  const [loadErrorMsg, setLoadErrorMsg] = React.useState<string>(undefined);\n\n  React.useEffect(() => {\n    let ignore = false;\n    if (loadErrorMsg) {\n      return null;\n    }\n\n    if (!namespacedTasks) {\n      if (!namespace) {\n        setNamespacedTasks([]);\n      } else {\n        k8sList(TaskModel, { ns: namespace })\n          .then((res: PipelineResourceTask[]) => {\n            if (ignore) {\n              return;\n            }\n            setNamespacedTasks(res);\n          })\n          .catch(() => {\n            setLoadErrorMsg(`Failed to load namespace Tasks. ${loadErrorMsg || ''}`);\n          });\n      }\n    }\n\n    if (!clusterTasks) {\n      k8sList(ClusterTaskModel)\n        .then((res: PipelineResourceTask[]) => {\n          if (ignore) {\n            return;\n          }\n          setClusterTasks(res);\n        })\n        .catch(() => {\n          setLoadErrorMsg(`Failed to load ClusterTasks. ${loadErrorMsg || ''}`);\n        });\n    }\n    return () => {\n      ignore = true;\n    };\n  }, [\n    namespace,\n    namespacedTasks,\n    setNamespacedTasks,\n    clusterTasks,\n    setClusterTasks,\n    setLoadErrorMsg,\n    loadErrorMsg,\n  ]);\n\n  return {\n    namespacedTasks,\n    clusterTasks,\n    errorMsg: loadErrorMsg,\n  };\n};\n\ntype UseNodes = {\n  nodes: PipelineMixedNodeModel[];\n  tasksCount: number;\n  tasksLoaded: boolean;\n  loadingTasksError?: string;\n};\nexport const useNodes = (\n  namespace: string,\n  onTaskSelection: SelectTaskCallback,\n  onUpdateTasks: UpdateTasksCallback,\n  taskGroup: PipelineBuilderTaskGroup,\n  tasksInError: TaskErrorMap,\n): UseNodes => {\n  const { clusterTasks, namespacedTasks, errorMsg } = useTasks(namespace);\n\n  const getTask = (taskRef: PipelineTaskRef) => {\n    if (taskRef.kind === ClusterTaskModel.kind) {\n      return clusterTasks?.find((task) => task.metadata.name === taskRef.name);\n    }\n    return namespacedTasks?.find((task) => task.metadata.name === taskRef.name);\n  };\n\n  const taskGroupRef = React.useRef(taskGroup);\n  taskGroupRef.current = taskGroup;\n\n  const onNewListNode = (task: PipelineVisualizationTaskItem, direction: AddNodeDirection) => {\n    const data: UpdateOperationAddData = { direction, relatedTask: task };\n    onUpdateTasks(taskGroupRef.current, { type: UpdateOperationType.ADD_LIST_TASK, data });\n  };\n  const onNewTask = (resource: PipelineResourceTask, name: string, runAfter?: string[]) => {\n    const data: UpdateOperationConvertToTaskData = { resource, name, runAfter };\n    onUpdateTasks(taskGroupRef.current, { type: UpdateOperationType.CONVERT_LIST_TO_TASK, data });\n  };\n\n  // TODO: Fix id collisions then remove this utility; we shouldn't need to trim the tasks\n  const noDuplicates = (resource: PipelineResourceTask) =>\n    !taskGroupRef.current.tasks.find((pt) => pt.name === resource.metadata.name);\n  const newListNode = (\n    name: string,\n    runAfter?: string[],\n    firstTask?: boolean,\n  ): PipelineTaskListNodeModel =>\n    createTaskListNode(name, {\n      namespaceTaskList: namespacedTasks?.filter(noDuplicates),\n      clusterTaskList: clusterTasks?.filter(noDuplicates),\n      onNewTask: (resource: PipelineResourceTask) => {\n        onNewTask(resource, name, runAfter);\n      },\n      onRemoveTask: firstTask\n        ? null\n        : () => {\n            onUpdateTasks(taskGroupRef.current, {\n              type: UpdateOperationType.DELETE_LIST_TASK,\n              data: { listTaskName: name },\n            });\n          },\n      task: {\n        name,\n        runAfter: runAfter || [],\n      },\n    });\n  const soloTask = (name = 'initial-node') => newListNode(name, undefined, true);\n  const newInvalidListNode = (name: string, runAfter?: string[]): PipelineTaskListNodeModel =>\n    createInvalidTaskListNode(name, {\n      namespaceTaskList: namespacedTasks?.filter(noDuplicates),\n      clusterTaskList: clusterTasks?.filter(noDuplicates),\n      onNewTask: (resource: PipelineResourceTask) => {\n        const data: UpdateOperationFixInvalidTaskListData = {\n          existingName: name,\n          resource,\n          runAfter,\n        };\n\n        onUpdateTasks(taskGroupRef.current, {\n          type: UpdateOperationType.FIX_INVALID_LIST_TASK,\n          data,\n        });\n      },\n      onRemoveTask: () => {\n        onUpdateTasks(taskGroupRef.current, {\n          type: UpdateOperationType.REMOVE_TASK,\n          data: { taskName: name },\n        });\n      },\n      task: {\n        name,\n        runAfter: runAfter || [],\n      },\n    });\n\n  const invalidTaskList = taskGroup.tasks.filter((task) => !getTask(task.taskRef));\n  const validTaskList = taskGroup.tasks.filter((task) => !!getTask(task.taskRef));\n\n  const invalidTaskListNodes: PipelineTaskListNodeModel[] = invalidTaskList.map((task) =>\n    newInvalidListNode(task.name, task.runAfter),\n  );\n  const taskNodes: PipelineBuilderTaskNodeModel[] =\n    validTaskList.length > 0\n      ? tasksToBuilderNodes(\n          validTaskList,\n          onNewListNode,\n          (task) => onTaskSelection(task, getTask(task.taskRef)),\n          getErrorMessage(nodeTaskErrors, tasksInError),\n          taskGroup.highlightedIds,\n        )\n      : [];\n  const taskListNodes: PipelineTaskListNodeModel[] =\n    taskGroup.tasks.length === 0 && taskGroup.listTasks.length <= 1\n      ? [soloTask(taskGroup.listTasks[0]?.name)]\n      : taskGroup.listTasks.map((listTask) => newListNode(listTask.name, listTask.runAfter));\n\n  const nodes: PipelineMixedNodeModel[] = handleParallelToParallelNodes([\n    ...taskNodes,\n    ...taskListNodes,\n    ...invalidTaskListNodes,\n  ]);\n\n  const localTaskCount = namespacedTasks?.length || 0;\n  const clusterTaskCount = clusterTasks?.length || 0;\n\n  return {\n    tasksCount: localTaskCount + clusterTaskCount,\n    tasksLoaded: !!namespacedTasks && !!clusterTasks,\n    loadingTasksError: errorMsg,\n    nodes,\n  };\n};\n\nexport const useResourceValidation = (\n  tasks: PipelineTask[],\n  resourceValues: PipelineResource[],\n  onError: UpdateErrors,\n) => {\n  const [previousErrorIds, setPreviousErrorIds] = React.useState([]);\n\n  React.useEffect(() => {\n    const resourceNames = resourceValues.map((r) => r.name);\n\n    const errors = tasks.reduce((acc, task) => {\n      const output = task.resources?.outputs || [];\n      const input = task.resources?.inputs || [];\n      const missingResources = [...output, ...input].filter(\n        (r) => !resourceNames.includes(r.resource),\n      );\n\n      if (missingResources.length === 0) {\n        return acc;\n      }\n\n      return {\n        ...acc,\n        [task.name]: [TaskErrorType.MISSING_RESOURCES],\n      };\n    }, {});\n\n    if (!_.isEmpty(errors) || previousErrorIds.length > 0) {\n      const outputErrors = previousErrorIds.reduce((acc, id) => {\n        if (acc[id]) {\n          // Error exists, leave it alone\n          return acc;\n        }\n\n        // Error doesn't exist but we had it once, make sure it is cleared\n        return {\n          ...acc,\n          [id]: null,\n        };\n      }, errors);\n\n      const currentErrorIds = Object.keys(outputErrors).filter((id) => !!outputErrors[id]);\n      if (!_.isEqual(currentErrorIds, previousErrorIds)) {\n        setPreviousErrorIds(currentErrorIds);\n      }\n      onError(outputErrors);\n    }\n  }, [tasks, resourceValues, onError, previousErrorIds, setPreviousErrorIds]);\n};\n"]}]}