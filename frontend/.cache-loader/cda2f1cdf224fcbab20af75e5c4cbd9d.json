{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/console-plugin-sdk/src/withExtensions.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/console-plugin-sdk/src/withExtensions.tsx","mtime":1615298458600},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import { connect } from 'react-redux';\nimport * as _ from 'lodash';\nimport { stateToFlagsObject } from '@console/internal/reducers/features';\nimport { pluginStore } from '@console/internal/plugins';\nimport { getGatingFlagNames, isExtensionInUse } from './store';\n/**\n * React higher-order component (HOC) for consuming Console extensions.\n *\n * This is semantically equivalent to `useExtensions` hook with one difference:\n * this HOC supports retrieving different extension types and providing them to\n * your component as props.\n *\n * Example usage:\n *\n * ```ts\n * import {\n *   withExtensions,\n *   NavItem,\n *   Perspective,\n *   isNavItem,\n *   isPerspective,\n * } from '@console/plugin-sdk';\n *\n * const Example = withExtensions<ExampleExtensionProps>({\n *   navItemExtensions: isNavItem,\n *   perspectiveExtensions: isPerspective,\n * })(\n *   class Example extends React.Component<ExampleOwnProps & ExampleExtensionProps> {\n *     render() {\n *       const { navItemExtensions, perspectiveExtensions } = this.props;\n *       // process extensions and render your component\n *     }\n *   },\n * );\n *\n * type ExampleExtensionProps = {\n *   navItemExtensions: NavItem[];\n *   perspectiveExtensions: Perspective[];\n * };\n * ```\n *\n * @param typeGuardMapper Object that maps prop names to extension type guards.\n * It's basically an object-based analogy to Redux `mapStateToProps` function.\n */\nexport const withExtensions = (typeGuardMapper) => {\n    const allExtensions = pluginStore.getAllExtensions();\n    // 1) Narrow extensions according to type guards\n    const matchedExtensions = _.flatMap(Object.values(typeGuardMapper).map((tg) => allExtensions.filter(tg)));\n    // 2.a) Compute flags relevant for gating matched extensions\n    const gatingFlagNames = getGatingFlagNames(matchedExtensions);\n    return connect((state) => {\n        // 2.b) Compute flags relevant for gating matched extensions\n        const gatingFlags = stateToFlagsObject(state.FLAGS, gatingFlagNames);\n        // 3) Gate matched extensions by relevant feature flags\n        const extensionsInUse = matchedExtensions.filter((e) => isExtensionInUse(e, gatingFlags));\n        return Object.keys(typeGuardMapper).reduce((props, propName) => (Object.assign(Object.assign({}, props), { [propName]: extensionsInUse.filter(typeGuardMapper[propName]) })), {});\n    }, null, null, {\n        areStatesEqual: ({ FLAGS: next }, { FLAGS: prev }) => gatingFlagNames.every((f) => next.get(f) === prev.get(f)),\n    });\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/console-plugin-sdk/src/withExtensions.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/console-plugin-sdk/src/withExtensions.tsx"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,aAAa,CAAC;AACtC,OAAO,KAAK,CAAC,MAAM,QAAQ,CAAC;AAE5B,OAAO,EAAE,kBAAkB,EAAE,MAAM,qCAAqC,CAAC;AACzE,OAAO,EAAE,WAAW,EAAE,MAAM,2BAA2B,CAAC;AACxD,OAAO,EAAE,kBAAkB,EAAE,gBAAgB,EAAE,MAAM,SAAS,CAAC;AAG/D;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;GAsCG;AACH,MAAM,CAAC,MAAM,cAAc,GAAG,CAI5B,eAA6D,EAK5D,EAAE;IACH,MAAM,aAAa,GAAG,WAAW,CAAC,gBAAgB,EAAE,CAAC;IAErD,gDAAgD;IAChD,MAAM,iBAAiB,GAAG,CAAC,CAAC,OAAO,CACjC,MAAM,CAAC,MAAM,CAAC,eAAe,CAAC,CAAC,GAAG,CAAC,CAAC,EAAE,EAAE,EAAE,CAAC,aAAa,CAAC,MAAM,CAAC,EAAE,CAAC,CAAC,CACrE,CAAC;IAEF,4DAA4D;IAC5D,MAAM,eAAe,GAAG,kBAAkB,CAAC,iBAAiB,CAAC,CAAC;IAE9D,OAAO,OAAO,CACZ,CAAC,KAAK,EAAE,EAAE;QACR,4DAA4D;QAC5D,MAAM,WAAW,GAAG,kBAAkB,CAAC,KAAK,CAAC,KAAK,EAAE,eAAe,CAAC,CAAC;QAErE,uDAAuD;QACvD,MAAM,eAAe,GAAG,iBAAiB,CAAC,MAAM,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,gBAAgB,CAAC,CAAC,EAAE,WAAW,CAAC,CAAC,CAAC;QAE1F,OAAO,MAAM,CAAC,IAAI,CAAC,eAAe,CAAC,CAAC,MAAM,CACxC,CAAC,KAAK,EAAE,QAAQ,EAAE,EAAE,CAAC,iCAChB,KAAK,KACR,CAAC,QAAQ,CAAC,EAAE,eAAe,CAAC,MAAM,CAAC,eAAe,CAAC,QAAQ,CAAC,CAAC,IAC7D,EACF,EAAE,CACgB,CAAC;IACvB,CAAC,EACD,IAAI,EACJ,IAAI,EACJ;QACE,cAAc,EAAE,CAAC,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE,KAAK,EAAE,IAAI,EAAE,EAAE,EAAE,CACnD,eAAe,CAAC,KAAK,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,KAAK,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;KAC5D,CACF,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { connect } from 'react-redux';\nimport * as _ from 'lodash';\nimport { RootState } from '@console/internal/redux';\nimport { stateToFlagsObject } from '@console/internal/reducers/features';\nimport { pluginStore } from '@console/internal/plugins';\nimport { getGatingFlagNames, isExtensionInUse } from './store';\nimport { Extension, ExtensionTypeGuard } from './typings';\n\n/**\n * React higher-order component (HOC) for consuming Console extensions.\n *\n * This is semantically equivalent to `useExtensions` hook with one difference:\n * this HOC supports retrieving different extension types and providing them to\n * your component as props.\n *\n * Example usage:\n *\n * ```ts\n * import {\n *   withExtensions,\n *   NavItem,\n *   Perspective,\n *   isNavItem,\n *   isPerspective,\n * } from '@console/plugin-sdk';\n *\n * const Example = withExtensions<ExampleExtensionProps>({\n *   navItemExtensions: isNavItem,\n *   perspectiveExtensions: isPerspective,\n * })(\n *   class Example extends React.Component<ExampleOwnProps & ExampleExtensionProps> {\n *     render() {\n *       const { navItemExtensions, perspectiveExtensions } = this.props;\n *       // process extensions and render your component\n *     }\n *   },\n * );\n *\n * type ExampleExtensionProps = {\n *   navItemExtensions: NavItem[];\n *   perspectiveExtensions: Perspective[];\n * };\n * ```\n *\n * @param typeGuardMapper Object that maps prop names to extension type guards.\n * It's basically an object-based analogy to Redux `mapStateToProps` function.\n */\nexport const withExtensions = <\n  TExtensionProps extends ExtensionProps<E>,\n  E extends Extension = Extension\n>(\n  typeGuardMapper: ExtensionTypeGuardMapper<E, TExtensionProps>,\n): (<P extends TExtensionProps>(\n  C: React.ComponentType<P>,\n) => React.ComponentType<Omit<P, keyof TExtensionProps>> & {\n  WrappedComponent: React.ComponentType<P>;\n}) => {\n  const allExtensions = pluginStore.getAllExtensions();\n\n  // 1) Narrow extensions according to type guards\n  const matchedExtensions = _.flatMap(\n    Object.values(typeGuardMapper).map((tg) => allExtensions.filter(tg)),\n  );\n\n  // 2.a) Compute flags relevant for gating matched extensions\n  const gatingFlagNames = getGatingFlagNames(matchedExtensions);\n\n  return connect<TExtensionProps, any, any, RootState>(\n    (state) => {\n      // 2.b) Compute flags relevant for gating matched extensions\n      const gatingFlags = stateToFlagsObject(state.FLAGS, gatingFlagNames);\n\n      // 3) Gate matched extensions by relevant feature flags\n      const extensionsInUse = matchedExtensions.filter((e) => isExtensionInUse(e, gatingFlags));\n\n      return Object.keys(typeGuardMapper).reduce(\n        (props, propName) => ({\n          ...props,\n          [propName]: extensionsInUse.filter(typeGuardMapper[propName]),\n        }),\n        {},\n      ) as TExtensionProps;\n    },\n    null,\n    null,\n    {\n      areStatesEqual: ({ FLAGS: next }, { FLAGS: prev }) =>\n        gatingFlagNames.every((f) => next.get(f) === prev.get(f)),\n    },\n  );\n};\n\ntype ExtensionProps<E extends Extension> = {\n  [propName: string]: E[];\n};\n\ntype ExtensionTypeGuardMapper<E extends Extension, P extends ExtensionProps<E>> = {\n  [K in keyof P]: ExtensionTypeGuard<E>;\n};\n"]}]}