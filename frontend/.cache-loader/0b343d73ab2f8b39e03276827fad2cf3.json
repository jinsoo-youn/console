{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/types.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/types.ts","mtime":1616735742510},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["export var K8sResourceConditionStatus;\n(function (K8sResourceConditionStatus) {\n    K8sResourceConditionStatus[\"True\"] = \"True\";\n    K8sResourceConditionStatus[\"False\"] = \"False\";\n    K8sResourceConditionStatus[\"Unknown\"] = \"Unknown\";\n})(K8sResourceConditionStatus || (K8sResourceConditionStatus = {}));\nexport var ImagePullPolicy;\n(function (ImagePullPolicy) {\n    ImagePullPolicy[\"Always\"] = \"Always\";\n    ImagePullPolicy[\"Never\"] = \"Never\";\n    ImagePullPolicy[\"IfNotPresent\"] = \"IfNotPresent\";\n})(ImagePullPolicy || (ImagePullPolicy = {}));\nexport var MachineConfigPoolConditionType;\n(function (MachineConfigPoolConditionType) {\n    MachineConfigPoolConditionType[\"Updated\"] = \"Updated\";\n    MachineConfigPoolConditionType[\"Updating\"] = \"Updating\";\n    MachineConfigPoolConditionType[\"Degraded\"] = \"Degraded\";\n})(MachineConfigPoolConditionType || (MachineConfigPoolConditionType = {}));\nexport var ClusterVersionConditionType;\n(function (ClusterVersionConditionType) {\n    ClusterVersionConditionType[\"Available\"] = \"Available\";\n    ClusterVersionConditionType[\"Failing\"] = \"Failing\";\n    ClusterVersionConditionType[\"Progressing\"] = \"Progressing\";\n    ClusterVersionConditionType[\"RetrievedUpdates\"] = \"RetrievedUpdates\";\n    ClusterVersionConditionType[\"Invalid\"] = \"Invalid\";\n})(ClusterVersionConditionType || (ClusterVersionConditionType = {}));\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/types.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/module/k8s/types.ts"],"names":[],"mappings":"AAgDA,MAAM,CAAN,IAAY,0BAIX;AAJD,WAAY,0BAA0B;IACpC,2CAAa,CAAA;IACb,6CAAe,CAAA;IACf,iDAAmB,CAAA;AACrB,CAAC,EAJW,0BAA0B,KAA1B,0BAA0B,QAIrC;AAsKD,MAAM,CAAN,IAAY,eAIX;AAJD,WAAY,eAAe;IACzB,oCAAiB,CAAA;IACjB,kCAAe,CAAA;IACf,gDAA6B,CAAA;AAC/B,CAAC,EAJW,eAAe,KAAf,eAAe,QAI1B;AAobD,MAAM,CAAN,IAAY,8BAIX;AAJD,WAAY,8BAA8B;IACxC,qDAAmB,CAAA;IACnB,uDAAqB,CAAA;IACrB,uDAAqB,CAAA;AACvB,CAAC,EAJW,8BAA8B,KAA9B,8BAA8B,QAIzC;AA4CD,MAAM,CAAN,IAAY,2BAMX;AAND,WAAY,2BAA2B;IACrC,sDAAuB,CAAA;IACvB,kDAAmB,CAAA;IACnB,0DAA2B,CAAA;IAC3B,oEAAqC,CAAA;IACrC,kDAAmB,CAAA;AACrB,CAAC,EANW,2BAA2B,KAA3B,2BAA2B,QAMtC","sourcesContent":["import { JSONSchema6 } from 'json-schema';\nimport { BadgeType, NodeAddress } from '@console/shared';\nimport { EventInvolvedObject } from './event';\n\nexport type OwnerReference = {\n  name: string;\n  kind: string;\n  uid: string;\n  apiVersion: string;\n  controller?: boolean;\n  blockOwnerDeletion?: boolean;\n};\n\nexport type ObjectReference = {\n  kind?: string;\n  namespace?: string;\n  name?: string;\n  uid?: string;\n  apiVersion?: string;\n  resourceVersion?: string;\n  fieldPath?: string;\n};\n\nexport type ObjectMetadata = {\n  annotations?: { [key: string]: string };\n  clusterName?: string;\n  creationTimestamp?: string;\n  deletionGracePeriodSeconds?: number;\n  deletionTimestamp?: string;\n  finalizers?: string[];\n  generateName?: string;\n  generation?: number;\n  labels?: { [key: string]: string };\n  managedFields?: any[];\n  name?: string;\n  namespace?: string;\n  ownerReferences?: OwnerReference[];\n  resourceVersion?: string;\n  selfLink?: string;\n  uid?: string;\n};\n\nexport type PartialObjectMetadata = {\n  apiVersion: string;\n  kind: string;\n  metadata: ObjectMetadata;\n};\n\nexport enum K8sResourceConditionStatus {\n  True = 'True',\n  False = 'False',\n  Unknown = 'Unknown',\n}\n\nexport type K8sResourceCondition = {\n  type: string;\n  status: keyof typeof K8sResourceConditionStatus;\n  lastTransitionTime?: string;\n  reason?: string;\n  message?: string;\n};\n\nexport type MatchExpression = {\n  key: string;\n  operator: 'Exists' | 'DoesNotExist' | 'In' | 'NotIn' | 'Equals' | 'NotEqual';\n  values?: string[];\n  value?: string;\n};\n\nexport type MatchLabels = {\n  [key: string]: string;\n};\n\nexport type Selector = {\n  matchLabels?: MatchLabels;\n  matchExpressions?: MatchExpression[];\n};\n\nexport type TaintEffect = '' | 'NoSchedule' | 'PreferNoSchedule' | 'NoExecute';\n\nexport type Taint = {\n  key: string;\n  value: string;\n  effect: TaintEffect;\n};\n\nexport type TolerationOperator = 'Exists' | 'Equal';\n\nexport type Toleration = {\n  effect: TaintEffect;\n  key?: string;\n  operator: TolerationOperator;\n  tolerationSeconds?: number;\n  value?: string;\n};\n\n// Properties common to (almost) all Kubernetes resources.\nexport type K8sResourceCommon = {\n  apiVersion?: string;\n  kind?: string;\n  metadata?: ObjectMetadata;\n};\n\n// Generic, unknown kind. Avoid when possible since it allows any key in spec\n// or status, weakening type checking.\nexport type K8sResourceKind = K8sResourceCommon & {\n  spec?: {\n    selector?: Selector | MatchLabels;\n    [key: string]: any;\n  };\n  status?: { [key: string]: any };\n  type?: { [key: string]: any };\n  data?: { [key: string]: any };\n  specLimit?: any;\n  resourceName?: any;\n};\n\nexport type VolumeMount = {\n  mountPath: string;\n  mountPropagation?: 'None' | 'HostToContainer' | 'Bidirectional';\n  name: string;\n  readOnly?: boolean;\n  subPath?: string;\n  subPathExpr?: string;\n};\n\ntype ProbePort = string | number;\n\nexport type ExecProbe = {\n  command: string[];\n};\n\nexport type HTTPGetProbe = {\n  path?: string;\n  port: ProbePort;\n  host?: string;\n  scheme: 'HTTP' | 'HTTPS';\n  httpHeaders?: any[];\n};\n\nexport type TCPSocketProbe = {\n  port: ProbePort;\n  host?: string;\n};\n\nexport type Handler = {\n  exec?: ExecProbe;\n  httpGet?: HTTPGetProbe;\n  tcpSocket?: TCPSocketProbe;\n};\n\nexport type ContainerProbe = {\n  initialDelaySeconds?: number;\n  timeoutSeconds?: number;\n  periodSeconds?: number;\n  successThreshold?: number;\n  failureThreshold?: number;\n} & Handler;\n\nexport type ContainerLifecycleStage = 'postStart' | 'preStop';\n\nexport type ContainerLifecycle = {\n  postStart?: Handler;\n  preStop?: Handler;\n};\n\nexport type ResourceList = {\n  [resourceName: string]: string;\n};\n\nexport type EnvVarSource = {\n  fieldRef?: {\n    apiVersion?: string;\n    fieldPath: string;\n  };\n  resourceFieldRef?: {\n    resource: string;\n    containerName?: string;\n    divisor?: string;\n  };\n  configMapKeyRef?: {\n    key: string;\n    name: string;\n  };\n  secretKeyRef?: {\n    key: string;\n    name: string;\n  };\n  configMapRef?: {\n    key?: string;\n    name: string;\n  };\n  secretRef?: {\n    key?: string;\n    name: string;\n  };\n  configMapSecretRef?: {\n    key?: string;\n    name: string;\n  };\n  serviceAccountRef?: {\n    key?: string;\n    name: string;\n  };\n};\n\nexport type EnvVar = {\n  name: string;\n  value?: string;\n  valueFrom?: EnvVarSource;\n};\n\nexport type ContainerPort = {\n  name?: string;\n  containerPort: number;\n  protocol: string;\n};\n\nexport enum ImagePullPolicy {\n  Always = 'Always',\n  Never = 'Never',\n  IfNotPresent = 'IfNotPresent',\n}\n\nexport type NodeAffinity = {\n  preferredDuringSchedulingIgnoredDuringExecution?: {\n    preference: Selector;\n    weight: number;\n  }[];\n  requiredDuringSchedulingIgnoredDuringExecution?: {\n    nodeSelectorTerms: Selector[];\n  };\n};\n\nexport type PodAffinityTerm = {\n  labelSelector?: Selector;\n  namespaces?: string[];\n  topologyKey: string;\n};\n\nexport type PodAffinity = {\n  preferredDuringSchedulingIgnoredDuringExecution: {\n    podAffinityTerm: PodAffinityTerm;\n    weight?: number;\n  }[];\n  requiredDuringSchedulingIgnoredDuringExecution: PodAffinityTerm[];\n};\n\nexport type ContainerSpec = {\n  name: string;\n  volumeMounts?: VolumeMount[];\n  env?: EnvVar[];\n  livenessProbe?: ContainerProbe;\n  readinessProbe?: ContainerProbe;\n  lifecycle?: ContainerLifecycle;\n  resources?: {\n    limits?: ResourceList;\n    requested?: ResourceList;\n  };\n  ports?: ContainerPort[];\n  imagePullPolicy?: ImagePullPolicy;\n  [key: string]: any;\n};\n\nexport type Volume = {\n  name: string;\n  [key: string]: any;\n};\n\nexport type PodSpec = {\n  volumes?: Volume[];\n  initContainers?: ContainerSpec[];\n  containers: ContainerSpec[];\n  restartPolicy?: 'Always' | 'OnFailure' | 'Never';\n  terminationGracePeriodSeconds?: number;\n  activeDeadlineSeconds?: number;\n  nodeSelector?: any;\n  serviceAccountName?: string;\n  priorityClassName?: string;\n  tolerations?: Toleration[];\n  nodeName?: string;\n  hostname?: string;\n  [key: string]: any;\n};\n\n// https://github.com/kubernetes/api/blob/release-1.16/core/v1/types.go#L2411-L2432\ntype PodPhase = 'Pending' | 'Running' | 'Succeeded' | 'Failed' | 'Unknown';\n\ntype ContainerStateValue = {\n  reason?: string;\n  [key: string]: any;\n};\n\nexport type ContainerState = {\n  waiting?: ContainerStateValue;\n  running?: ContainerStateValue;\n  terminated?: ContainerStateValue;\n};\n\nexport type ContainerStatus = {\n  name: string;\n  state?: ContainerState;\n  lastState?: ContainerState;\n  ready: boolean;\n  restartCount: number;\n  image: string;\n  imageID: string;\n  containerID?: string;\n};\n\nexport type PodCondition = {\n  lastProbeTime?: string;\n} & K8sResourceCondition;\n\nexport type PodStatus = {\n  phase: PodPhase;\n  conditions?: PodCondition[];\n  message?: string;\n  reason?: string;\n  startTime?: string;\n  initContainerStatuses?: ContainerStatus[];\n  containerStatuses?: ContainerStatus[];\n  [key: string]: any;\n};\n\nexport type PodTemplate = {\n  metadata: ObjectMetadata;\n  spec: PodSpec;\n};\n\nexport type PodKind = {\n  status?: PodStatus;\n} & K8sResourceCommon &\n  PodTemplate;\n\nexport type DeploymentCondition = {\n  lastUpdateTime?: string;\n} & K8sResourceCondition;\n\nexport type DeploymentKind = {\n  spec: {\n    minReadySeconds?: number;\n    paused?: boolean;\n    progressDeadlineSeconds?: number;\n    replicas?: number;\n    revisionHistoryLimit?: number;\n    selector: Selector;\n    strategy?: {\n      rollingUpdate?: {\n        maxSurge: number | string;\n        maxUnavailable: number | string;\n      };\n      type?: string;\n    };\n    template: PodTemplate;\n  };\n  status?: {\n    availableReplicas?: number;\n    collisionCount?: number;\n    conditions?: DeploymentCondition[];\n    observedGeneration?: number;\n    readyReplicas?: number;\n    replicas?: number;\n    unavailableReplicas?: number;\n    updatedReplicas?: number;\n  };\n} & K8sResourceCommon;\n\nexport type StorageClassResourceKind = {\n  provisioner: string;\n  reclaimPolicy: string;\n} & K8sResourceCommon;\n\nexport type NodeCondition = {\n  lastHeartbeatTime?: string;\n} & K8sResourceCondition;\n\nexport type NodeKind = {\n  spec: {\n    taints?: Taint[];\n    unschedulable?: boolean;\n  };\n  status?: {\n    capacity?: {\n      [key: string]: string;\n    };\n    conditions?: NodeCondition[];\n    images?: {\n      names: string[];\n      sizeBytes?: number;\n    }[];\n    phase?: string;\n  };\n} & K8sResourceCommon;\n\nexport type ConfigMapKind = {\n  data?: { [key: string]: string };\n  binaryData?: { [key: string]: string };\n} & K8sResourceCommon;\n\nexport type JobTemplate = {\n  metadata: ObjectMetadata;\n  spec: {\n    activeDeadlineSeconds?: number;\n    backoffLimit?: number;\n    completions?: number;\n    manualSelector?: boolean;\n    parallelism?: boolean;\n    selector?: Selector;\n    template: PodTemplate;\n    ttlSecondsAfterFinished?: number;\n  };\n};\n\nexport type JobKind = {\n  apiVersion: string;\n  kind: string;\n  status: {\n    active?: number;\n    completionTime?: string;\n    conditions?: K8sResourceCondition[];\n    failed?: number;\n    startTime?: string;\n    succeeded?: number;\n  };\n} & JobTemplate;\n\nexport type CronJobKind = {\n  apiVersion: string;\n  kind: string;\n  metadata: ObjectMetadata;\n  spec: {\n    concurrencyPolicy?: string;\n    failedJobsHistoryLimit?: number;\n    jobTemplate: JobTemplate;\n    schedule: string;\n    startingDeadlineSeconds?: number;\n    successfulJobsHistoryLimit?: number;\n    suspend?: boolean;\n  };\n  status: {\n    active?: {\n      apiVersion?: string;\n      fieldPath?: string;\n      kind?: string;\n      name?: string;\n      namespace?: string;\n      resourceVersion?: string;\n      uid?: string;\n    }[];\n    lastScheduleTime?: string;\n  };\n};\n\nexport type CRDVersion = {\n  name: string;\n  served: boolean;\n  storage: boolean;\n};\n\nexport type CustomResourceDefinitionKind = {\n  spec: {\n    version: string;\n    group: string;\n    names: {\n      kind: string;\n      singular: string;\n      plural: string;\n      listKind: string;\n      shortNames?: string[];\n    };\n    scope?: 'Namespaced';\n    validation?: {\n      // NOTE: Actually a subset of JSONSchema, but using this type for convenience\n      openAPIV3Schema: JSONSchema6;\n    };\n    versions?: CRDVersion[];\n  };\n  status?: {\n    conditions?: K8sResourceCondition[];\n  };\n} & K8sResourceCommon;\n\nexport type RouteTarget = {\n  kind: 'Service';\n  name: string;\n  weight: number;\n};\n\nexport type RouteTLS = {\n  caCertificate?: string;\n  certificate?: string;\n  destinationCACertificate?: string;\n  insecureEdgeTerminationPolicy?: string;\n  key?: string;\n  termination: string;\n};\n\nexport type RouteIngress = {\n  conditions: K8sResourceCondition[];\n  host?: string;\n  routerCanonicalHostname?: string;\n  routerName?: string;\n  wildcardPolicy?: string;\n};\n\nexport type RouteKind = {\n  spec: {\n    alternateBackends?: RouteTarget[];\n    host?: string;\n    path?: string;\n    port?: {\n      targetPort: number | string;\n    };\n    subdomain?: string;\n    tls?: RouteTLS;\n    to: RouteTarget;\n    wildcardPolicy?: string;\n  };\n  status?: {\n    ingress: RouteIngress[];\n  };\n} & K8sResourceCommon;\n\nexport type TemplateParameter = {\n  name: string;\n  value?: string;\n  displayName?: string;\n  description?: string;\n  generate?: string;\n  required?: boolean;\n};\n\nexport type TemplateKind = {\n  message?: string;\n  objects: any[];\n  parameters: TemplateParameter[];\n  labels?: any[];\n} & K8sResourceCommon;\n\ntype TemplateInstanceObject = {\n  ref: ObjectReference;\n};\n\nexport type TemplateInstanceKind = {\n  spec: {\n    template: TemplateKind;\n    secret: {\n      name: string;\n    };\n    requester?: {\n      username?: string;\n      uid?: string;\n      groups?: string[];\n      extra?: any;\n    };\n  };\n  status?: {\n    conditions: K8sResourceCondition[];\n    objects: TemplateInstanceObject[];\n  };\n} & K8sResourceCommon;\n\nexport type MachineAWSPlacement = {\n  availabilityZone?: string;\n  region?: string;\n};\n\nexport type MachineSpec = {\n  providerSpec: {\n    value?: {\n      placement?: MachineAWSPlacement;\n    };\n  };\n  versions: {\n    kubelet: string;\n  };\n  [key: string]: any;\n};\n\nexport type MachineKind = {\n  spec: MachineSpec;\n  status?: {\n    phase?: string;\n    addresses: NodeAddress[];\n    lastUpdated: string;\n    nodeRef: {\n      kind: string;\n      name: string;\n      uid: string;\n    };\n    providerStatus: {\n      kind: string;\n      conditions?: K8sResourceCondition[];\n      [key: string]: any;\n    };\n  };\n} & K8sResourceCommon;\n\nexport type MachineSetKind = {\n  spec: {\n    replicas: number;\n    selector: any;\n    template: {\n      spec: MachineSpec;\n    };\n  };\n  status?: {\n    availableReplicas: number;\n    fullyLabeledReplicas: number;\n    readyReplicas: number;\n    replicas: number;\n  };\n} & K8sResourceCommon;\n\nexport type Patch = {\n  op: string;\n  path: string;\n  value?: any;\n};\n\nexport type RollingUpdate = { maxUnavailable?: number | string; maxSurge?: number | string };\nexport type DeploymentUpdateStrategy =\n  | {\n      type: 'Recreate';\n    }\n  | {\n      type: 'RollingUpdate';\n      rollingUpdate: RollingUpdate;\n    };\n\nexport type MachineDeploymentKind = {\n  spec: {\n    replicas: number;\n    selector: Selector;\n    template: {\n      spec: MachineSpec;\n    };\n    paused?: boolean;\n    minReadySeconds?: number;\n    progressDeadlineSeconds?: number;\n    strategy: DeploymentUpdateStrategy;\n  };\n  status?: {\n    availableReplicas: number;\n    unavailableReplicas: number;\n    readyReplicas: number;\n    replicas: number;\n  };\n} & K8sResourceCommon;\n\nexport type MachineConfigKind = {\n  spec: {\n    osImageURL: string;\n    config: any;\n  };\n} & K8sResourceCommon;\n\nexport enum MachineConfigPoolConditionType {\n  Updated = 'Updated',\n  Updating = 'Updating',\n  Degraded = 'Degraded',\n}\n\nexport type MachineConfigPoolCondition = {\n  type: keyof typeof MachineConfigPoolConditionType;\n} & K8sResourceCondition;\n\nexport type MachineConfigPoolStatus = {\n  observedGeneration?: number;\n  configuration: {\n    name: string;\n    source: ObjectReference[];\n  };\n  machineCount: number;\n  updatedMachineCount: number;\n  readyMachineCount: number;\n  unavailableMachineCount: number;\n  conditions: MachineConfigPoolCondition[];\n};\n\nexport type MachineConfigPoolSpec = {\n  machineConfigSelector?: Selector;\n  nodeSelector?: Selector;\n  paused: boolean;\n  maxUnavailable: number | string;\n};\n\nexport type MachineConfigPoolKind = {\n  spec: MachineConfigPoolSpec;\n  status: MachineConfigPoolStatus;\n} & K8sResourceKind;\n\nexport type ClusterUpdate = {\n  image: string;\n  version: string;\n};\n\nexport type UpdateHistory = {\n  state: 'Completed' | 'Partial';\n  startedTime: string;\n  completionTime: string;\n  version: string;\n  image: string;\n};\n\nexport enum ClusterVersionConditionType {\n  Available = 'Available',\n  Failing = 'Failing',\n  Progressing = 'Progressing',\n  RetrievedUpdates = 'RetrievedUpdates',\n  Invalid = 'Invalid',\n}\n\nexport type ClusterVersionCondition = {\n  type: keyof typeof ClusterVersionConditionType;\n} & K8sResourceCondition;\n\ntype ClusterVersionStatus = {\n  availableUpdates: ClusterUpdate[];\n  conditions: ClusterVersionCondition[];\n  desired: ClusterUpdate;\n  history: UpdateHistory[];\n};\n\ntype ClusterVersionSpec = {\n  channel: string;\n  clusterID: string;\n  desiredUpdate: ClusterUpdate;\n  upstream: string;\n};\n\nexport type ClusterVersionKind = {\n  spec: ClusterVersionSpec;\n  status: ClusterVersionStatus;\n} & K8sResourceCommon;\n\nexport type OperandVersion = {\n  name: string;\n  version: string;\n};\n\ntype ClusterOperatorObjectReference = {\n  group: string;\n  resource: string;\n  namespace?: string;\n  name: string;\n};\n\nexport type ClusterOperator = {\n  spec: {};\n  status: {\n    conditions?: K8sResourceCondition[];\n    versions?: OperandVersion[];\n    relatedObjects?: ClusterOperatorObjectReference[];\n  };\n} & K8sResourceCommon;\n\nexport type MappingMethodType = 'claim' | 'lookup' | 'add';\n\ntype IdentityProviderType = 'BasicAuth' | 'GitHub' | 'GitLab' | 'Google' | 'HTPasswd' | 'Keystone' | 'LDAP' | 'OpenID' | 'RequestHeader';\n\ntype IdentityProviderConfig = {\n  [key: string]: any;\n};\n\nexport type IdentityProvider = {\n  name: string;\n  mappingMethod: MappingMethodType;\n  type: IdentityProviderType;\n  basicAuth?: IdentityProviderConfig;\n  github?: IdentityProviderConfig;\n  gitlab?: IdentityProviderConfig;\n  google?: IdentityProviderConfig;\n  htpasswd?: IdentityProviderConfig;\n  keystone?: IdentityProviderConfig;\n  ldap?: IdentityProviderConfig;\n  openID?: IdentityProviderConfig;\n  requestHeader?: IdentityProviderConfig;\n};\n\nexport type OAuthKind = {\n  spec: {\n    identityProviders?: IdentityProvider[];\n    tokenConfig?: {\n      accessTokenMaxAgeSeconds: number;\n    };\n    templates?: {\n      login: string;\n      providerSelection: string;\n      error: string;\n    };\n  };\n} & K8sResourceCommon;\n\nexport type K8sVerb = 'create' | 'get' | 'list' | 'update' | 'patch' | 'delete' | 'deletecollection' | 'watch';\n\nexport type AccessReviewResourceAttributes = {\n  group?: string;\n  resource?: string;\n  subresource?: string;\n  verb?: K8sVerb;\n  name?: string;\n  namespace?: string;\n};\n\nexport type SelfSubjectAccessReviewKind = {\n  apiVersion: string;\n  kind: string;\n  metadata?: ObjectMetadata;\n  spec: {\n    resourceAttributes?: AccessReviewResourceAttributes;\n  };\n  status?: {\n    allowed: boolean;\n    denied?: boolean;\n    reason?: string;\n    evaluationError?: string;\n  };\n};\n\nexport type ResourceAccessReviewRequest = {\n  apiVersion: string;\n  kind: string;\n  namespace?: string;\n  resourceAPIVersion: string;\n  resourceAPIGroup: string;\n  resource: string;\n  verb: K8sVerb;\n};\n\nexport type ResourceAccessReviewResponse = {\n  namespace?: string;\n  users: string[];\n  groups: string[];\n} & K8sResourceCommon;\n\nexport type UserKind = {\n  fullName?: string;\n  identities: string[];\n} & K8sResourceCommon;\n\nexport type GroupKind = {\n  users: string[];\n} & K8sResourceCommon;\n\nexport type K8sKind = {\n  abbr: string;\n  kind: string;\n  label: string;\n  labelPlural: string;\n  plural: string;\n  propagationPolicy?: 'Foreground' | 'Background';\n\n  id?: string;\n  crd?: boolean;\n  apiVersion: string;\n  apiGroup?: string;\n  namespaced?: boolean;\n  selector?: Selector;\n  labels?: { [key: string]: string };\n  annotations?: { [key: string]: string };\n  verbs?: K8sVerb[];\n  shortNames?: string[];\n  badge?: BadgeType;\n  color?: string;\n\n  // Legacy option for supporing plural names in URL paths when `crd: true`.\n  // This should not be set for new models, but is needed to avoid breaking\n  // existing links as we transition to using the API group in URL paths.\n  legacyPluralURL?: boolean;\n};\n\nexport type Cause = {\n  field: string;\n  message: string;\n  reason: string;\n};\n\nexport type Status = {\n  apiVersion: 'v1';\n  kind: 'Status';\n  details: {\n    causes: Cause[];\n    group: string;\n    kind: string;\n  };\n  message: string;\n  metadata: any;\n  reason: string;\n  status: string;\n};\n\n/**\n * GroupVersionKind unambiguously identifies a kind.\n * https://godoc.org/k8s.io/apimachinery/pkg/runtime/schema#GroupVersionKind\n * TODO: Change this to a regex-type if it ever becomes a thing (https://github.com/Microsoft/TypeScript/issues/6579)\n */\nexport type GroupVersionKind = string;\n\n/**\n * The canonical, unique identifier for a Kubernetes resource type.\n * Maintains backwards-compatibility with references using the `kind` string field.\n */\nexport type K8sResourceKindReference = GroupVersionKind | string;\n\nexport type SecretKind = {\n  data: { [key: string]: string };\n  stringData?: { [key: string]: string };\n  type: string;\n} & K8sResourceCommon;\n\nexport type ServiceAccountKind = {\n  automountServiceAccountToken?: boolean;\n  imagePullSecrets?: { [key: string]: string };\n  secrets?: SecretKind[] | { [key: string]: string };\n} & K8sResourceCommon;\n\nexport type ListKind<R extends K8sResourceCommon> = K8sResourceCommon & {\n  items: R[];\n};\n\nexport type EventKind = {\n  action?: string;\n  count?: number;\n  type?: string;\n  involvedObject: EventInvolvedObject;\n  message?: string;\n  eventTime?: string;\n  lastTimestamp?: string;\n  firstTimestamp?: string;\n  reason?: string;\n  source: {\n    component: string;\n    host?: string;\n  };\n  series?: {\n    count?: number;\n    lastObservedTime?: string;\n    state?: string;\n  };\n} & K8sResourceCommon;\n\nexport type MachineHealthCondition = {\n  type: string;\n  status: string;\n  timeout: string;\n};\n\nexport type MachineHealthCheckKind = K8sResourceCommon & {\n  spec: {\n    selector: Selector;\n    unhealthyConditions: MachineHealthCondition[];\n  };\n};\n"]}]}