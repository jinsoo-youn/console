{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/k8s/patches/vm/vm-cdrom-patches.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/k8s/patches/vm/vm-cdrom-patches.ts","mtime":1616735742430},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import { last, includes } from 'lodash';\nimport { getName } from '@console/shared';\nimport { PatchBuilder } from '@console/shared/src/k8s';\nimport { StorageType } from '../../../components/modals/cdrom-vm-modal/constants';\nimport { DataVolumeWrapper } from '../../wrapper/vm/data-volume-wrapper';\nimport { getDefaultSCAccessModes, getDefaultSCVolumeMode, } from '../../../selectors/config-map/sc-defaults';\nimport { getVolumes, getDataVolumeTemplates, getDisks, getVolumeDataVolumeName, asVM, getBootableDevicesInOrder, } from '../../../selectors/vm';\nimport { getVMLikePatches } from '../vm-template';\nimport { BOOT_ORDER_FIRST, BOOT_ORDER_SECOND, DiskBus } from '../../../constants';\nconst getNextAvailableBootOrderIndex = (vm) => {\n    const sortedBootableDevices = getBootableDevicesInOrder(vm);\n    const numBootableDevices = sortedBootableDevices.length;\n    const lastBootableDevice = last(sortedBootableDevices);\n    // assigned indexes start at two as the first index is assigned directly by the user\n    return numBootableDevices > 0 ? lastBootableDevice.value.bootOrder + 1 : BOOT_ORDER_SECOND;\n};\nconst assignBootOrderIndex = (vm, currDevBootOrder = -1) => {\n    let bootOrder = currDevBootOrder;\n    if (currDevBootOrder !== BOOT_ORDER_FIRST) {\n        bootOrder = getNextAvailableBootOrderIndex(vm);\n    }\n    return bootOrder;\n};\nexport const getCDsPatch = (vm, cds, storageClassConfigMap) => {\n    let newBootOrder = assignBootOrderIndex(asVM(vm));\n    let DISKS = getDisks(asVM(vm)).filter((disk) => !disk.cdrom || cds.find((modalCD) => disk.name === modalCD.name || modalCD.newCD));\n    let VOLS = getVolumes(asVM(vm)).filter((v) => DISKS.find((disk) => v.name === disk.name));\n    let DATATEMPLATES = getDataVolumeTemplates(asVM(vm)).filter((dataVol) => VOLS.find((vol) => getVolumeDataVolumeName(vol) === getName(dataVol)));\n    cds.forEach(({ name, pvc, type, bootOrder, bus, container, windowsTools, url, storageClass, size }) => {\n        const existingCD = !!bootOrder;\n        const disk = {\n            name,\n            bootOrder: existingCD ? bootOrder : newBootOrder,\n            cdrom: { bus: bus || DiskBus.SATA.getValue() },\n        };\n        let volume = { name };\n        let finalDataVolume;\n        // Patches\n        if (type === StorageType.PVC) {\n            volume = {\n                persistentVolumeClaim: {\n                    claimName: pvc,\n                },\n                name,\n            };\n        }\n        if (type === StorageType.URL) {\n            const newDataVolume = {\n                metadata: {\n                    name: `${getName(vm)}-${name}`,\n                },\n                spec: {\n                    pvc: {\n                        accessModes: undefined,\n                        volumeMode: undefined,\n                        resources: {\n                            requests: {\n                                storage: `${size}Gi`,\n                            },\n                        },\n                        storageClassName: storageClass,\n                    },\n                    source: { http: { url } },\n                },\n            };\n            const dataVolumeWrapper = new DataVolumeWrapper(newDataVolume);\n            const storageClassName = dataVolumeWrapper.getStorageClassName();\n            finalDataVolume = dataVolumeWrapper\n                .setVolumeMode(getDefaultSCVolumeMode(storageClassConfigMap, storageClassName))\n                .setAccessModes(getDefaultSCAccessModes(storageClassConfigMap, storageClassName))\n                .asResource();\n            volume = {\n                name,\n                dataVolume: {\n                    name: `${getName(vm)}-${name}`,\n                },\n            };\n        }\n        if (type === StorageType.CONTAINER) {\n            volume = { name, containerDisk: { image: container } };\n        }\n        if (type === StorageType.WINTOOLS) {\n            volume = { name, containerDisk: { image: windowsTools } };\n        }\n        const restOfDisks = DISKS.filter((vol) => vol.name !== name);\n        const restOfVolumes = VOLS.filter((vol) => vol.name !== name);\n        let restOfDataTemplates = DATATEMPLATES;\n        if (type !== StorageType.CONTAINER && VOLS.filter((vol) => !!vol.dataVolume).length > 0) {\n            const isDataVolume = VOLS.find((vol) => vol.name === name);\n            if (isDataVolume) {\n                restOfDataTemplates = DATATEMPLATES.filter((vol) => vol.metadata.name !== getVolumeDataVolumeName(isDataVolume));\n            }\n        }\n        DISKS = [...restOfDisks, disk];\n        VOLS = [...restOfVolumes, volume];\n        DATATEMPLATES = restOfDataTemplates;\n        if (finalDataVolume) {\n            DATATEMPLATES = [...restOfDataTemplates, finalDataVolume];\n        }\n        if (type !== StorageType.URL) {\n            // remove unnecessary dataVolumeTemplates\n            DATATEMPLATES = DATATEMPLATES.filter((dataVol) => includes(VOLS.map((vol) => getVolumeDataVolumeName(vol)), dataVol.metadata.name));\n        }\n        if (!existingCD) {\n            newBootOrder++;\n        }\n    });\n    const patches = [\n        new PatchBuilder('/spec/template/spec/domain/devices/disks').replace(DISKS).build(),\n        new PatchBuilder('/spec/template/spec/volumes').replace(VOLS).build(),\n        new PatchBuilder('/spec/dataVolumeTemplates').replace(DATATEMPLATES).build(),\n    ].filter((patch) => patch);\n    return getVMLikePatches(vm, () => patches);\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/k8s/patches/vm/vm-cdrom-patches.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/kubevirt-plugin/src/k8s/patches/vm/vm-cdrom-patches.ts"],"names":[],"mappings":"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","sourcesContent":["import { last, includes } from 'lodash';\nimport { getName } from '@console/shared';\nimport { ConfigMapKind, Volume } from '@console/internal/module/k8s';\nimport { PatchBuilder } from '@console/shared/src/k8s';\nimport { StorageType } from '../../../components/modals/cdrom-vm-modal/constants';\nimport { DataVolumeWrapper } from '../../wrapper/vm/data-volume-wrapper';\nimport {\n  getDefaultSCAccessModes,\n  getDefaultSCVolumeMode,\n} from '../../../selectors/config-map/sc-defaults';\nimport { VMLikeEntityKind } from '../../../types/vmLike';\nimport {\n  getVolumes,\n  getDataVolumeTemplates,\n  getDisks,\n  getVolumeDataVolumeName,\n  asVM,\n  getBootableDevicesInOrder,\n} from '../../../selectors/vm';\nimport { getVMLikePatches } from '../vm-template';\nimport { BOOT_ORDER_FIRST, BOOT_ORDER_SECOND, DiskBus } from '../../../constants';\nimport { CD } from '../../../components/modals/cdrom-vm-modal/types';\n\nconst getNextAvailableBootOrderIndex = (vm: VMLikeEntityKind) => {\n  const sortedBootableDevices = getBootableDevicesInOrder(vm);\n  const numBootableDevices = sortedBootableDevices.length;\n  const lastBootableDevice: any = last(sortedBootableDevices);\n\n  // assigned indexes start at two as the first index is assigned directly by the user\n  return numBootableDevices > 0 ? lastBootableDevice.value.bootOrder + 1 : BOOT_ORDER_SECOND;\n};\n\nconst assignBootOrderIndex = (vm: VMLikeEntityKind, currDevBootOrder = -1) => {\n  let bootOrder = currDevBootOrder;\n  if (currDevBootOrder !== BOOT_ORDER_FIRST) {\n    bootOrder = getNextAvailableBootOrderIndex(vm);\n  }\n  return bootOrder;\n};\n\nexport const getCDsPatch = (\n  vm: VMLikeEntityKind,\n  cds: CD[],\n  storageClassConfigMap: ConfigMapKind,\n) => {\n  let newBootOrder = assignBootOrderIndex(asVM(vm));\n\n  let DISKS = getDisks(asVM(vm)).filter(\n    (disk) => !disk.cdrom || cds.find((modalCD) => disk.name === modalCD.name || modalCD.newCD),\n  );\n  let VOLS = getVolumes(asVM(vm)).filter((v) => DISKS.find((disk) => v.name === disk.name));\n  let DATATEMPLATES = getDataVolumeTemplates(asVM(vm)).filter((dataVol) =>\n    VOLS.find((vol) => getVolumeDataVolumeName(vol) === getName(dataVol)),\n  );\n\n  cds.forEach(\n    ({ name, pvc, type, bootOrder, bus, container, windowsTools, url, storageClass, size }) => {\n      const existingCD = !!bootOrder;\n\n      const disk: CD = {\n        name,\n        bootOrder: existingCD ? bootOrder : newBootOrder,\n        cdrom: { bus: bus || DiskBus.SATA.getValue() },\n      };\n      let volume: Volume = { name };\n      let finalDataVolume;\n\n      // Patches\n      if (type === StorageType.PVC) {\n        volume = {\n          persistentVolumeClaim: {\n            claimName: pvc,\n          },\n          name,\n        };\n      }\n\n      if (type === StorageType.URL) {\n        const newDataVolume = {\n          metadata: {\n            name: `${getName(vm)}-${name}`,\n          },\n          spec: {\n            pvc: {\n              accessModes: undefined,\n              volumeMode: undefined,\n              resources: {\n                requests: {\n                  storage: `${size}Gi`,\n                },\n              },\n              storageClassName: storageClass,\n            },\n            source: { http: { url } },\n          },\n        };\n\n        const dataVolumeWrapper = new DataVolumeWrapper(newDataVolume);\n        const storageClassName = dataVolumeWrapper.getStorageClassName();\n\n        finalDataVolume = dataVolumeWrapper\n          .setVolumeMode(getDefaultSCVolumeMode(storageClassConfigMap, storageClassName))\n          .setAccessModes(getDefaultSCAccessModes(storageClassConfigMap, storageClassName))\n          .asResource();\n\n        volume = {\n          name,\n          dataVolume: {\n            name: `${getName(vm)}-${name}`,\n          },\n        };\n      }\n      if (type === StorageType.CONTAINER) {\n        volume = { name, containerDisk: { image: container } };\n      }\n      if (type === StorageType.WINTOOLS) {\n        volume = { name, containerDisk: { image: windowsTools } };\n      }\n\n      const restOfDisks = DISKS.filter((vol) => vol.name !== name);\n      const restOfVolumes = VOLS.filter((vol) => vol.name !== name);\n\n      let restOfDataTemplates = DATATEMPLATES;\n      if (type !== StorageType.CONTAINER && VOLS.filter((vol) => !!vol.dataVolume).length > 0) {\n        const isDataVolume = VOLS.find((vol) => vol.name === name);\n        if (isDataVolume) {\n          restOfDataTemplates = DATATEMPLATES.filter(\n            (vol) => vol.metadata.name !== getVolumeDataVolumeName(isDataVolume),\n          );\n        }\n      }\n\n      DISKS = [...restOfDisks, disk];\n      VOLS = [...restOfVolumes, volume];\n      DATATEMPLATES = restOfDataTemplates;\n\n      if (finalDataVolume) {\n        DATATEMPLATES = [...restOfDataTemplates, finalDataVolume];\n      }\n\n      if (type !== StorageType.URL) {\n        // remove unnecessary dataVolumeTemplates\n        DATATEMPLATES = DATATEMPLATES.filter((dataVol) =>\n          includes(\n            VOLS.map((vol) => getVolumeDataVolumeName(vol)),\n            dataVol.metadata.name,\n          ),\n        );\n      }\n      if (!existingCD) {\n        newBootOrder++;\n      }\n    },\n  );\n\n  const patches = [\n    new PatchBuilder('/spec/template/spec/domain/devices/disks').replace(DISKS).build(),\n    new PatchBuilder('/spec/template/spec/volumes').replace(VOLS).build(),\n    new PatchBuilder('/spec/dataVolumeTemplates').replace(DATATEMPLATES).build(),\n  ].filter((patch) => patch);\n\n  return getVMLikePatches(vm, () => patches);\n};\n"]}]}