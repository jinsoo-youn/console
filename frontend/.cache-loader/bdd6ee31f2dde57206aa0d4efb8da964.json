{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/public/components/hypercloud/utils/expandable-table.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/public/components/hypercloud/utils/expandable-table.tsx","mtime":1615298458730},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as React from 'react';\nimport { useState, useEffect } from 'react';\nimport * as _ from 'lodash-es';\nimport { Table as PfTable, TableHeader as PfTableHeader, TableBody as PfTableBody } from '@patternfly/react-table';\nexport const SingleExpandableTable = ({ header, itemList, rowRenderer, innerRenderer, compoundParent }) => {\n    const [tableRows, setTableRows] = useState([]);\n    useEffect(() => {\n        const preData = [];\n        itemList\n            .reduce((result, item, index) => {\n            return result.then(() => __awaiter(void 0, void 0, void 0, function* () {\n                var _a, _b, _c, _d;\n                const innerTable = yield innerRenderer(item);\n                if (!!innerTable) {\n                    preData.push({\n                        isOpen: false,\n                        cells: rowRenderer(index, item, (_b = (_a = innerTable.props) === null || _a === void 0 ? void 0 : _a.data) === null || _b === void 0 ? void 0 : _b.length),\n                    });\n                    if (((_d = (_c = innerTable.props) === null || _c === void 0 ? void 0 : _c.data) === null || _d === void 0 ? void 0 : _d.length) > 0) {\n                        let parentValue = index * 2;\n                        preData.push({\n                            parent: parentValue,\n                            compoundParent: compoundParent,\n                            cells: [\n                                {\n                                    title: innerTable,\n                                    props: { colSpan: header.length, className: 'pf-m-no-padding' },\n                                },\n                            ],\n                        });\n                    }\n                    else {\n                        let parentValue = index * 2;\n                        preData.push({\n                            parent: parentValue,\n                            compoundParent: compoundParent,\n                            cells: [\n                                {\n                                    title: React.createElement(\"div\", null, \"...No Data...\"),\n                                    props: { colSpan: header.length, className: 'pf-m-no-padding' },\n                                },\n                            ],\n                        });\n                    }\n                }\n            }));\n        }, Promise.resolve())\n            .then(() => {\n            setTableRows(_.cloneDeep(preData));\n        });\n    }, [itemList]);\n    // function delay() {\n    //   return new Promise(resolve => setTimeout(resolve, 300));\n    // }\n    const onExpand = (event, rowIndex, colIndex, isOpen, rowData, extraData) => {\n        let rows = _.cloneDeep(tableRows);\n        if (!isOpen) {\n            rows[rowIndex].cells.forEach((cell) => {\n                if (cell.props)\n                    cell.props.isOpen = false;\n            });\n            rows[rowIndex].cells[colIndex].props.isOpen = true;\n            rows[rowIndex].isOpen = true;\n        }\n        else {\n            rows[rowIndex].cells[colIndex].props.isOpen = false;\n            rows[rowIndex].isOpen = rows[rowIndex].cells.some((cell) => cell.props && cell.props.isOpen);\n        }\n        setTableRows(rows);\n    };\n    return (React.createElement(PfTable, { \"aria-label\": \"Compound expandable table\", onExpand: onExpand, rows: tableRows, cells: header },\n        React.createElement(PfTableHeader, null),\n        React.createElement(PfTableBody, null)));\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/public/components/hypercloud/utils/expandable-table.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/public/components/hypercloud/utils/expandable-table.tsx"],"names":[],"mappings":";;;;;;;;;AAAA,OAAO,KAAK,KAAK,MAAM,OAAO,CAAC;AAC/B,OAAO,EAAE,QAAQ,EAAE,SAAS,EAAE,MAAM,OAAO,CAAC;AAC5C,OAAO,KAAK,CAAC,MAAM,WAAW,CAAC;AAC/B,OAAO,EAAE,KAAK,IAAI,OAAO,EAAE,WAAW,IAAI,aAAa,EAAE,SAAS,IAAI,WAAW,EAAS,MAAM,yBAAyB,CAAC;AAE1H,MAAM,CAAC,MAAM,qBAAqB,GAAyC,CAAC,EAAE,MAAM,EAAE,QAAQ,EAAE,WAAW,EAAE,aAAa,EAAE,cAAc,EAAE,EAAE,EAAE;IAC9I,MAAM,CAAC,SAAS,EAAE,YAAY,CAAC,GAAG,QAAQ,CAAC,EAAE,CAAC,CAAC;IAC/C,SAAS,CAAC,GAAG,EAAE;QACb,MAAM,OAAO,GAAG,EAAE,CAAC;QACnB,QAAQ;aACL,MAAM,CAAC,CAAC,MAAM,EAAE,IAAI,EAAE,KAAa,EAAE,EAAE;YACtC,OAAO,MAAM,CAAC,IAAI,CAAC,GAAS,EAAE;;gBAC5B,MAAM,UAAU,GAAG,MAAM,aAAa,CAAC,IAAI,CAAC,CAAC;gBAC7C,IAAI,CAAC,CAAC,UAAU,EAAE;oBAChB,OAAO,CAAC,IAAI,CAAC;wBACX,MAAM,EAAE,KAAK;wBACb,KAAK,EAAE,WAAW,CAAC,KAAK,EAAE,IAAI,cAAE,UAAU,CAAC,KAAK,0CAAE,IAAI,0CAAE,MAAM,CAAC;qBAChE,CAAC,CAAC;oBAEH,IAAI,aAAA,UAAU,CAAC,KAAK,0CAAE,IAAI,0CAAE,MAAM,IAAG,CAAC,EAAE;wBACtC,IAAI,WAAW,GAAG,KAAK,GAAG,CAAC,CAAC;wBAC5B,OAAO,CAAC,IAAI,CAAC;4BACX,MAAM,EAAE,WAAW;4BACnB,cAAc,EAAE,cAAc;4BAC9B,KAAK,EAAE;gCACL;oCACE,KAAK,EAAE,UAAU;oCACjB,KAAK,EAAE,EAAE,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,iBAAiB,EAAE;iCAChE;6BACF;yBACF,CAAC,CAAC;qBACJ;yBAAM;wBACL,IAAI,WAAW,GAAG,KAAK,GAAG,CAAC,CAAC;wBAC5B,OAAO,CAAC,IAAI,CAAC;4BACX,MAAM,EAAE,WAAW;4BACnB,cAAc,EAAE,cAAc;4BAC9B,KAAK,EAAE;gCACL;oCACE,KAAK,EAAE,iDAAwB;oCAC/B,KAAK,EAAE,EAAE,OAAO,EAAE,MAAM,CAAC,MAAM,EAAE,SAAS,EAAE,iBAAiB,EAAE;iCAChE;6BACF;yBACF,CAAC,CAAC;qBACJ;iBACF;YACH,CAAC,CAAA,CAAC,CAAC;QACL,CAAC,EAAE,OAAO,CAAC,OAAO,EAAE,CAAC;aACpB,IAAI,CAAC,GAAG,EAAE;YACT,YAAY,CAAC,CAAC,CAAC,SAAS,CAAC,OAAO,CAAC,CAAC,CAAC;QACrC,CAAC,CAAC,CAAC;IACP,CAAC,EAAE,CAAC,QAAQ,CAAC,CAAC,CAAC;IAEf,qBAAqB;IACrB,6DAA6D;IAC7D,IAAI;IAEJ,MAAM,QAAQ,GAAG,CAAC,KAAK,EAAE,QAAQ,EAAE,QAAQ,EAAE,MAAM,EAAE,OAAO,EAAE,SAAS,EAAE,EAAE;QACzE,IAAI,IAAI,GAAG,CAAC,CAAC,SAAS,CAAC,SAAS,CAAC,CAAC;QAClC,IAAI,CAAC,MAAM,EAAE;YACX,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,OAAO,CAAC,CAAC,IAAW,EAAE,EAAE;gBAC3C,IAAI,IAAI,CAAC,KAAK;oBAAE,IAAI,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC;YAC5C,CAAC,CAAC,CAAC;YACF,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAW,CAAC,KAAK,CAAC,MAAM,GAAG,IAAI,CAAC;YAC9D,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC;SAC9B;aAAM;YACJ,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAW,CAAC,KAAK,CAAC,MAAM,GAAG,KAAK,CAAC;YAC/D,IAAI,CAAC,QAAQ,CAAC,CAAC,MAAM,GAAG,IAAI,CAAC,QAAQ,CAAC,CAAC,KAAK,CAAC,IAAI,CAAC,CAAC,IAAW,EAAE,EAAE,CAAC,IAAI,CAAC,KAAK,IAAI,IAAI,CAAC,KAAK,CAAC,MAAM,CAAC,CAAC;SACrG;QACD,YAAY,CAAC,IAAI,CAAC,CAAC;IACrB,CAAC,CAAC;IAEF,OAAO,CACL,oBAAC,OAAO,kBAAY,2BAA2B,EAAC,QAAQ,EAAE,QAAQ,EAAE,IAAI,EAAE,SAAS,EAAE,KAAK,EAAE,MAAM;QAChG,oBAAC,aAAa,OAAG;QACjB,oBAAC,WAAW,OAAG,CACP,CACX,CAAC;AACJ,CAAC,CAAC","sourcesContent":["import * as React from 'react';\nimport { useState, useEffect } from 'react';\nimport * as _ from 'lodash-es';\nimport { Table as PfTable, TableHeader as PfTableHeader, TableBody as PfTableBody, ICell } from '@patternfly/react-table';\n\nexport const SingleExpandableTable: React.FC<SingleExpandableTableProps> = ({ header, itemList, rowRenderer, innerRenderer, compoundParent }) => {\n  const [tableRows, setTableRows] = useState([]);\n  useEffect(() => {\n    const preData = [];\n    itemList\n      .reduce((result, item, index: number) => {\n        return result.then(async () => {\n          const innerTable = await innerRenderer(item);\n          if (!!innerTable) {\n            preData.push({\n              isOpen: false,\n              cells: rowRenderer(index, item, innerTable.props?.data?.length),\n            });\n\n            if (innerTable.props?.data?.length > 0) {\n              let parentValue = index * 2;\n              preData.push({\n                parent: parentValue,\n                compoundParent: compoundParent,\n                cells: [\n                  {\n                    title: innerTable,\n                    props: { colSpan: header.length, className: 'pf-m-no-padding' },\n                  },\n                ],\n              });\n            } else {\n              let parentValue = index * 2;\n              preData.push({\n                parent: parentValue,\n                compoundParent: compoundParent,\n                cells: [\n                  {\n                    title: <div>...No Data...</div>,\n                    props: { colSpan: header.length, className: 'pf-m-no-padding' },\n                  },\n                ],\n              });\n            }\n          }\n        });\n      }, Promise.resolve())\n      .then(() => {\n        setTableRows(_.cloneDeep(preData));\n      });\n  }, [itemList]);\n\n  // function delay() {\n  //   return new Promise(resolve => setTimeout(resolve, 300));\n  // }\n\n  const onExpand = (event, rowIndex, colIndex, isOpen, rowData, extraData) => {\n    let rows = _.cloneDeep(tableRows);\n    if (!isOpen) {\n      rows[rowIndex].cells.forEach((cell: ICell) => {\n        if (cell.props) cell.props.isOpen = false;\n      });\n      (rows[rowIndex].cells[colIndex] as ICell).props.isOpen = true;\n      rows[rowIndex].isOpen = true;\n    } else {\n      (rows[rowIndex].cells[colIndex] as ICell).props.isOpen = false;\n      rows[rowIndex].isOpen = rows[rowIndex].cells.some((cell: ICell) => cell.props && cell.props.isOpen);\n    }\n    setTableRows(rows);\n  };\n\n  return (\n    <PfTable aria-label=\"Compound expandable table\" onExpand={onExpand} rows={tableRows} cells={header}>\n      <PfTableHeader />\n      <PfTableBody />\n    </PfTable>\n  );\n};\n\ntype SingleExpandableTableProps = {\n  itemList: any[]; // outer table의 itemList\n  rowRenderer: (index, obj, itemCount: number) => any[]; // outer table의 row 한줄에 들어갈 요소들을 배열 형태로 return하는 renderer 함수\n  innerRenderer: (parentItem) => any; // inner table을 render하는 함수(ExpandableInnerTable 컴포넌트 사용해야됨)\n  header: (ICell | string)[]; // header column들의 배열. 펼침 기능을 사용할 column object에는 cellTransforms: [compoundExpand] 속성 넣어줘야 함.\n  compoundParent: number; // table 펼칠 수 있는 column의 index\n};\n"]}]}