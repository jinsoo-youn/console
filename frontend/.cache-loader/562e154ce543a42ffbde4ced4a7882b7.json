{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/components/ConnectorArrow.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/components/ConnectorArrow.tsx","mtime":1615298458710},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import * as React from 'react';\nimport * as classNames from 'classnames';\nimport * as _ from 'lodash';\nimport './ConnectorArrow.scss';\nconst pointsStringFromPoints = (points) => {\n    return _.reduce(points, (result, nextPoint) => {\n        return `${result} ${nextPoint[0]},${nextPoint[1]}`;\n    }, '');\n};\nconst ConnectorArrow = ({ startPoint, endPoint, className = '', isTarget = true, size = 10, dragRef, }) => {\n    if (!startPoint || !endPoint) {\n        return null;\n    }\n    const arrowEndPoint = isTarget\n        ? [endPoint.x, endPoint.y]\n        : [startPoint.x, startPoint.y];\n    const prevPoint = isTarget\n        ? [startPoint.x, startPoint.y]\n        : [endPoint.x, endPoint.y];\n    const length = Math.sqrt((arrowEndPoint[0] - prevPoint[0]) ** 2 + (arrowEndPoint[1] - prevPoint[1]) ** 2);\n    if (!length) {\n        return null;\n    }\n    const ratio = (length - size) / length;\n    const arrowStartPoint = [\n        prevPoint[0] + (arrowEndPoint[0] - prevPoint[0]) * ratio,\n        prevPoint[1] + (arrowEndPoint[1] - prevPoint[1]) * ratio,\n    ];\n    const arrowPoints = [\n        [0, size / 2],\n        [0, -size / 2],\n        [size, 0],\n    ];\n    const padding = Math.max(size, 8);\n    const deltaY = padding / 2;\n    const boundingBox = [\n        [0, -deltaY],\n        [padding, -deltaY],\n        [padding, deltaY],\n        [0, deltaY],\n    ];\n    const angleDeg = 180 -\n        (Math.atan2(arrowEndPoint[1] - prevPoint[1], prevPoint[0] - arrowEndPoint[0]) * 180) / Math.PI;\n    return (React.createElement(\"g\", { transform: `translate(${arrowStartPoint[0]}, ${arrowStartPoint[1]}) rotate(${angleDeg})`, ref: dragRef, className: classNames('topology-connector-arrow', className) },\n        React.createElement(\"polygon\", { points: pointsStringFromPoints(arrowPoints) }),\n        React.createElement(\"polygon\", { points: pointsStringFromPoints(boundingBox), fillOpacity: 0, strokeWidth: 0 })));\n};\nexport default ConnectorArrow;\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/components/ConnectorArrow.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/components/ConnectorArrow.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport * as classNames from 'classnames';\nimport * as _ from 'lodash';\nimport Point from '../geom/Point';\nimport { ConnectDragSource } from '../behavior/dnd-types';\nimport './ConnectorArrow.scss';\n\ntype ConnectorArrowProps = {\n  startPoint: Point;\n  endPoint: Point;\n  className?: string;\n  isTarget?: boolean;\n  size?: number;\n  dragRef?: ConnectDragSource;\n};\n\nconst pointsStringFromPoints = (points: [number, number][]): string => {\n  return _.reduce(\n    points,\n    (result: string, nextPoint: [number, number]) => {\n      return `${result} ${nextPoint[0]},${nextPoint[1]}`;\n    },\n    '',\n  );\n};\n\nconst ConnectorArrow: React.FC<ConnectorArrowProps> = ({\n  startPoint,\n  endPoint,\n  className = '',\n  isTarget = true,\n  size = 10,\n  dragRef,\n}) => {\n  if (!startPoint || !endPoint) {\n    return null;\n  }\n  const arrowEndPoint: [number, number] = isTarget\n    ? [endPoint.x, endPoint.y]\n    : [startPoint.x, startPoint.y];\n  const prevPoint: [number, number] = isTarget\n    ? [startPoint.x, startPoint.y]\n    : [endPoint.x, endPoint.y];\n\n  const length = Math.sqrt(\n    (arrowEndPoint[0] - prevPoint[0]) ** 2 + (arrowEndPoint[1] - prevPoint[1]) ** 2,\n  );\n  if (!length) {\n    return null;\n  }\n\n  const ratio = (length - size) / length;\n  const arrowStartPoint: [number, number] = [\n    prevPoint[0] + (arrowEndPoint[0] - prevPoint[0]) * ratio,\n    prevPoint[1] + (arrowEndPoint[1] - prevPoint[1]) * ratio,\n  ];\n\n  const arrowPoints: [number, number][] = [\n    [0, size / 2],\n    [0, -size / 2],\n    [size, 0],\n  ];\n  const padding = Math.max(size, 8);\n  const deltaY = padding / 2;\n  const boundingBox: [number, number][] = [\n    [0, -deltaY],\n    [padding, -deltaY],\n    [padding, deltaY],\n    [0, deltaY],\n  ];\n\n  const angleDeg =\n    180 -\n    (Math.atan2(arrowEndPoint[1] - prevPoint[1], prevPoint[0] - arrowEndPoint[0]) * 180) / Math.PI;\n\n  return (\n    <g\n      transform={`translate(${arrowStartPoint[0]}, ${arrowStartPoint[1]}) rotate(${angleDeg})`}\n      ref={dragRef}\n      className={classNames('topology-connector-arrow', className)}\n    >\n      <polygon points={pointsStringFromPoints(arrowPoints)} />\n      <polygon points={pointsStringFromPoints(boundingBox)} fillOpacity={0} strokeWidth={0} />\n    </g>\n  );\n};\n\nexport default ConnectorArrow;\n"]}]}