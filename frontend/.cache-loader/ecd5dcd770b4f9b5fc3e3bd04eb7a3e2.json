{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/draw-utils.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/draw-utils.ts","mtime":1616735742390},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import { Point } from '@console/topology';\nimport { DrawDesign, NODE_SEPARATION_HORIZONTAL } from './const';\nconst join = (...segments) => segments.filter((seg) => !!seg).join(' ');\nconst leftRight = (p1, p2) => p1.x < p2.x;\nconst topDown = (p1, p2) => p1.y < p2.y;\nconst bottomUp = (p1, p2) => p1.y > p2.y;\nconst point = (p) => `${p.x},${p.y}`;\nconst moveTo = (p) => `M ${point(p)}`;\nconst lineTo = (p) => `L ${point(p)}`;\nconst quadTo = (corner, end) => `Q ${point(corner)} ${point(end)}`;\n// TODO: Try to simplify\n// x should not be greater than (NODE_SEPARATION_HORIZONTAL / 2)\nconst CURVE_SIZE = { x: 8, y: 10 };\nconst curve = (fromPoint, cornerPoint, toPoint) => {\n    const topToBottom = topDown(fromPoint, toPoint);\n    if (topToBottom) {\n        const rightAndDown = leftRight(fromPoint, cornerPoint) && topDown(cornerPoint, toPoint);\n        const downAndRight = topDown(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);\n        if (rightAndDown) {\n            return join(lineTo(cornerPoint.clone().translate(-CURVE_SIZE.x, 0)), quadTo(cornerPoint, cornerPoint.clone().translate(0, CURVE_SIZE.y)));\n        }\n        if (downAndRight) {\n            return join(lineTo(cornerPoint.clone().translate(0, -CURVE_SIZE.y)), quadTo(cornerPoint, cornerPoint.clone().translate(CURVE_SIZE.x, 0)));\n        }\n    }\n    else {\n        const rightAndUp = leftRight(fromPoint, cornerPoint) && bottomUp(cornerPoint, toPoint);\n        const upAndRight = bottomUp(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);\n        if (rightAndUp) {\n            return join(lineTo(cornerPoint.clone().translate(-CURVE_SIZE.x, 0)), quadTo(cornerPoint, cornerPoint.clone().translate(0, -CURVE_SIZE.y)));\n        }\n        if (upAndRight) {\n            return join(lineTo(cornerPoint.clone().translate(0, CURVE_SIZE.y)), quadTo(cornerPoint, cornerPoint.clone().translate(CURVE_SIZE.x, 0)));\n        }\n    }\n    return '';\n};\nexport const straightPath = (start, finish) => join(moveTo(start), lineTo(finish));\nexport const integralShapePath = (start, finish) => {\n    // Integral shape: ∫\n    let firstCurve = null;\n    let secondCurve = null;\n    if (start.y !== finish.y) {\n        const cornerX = Math.floor(start.x + NODE_SEPARATION_HORIZONTAL / 2);\n        const firstCorner = new Point(cornerX, start.y);\n        const secondCorner = new Point(cornerX, finish.y);\n        firstCurve = curve(start, firstCorner, secondCorner);\n        secondCurve = curve(firstCorner, secondCorner, finish);\n    }\n    return join(moveTo(start), firstCurve, secondCurve, lineTo(finish));\n};\nexport const path = (start, finish, drawDesign) => {\n    switch (drawDesign) {\n        case DrawDesign.INTEGRAL_SHAPE:\n            return integralShapePath(start, finish);\n        case DrawDesign.STRAIGHT:\n        default:\n            return straightPath(start, finish);\n    }\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/draw-utils.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/components/pipelines/pipeline-topology/draw-utils.ts"],"names":[],"mappings":"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","sourcesContent":["import { Point } from '@console/topology';\nimport { DrawDesign, NODE_SEPARATION_HORIZONTAL } from './const';\n\ntype SingleDraw = (p: Point) => string;\ntype DoubleDraw = (p1: Point, p2: Point) => string;\ntype TripleDraw = (p1: Point, p2: Point, p3: Point) => string;\ntype DetermineDirection = (p1: Point, p2: Point) => boolean;\n\nconst join = (...segments: string[]) => segments.filter((seg) => !!seg).join(' ');\n\nconst leftRight: DetermineDirection = (p1, p2) => p1.x < p2.x;\nconst topDown: DetermineDirection = (p1, p2) => p1.y < p2.y;\nconst bottomUp: DetermineDirection = (p1, p2) => p1.y > p2.y;\n\nconst point: SingleDraw = (p) => `${p.x},${p.y}`;\nconst moveTo: SingleDraw = (p) => `M ${point(p)}`;\nconst lineTo: SingleDraw = (p) => `L ${point(p)}`;\nconst quadTo: DoubleDraw = (corner, end) => `Q ${point(corner)} ${point(end)}`;\n\n// TODO: Try to simplify\n// x should not be greater than (NODE_SEPARATION_HORIZONTAL / 2)\nconst CURVE_SIZE = { x: 8, y: 10 };\nconst curve: TripleDraw = (fromPoint, cornerPoint, toPoint) => {\n  const topToBottom = topDown(fromPoint, toPoint);\n  if (topToBottom) {\n    const rightAndDown = leftRight(fromPoint, cornerPoint) && topDown(cornerPoint, toPoint);\n    const downAndRight = topDown(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);\n    if (rightAndDown) {\n      return join(\n        lineTo(cornerPoint.clone().translate(-CURVE_SIZE.x, 0)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(0, CURVE_SIZE.y)),\n      );\n    }\n    if (downAndRight) {\n      return join(\n        lineTo(cornerPoint.clone().translate(0, -CURVE_SIZE.y)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(CURVE_SIZE.x, 0)),\n      );\n    }\n  } else {\n    const rightAndUp = leftRight(fromPoint, cornerPoint) && bottomUp(cornerPoint, toPoint);\n    const upAndRight = bottomUp(fromPoint, cornerPoint) && leftRight(cornerPoint, toPoint);\n    if (rightAndUp) {\n      return join(\n        lineTo(cornerPoint.clone().translate(-CURVE_SIZE.x, 0)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(0, -CURVE_SIZE.y)),\n      );\n    }\n    if (upAndRight) {\n      return join(\n        lineTo(cornerPoint.clone().translate(0, CURVE_SIZE.y)),\n        quadTo(cornerPoint, cornerPoint.clone().translate(CURVE_SIZE.x, 0)),\n      );\n    }\n  }\n\n  return '';\n};\n\nexport const straightPath: DoubleDraw = (start, finish) => join(moveTo(start), lineTo(finish));\n\nexport const integralShapePath: DoubleDraw = (start, finish) => {\n  // Integral shape: ∫\n  let firstCurve: string = null;\n  let secondCurve: string = null;\n\n  if (start.y !== finish.y) {\n    const cornerX = Math.floor(start.x + NODE_SEPARATION_HORIZONTAL / 2);\n    const firstCorner = new Point(cornerX, start.y);\n    const secondCorner = new Point(cornerX, finish.y);\n\n    firstCurve = curve(start, firstCorner, secondCorner);\n    secondCurve = curve(firstCorner, secondCorner, finish);\n  }\n\n  return join(moveTo(start), firstCurve, secondCurve, lineTo(finish));\n};\n\nexport const path = (start: Point, finish: Point, drawDesign?: DrawDesign) => {\n  switch (drawDesign) {\n    case DrawDesign.INTEGRAL_SHAPE:\n      return integralShapePath(start, finish);\n    case DrawDesign.STRAIGHT:\n    default:\n      return straightPath(start, finish);\n  }\n};\n"]}]}