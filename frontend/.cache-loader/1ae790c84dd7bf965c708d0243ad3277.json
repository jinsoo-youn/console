{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndManager.tsx","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndManager.tsx","mtime":1616735742450},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport * as React from 'react';\nimport { computed, observable } from 'mobx';\nimport ControllerContext from '../utils/ControllerContext';\nlet nextUniqueId = 0;\nconst getNextUniqueId = () => {\n    return nextUniqueId++;\n};\nexport const matchesType = (targetType, draggedItemType) => {\n    if (draggedItemType === null) {\n        return targetType === null;\n    }\n    return Array.isArray(targetType)\n        ? targetType.some((t) => t === draggedItemType)\n        : targetType === draggedItemType;\n};\nexport class DndManagerImpl {\n    constructor(state) {\n        // TODO are these really required to be observable?\n        this.sources = {};\n        this.targets = {};\n        this.state = state;\n    }\n    get dropHints() {\n        return this.state.targetIds\n            ? this.state.targetIds\n                .map((id) => {\n                const target = this.getTarget(id);\n                return target ? target.dropHint(this) : [];\n            })\n                .filter((x) => x)\n            : [];\n    }\n    registerSource(source) {\n        const key = `S${getNextUniqueId()}`;\n        this.sources[key] = source;\n        return [\n            key,\n            () => {\n                delete this.sources[key];\n            },\n        ];\n    }\n    registerTarget(target) {\n        const key = `T${getNextUniqueId()}`;\n        this.targets[key] = target;\n        return [\n            key,\n            () => {\n                delete this.targets[key];\n            },\n        ];\n    }\n    getDropHints() {\n        return this.dropHints;\n    }\n    canDragSource(sourceId) {\n        const source = this.getSource(sourceId);\n        if (!source || this.isDragging()) {\n            return false;\n        }\n        return source && source.canDrag(this);\n    }\n    canDropOnTarget(targetId) {\n        const target = this.getTarget(targetId);\n        if (!target || !this.isDragging() || this.didDrop()) {\n            return false;\n        }\n        const draggedItemType = this.getItemType();\n        return matchesType(target.type, draggedItemType) && target.canDrop(this);\n    }\n    isDragging() {\n        return !!this.state.isDragging;\n    }\n    isDraggingSource(sourceId) {\n        return this.state.sourceId != null && this.state.sourceId === sourceId;\n    }\n    isOverTarget(targetId, options = { shallow: false }) {\n        if (!targetId) {\n            return false;\n        }\n        const { shallow } = options;\n        if (!this.isDragging()) {\n            return false;\n        }\n        const target = this.targets[targetId];\n        const draggedItemType = this.getItemType();\n        if (draggedItemType && !matchesType(target.type, draggedItemType)) {\n            return false;\n        }\n        const targetIds = this.getTargetIds();\n        if (!targetIds.length) {\n            return false;\n        }\n        const index = targetIds.indexOf(targetId);\n        if (shallow) {\n            return index === targetIds.length - 1;\n        }\n        return index > -1;\n    }\n    getItemType() {\n        return this.state.itemType;\n    }\n    getItem() {\n        return this.state.item;\n    }\n    getSourceId() {\n        return this.state.sourceId;\n    }\n    getTargetIds() {\n        return this.state.targetIds || [];\n    }\n    hasDropTarget() {\n        return !!this.getTargetIds().find((id) => this.canDropOnTarget(id));\n    }\n    getDropResult() {\n        return this.state.dropResult;\n    }\n    didDrop() {\n        return !!this.state.didDrop;\n    }\n    getDragEvent() {\n        return this.state.event;\n    }\n    getOperation() {\n        return this.state.operation;\n    }\n    isCancelled() {\n        return !!this.state.cancelled;\n    }\n    beginDrag(sourceIds, operation, x, y, pageX, pageY) {\n        const ids = Array.isArray(sourceIds) ? sourceIds : [sourceIds];\n        if (ids.length) {\n            let sourceId = null;\n            for (let i = ids.length - 1; i >= 0; i--) {\n                if (this.canDragSource(ids[i])) {\n                    sourceId = ids[i];\n                    break;\n                }\n            }\n            if (sourceId) {\n                const source = this.getSource(sourceId);\n                if (source) {\n                    this.state.sourceId = sourceId;\n                    this.state.itemType = source.type;\n                    this.state.event = {\n                        initialPageX: pageX,\n                        initialPageY: pageY,\n                        pageX,\n                        pageY,\n                        initialX: x,\n                        initialY: y,\n                        x,\n                        y,\n                        dx: 0,\n                        dy: 0,\n                    };\n                    this.state.operation = operation;\n                    this.state.isDragging = true;\n                    this.state.item = source.beginDrag(this);\n                }\n            }\n        }\n        this.performHitTests();\n    }\n    hover(targetIds) {\n        const ids = targetIds.filter((id) => this.getTarget(id));\n        this.state.targetIds = ids;\n        ids.forEach((id) => {\n            const target = this.getTarget(id);\n            if (target) {\n                target.hover(this);\n            }\n        });\n    }\n    endDrag() {\n        return __awaiter(this, void 0, void 0, function* () {\n            const source = this.getSource(this.getSourceId());\n            try {\n                if (source) {\n                    yield source.endDrag(this);\n                }\n            }\n            finally {\n                // clear state\n                delete this.state.didDrop;\n                delete this.state.dropResult;\n                delete this.state.event;\n                delete this.state.isDragging;\n                delete this.state.item;\n                delete this.state.sourceId;\n                delete this.state.targetIds;\n                delete this.state.operation;\n                delete this.state.cancelled;\n            }\n        });\n    }\n    drop() {\n        this.getTargetIds()\n            .filter((id) => this.canDropOnTarget(id))\n            .reverse()\n            .forEach((id, idx) => {\n            const target = this.getTarget(id);\n            if (target) {\n                let result = target.drop(this);\n                if (typeof result === 'undefined') {\n                    result = idx === 0 ? {} : this.state.dropResult;\n                }\n                this.state.dropResult = result;\n                this.state.didDrop = true;\n            }\n        });\n    }\n    drag(x, y, pageX, pageY) {\n        if (!this.state.event) {\n            throw new Error('Drag event not initialized');\n        }\n        this.state.event.dx = x - this.state.event.x;\n        this.state.event.dy = y - this.state.event.y;\n        this.state.event.x = x;\n        this.state.event.y = y;\n        this.state.event.pageX = pageX;\n        this.state.event.pageY = pageY;\n        const source = this.getSource(this.getSourceId());\n        if (source) {\n            source.drag(this);\n        }\n        this.performHitTests();\n    }\n    cancel() {\n        if (!this.state.event) {\n            throw new Error('Drag event not initialized');\n        }\n        if (this.state.cancelled) {\n            return true;\n        }\n        const source = this.getSource(this.getSourceId());\n        if (source && source.canCancel(this)) {\n            this.state.cancelled = true;\n            this.drag(this.state.event.initialX, this.state.event.initialY, this.state.event.pageX, this.state.event.pageY);\n            return true;\n        }\n        return false;\n    }\n    performHitTests() {\n        const draggedItemType = this.getItemType();\n        const event = this.getDragEvent();\n        if (event && draggedItemType) {\n            const targetIds = [];\n            Object.keys(this.targets).forEach((targetId) => {\n                const target = this.getTarget(targetId);\n                if (target &&\n                    matchesType(target.type, draggedItemType) &&\n                    target.hitTest(event.x, event.y)) {\n                    targetIds.push(targetId);\n                }\n            });\n            this.hover(targetIds);\n        }\n    }\n    getSource(sourceId) {\n        return sourceId ? this.sources[sourceId] : undefined;\n    }\n    getTarget(targetId) {\n        return targetId ? this.targets[targetId] : undefined;\n    }\n}\n__decorate([\n    observable.shallow\n], DndManagerImpl.prototype, \"sources\", void 0);\n__decorate([\n    observable.shallow\n], DndManagerImpl.prototype, \"targets\", void 0);\n__decorate([\n    computed\n], DndManagerImpl.prototype, \"dropHints\", null);\nexport const useDndManager = () => {\n    const controller = React.useContext(ControllerContext);\n    const store = controller.getStore();\n    let { dndManager } = store;\n    if (!dndManager) {\n        const state = controller.getState();\n        let { dragDrop } = state;\n        if (!dragDrop) {\n            dragDrop = observable.object({});\n            state.dragDrop = dragDrop;\n        }\n        dndManager = new DndManagerImpl(dragDrop);\n        store.dndManager = dndManager;\n    }\n    return dndManager;\n};\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndManager.tsx","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/behavior/useDndManager.tsx"],"names":[],"mappings":"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","sourcesContent":["import * as React from 'react';\nimport { computed, observable } from 'mobx';\nimport ControllerContext from '../utils/ControllerContext';\nimport {\n  DndManager,\n  Identifier,\n  DropTarget,\n  DragEvent,\n  DndStore,\n  DragSource,\n  Unregister,\n  DndState,\n  DndStateContainer,\n  DragOperationWithType,\n} from './dnd-types';\n\nlet nextUniqueId = 0;\n\nconst getNextUniqueId = (): number => {\n  return nextUniqueId++;\n};\n\nexport const matchesType = (\n  targetType: Identifier | Identifier[] | undefined,\n  draggedItemType: Identifier | undefined,\n): boolean => {\n  if (draggedItemType === null) {\n    return targetType === null;\n  }\n  return Array.isArray(targetType)\n    ? targetType.some((t) => t === draggedItemType)\n    : targetType === draggedItemType;\n};\n\nexport class DndManagerImpl implements DndManager {\n  private state: DndState;\n\n  constructor(state: DndState) {\n    this.state = state;\n  }\n\n  // TODO are these really required to be observable?\n  @observable.shallow\n  private sources: { [key: string]: DragSource } = {};\n\n  @observable.shallow\n  private targets: { [key: string]: DropTarget } = {};\n\n  @computed\n  get dropHints(): string[] {\n    return this.state.targetIds\n      ? (this.state.targetIds\n          .map((id) => {\n            const target = this.getTarget(id);\n            return target ? target.dropHint(this) : [];\n          })\n          .filter((x) => x) as string[])\n      : [];\n  }\n\n  registerSource(source: DragSource): [string, Unregister] {\n    const key = `S${getNextUniqueId()}`;\n    this.sources[key] = source;\n    return [\n      key,\n      () => {\n        delete this.sources[key];\n      },\n    ];\n  }\n\n  registerTarget(target: DropTarget): [string, Unregister] {\n    const key = `T${getNextUniqueId()}`;\n    this.targets[key] = target;\n    return [\n      key,\n      () => {\n        delete this.targets[key];\n      },\n    ];\n  }\n\n  getDropHints(): string[] {\n    return this.dropHints;\n  }\n\n  canDragSource(sourceId: string | undefined): boolean {\n    const source = this.getSource(sourceId);\n    if (!source || this.isDragging()) {\n      return false;\n    }\n    return source && source.canDrag(this);\n  }\n\n  canDropOnTarget(targetId: string | undefined): boolean {\n    const target = this.getTarget(targetId);\n    if (!target || !this.isDragging() || this.didDrop()) {\n      return false;\n    }\n\n    const draggedItemType = this.getItemType();\n    return matchesType(target.type, draggedItemType) && target.canDrop(this);\n  }\n\n  isDragging(): boolean {\n    return !!this.state.isDragging;\n  }\n\n  isDraggingSource(sourceId: string | undefined): boolean {\n    return this.state.sourceId != null && this.state.sourceId === sourceId;\n  }\n\n  isOverTarget(targetId: string | undefined, options = { shallow: false }): boolean {\n    if (!targetId) {\n      return false;\n    }\n\n    const { shallow } = options;\n    if (!this.isDragging()) {\n      return false;\n    }\n\n    const target = this.targets[targetId];\n    const draggedItemType = this.getItemType();\n    if (draggedItemType && !matchesType(target.type, draggedItemType)) {\n      return false;\n    }\n\n    const targetIds = this.getTargetIds();\n    if (!targetIds.length) {\n      return false;\n    }\n\n    const index = targetIds.indexOf(targetId);\n    if (shallow) {\n      return index === targetIds.length - 1;\n    }\n    return index > -1;\n  }\n\n  getItemType(): Identifier | undefined {\n    return this.state.itemType;\n  }\n\n  getItem(): any {\n    return this.state.item;\n  }\n\n  getSourceId(): string | undefined {\n    return this.state.sourceId;\n  }\n\n  getTargetIds(): string[] {\n    return this.state.targetIds || [];\n  }\n\n  hasDropTarget(): boolean {\n    return !!this.getTargetIds().find((id) => this.canDropOnTarget(id));\n  }\n\n  getDropResult(): any {\n    return this.state.dropResult;\n  }\n\n  didDrop(): boolean {\n    return !!this.state.didDrop;\n  }\n\n  getDragEvent(): DragEvent | undefined {\n    return this.state.event;\n  }\n\n  getOperation(): DragOperationWithType | undefined {\n    return this.state.operation;\n  }\n\n  isCancelled(): boolean {\n    return !!this.state.cancelled;\n  }\n\n  beginDrag(\n    sourceIds: string | string[],\n    operation: DragOperationWithType | undefined,\n    x: number,\n    y: number,\n    pageX: number,\n    pageY: number,\n  ): void {\n    const ids = Array.isArray(sourceIds) ? sourceIds : [sourceIds];\n    if (ids.length) {\n      let sourceId: string | null = null;\n      for (let i = ids.length - 1; i >= 0; i--) {\n        if (this.canDragSource(ids[i])) {\n          sourceId = ids[i];\n          break;\n        }\n      }\n      if (sourceId) {\n        const source = this.getSource(sourceId);\n        if (source) {\n          this.state.sourceId = sourceId;\n          this.state.itemType = source.type;\n          this.state.event = {\n            initialPageX: pageX,\n            initialPageY: pageY,\n            pageX,\n            pageY,\n            initialX: x,\n            initialY: y,\n            x,\n            y,\n            dx: 0,\n            dy: 0,\n          };\n          this.state.operation = operation;\n          this.state.isDragging = true;\n          this.state.item = source.beginDrag(this);\n        }\n      }\n    }\n    this.performHitTests();\n  }\n\n  hover(targetIds: string[]): void {\n    const ids: string[] = targetIds.filter((id) => this.getTarget(id));\n    this.state.targetIds = ids;\n    ids.forEach((id) => {\n      const target = this.getTarget(id);\n      if (target) {\n        target.hover(this);\n      }\n    });\n  }\n\n  async endDrag(): Promise<void> {\n    const source = this.getSource(this.getSourceId());\n    try {\n      if (source) {\n        await source.endDrag(this);\n      }\n    } finally {\n      // clear state\n      delete this.state.didDrop;\n      delete this.state.dropResult;\n      delete this.state.event;\n      delete this.state.isDragging;\n      delete this.state.item;\n      delete this.state.sourceId;\n      delete this.state.targetIds;\n      delete this.state.operation;\n      delete this.state.cancelled;\n    }\n  }\n\n  drop(): void {\n    this.getTargetIds()\n      .filter((id) => this.canDropOnTarget(id))\n      .reverse()\n      .forEach((id, idx) => {\n        const target = this.getTarget(id);\n        if (target) {\n          let result = target.drop(this);\n          if (typeof result === 'undefined') {\n            result = idx === 0 ? {} : this.state.dropResult;\n          }\n          this.state.dropResult = result;\n          this.state.didDrop = true;\n        }\n      });\n  }\n\n  drag(x: number, y: number, pageX: number, pageY: number): void {\n    if (!this.state.event) {\n      throw new Error('Drag event not initialized');\n    }\n    this.state.event.dx = x - this.state.event.x;\n    this.state.event.dy = y - this.state.event.y;\n    this.state.event.x = x;\n    this.state.event.y = y;\n    this.state.event.pageX = pageX;\n    this.state.event.pageY = pageY;\n\n    const source = this.getSource(this.getSourceId());\n    if (source) {\n      source.drag(this);\n    }\n    this.performHitTests();\n  }\n\n  cancel(): boolean {\n    if (!this.state.event) {\n      throw new Error('Drag event not initialized');\n    }\n    if (this.state.cancelled) {\n      return true;\n    }\n    const source = this.getSource(this.getSourceId());\n    if (source && source.canCancel(this)) {\n      this.state.cancelled = true;\n      this.drag(\n        this.state.event.initialX,\n        this.state.event.initialY,\n        this.state.event.pageX,\n        this.state.event.pageY,\n      );\n      return true;\n    }\n    return false;\n  }\n\n  private performHitTests(): void {\n    const draggedItemType = this.getItemType();\n    const event = this.getDragEvent();\n    if (event && draggedItemType) {\n      const targetIds: string[] = [];\n      Object.keys(this.targets).forEach((targetId) => {\n        const target = this.getTarget(targetId);\n        if (\n          target &&\n          matchesType(target.type, draggedItemType) &&\n          target.hitTest(event.x, event.y)\n        ) {\n          targetIds.push(targetId);\n        }\n      });\n\n      this.hover(targetIds);\n    }\n  }\n\n  private getSource(sourceId: string | undefined): DragSource | undefined {\n    return sourceId ? this.sources[sourceId] : undefined;\n  }\n\n  private getTarget(targetId: string | undefined): DropTarget | undefined {\n    return targetId ? this.targets[targetId] : undefined;\n  }\n}\n\nexport const useDndManager = () => {\n  const controller = React.useContext(ControllerContext);\n  const store = controller.getStore<DndStore>();\n  let { dndManager } = store;\n  if (!dndManager) {\n    const state = controller.getState<DndStateContainer>();\n    let { dragDrop } = state;\n    if (!dragDrop) {\n      dragDrop = observable.object<DndState>({});\n      state.dragDrop = dragDrop;\n    }\n    dndManager = new DndManagerImpl(dragDrop);\n    store.dndManager = dndManager;\n  }\n  return dndManager;\n};\n"]}]}