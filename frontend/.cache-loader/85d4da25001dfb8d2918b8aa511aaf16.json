{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-augment.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-augment.ts","mtime":1617182414010},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["import { chart_color_green_400 as successColor, chart_color_blue_300 as runningColor, global_danger_color_100 as failureColor, chart_color_blue_100 as pendingColor, chart_color_black_400 as skippedColor, chart_color_black_500 as cancelledColor, } from '@patternfly/react-tokens';\nimport { referenceForModel } from '@console/internal/module/k8s';\nimport { ClusterTaskModel, ClusterTriggerBindingModel, PipelineRunModel, TaskModel, TriggerBindingModel, } from '../models';\nimport { pipelineRunFilterReducer } from './pipeline-filter-reducer';\nexport const getResources = (data) => {\n    const resources = [];\n    const propsReferenceForRuns = [];\n    if (data && data.length > 0) {\n        data.forEach((pipeline, i) => {\n            if (pipeline.metadata && pipeline.metadata.namespace && pipeline.metadata.name) {\n                propsReferenceForRuns.push(`PipelineRun_${i}`);\n                resources.push({\n                    kind: referenceForModel(PipelineRunModel),\n                    namespace: pipeline.metadata.namespace,\n                    isList: true,\n                    prop: `PipelineRun_${i}`,\n                    selector: {\n                        'tekton.dev/pipeline': pipeline.metadata.name,\n                    },\n                });\n            }\n        });\n        return { propsReferenceForRuns, resources };\n    }\n    return { propsReferenceForRuns: null, resources: null };\n};\nexport const getLatestRun = (runs, field) => {\n    if (!runs || !runs.data || !(runs.data.length > 0) || !field) {\n        return null;\n    }\n    let latestRun = runs.data[0];\n    if (field === 'creationTimestamp') {\n        for (let i = 1; i < runs.data.length; i++) {\n            latestRun =\n                runs.data[i] &&\n                    runs.data[i].metadata &&\n                    runs.data[i].metadata[field] &&\n                    new Date(runs.data[i].metadata[field]) > new Date(latestRun.metadata[field])\n                    ? runs.data[i]\n                    : latestRun;\n        }\n    }\n    else if (field === 'startTime' || field === 'completionTime') {\n        for (let i = 1; i < runs.data.length; i++) {\n            latestRun =\n                runs.data[i] &&\n                    runs.data[i].status &&\n                    runs.data[i].status[field] &&\n                    new Date(runs.data[i].status[field]) > new Date(latestRun.status[field])\n                    ? runs.data[i]\n                    : latestRun;\n        }\n    }\n    else {\n        latestRun = runs.data[runs.data.length - 1];\n    }\n    if (!latestRun.status) {\n        latestRun = Object.assign(Object.assign({}, latestRun), { status: {} });\n    }\n    if (!latestRun.status.succeededCondition) {\n        latestRun.status = Object.assign(Object.assign({}, latestRun.status), { succeededCondition: '' });\n    }\n    latestRun.status.succeededCondition = pipelineRunFilterReducer(latestRun);\n    return latestRun;\n};\nexport const augmentRunsToData = (data, propsReferenceForRuns, runs) => {\n    if (propsReferenceForRuns) {\n        const newData = [];\n        propsReferenceForRuns.forEach((reference, i) => {\n            const latestRun = getLatestRun(runs[reference], 'creationTimestamp');\n            if (latestRun !== data[i].latestRun) {\n                // ensure we create a new data object if the latestRun has changed so that shallow compare fails\n                newData.push(Object.assign(Object.assign({}, data[i]), { latestRun }));\n            }\n            else {\n                newData.push(data[i]);\n            }\n        });\n        return newData;\n    }\n    return data;\n};\nexport var runStatus;\n(function (runStatus) {\n    runStatus[\"Succeeded\"] = \"Succeeded\";\n    runStatus[\"Failed\"] = \"Failed\";\n    runStatus[\"Running\"] = \"Running\";\n    runStatus[\"In Progress\"] = \"In Progress\";\n    runStatus[\"FailedToStart\"] = \"FailedToStart\";\n    runStatus[\"PipelineNotStarted\"] = \"PipelineNotStarted\";\n    runStatus[\"Skipped\"] = \"Skipped\";\n    runStatus[\"Cancelled\"] = \"Cancelled\";\n    runStatus[\"Pending\"] = \"Pending\";\n    runStatus[\"Idle\"] = \"Idle\";\n})(runStatus || (runStatus = {}));\nexport const getRunStatusColor = (status) => {\n    switch (status) {\n        case runStatus.Succeeded:\n            return { message: 'Succeeded', pftoken: successColor };\n        case runStatus.Failed:\n            return { message: 'Failed', pftoken: failureColor };\n        case runStatus.FailedToStart:\n            return {\n                message: 'PipelineRun failed to start',\n                pftoken: failureColor,\n            };\n        case runStatus.Running:\n            return { message: 'Running', pftoken: runningColor };\n        case runStatus['In Progress']:\n            return { message: 'Running', pftoken: runningColor };\n        case runStatus.Skipped:\n            return { message: 'Skipped', pftoken: skippedColor };\n        case runStatus.Cancelled:\n            return { message: 'Cancelled', pftoken: cancelledColor };\n        case runStatus.Idle:\n        case runStatus.Pending:\n            return { message: 'Pending', pftoken: pendingColor };\n        default:\n            return { message: 'PipelineRun not started yet', pftoken: pendingColor };\n    }\n};\nexport const truncateName = (name, length) => name.length < length ? name : `${name.slice(0, length - 1)}...`;\nexport const getTaskStatus = (pipelinerun, pipeline) => {\n    const totalTasks = pipeline && pipeline.spec && pipeline.spec.tasks ? pipeline.spec.tasks.length : 0;\n    const plrTasks = pipelinerun && pipelinerun.status && pipelinerun.status.taskRuns\n        ? pipelinerun.status.runs ? Object.keys(pipelinerun.status.runs).concat(Object.keys(pipelinerun.status.taskRuns))\n            : Object.keys(pipelinerun.status.taskRuns)\n        : [];\n    const plrTaskLength = plrTasks.length;\n    const taskStatus = {\n        PipelineNotStarted: 0,\n        Pending: 0,\n        Running: 0,\n        Succeeded: 0,\n        Failed: 0,\n        Cancelled: 0,\n    };\n    if (plrTasks) {\n        plrTasks.forEach((taskRun) => {\n            var _a;\n            const status = pipelineRunFilterReducer((_a = pipelinerun.status.taskRuns[taskRun]) !== null && _a !== void 0 ? _a : pipelinerun.status.runs[taskRun]);\n            if (status === 'Succeeded' || status === 'Completed' || status === 'Complete') {\n                taskStatus[runStatus.Succeeded]++;\n            }\n            else if (status === 'Running') {\n                taskStatus[runStatus.Running]++;\n            }\n            else if (status === 'Failed') {\n                taskStatus[runStatus.Failed]++;\n            }\n            else if (status === 'Cancelled') {\n                taskStatus[runStatus.Cancelled]++;\n            }\n            else {\n                taskStatus[runStatus.Pending]++;\n            }\n        });\n        taskStatus[runStatus.Failed] > 0 || taskStatus[runStatus.Cancelled] > 0\n            ? (taskStatus[runStatus.Cancelled] +=\n                totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks)\n            : (taskStatus[runStatus.Pending] +=\n                totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks);\n    }\n    else if (pipelinerun &&\n        pipelinerun.status &&\n        pipelinerun.status.conditions &&\n        pipelinerun.status.conditions[0].status === 'False') {\n        taskStatus[runStatus.Cancelled] = totalTasks;\n    }\n    else {\n        taskStatus[runStatus.PipelineNotStarted]++;\n    }\n    return taskStatus;\n};\nexport const getResourceModelFromTaskKind = (kind) => kind === ClusterTaskModel.kind ? ClusterTaskModel : TaskModel;\nexport const getResourceModelFromBindingKind = (kind) => kind === ClusterTriggerBindingModel.kind ? ClusterTriggerBindingModel : TriggerBindingModel;\nexport const getResourceModelFromTask = (task) => {\n    const { taskRef: { kind }, } = task;\n    return getResourceModelFromTaskKind(kind);\n};\nexport const pipelineRefExists = (pipelineRun) => { var _a; return !!((_a = pipelineRun.spec.pipelineRef) === null || _a === void 0 ? void 0 : _a.name); };\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-augment.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/dev-console/src/utils/pipeline-augment.ts"],"names":[],"mappings":"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","sourcesContent":["import {\n  chart_color_green_400 as successColor,\n  chart_color_blue_300 as runningColor,\n  global_danger_color_100 as failureColor,\n  chart_color_blue_100 as pendingColor,\n  chart_color_black_400 as skippedColor,\n  chart_color_black_500 as cancelledColor,\n} from '@patternfly/react-tokens';\nimport { K8sKind, K8sResourceKind, referenceForModel } from '@console/internal/module/k8s';\nimport {\n  ClusterTaskModel,\n  ClusterTriggerBindingModel,\n  PipelineRunModel,\n  TaskModel,\n  TriggerBindingModel,\n} from '../models';\nimport { pipelineRunFilterReducer } from './pipeline-filter-reducer';\n\ninterface Metadata {\n  name: string;\n  namespace?: string;\n}\n\nexport interface PropPipelineData {\n  metadata: Metadata;\n  latestRun?: PipelineRun;\n}\n\ninterface StatusMessage {\n  message: string;\n  pftoken: { name: string; value: string; var: string };\n}\n\nexport interface TaskStatus {\n  PipelineNotStarted: number;\n  Pending: number;\n  Running: number;\n  Succeeded: number;\n  Cancelled: number;\n  Failed: number;\n}\n\nexport interface PipelineTaskRef {\n  kind?: string;\n  name: string;\n}\n\nexport interface PipelineTaskParam {\n  name: string;\n  value: any;\n}\nexport interface PipelineTaskResources {\n  inputs?: PipelineTaskResource[];\n  outputs?: PipelineTaskResource[];\n}\nexport interface PipelineTaskResource {\n  name: string;\n  resource?: string;\n  from?: string[];\n}\nexport interface PipelineTask {\n  name: string;\n  runAfter?: string[];\n  taskRef: PipelineTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n}\n\nexport interface Resource {\n  propsReferenceForRuns: string[];\n  resources: FirehoseResource[];\n}\n\nexport interface PipelineResource {\n  name: string;\n  type: string;\n}\n\ntype PipelineRunResourceCommonProperties = {\n  name: string;\n};\nexport type PipelineRunInlineResourceParam = { name: string; value: string };\nexport type PipelineRunInlineResource = PipelineRunResourceCommonProperties & {\n  resourceSpec: {\n    params: PipelineRunInlineResourceParam[];\n    type: string;\n  };\n};\nexport type PipelineRunReferenceResource = PipelineRunResourceCommonProperties & {\n  resourceRef: {\n    name: string;\n  };\n};\nexport type PipelineRunResource = PipelineRunReferenceResource | PipelineRunInlineResource;\n\nexport interface Runs {\n  data?: PipelineRun[];\n}\n\nexport type KeyedRuns = { [key: string]: Runs };\n\nexport interface Pipeline extends K8sResourceKind {\n  latestRun?: PipelineRun;\n  spec: {\n    params?: PipelineParam[];\n    resources?: PipelineResource[];\n    workspaces?: PipelineWorkspace[];\n    tasks: PipelineTask[];\n    serviceAccountName?: string;\n  };\n}\n\nexport type TaskRunKind = { pipelineTaskName?: string } & K8sResourceKind;\n\nexport interface TaskRuns {\n  [key: string]: TaskRunKind;\n}\n\nexport interface PipelineSpecTaskRef {\n  kind?: string;\n  name?: string;\n  apiVersion?: string;\n}\n\nexport interface PipelineSpecTaskSpec {\n  metadata?: {};\n  steps?: {\n    // TODO: Figure out required fields\n    env?: PipelineTaskParam[];\n    image?: string;\n    name?: string;\n    resources?: {};\n    script?: string;\n    securityContext?: {\n      privileged: boolean;\n      [key: string]: any;\n    }\n    imagePullPolicy?: string;\n    workingDir?: string;\n  }[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpecTask {\n  name: string;\n  runAfter?: string[];\n  taskRef?: PipelineSpecTaskRef;\n  params?: PipelineTaskParam[];\n  resources?: PipelineTaskResources;\n  taskSpec?: PipelineSpecTaskSpec;\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineSpec extends K8sResourceKind {\n  tasks: PipelineSpecTask[];\n  workspaces?: PipelineRunWorkspace[];\n}\n\nexport interface PipelineRun extends K8sResourceKind {\n  spec?: {\n    pipelineRef?: { name: string };\n    params?: PipelineRunParam[];\n    workspaces?: PipelineRunWorkspace[];\n    resources?: PipelineRunResource[];\n    serviceAccountName?: string;\n    // Odd status value that only appears in a single case - cancelling a pipeline\n    status?: 'PipelineRunCancelled';\n    timeout?: string;\n    pipelineSpec?: PipelineSpec;\n  };\n  status?: {\n    succeededCondition?: string;\n    creationTimestamp?: string;\n    conditions?: Condition[];\n    startTime?: string;\n    completionTime?: string;\n    taskRuns?: TaskRuns;\n    runs?: TaskRuns; \n    phase?: string;\n    nodes?: any;\n  };\n}\n\nexport type PipelineResourceKind = K8sResourceKind & {\n  spec: {\n    params: { name: string; value: string }[];\n    type: string;\n  };\n};\n\nexport interface PipelineResourceTaskParam extends PipelineParam {\n  type: string;\n}\nexport interface PipelineResourceTaskResource {\n  name: string;\n  type: string;\n  optional?: boolean;\n}\nexport interface PipelineResourceTask extends K8sResourceKind {\n  spec: {\n    params?: PipelineResourceTaskParam[];\n    resources?: {\n      inputs?: PipelineResourceTaskResource[];\n      outputs?: PipelineResourceTaskResource[];\n    };\n\n    steps: {\n      // TODO: Figure out required fields\n      args?: string[];\n      command?: string[];\n      image?: string;\n      resources?: {}[];\n    }[];\n  };\n}\n\nexport interface Condition {\n  type: string;\n  status: string;\n  reason?: string;\n  message?: string;\n  lastTransitionTime?: string;\n}\n\nexport interface Param {\n  name: string;\n}\n\nexport interface PipelineParam extends Param {\n  default?: string | string[];\n  description?: string;\n}\n\nexport interface PipelineRunParam extends Param {\n  value: string | string[];\n  input?: string;\n  output?: string;\n  resource?: object;\n}\n\nexport interface PipelineWorkspace extends Param {\n  type: string;\n  data?: {\n    [key: string]: string;\n  };\n}\n\nexport interface PipelineRunWorkspace extends Param {\n  [key: string]: string;\n}\n\ninterface FirehoseResource {\n  kind: string;\n  namespace?: string;\n  isList?: boolean;\n  selector?: object;\n}\n\nexport const getResources = (data: PropPipelineData[]): Resource => {\n  const resources = [];\n  const propsReferenceForRuns = [];\n  if (data && data.length > 0) {\n    data.forEach((pipeline, i) => {\n      if (pipeline.metadata && pipeline.metadata.namespace && pipeline.metadata.name) {\n        propsReferenceForRuns.push(`PipelineRun_${i}`);\n        resources.push({\n          kind: referenceForModel(PipelineRunModel),\n          namespace: pipeline.metadata.namespace,\n          isList: true,\n          prop: `PipelineRun_${i}`,\n          selector: {\n            'tekton.dev/pipeline': pipeline.metadata.name,\n          },\n        });\n      }\n    });\n    return { propsReferenceForRuns, resources };\n  }\n  return { propsReferenceForRuns: null, resources: null };\n};\n\nexport const getLatestRun = (runs: Runs, field: string): PipelineRun => {\n  if (!runs || !runs.data || !(runs.data.length > 0) || !field) {\n    return null;\n  }\n  let latestRun = runs.data[0];\n  if (field === 'creationTimestamp') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].metadata &&\n        runs.data[i].metadata[field] &&\n        new Date(runs.data[i].metadata[field]) > new Date(latestRun.metadata[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else if (field === 'startTime' || field === 'completionTime') {\n    for (let i = 1; i < runs.data.length; i++) {\n      latestRun =\n        runs.data[i] &&\n        runs.data[i].status &&\n        runs.data[i].status[field] &&\n        new Date(runs.data[i].status[field]) > new Date(latestRun.status[field])\n          ? runs.data[i]\n          : latestRun;\n    }\n  } else {\n    latestRun = runs.data[runs.data.length - 1];\n  }\n  if (!latestRun.status) {\n    latestRun = { ...latestRun, status: {} };\n  }\n  if (!latestRun.status.succeededCondition) {\n    latestRun.status = { ...latestRun.status, succeededCondition: '' };\n  }\n  latestRun.status.succeededCondition = pipelineRunFilterReducer(latestRun);\n  return latestRun;\n};\n\nexport const augmentRunsToData = (\n  data: PropPipelineData[],\n  propsReferenceForRuns: string[],\n  runs: { [key: string]: Runs },\n): PropPipelineData[] => {\n  if (propsReferenceForRuns) {\n    const newData: PropPipelineData[] = [];\n    propsReferenceForRuns.forEach((reference, i) => {\n      const latestRun = getLatestRun(runs[reference], 'creationTimestamp');\n      if (latestRun !== data[i].latestRun) {\n        // ensure we create a new data object if the latestRun has changed so that shallow compare fails\n        newData.push({ ...data[i], latestRun });\n      } else {\n        newData.push(data[i]);\n      }\n    });\n    return newData;\n  }\n  return data;\n};\n\nexport enum runStatus {\n  Succeeded = 'Succeeded',\n  Failed = 'Failed',\n  Running = 'Running',\n  'In Progress' = 'In Progress',\n  FailedToStart = 'FailedToStart',\n  PipelineNotStarted = 'PipelineNotStarted',\n  Skipped = 'Skipped',\n  Cancelled = 'Cancelled',\n  Pending = 'Pending',\n  Idle = 'Idle',\n}\n\nexport const getRunStatusColor = (status: string): StatusMessage => {\n  switch (status) {\n    case runStatus.Succeeded:\n      return { message: 'Succeeded', pftoken: successColor };\n    case runStatus.Failed:\n      return { message: 'Failed', pftoken: failureColor };\n    case runStatus.FailedToStart:\n      return {\n        message: 'PipelineRun failed to start',\n        pftoken: failureColor,\n      };\n    case runStatus.Running:\n      return { message: 'Running', pftoken: runningColor };\n    case runStatus['In Progress']:\n      return { message: 'Running', pftoken: runningColor };\n\n    case runStatus.Skipped:\n      return { message: 'Skipped', pftoken: skippedColor };\n    case runStatus.Cancelled:\n      return { message: 'Cancelled', pftoken: cancelledColor };\n    case runStatus.Idle:\n    case runStatus.Pending:\n      return { message: 'Pending', pftoken: pendingColor };\n    default:\n      return { message: 'PipelineRun not started yet', pftoken: pendingColor };\n  }\n};\n\nexport const truncateName = (name: string, length: number): string =>\n  name.length < length ? name : `${name.slice(0, length - 1)}...`;\n\nexport const getTaskStatus = (pipelinerun: PipelineRun, pipeline: Pipeline): TaskStatus => {\n  const totalTasks =\n    pipeline && pipeline.spec && pipeline.spec.tasks ? pipeline.spec.tasks.length : 0;\n  const plrTasks =\n    pipelinerun && pipelinerun.status && pipelinerun.status.taskRuns\n      ? pipelinerun.status.runs ? Object.keys(pipelinerun.status.runs).concat(Object.keys(pipelinerun.status.taskRuns))\n        : Object.keys(pipelinerun.status.taskRuns)\n      : [];\n  const plrTaskLength = plrTasks.length;\n  const taskStatus: TaskStatus = {\n    PipelineNotStarted: 0,\n    Pending: 0,\n    Running: 0,\n    Succeeded: 0,\n    Failed: 0,\n    Cancelled: 0,\n  };\n  if (plrTasks) {\n    plrTasks.forEach((taskRun) => {\n      const status = pipelineRunFilterReducer(pipelinerun.status.taskRuns[taskRun] ?? pipelinerun.status.runs[taskRun]);\n      if (status === 'Succeeded' || status === 'Completed' || status === 'Complete') {\n        taskStatus[runStatus.Succeeded]++;\n      } else if (status === 'Running') {\n        taskStatus[runStatus.Running]++;\n      } else if (status === 'Failed') {\n        taskStatus[runStatus.Failed]++;\n      } else if (status === 'Cancelled') {\n        taskStatus[runStatus.Cancelled]++;\n      } else {\n        taskStatus[runStatus.Pending]++;\n      }\n    });\n    taskStatus[runStatus.Failed] > 0 || taskStatus[runStatus.Cancelled] > 0\n      ? (taskStatus[runStatus.Cancelled] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks)\n      : (taskStatus[runStatus.Pending] +=\n          totalTasks >= plrTaskLength ? totalTasks - plrTaskLength : totalTasks);\n  } else if (\n    pipelinerun &&\n    pipelinerun.status &&\n    pipelinerun.status.conditions &&\n    pipelinerun.status.conditions[0].status === 'False'\n  ) {\n    taskStatus[runStatus.Cancelled] = totalTasks;\n  } else {\n    taskStatus[runStatus.PipelineNotStarted]++;\n  }\n  return taskStatus;\n};\n\nexport const getResourceModelFromTaskKind = (kind: string): K8sKind =>\n  kind === ClusterTaskModel.kind ? ClusterTaskModel : TaskModel;\n\nexport const getResourceModelFromBindingKind = (kind: string): K8sKind =>\n  kind === ClusterTriggerBindingModel.kind ? ClusterTriggerBindingModel : TriggerBindingModel;\n\nexport const getResourceModelFromTask = (task: PipelineTask): K8sKind => {\n  const {\n    taskRef: { kind },\n  } = task;\n\n  return getResourceModelFromTaskKind(kind);\n};\n\nexport const pipelineRefExists = (pipelineRun: PipelineRun): boolean =>\n  !!pipelineRun.spec.pipelineRef?.name;\n"]}]}