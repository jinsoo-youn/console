{"remainingRequest":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js??ref--5-1!/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js??ref--5-2!/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseGraph.ts","dependencies":[{"path":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseGraph.ts","mtime":1616735742460},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/cache-loader/dist/cjs.js","mtime":1607306270906},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/thread-loader/dist/cjs.js","mtime":1607306283100},{"path":"/home/jinsoo/hypercloud-console5.0/frontend/node_modules/ts-loader/index.js","mtime":1607306283339}],"contextDependencies":[],"result":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { computed, observable } from 'mobx';\nimport Rect from '../geom/Rect';\nimport Point from '../geom/Point';\nimport Dimensions from '../geom/Dimensions';\nimport { DEFAULT_LAYERS } from '../const';\nimport { ModelKind, isNode, isEdge, } from '../types';\nimport BaseElement from './BaseElement';\nexport default class BaseGraph extends BaseElement {\n    constructor() {\n        super(...arguments);\n        this.layers = DEFAULT_LAYERS;\n        this.scale = 1;\n        this.dimensions = new Dimensions();\n        this.position = new Point();\n        this.scaleExtent = [0.25, 4];\n        this.panIntoView = (nodeElement, { offset = 0, minimumVisible = 0 } = {}) => {\n            if (!nodeElement) {\n                return;\n            }\n            const { x: viewX, y: viewY, width: viewWidth, height: viewHeight } = this.getBounds();\n            const boundingBox = nodeElement\n                .getBounds()\n                .clone()\n                .scale(this.scale)\n                .translate(viewX, viewY);\n            const { x, y, width, height } = boundingBox;\n            let move = false;\n            const panOffset = offset * this.scale;\n            const minVisibleSize = minimumVisible * this.scale;\n            const newLocation = {\n                x: viewX,\n                y: viewY,\n            };\n            if (x + width - minVisibleSize < 0) {\n                newLocation.x -= x - panOffset;\n                move = true;\n            }\n            if (x + minVisibleSize > viewWidth) {\n                newLocation.x -= x + width - viewWidth + panOffset;\n                move = true;\n            }\n            if (y + height - minVisibleSize < 0) {\n                newLocation.y -= y - panOffset;\n                move = true;\n            }\n            if (y + minVisibleSize > viewHeight) {\n                newLocation.y -= y + height - viewHeight + panOffset;\n                move = true;\n            }\n            if (move) {\n                this.setBounds(new Rect(newLocation.x, newLocation.y, viewWidth, viewHeight));\n            }\n        };\n    }\n    get edges() {\n        return this.getChildren().filter(isEdge);\n    }\n    get nodes() {\n        return this.getChildren().filter(isNode);\n    }\n    getKind() {\n        return ModelKind.graph;\n    }\n    getLayers() {\n        return this.layers;\n    }\n    setLayers(layers) {\n        this.layers = layers;\n    }\n    getScaleExtent() {\n        return this.scaleExtent;\n    }\n    setScaleExtent(scaleExtent) {\n        this.scaleExtent = scaleExtent;\n    }\n    getBounds() {\n        const { position: { x, y }, dimensions: { width, height }, } = this;\n        return new Rect(x, y, width, height);\n    }\n    setBounds(bounds) {\n        const { width, height } = this.dimensions;\n        if (bounds.width !== width || bounds.height !== height) {\n            this.dimensions = new Dimensions(bounds.width, bounds.height);\n        }\n        const { x, y } = this.position;\n        if (bounds.x !== x || bounds.y !== y) {\n            this.position = new Point(bounds.x, bounds.y);\n        }\n    }\n    getPosition() {\n        return this.position;\n    }\n    setPosition(point) {\n        this.position = point;\n    }\n    getDimensions() {\n        return this.dimensions;\n    }\n    setDimensions(dimensions) {\n        this.dimensions = dimensions;\n    }\n    getNodes() {\n        return this.nodes;\n    }\n    getEdges() {\n        return this.edges;\n    }\n    getLayout() {\n        return this.layoutType;\n    }\n    setLayout(layout) {\n        if (layout === this.layoutType) {\n            return;\n        }\n        if (this.currentLayout) {\n            this.currentLayout.destroy();\n        }\n        this.layoutType = layout;\n        this.currentLayout = layout ? this.getController().getLayout(layout) : undefined;\n    }\n    layout() {\n        if (this.currentLayout) {\n            this.currentLayout.layout();\n        }\n    }\n    getScale() {\n        return this.scale;\n    }\n    setScale(scale) {\n        this.scale = scale;\n    }\n    reset() {\n        this.scale = 1;\n        this.position = new Point(0, 0);\n    }\n    scaleBy(scale, location) {\n        const b = this.getBounds();\n        let { x, y } = b;\n        const c = location || b.getCenter().translate(-x, -y);\n        x = (c.x - x) / this.scale;\n        y = (c.y - y) / this.scale;\n        const newScale = Math.max(Math.min(this.scale * scale, this.scaleExtent[1]), this.scaleExtent[0]);\n        this.setScale(newScale);\n        x = c.x - x * this.scale;\n        y = c.y - y * this.scale;\n        this.position = new Point(x, y);\n    }\n    fit(padding = 0) {\n        let rect;\n        this.getNodes().forEach((c) => {\n            const b = c.getBounds();\n            if (!rect) {\n                rect = b.clone();\n            }\n            else {\n                rect.union(b);\n            }\n        });\n        if (!rect) {\n            return;\n        }\n        const { width, height } = rect;\n        if (width === 0 || height === 0) {\n            return;\n        }\n        const { width: fullWidth, height: fullHeight } = this.getDimensions();\n        const midX = rect.x + width / 2;\n        const midY = rect.y + height / 2;\n        // set the max scale to be the current zoom level or 1\n        const maxScale = Math.max(this.getScale(), 1);\n        // compute the scale\n        const scale = Math.min(1 /\n            Math.max(width / Math.max(1, fullWidth - padding), height / Math.max(1, fullHeight - padding)), maxScale);\n        // translate to center\n        const tx = fullWidth / 2 - midX * scale;\n        const ty = fullHeight / 2 - midY * scale;\n        // TODO should scale and bound be kept in a single geom Transform object instead of separately?\n        this.scale = scale;\n        this.position = new Point(tx, ty);\n    }\n    setModel(model) {\n        var _a;\n        super.setModel(model);\n        if ('layers' in model && model.layers) {\n            this.setLayers(model.layers);\n        }\n        if ('layout' in model) {\n            this.setLayout(model.layout);\n        }\n        if (((_a = model.scaleExtent) === null || _a === void 0 ? void 0 : _a.length) === 2) {\n            this.setScaleExtent(model.scaleExtent);\n        }\n        if ('scale' in model && typeof model.scale === 'number') {\n            this.setScale(+model.scale);\n        }\n        let p;\n        if ('x' in model && model.x != null) {\n            if (!p) {\n                p = this.position.clone();\n            }\n            p.x = model.x;\n        }\n        if ('y' in model && model.y != null) {\n            if (!p) {\n                p = this.position.clone();\n            }\n            p.y = model.y;\n        }\n        if (p) {\n            this.setPosition(p);\n        }\n    }\n    translateToAbsolute() {\n        // do nothing\n    }\n    translateFromAbsolute() {\n        // do nothing\n    }\n    destroy() {\n        if (this.currentLayout) {\n            this.currentLayout.destroy();\n        }\n    }\n}\n__decorate([\n    observable.ref\n], BaseGraph.prototype, \"layers\", void 0);\n__decorate([\n    observable\n], BaseGraph.prototype, \"scale\", void 0);\n__decorate([\n    observable\n], BaseGraph.prototype, \"layoutType\", void 0);\n__decorate([\n    observable.ref\n], BaseGraph.prototype, \"dimensions\", void 0);\n__decorate([\n    observable.ref\n], BaseGraph.prototype, \"position\", void 0);\n__decorate([\n    observable.ref\n], BaseGraph.prototype, \"scaleExtent\", void 0);\n__decorate([\n    computed\n], BaseGraph.prototype, \"edges\", null);\n__decorate([\n    computed\n], BaseGraph.prototype, \"nodes\", null);\n",{"version":3,"file":"/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseGraph.ts","sourceRoot":"","sources":["/home/jinsoo/hypercloud-console5.0/frontend/packages/topology/src/elements/BaseGraph.ts"],"names":[],"mappings":"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","sourcesContent":["import { computed, observable } from 'mobx';\nimport Rect from '../geom/Rect';\nimport Point from '../geom/Point';\nimport Dimensions from '../geom/Dimensions';\nimport { DEFAULT_LAYERS } from '../const';\nimport {\n  Graph,\n  Edge,\n  Node,\n  GraphModel,\n  ModelKind,\n  isNode,\n  isEdge,\n  Layout,\n  ScaleExtent,\n} from '../types';\nimport BaseElement from './BaseElement';\n\nexport default class BaseGraph<E extends GraphModel = GraphModel, D = any> extends BaseElement<E, D>\n  implements Graph<E, D> {\n  @observable.ref\n  private layers = DEFAULT_LAYERS;\n\n  @observable\n  private scale = 1;\n\n  @observable\n  private layoutType?: string;\n\n  @observable.ref\n  private dimensions = new Dimensions();\n\n  @observable.ref\n  private position = new Point();\n\n  private currentLayout?: Layout;\n\n  @observable.ref\n  private scaleExtent: ScaleExtent = [0.25, 4];\n\n  @computed\n  private get edges(): Edge[] {\n    return this.getChildren().filter(isEdge);\n  }\n\n  @computed\n  private get nodes(): Node[] {\n    return this.getChildren().filter(isNode);\n  }\n\n  getKind(): ModelKind {\n    return ModelKind.graph;\n  }\n\n  getLayers(): string[] {\n    return this.layers;\n  }\n\n  setLayers(layers: string[]): void {\n    this.layers = layers;\n  }\n\n  getScaleExtent(): ScaleExtent {\n    return this.scaleExtent;\n  }\n\n  setScaleExtent(scaleExtent: ScaleExtent): void {\n    this.scaleExtent = scaleExtent;\n  }\n\n  getBounds(): Rect {\n    const {\n      position: { x, y },\n      dimensions: { width, height },\n    } = this;\n    return new Rect(x, y, width, height);\n  }\n\n  setBounds(bounds: Rect): void {\n    const { width, height } = this.dimensions;\n    if (bounds.width !== width || bounds.height !== height) {\n      this.dimensions = new Dimensions(bounds.width, bounds.height);\n    }\n    const { x, y } = this.position;\n    if (bounds.x !== x || bounds.y !== y) {\n      this.position = new Point(bounds.x, bounds.y);\n    }\n  }\n\n  getPosition(): Point {\n    return this.position;\n  }\n\n  setPosition(point: Point): void {\n    this.position = point;\n  }\n\n  getDimensions(): Dimensions {\n    return this.dimensions;\n  }\n\n  setDimensions(dimensions: Dimensions): void {\n    this.dimensions = dimensions;\n  }\n\n  getNodes(): Node[] {\n    return this.nodes;\n  }\n\n  getEdges(): Edge[] {\n    return this.edges;\n  }\n\n  getLayout(): string | undefined {\n    return this.layoutType;\n  }\n\n  setLayout(layout: string | undefined): void {\n    if (layout === this.layoutType) {\n      return;\n    }\n\n    if (this.currentLayout) {\n      this.currentLayout.destroy();\n    }\n\n    this.layoutType = layout;\n    this.currentLayout = layout ? this.getController().getLayout(layout) : undefined;\n  }\n\n  layout(): void {\n    if (this.currentLayout) {\n      this.currentLayout.layout();\n    }\n  }\n\n  getScale(): number {\n    return this.scale;\n  }\n\n  setScale(scale: number): void {\n    this.scale = scale;\n  }\n\n  reset(): void {\n    this.scale = 1;\n    this.position = new Point(0, 0);\n  }\n\n  scaleBy(scale: number, location?: Point): void {\n    const b = this.getBounds();\n    let { x, y } = b;\n    const c = location || b.getCenter().translate(-x, -y);\n    x = (c.x - x) / this.scale;\n    y = (c.y - y) / this.scale;\n    const newScale = Math.max(\n      Math.min(this.scale * scale, this.scaleExtent[1]),\n      this.scaleExtent[0],\n    );\n    this.setScale(newScale);\n    x = c.x - x * this.scale;\n    y = c.y - y * this.scale;\n    this.position = new Point(x, y);\n  }\n\n  fit(padding = 0): void {\n    let rect: Rect | undefined;\n    this.getNodes().forEach((c) => {\n      const b = c.getBounds();\n      if (!rect) {\n        rect = b.clone();\n      } else {\n        rect.union(b);\n      }\n    });\n    if (!rect) {\n      return;\n    }\n\n    const { width, height } = rect;\n\n    if (width === 0 || height === 0) {\n      return;\n    }\n\n    const { width: fullWidth, height: fullHeight } = this.getDimensions();\n    const midX = rect.x + width / 2;\n    const midY = rect.y + height / 2;\n\n    // set the max scale to be the current zoom level or 1\n    const maxScale = Math.max(this.getScale(), 1);\n\n    // compute the scale\n    const scale = Math.min(\n      1 /\n        Math.max(\n          width / Math.max(1, fullWidth - padding),\n          height / Math.max(1, fullHeight - padding),\n        ),\n      maxScale,\n    );\n\n    // translate to center\n    const tx = fullWidth / 2 - midX * scale;\n    const ty = fullHeight / 2 - midY * scale;\n\n    // TODO should scale and bound be kept in a single geom Transform object instead of separately?\n    this.scale = scale;\n    this.position = new Point(tx, ty);\n  }\n\n  panIntoView = (\n    nodeElement: Node,\n    { offset = 0, minimumVisible = 0 }: { offset?: number; minimumVisible?: number } = {},\n  ): void => {\n    if (!nodeElement) {\n      return;\n    }\n    const { x: viewX, y: viewY, width: viewWidth, height: viewHeight } = this.getBounds();\n    const boundingBox = nodeElement\n      .getBounds()\n      .clone()\n      .scale(this.scale)\n      .translate(viewX, viewY);\n    const { x, y, width, height } = boundingBox;\n    let move = false;\n    const panOffset = offset * this.scale;\n    const minVisibleSize = minimumVisible * this.scale;\n\n    const newLocation = {\n      x: viewX,\n      y: viewY,\n    };\n\n    if (x + width - minVisibleSize < 0) {\n      newLocation.x -= x - panOffset;\n      move = true;\n    }\n    if (x + minVisibleSize > viewWidth) {\n      newLocation.x -= x + width - viewWidth + panOffset;\n      move = true;\n    }\n    if (y + height - minVisibleSize < 0) {\n      newLocation.y -= y - panOffset;\n      move = true;\n    }\n    if (y + minVisibleSize > viewHeight) {\n      newLocation.y -= y + height - viewHeight + panOffset;\n      move = true;\n    }\n\n    if (move) {\n      this.setBounds(new Rect(newLocation.x, newLocation.y, viewWidth, viewHeight));\n    }\n  };\n\n  setModel(model: E): void {\n    super.setModel(model);\n\n    if ('layers' in model && model.layers) {\n      this.setLayers(model.layers);\n    }\n    if ('layout' in model) {\n      this.setLayout(model.layout);\n    }\n    if (model.scaleExtent?.length === 2) {\n      this.setScaleExtent(model.scaleExtent);\n    }\n    if ('scale' in model && typeof model.scale === 'number') {\n      this.setScale(+model.scale);\n    }\n    let p: Point | undefined;\n    if ('x' in model && model.x != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.x = model.x;\n    }\n    if ('y' in model && model.y != null) {\n      if (!p) {\n        p = this.position.clone();\n      }\n      p.y = model.y;\n    }\n    if (p) {\n      this.setPosition(p);\n    }\n  }\n\n  translateToAbsolute(): void {\n    // do nothing\n  }\n\n  translateFromAbsolute(): void {\n    // do nothing\n  }\n\n  destroy(): void {\n    if (this.currentLayout) {\n      this.currentLayout.destroy();\n    }\n  }\n}\n"]}]}